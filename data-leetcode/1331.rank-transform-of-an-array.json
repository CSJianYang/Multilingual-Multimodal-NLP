[
    {
        "title": "Sort Array By Parity II",
        "question_content": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\nExample 2:\n\nInput: nums = [2,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 2 * 104\n\tnums.length is even.\n\tHalf of the integers in nums are even.\n\t0 <= nums[i] <= 1000\n\n&nbsp;\nFollow Up: Could you solve it in-place?",
        "solutions": [
            {
                "id": 181160,
                "title": "java-two-pointer-one-pass-inplace",
                "content": "```\\n\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int i = 0, j = 1, n = A.length;\\n        while (i < n && j < n) {\\n            while (i < n && A[i] % 2 == 0) {\\n                i += 2;\\n            }\\n            while (j < n && A[j] % 2 == 1) {\\n                j += 2;\\n            }\\n            if (i < n && j < n) {\\n                swap(A, i, j);\\n            }\\n        }\\n        return A;\\n    }\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int i = 0, j = 1, n = A.length;\\n        while (i < n && j < n) {\\n            while (i < n && A[i] % 2 == 0) {\\n                i += 2;\\n            }\\n            while (j < n && A[j] % 2 == 1) {\\n                j += 2;\\n            }\\n            if (i < n && j < n) {\\n                swap(A, i, j);\\n            }\\n        }\\n        return A;\\n    }\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205903,
                "title": "python-one-pass-o-1-memory-simple-code-beats-90",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, a):\\n        i = 0 # pointer for even misplaced\\n        j = 1 # pointer for odd misplaced\\n        sz = len(a)\\n        \\n        # invariant: for every misplaced odd there is misplaced even\\n        # since there is just enough space for odds and evens\\n\\n        while i < sz and j < sz:\\n            if a[i] % 2 == 0:\\n                i += 2\\n            elif a[j] % 2 == 1:\\n                j += 2\\n            else:\\n                # a[i] % 2 == 1 AND a[j] % 2 == 0\\n                a[i],a[j] = a[j],a[i]\\n                i += 2\\n                j += 2\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, a):\\n        i = 0 # pointer for even misplaced\\n        j = 1 # pointer for odd misplaced\\n        sz = len(a)\\n        \\n        # invariant: for every misplaced odd there is misplaced even\\n        # since there is just enough space for odds and evens\\n\\n        while i < sz and j < sz:\\n            if a[i] % 2 == 0:\\n                i += 2\\n            elif a[j] % 2 == 1:\\n                j += 2\\n            else:\\n                # a[i] % 2 == 1 AND a[j] % 2 == 0\\n                a[i],a[j] = a[j],a[i]\\n                i += 2\\n                j += 2\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181158,
                "title": "c-5-lines-two-pointers-2-liner-bonus",
                "content": "Use two pointers to search for missplaced odd and even elements, and swap them.\\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n    for (int i = 0, j = 1; i < A.size(); i += 2, j += 2) {\\n        while (i < A.size() && A[i] % 2 == 0) i += 2;\\n        while (j < A.size() && A[j] % 2 == 1) j += 2;\\n        if (i < A.size()) swap(A[i], A[j]);\\n    }\\n    return A;\\n}\\n```\\nNow, some fun for for my minimalistic functional friends. It\\'s techically a two-liner, though I split ```swap``` into 3 lines for readability :) It actually may even look a bit cleaner, as you do not have to do \"plus 2\".\\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n  for (int i = 0, j = 0; i < A.size() && j < A.size(); ) swap(\\n      *find_if(begin(A) + i, end(A), [&] (int v) { return (i++ % 2 == 0 && v % 2 != 0) || i == A.size(); }),\\n      *find_if(begin(A) + j, end(A), [&] (int v) { return (j++ % 2 != 0 && v % 2 == 0) || j == A.size(); }));\\n  return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n    for (int i = 0, j = 1; i < A.size(); i += 2, j += 2) {\\n        while (i < A.size() && A[i] % 2 == 0) i += 2;\\n        while (j < A.size() && A[j] % 2 == 1) j += 2;\\n        if (i < A.size()) swap(A[i], A[j]);\\n    }\\n    return A;\\n}\\n```\n```swap```\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n  for (int i = 0, j = 0; i < A.size() && j < A.size(); ) swap(\\n      *find_if(begin(A) + i, end(A), [&] (int v) { return (i++ % 2 == 0 && v % 2 != 0) || i == A.size(); }),\\n      *find_if(begin(A) + j, end(A), [&] (int v) { return (j++ % 2 != 0 && v % 2 == 0) || j == A.size(); }));\\n  return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252502,
                "title": "c-o-n-time-o-1-space-solution-with-intuition-for-building-the-solution",
                "content": "## Basic Idea of Question\\nWe are given an array in which half of the numbers are odd, and the other half are even. So the length of the array is always even, and the first index is even (0), while the last index is odd (n-1). We have to arrange the numbers in the array such that at every even index, there is an even number, while at every odd index, there is an odd number.\\n\\nThe most naive solution to this question is to just traverse the array, and upon finding an out-of-place element, find its replacement in the array by traversing the subarray after it. This algorithm will cost us **O(n<sup>2</sup>)** in time and **O(1)** in space, but it isn\\'t enough. It just seems too naive of a solution.\\n<br>\\n\\n## Approach 1: Separate even and odd numbers\\nThe next approach that might come to mind is to just iterate over the array and separate the numbers into two groups, even and odd.\\nThen we build the array again from the start by choosing an even number for each even index and an odd number for each odd index.\\nThis is a good solution, and it does fit in with the least runtime possible for such an algorithm, which is **O(n)** since we have to at least check every element, so that they are all at their place, but it also requires extra space of O(n) for storing the even and odd numbers.\\n\\nThe code for the approach is as follows:\\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> evens, odds;\\n\\tevens.reserve(n/2);\\n\\todds.reserve(n/2);\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(nums[i] % 2 == 0) {\\n\\t\\t\\tevens.push_back(nums[i]);\\n\\t\\telse {\\n\\t\\t\\todds.push_back(nums[i]);\\n\\t}\\n\\t//filling even spaces\\n\\tfor(int i = 0; i<n; i+=2) {\\n\\t\\tnums[i] = evens[i/2];\\n\\t}\\n\\t//filling odd spaces\\n\\tfor(int i = 1; i<n; i+=2) {\\n\\t\\tnums[i] = odds[i/2];\\n\\t}\\n\\treturn nums;\\n}\\n```\\nIf you are confused by the lines ```evens.reserve(n/2)``` and ```odds.reserve(n/2)```, they are just ensuring beforehand that our vectors have adequate capacities, so that all push back operations are completed in O(1).\\n\\n**Time: O(n)** as we just iterate the array two times.\\n**Space: O(n)**, the extra space required for the two arrays.\\n<br>\\n\\n## Approach 2: Swap outliers\\nWe can think of this question in another way as well. Since the number of even and odd numbers in the array is equal, if there is one outlier (even number at odd index or vice versa), there must be another outlier somewhere, since if there isn\\'t, then this place has no rightful element which can fill it.\\nIf we find and swap such pairs, we wouldn\\'t have to care about finding the odd or even numbers and separating them. In fact, we can even do it in one iteration only, using two pointers.\\n\\nComing back to the question statement, as n is even,, so index 0 is even and the index (n-1) is odd. So starting at index 0 for the even pointer, and n-1 for the odd pointer would be just fine.\\nWe follow the below algorithm until one of the pointers reaches the other end of the array (here i represents the even pointer, and j represents the odd pointer):\\n\\n1. Keep incrementing i by 2 until either it reaches the other end, or an outlier (odd number at even index).\\n2. Keep decrementing j by 2 until either it reaches the other end, or an outlier (even number at odd index).\\n3. Swap nums[i] and nums[j]\\n\\nYou might be thinking, what happens if i stops at an outlier and j reaches the other end, or vice versa?\\nWell, the fact that n is even, and there being equal number of even and odd numbers prevents that situation from happening (as explained above). If there will be a pair, it will be a valid pair, otherwise both of them will reach the ends.\\n\\nThe code for this approach is as follows:\\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0, j = n-1;\\n\\twhile(i<n) {\\n\\t\\twhile(i<n && nums[i]%2==0) i+=2;\\n\\t\\tif(i==n) break;\\n\\t\\twhile(j>=0 && nums[j]%2==1) j-=2;\\n\\t\\t//swap the outliers\\n\\t\\tswap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\\n\\n**Time: O(n)** as we traverse the array once.\\n**Space: O(1)** as we only use two pointers, and no other space.\\n\\n<br>\\n\\n**Don\\'t forget to upvote** if you liked this post and learned something from it, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> evens, odds;\\n\\tevens.reserve(n/2);\\n\\todds.reserve(n/2);\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(nums[i] % 2 == 0) {\\n\\t\\t\\tevens.push_back(nums[i]);\\n\\t\\telse {\\n\\t\\t\\todds.push_back(nums[i]);\\n\\t}\\n\\t//filling even spaces\\n\\tfor(int i = 0; i<n; i+=2) {\\n\\t\\tnums[i] = evens[i/2];\\n\\t}\\n\\t//filling odd spaces\\n\\tfor(int i = 1; i<n; i+=2) {\\n\\t\\tnums[i] = odds[i/2];\\n\\t}\\n\\treturn nums;\\n}\\n```\n```evens.reserve(n/2)```\n```odds.reserve(n/2)```\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0, j = n-1;\\n\\twhile(i<n) {\\n\\t\\twhile(i<n && nums[i]%2==0) i+=2;\\n\\t\\tif(i==n) break;\\n\\t\\twhile(j>=0 && nums[j]%2==1) j-=2;\\n\\t\\t//swap the outliers\\n\\t\\tswap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490877,
                "title": "python-o-1-space-solution-explained",
                "content": "`O(n)` space complexity soluiton is straightforward. It is more interseting to investigate `O(1)` solution. The idea is to use two pointers approach, where we start with index `0` for even numbers and with index `1` for odd numbers. We traverse our numbers, where we can have the following options:\\n\\n1. if `nums[i] % 2 == 0`, then number is already on place, so we look at the next place for `i`.\\n2. if `nums[j] % 2 == 1`, then number is already on place, so we look ate the next place for `j`.\\n3. In the opposite case we need to sweich elements.\\n\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j, n = 0, 1, len(nums)\\n        while j < n and i < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j, n = 0, 1, len(nums)\\n        while j < n and i < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490847,
                "title": "c-two-pointers-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint i = 0, j = 1;\\n\\t\\t\\twhile(i < n && j < n){\\n\\t\\t\\t\\tif(nums[i] % 2 == 0){\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[j] % 2 == 1){\\n\\t\\t\\t\\t\\tj += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint i = 0, j = 1;\\n\\t\\t\\twhile(i < n && j < n){\\n\\t\\t\\t\\tif(nums[i] % 2 == 0){\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 181500,
                "title": "java-two-pointers-inplace-o-n-time-simple-straightforward",
                "content": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int e = 0;\\n        int o = 1;\\n        \\n        while(e < A.length && o < A.length) {\\n            if(A[e]%2 != 0) {\\n                swap(A, e, o);\\n                o += 2;\\n            } else {\\n                e += 2;\\n            }\\n        }\\n\\n        return A;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int e = 0;\\n        int o = 1;\\n        \\n        while(e < A.length && o < A.length) {\\n            if(A[e]%2 != 0) {\\n                swap(A, e, o);\\n                o += 2;\\n            } else {\\n                e += 2;\\n            }\\n        }\\n\\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193854,
                "title": "linear-pass-using-2-pointers-in-c",
                "content": "We need to maintain a following invariant: `A[i]` is an even number at even position and `A[j]` is an odd number at odd position. As soon as this invariant is violated, it\\'s possible to swap numbers to restore it.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        for (int i = 0, j = 1; j < A.size() && i < A.size();) {\\n            if (A[i] % 2 == 0) {\\n                i += 2;\\n            } else if (A[j] % 2 == 1) {\\n                j += 2;\\n            } else {\\n                swap(A[i], A[j]);\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        for (int i = 0, j = 1; j < A.size() && i < A.size();) {\\n            if (A[i] % 2 == 0) {\\n                i += 2;\\n            } else if (A[j] % 2 == 1) {\\n                j += 2;\\n            } else {\\n                swap(A[i], A[j]);\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319267,
                "title": "python-o-n-t-o-1-s-easy-to-understand-with-explanation",
                "content": "The idea: \\nGetting odd numbers on odd indices, after which, even numbers would also stand right positions;\\n**i** as even index starts from 0 (2, 4, 6...), **j** as odd index starts from 1 (3, 5, 7...)\\n\\nA half of A is odd, so the length of A - **L**  so 2|L, also means **L - 1** is odd;\\n\\nJudging every number on odd indices if it is odd, if it is, it stands at a right position, then j = j + 2 (jumping to next odd index), and \\'i\\' keep the same. \\nOtherwise, exchanging the values between index j and i,  then index \\'i\\'  has a right value and can point to next even position i = i + 2, but we don\\'t know the original value on i is odd, so j keep unchanged.\\n\\nAfter processing all odd indices, we get the result we want.\\n```\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        i, j, L = 0, 1, len(A)              # i - even index, j - odd index, L - length of A\\n        while j < L:                          # (L - 1) is odd, j can reach the last element, so this condition is enough\\n            if A[j] % 2 == 0:              # judge if the value on odd indices is odd\\n                A[j], A[i] = A[i], A[j]     # if it is even, exchange the values between index j and i\\n                i += 2                         # even indices get a right value, then i pointer jump to next even index\\n            else:\\n                j += 2                         # if it is odd, odd indices get a right value, then j pointer jump to next odd index\\n        return A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        i, j, L = 0, 1, len(A)              # i - even index, j - odd index, L - length of A\\n        while j < L:                          # (L - 1) is odd, j can reach the last element, so this condition is enough\\n            if A[j] % 2 == 0:              # judge if the value on odd indices is odd\\n                A[j], A[i] = A[i], A[j]     # if it is even, exchange the values between index j and i\\n                i += 2                         # even indices get a right value, then i pointer jump to next even index\\n            else:\\n                j += 2                         # if it is odd, odd indices get a right value, then j pointer jump to next odd index\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234994,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181261,
                "title": "python-easy-2-liner",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]\\n        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]\\n        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283369,
                "title": "java-2ms-99-76-faster",
                "content": "1. Get first even entry at the wrong index\\n2. Get first odd entry at the wrong index\\n3. swap\\n4. repeat\\n```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int even = 0, odd = 1;\\n        while(true){\\n            while(even < A.length && A[even] % 2 == 0) /*(1)*/\\n                even += 2;\\n            while(odd < A.length && A[odd] % 2 != 0) /*(2)*/\\n                odd += 2;\\n            if(odd >= A.length || even >= A.length) return A;\\n\\t\\t\\t\\n\\t\\t\\t/*(3)*/\\n            int temp = A[even];\\n            A[even] = A[odd];\\n            A[odd] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int even = 0, odd = 1;\\n        while(true){\\n            while(even < A.length && A[even] % 2 == 0) /*(1)*/\\n                even += 2;\\n            while(odd < A.length && A[odd] % 2 != 0) /*(2)*/\\n                odd += 2;\\n            if(odd >= A.length || even >= A.length) return A;\\n\\t\\t\\t\\n\\t\\t\\t/*(3)*/\\n            int temp = A[even];\\n            A[even] = A[odd];\\n            A[odd] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491154,
                "title": "python-two-pointers-o-1-space-clean-concise",
                "content": "**Idea**\\n- Let `iEven` point to the first number which has an even index but the value is odd.\\n- Let `iOdd` point to the first number which has an odd index but the value is even.\\n- We need to swap `nums[iEven]` and `nums[iOdd]` together since they are mismatch.\\n```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        iEven = 0\\n        iOdd = 1\\n        while True:\\n            while iEven < n and nums[iEven] % 2 == 0:\\n                iEven += 2\\n            while iOdd < n and nums[iOdd] % 2 == 1:\\n                iOdd += 2\\n            if iEven >= n or iOdd >= n:\\n                break\\n\\n            nums[iEven], nums[iOdd] = nums[iOdd], nums[iEven]\\n            iEven += 2\\n            iOdd += 2\\n        return nums\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 2*10^4` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        iEven = 0\\n        iOdd = 1\\n        while True:\\n            while iEven < n and nums[iEven] % 2 == 0:\\n                iEven += 2\\n            while iOdd < n and nums[iOdd] % 2 == 1:\\n                iOdd += 2\\n            if iEven >= n or iOdd >= n:\\n                break\\n\\n            nums[iEven], nums[iOdd] = nums[iOdd], nums[iEven]\\n            iEven += 2\\n            iOdd += 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213068,
                "title": "3-lines-javascript-solution",
                "content": "```\\n  let evenArray = A.filter(x => x % 2 === 0);\\n  let oddArray = A.filter(x => x % 2 === 1);\\n  return A.map((x, index) => index % 2 === 0 ? evenArray.pop() : oddArray.pop());\\n```",
                "solutionTags": [],
                "code": "```\\n  let evenArray = A.filter(x => x % 2 === 0);\\n  let oddArray = A.filter(x => x % 2 === 1);\\n  return A.map((x, index) => index % 2 === 0 ? evenArray.pop() : oddArray.pop());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490850,
                "title": "simple-to-understand-for-beginners-91-faster",
                "content": "## IDEA:\\n* Separate all even and odd numbers Once.\\n* Then now replace original arr with alternate even and odd numbers.\\n* Here flag denotes you are at even index.\\n\\n**For Biginners:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        odd,even = [],[]\\n        for n in nums:\\n            if n%2: odd.append(n)\\n            else: even.append(n)\\n        \\n        o,e = 0,0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i]=even[e]\\n                e+=1\\n            else:\\n                nums[i]=odd[o]\\n                o+=1\\n        \\n        return nums\\n\\n**Most Efficient:**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0                            #even_index\\n        o = 1                            #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return num\\n\\n### Thanks and Upvote If you got any help !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n* Separate all even and odd numbers Once.\\n* Then now replace original arr with alternate even and odd numbers.\\n* Here flag denotes you are at even index.\\n\\n**For Biginners:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        odd,even = [],[]\\n        for n in nums:\\n            if n%2: odd.append(n)\\n            else: even.append(n)\\n        \\n        o,e = 0,0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i]=even[e]\\n                e+=1\\n            else:\\n                nums[i]=odd[o]\\n                o+=1\\n        \\n        return nums\\n\\n**Most Efficient:**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0                            #even_index\\n        o = 1                            #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return num\\n\\n### Thanks and Upvote If you got any help !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1235041,
                "title": "swift-sort-array-by-parity-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func sortArrayByParityII(_ nums: [Int]) -> [Int] {\\n        var map = [Int](repeating: 0, count: nums.count)\\n        var i = 0, j = 1\\n        nums.forEach({\\n            if $0 % 2 == 0 {\\n                map[i] = $0\\n                i += 2\\n            } else {\\n                map[j] = $0\\n                j += 2\\n            }\\n        })\\n        return map\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.sortArrayByParityII([4,2,5,7]), [4,5,2,7])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.sortArrayByParityII([2,3]), [2,3])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func sortArrayByParityII(_ nums: [Int]) -> [Int] {\\n        var map = [Int](repeating: 0, count: nums.count)\\n        var i = 0, j = 1\\n        nums.forEach({\\n            if $0 % 2 == 0 {\\n                map[i] = $0\\n                i += 2\\n            } else {\\n                map[j] = $0\\n                j += 2\\n            }\\n        })\\n        return map\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.sortArrayByParityII([4,2,5,7]), [4,5,2,7])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.sortArrayByParityII([2,3]), [2,3])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181075,
                "title": "java-simple-code-swap-odd-and-even-indices-elements",
                "content": "Use i and j to denote even and odd indices, respectively.\\nLoop through input array,\\n1. locate next wrongly placed item with odd index j;\\n2. if current even-index item, A[i], is wrongly placed, swap it with A[j]; otherwise, forward to the next even index;\\n\\nTime: O(n), space: O(1).\\n\\n```\\n    public int[] sortArrayByParityII(int[] A) {\\n        for (int i = 0, j = 1; i < A.length; i += 2) {\\n            while (j < A.length && A[j] % 2 == 1) { j += 2; } //find next odd-index item A[j] with even value.\\n            if (A[i] % 2 == 1) { // if odd-index item A[i] is odd, swap it with A[j].\\n                int t = A[i];\\n                A[i] = A[j];\\n                A[j] = t;\\n                j += 2;\\n            }\\n        }\\n        return A;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortArrayByParityII(int[] A) {\\n        for (int i = 0, j = 1; i < A.length; i += 2) {\\n            while (j < A.length && A[j] % 2 == 1) { j += 2; } //find next odd-index item A[j] with even value.\\n            if (A[i] % 2 == 1) { // if odd-index item A[i] is odd, swap it with A[j].\\n                int t = A[i];\\n                A[i] = A[j];\\n                A[j] = t;\\n                j += 2;\\n            }\\n        }\\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420962,
                "title": "c-easy-to-understand-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n    \\n        vector<int> ans(nums.size());\\n        int e=0,o=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[e]=nums[i];\\n                    e+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    ans[o]=nums[i];\\n                    o+=2;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n    \\n        vector<int> ans(nums.size());\\n        int e=0,o=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[e]=nums[i];\\n                    e+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2431242,
                "title": "100-t-c-short-solution-easy-to-undesrtand",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int[] ans = new int[nums.length];\\n        int even = -2, odd = -1;\\n\\n        for (int  i: nums){\\n            if (i % 2 == 0) ans[even+=2] = i;\\n            else ans[odd+=2] = i;\\n        }\\n\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224767,
                "title": "python-two-pointers-one-pass",
                "content": "one pointer is used to remember the odd position, the other is to remember the even position\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd = 1\\n        even = 0\\n        result = [0]*len(A)\\n        for num in A:\\n            if num%2==0:\\n                result[even] = num\\n                even += 2\\n            else:\\n                result[odd] = num\\n                odd += 2\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd = 1\\n        even = 0\\n        result = [0]*len(A)\\n        for num in A:\\n            if num%2==0:\\n                result[even] = num\\n                even += 2\\n            else:\\n                result[odd] = num\\n                odd += 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182347,
                "title": "python-beginner-solution",
                "content": "Tried to make a simple solution. \\n1. Loop through initial list, check for odd/even, and append to an odd_list or even list\\n2. Combine the lists with slicing to alternate odd/even lists\\n\\n```class Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd_list = []\\n        even_list = []\\n        \\n        for i in A:\\n            if i % 2 == 1:\\n                odd_list.append(i)\\n            else:\\n                even_list.append(i)\\n\\n        result = [None]*(len(odd_list)+len(even_list))\\n        result[::2] = even_list\\n        result[1::2] = odd_list\\n        return result",
                "solutionTags": [],
                "code": "Tried to make a simple solution. \\n1. Loop through initial list, check for odd/even, and append to an odd_list or even list\\n2. Combine the lists with slicing to alternate odd/even lists\\n\\n```class Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd_list = []\\n        even_list = []\\n        \\n        for i in A:\\n            if i % 2 == 1:\\n                odd_list.append(i)\\n            else:\\n                even_list.append(i)\\n\\n        result = [None]*(len(odd_list)+len(even_list))\\n        result[::2] = even_list\\n        result[1::2] = odd_list\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 3253084,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even = []\\n        odd = []\\n        lst=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                even.append(nums[i])\\n            else:\\n                odd.append(nums[i])\\n        for i in range(len(even)):\\n            lst.append(even[i])\\n            lst.append(odd[i])\\n        return lst\\n```\\n![image.png](https://assets.leetcode.com/users/images/d1d1fa02-4b7b-4404-b577-ebef47fd1b2f_1677865820.3052886.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even = []\\n        odd = []\\n        lst=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                even.append(nums[i])\\n            else:\\n                odd.append(nums[i])\\n        for i in range(len(even)):\\n            lst.append(even[i])\\n            lst.append(odd[i])\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665223,
                "title": "c-three-o-n-solutions",
                "content": "**Solution #1:** Two-pass solution using two-pointer technique [O(n) Time & O(1) Space]\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tfor (int i = 0, c = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 != 0) c++;\\n\\t\\telse if (c > 0) swap(nums[i], nums[i - c]);\\n\\t}\\n\\tfor (int i = 1; i < nums.size() / 2; i += 2) swap(nums[i], nums[nums.size() - i - 1]);\\n\\treturn nums;\\n}\\n```\\n\\n**Solution #2:** One-pass solution using two-pointer technique [O(n) Time & O(1) Space]\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tint i = 0, j = nums.size() - 1;\\n\\twhile (i < nums.size() && j >= 0) {\\n\\t\\tif (nums[i] % 2 == 0) i += 2;\\n\\t\\telse if (nums[j] % 2 != 0) j -= 2;\\n\\t\\telse swap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\\n\\n**Solution #3:** One-pass solution [O(n) Time & O(n) Space] \\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tvector<int> result(nums.size());\\n\\tfor (int i = 0, j = 0, k = 1; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 == 0) {\\n\\t\\t\\tresult[j] = nums[i];\\n\\t\\t\\tj += 2;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k] = nums[i];\\n\\t\\t\\tk += 2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n**Note:** Not an in-place solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tfor (int i = 0, c = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 != 0) c++;\\n\\t\\telse if (c > 0) swap(nums[i], nums[i - c]);\\n\\t}\\n\\tfor (int i = 1; i < nums.size() / 2; i += 2) swap(nums[i], nums[nums.size() - i - 1]);\\n\\treturn nums;\\n}\\n```\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tint i = 0, j = nums.size() - 1;\\n\\twhile (i < nums.size() && j >= 0) {\\n\\t\\tif (nums[i] % 2 == 0) i += 2;\\n\\t\\telse if (nums[j] % 2 != 0) j -= 2;\\n\\t\\telse swap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tvector<int> result(nums.size());\\n\\tfor (int i = 0, j = 0, k = 1; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 == 0) {\\n\\t\\t\\tresult[j] = nums[i];\\n\\t\\t\\tj += 2;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k] = nums[i];\\n\\t\\t\\tk += 2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404663,
                "title": "python3-2-pointer",
                "content": "Even & odd indices \\n1) maintain two indices \"even\" and \"odd\" which start at 0 and 1 spectively;\\n2) loop through elements in array;\\n3) if element is of odd parity, copy it to position of \"odd\" index and increase odd by two; if element is of even parity, copy it to positon of \"even\" index and increase even by two.\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        ans = [None] * len(A)\\n        index = [0, 1] #even & odd indices\\n        for x in A:\\n            ans[index[x%2]] = x\\n            index[x%2] += 2\\n        return ans \\n```\\n\\nAn alternative implementation which updates A in place is as below. \\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        ii, i = 0, 1\\n        while ii < len(nums) and i < len(nums): \\n            if not nums[ii] & 1: ii += 2\\n            elif nums[i] & 1: i += 2\\n            else: \\n                nums[ii], nums[i] = nums[i], nums[ii]\\n                ii += 2\\n                i += 2\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        ans = [None] * len(A)\\n        index = [0, 1] #even & odd indices\\n        for x in A:\\n            ans[index[x%2]] = x\\n            index[x%2] += 2\\n        return ans \\n```\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        ii, i = 0, 1\\n        while ii < len(nums) and i < len(nums): \\n            if not nums[ii] & 1: ii += 2\\n            elif nums[i] & 1: i += 2\\n            else: \\n                nums[ii], nums[i] = nums[i], nums[ii]\\n                ii += 2\\n                i += 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184608,
                "title": "javascript-beats-100",
                "content": "```\\n    var ans = new Array(A.length);\\n    var odd = 1, even = 0;\\n    \\n    for (var i = 0; i < A.length ; i++){\\n        if (A[i] % 2 === 0){\\n            ans[even] = A[i];\\n            even += 2;\\n        }else{\\n            ans[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n\\n    return ans;",
                "solutionTags": [],
                "code": "```\\n    var ans = new Array(A.length);\\n    var odd = 1, even = 0;\\n    \\n    for (var i = 0; i < A.length ; i++){\\n        if (A[i] % 2 === 0){\\n            ans[even] = A[i];\\n            even += 2;\\n        }else{\\n            ans[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n\\n    return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3440920,
                "title": "smartest-solution-with-java-beats-99-90-1-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }else{\\n                ret[odd] = a;\\n                odd+=2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }else{\\n                ret[odd] = a;\\n                odd+=2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499431,
                "title": "one-pass-two-pointer-solution",
                "content": "Consider two pointers, one **oddIx**, pointing to odd position and the other **evenIx**, pointing to even position.\\nBegining with **oddIx at 1** and **evenIx at 0**, we will increment these **until one exceeds the length** of the array.\\nIf we have odd number at even position or even number at odd position, we will like to change this, so we will **swap** only **when both**, oddIx and evenIx, **holds number of opposite category(even/odd)**.\\nElse, we would simply skip the position for oddIx and evenIx if they hold number belonging to their category.\\n\\n\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddIx = 1, evenIx = 0;\\n        while(oddIx < nums.length && evenIx < nums.length){\\n            if (nums[oddIx] % 2 < nums[evenIx] % 2){\\n                int temp = nums[oddIx];\\n                nums[oddIx] = nums[evenIx];\\n                nums[evenIx] = temp;\\n            }\\n            if (nums[oddIx] % 2 == 1)\\n                oddIx = oddIx + 2;\\n            if (nums[evenIx] % 2 == 0)\\n                evenIx = evenIx + 2;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddIx = 1, evenIx = 0;\\n        while(oddIx < nums.length && evenIx < nums.length){\\n            if (nums[oddIx] % 2 < nums[evenIx] % 2){\\n                int temp = nums[oddIx];\\n                nums[oddIx] = nums[evenIx];\\n                nums[evenIx] = temp;\\n            }\\n            if (nums[oddIx] % 2 == 1)\\n                oddIx = oddIx + 2;\\n            if (nums[evenIx] % 2 == 0)\\n                evenIx = evenIx + 2;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476301,
                "title": "c-simpler-than-top-voted-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = n-1;\\n        //i stands for even\\n        //j stands for odd\\n        while(i < n && j >= 0) {\\n            if   (nums[i]%2 == 0)    i += 2;\\n            else if(nums[j] %2 == 1) j -= 2;\\n            else                     swap(nums[i], nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = n-1;\\n        //i stands for even\\n        //j stands for odd\\n        while(i < n && j >= 0) {\\n            if   (nums[i]%2 == 0)    i += 2;\\n            else if(nums[j] %2 == 1) j -= 2;\\n            else                     swap(nums[i], nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156067,
                "title": "java-faster-than-99",
                "content": "\\tclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddindex = 1;\\n       int evenindex = 0;\\n       int res[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]%2==0) {\\n                res[evenindex]=nums[i];\\n                evenindex+=2;\\n            }\\n            else\\n            {\\n                res[oddindex]=nums[i];\\n                oddindex+=2;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddindex = 1;\\n       int evenindex = 0;\\n       int res[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]%2==0) {\\n                res[evenindex]=nums[i];\\n                evenindex+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 397526,
                "title": "javascript-one-loop-solution",
                "content": "```\\nconst sortArrayByParityII = arr => {\\n    let res = []\\n    let evenIndex = 0\\n    let oddIndex = 1\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 0) {\\n            res[evenIndex] = arr[i]\\n            evenIndex = evenIndex + 2\\n        } else {\\n            res[oddIndex] = arr[i]\\n            oddIndex = oddIndex + 2\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortArrayByParityII = arr => {\\n    let res = []\\n    let evenIndex = 0\\n    let oddIndex = 1\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 0) {\\n            res[evenIndex] = arr[i]\\n            evenIndex = evenIndex + 2\\n        } else {\\n            res[oddIndex] = arr[i]\\n            oddIndex = oddIndex + 2\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169529,
                "title": "python3-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even, odd = 0, 1\\n        \\n        while even < len(nums) and odd < len(nums):\\n            while even < len(nums) and nums[even] % 2 == 0:\\n                even += 2\\n            while odd < len(nums) and nums[odd] % 2 != 0:\\n                odd += 2\\n                \\n            if even < len(nums) and odd < len(nums):\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n                \\n            even += 2\\n            odd += 2\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even, odd = 0, 1\\n        \\n        while even < len(nums) and odd < len(nums):\\n            while even < len(nums) and nums[even] % 2 == 0:\\n                even += 2\\n            while odd < len(nums) and nums[odd] % 2 != 0:\\n                odd += 2\\n                \\n            if even < len(nums) and odd < len(nums):\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n                \\n            even += 2\\n            odd += 2\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049238,
                "title": "simple-c-two-pointers-solution",
                "content": "Simple two pointers solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n      int n = A.size();\\n        for(int i = 0, j = 1; j < A.size() && i < A.size();){\\n            if(A[i]%2==0 )\\n                i+=2;\\n            else if(A[j]%2==1)\\n                j+=2;\\n            else(swap(A[i],A[j]));\\n            \\n        }\\n        return A;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n      int n = A.size();\\n        for(int i = 0, j = 1; j < A.size() && i < A.size();){\\n            if(A[i]%2==0 )\\n                i+=2;\\n            else if(A[j]%2==1)\\n                j+=2;\\n            else(swap(A[i],A[j]));\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3519592,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n){\\n            if(nums[i]%2==0)\\n                i=i+2;\\n            else if(nums[j]%2==1)\\n                j=j+2;\\n            else\\n                swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        j=1\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2:\\n                while nums[j]%2:\\n                    j+=2\\n                nums[i],nums[j]=nums[j],nums[i]\\n\\n        return nums\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }\\n        for (int k = 0; k < 2; k++) {\\n            int cur = k;\\n            for (int i = k; i < nums.length; i += 2) {\\n                while (freq[cur] == 0) cur += 2;\\n                freq[cur]--;\\n                nums[i] = cur;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n){\\n            if(nums[i]%2==0)\\n                i=i+2;\\n            else if(nums[j]%2==1)\\n                j=j+2;\\n            else\\n                swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        j=1\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2:\\n                while nums[j]%2:\\n                    j+=2\\n                nums[i],nums[j]=nums[j],nums[i]\\n\\n        return nums\\n```\n```Java []\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }\\n        for (int k = 0; k < 2; k++) {\\n            int cur = k;\\n            for (int i = k; i < nums.length; i += 2) {\\n                while (freq[cur] == 0) cur += 2;\\n                freq[cur]--;\\n                nums[i] = cur;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722158,
                "title": "c-easy-even-odd-vector",
                "content": "### Simple Solution using Even & Odd Vector \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]%2==0)\\n                even.push_back(a[i]);\\n            else\\n                odd.push_back(a[i]);\\n        }\\n        int n=even.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(even[i]);\\n            ans.push_back(odd[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]%2==0)\\n                even.push_back(a[i]);\\n            else\\n                odd.push_back(a[i]);\\n        }\\n        int n=even.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(even[i]);\\n            ans.push_back(odd[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628372,
                "title": "2-solutions-using-extra-space-and-without-extra-space-c",
                "content": "# **Using Extra Space : O(N)** #\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> odd, even;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((nums[i]&1) == 1)\\n                odd.push_back(nums[i]);\\n            else\\n                even.push_back(nums[i]);\\n        }\\n        int e = 0, o = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((i & 1) == 0){\\n                nums[i] = even[e];\\n                e++;\\n            }\\n            else\\n            {\\n                nums[i] = odd[o];\\n                o++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# **Without Using Extra Space : O(1)** #\\n```\\nclass Solution{\\npublic:\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        int i = 0, j = 1, n = nums.size();\\n        while (i < n && j < n)\\n        {\\n            if (nums[i] % 2 == 0)\\n                i += 2;\\n            else if (nums[j] % 2 != 0)\\n                j += 2;\\n            else\\n            {\\n                swap(nums[i], nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> odd, even;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((nums[i]&1) == 1)\\n                odd.push_back(nums[i]);\\n            else\\n                even.push_back(nums[i]);\\n        }\\n        int e = 0, o = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((i & 1) == 0){\\n                nums[i] = even[e];\\n                e++;\\n            }\\n            else\\n            {\\n                nums[i] = odd[o];\\n                o++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        int i = 0, j = 1, n = nums.size();\\n        while (i < n && j < n)\\n        {\\n            if (nums[i] % 2 == 0)\\n                i += 2;\\n            else if (nums[j] % 2 != 0)\\n                j += 2;\\n            else\\n            {\\n                swap(nums[i], nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1774458,
                "title": "c-easy-to-understand-step-by-step-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> result(nums.size());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[even]=nums[i];\\n                    even+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    result[odd]=nums[i];\\n                    odd+=2;\\n                }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> result(nums.size());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[even]=nums[i];\\n                    even+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    result[odd]=nums[i];\\n                    odd+=2;\\n                }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498698,
                "title": "very-easy-two-pointer-solution-in-java-for-beginners",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 ;\\n        int odd =  1 ;\\n        \\n        while(even < nums.length && odd < nums.length){\\n            \\n            if(nums[even]%2 != 0){\\n                swap(nums , even , odd);\\n                odd += 2 ;\\n            } else{\\n                even += 2 ;\\n            }\\n        }\\n        \\n        return nums ;\\n    }\\n    \\n    public void swap(int[] arr , int e1 , int e2){\\n        int temp = arr[e1];\\n        arr[e1] = arr[e2];\\n        arr[e2] = temp ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 ;\\n        int odd =  1 ;\\n        \\n        while(even < nums.length && odd < nums.length){\\n            \\n            if(nums[even]%2 != 0){\\n                swap(nums , even , odd);\\n                odd += 2 ;\\n            } else{\\n                even += 2 ;\\n            }\\n        }\\n        \\n        return nums ;\\n    }\\n    \\n    public void swap(int[] arr , int e1 , int e2){\\n        int temp = arr[e1];\\n        arr[e1] = arr[e2];\\n        arr[e2] = temp ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330742,
                "title": "two-pointer-solution-python-3-beats-90",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0 #even_index\\n        o = 1 #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0 #even_index\\n        o = 1 #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210032,
                "title": "c-in-place-solution-for-90-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n         \\n        for(int i =0 , j =1 ; j < nums.size() && i <nums.size();)\\n        {\\n            if(nums[i] %2 ==0)\\n            i+=2;\\n            else if(nums[j] % 2 ==1)\\n            j+=2;\\n            else\\n            swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n         \\n        for(int i =0 , j =1 ; j < nums.size() && i <nums.size();)\\n        {\\n            if(nums[i] %2 ==0)\\n            i+=2;\\n            else if(nums[j] % 2 ==1)\\n            j+=2;\\n            else\\n            swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197747,
                "title": "c-12ms-98-two-pointers-in-place",
                "content": "Runtime: 12 ms, faster than 98.13% of C++ online submissions for Sort Array By Parity II.\\nMemory Usage: 21.5 MB, less than 29.09% of C++ online submissions for Sort Array By Parity II.\\n```\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i = 0, ni = A.size(), j = 1, nj = A.size() + 1;\\n    \\n    while(true){\\n      while(i != ni && A[i]%2 == 0) i+=2;\\n      while(j != nj && A[j]%2 == 1) j+=2;\\n      if(i == ni) break;\\n      swap(A[i],A[j]);\\n    }\\n    return A;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i = 0, ni = A.size(), j = 1, nj = A.size() + 1;\\n    \\n    while(true){\\n      while(i != ni && A[i]%2 == 0) i+=2;\\n      while(j != nj && A[j]%2 == 1) j+=2;\\n      if(i == ni) break;\\n      swap(A[i],A[j]);\\n    }\\n    return A;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919338,
                "title": "python3-easy-to-understand-solution",
                "content": "class Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        op=[0]*len(A)\\n        e=0\\n        o=1\\n        for i in A:\\n            if i%2==0:\\n                op[e]=i\\n                e+=2\\n            else:\\n                op[o]=i\\n                o+=2\\n        return op\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        op=[0]*len(A)\\n        e=0\\n        o=1\\n        for i in A:\\n            if i%2==0:\\n                op[e]=i\\n                e+=2\\n            else:\\n                op[o]=i\\n                o+=2\\n        return op\\n",
                "codeTag": "Java"
            },
            {
                "id": 764104,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *odd, *even, i = 0;\\n    \\n    odd = res + 1;\\n    even = res;\\n    \\n    while(i < ASize)\\n    {\\n        if(A[i] % 2)\\n        {\\n            *odd = A[i];\\n            odd +=2;\\n            i++;\\n            \\n        }\\n        else\\n        {\\n            *even = A[i];\\n            even += 2;\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *odd, *even, i = 0;\\n    \\n    odd = res + 1;\\n    even = res;\\n    \\n    while(i < ASize)\\n    {\\n        if(A[i] % 2)\\n        {\\n            *odd = A[i];\\n            odd +=2;\\n            i++;\\n            \\n        }\\n        else\\n        {\\n            *even = A[i];\\n            even += 2;\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558016,
                "title": "java-faster-than-99-63",
                "content": "```\\nclass Solution {\\n    \\n    void swap(int[] A, int i, int j){\\n         int tmp = A[i];\\n         A[i] = A[j];\\n         A[j] = tmp;\\n    }\\n    \\n    public int[] sortArrayByParityII(int[] A) {\\n        int odd_p = 1;\\n        int n = A.length;\\n        \\n        for(int i=0;i<n;i+=2){\\n            if(A[i]%2 == 1){\\n                while(A[odd_p]%2 == 1)\\n                    odd_p += 2;\\n                swap(A, i, odd_p);\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void swap(int[] A, int i, int j){\\n         int tmp = A[i];\\n         A[i] = A[j];\\n         A[j] = tmp;\\n    }\\n    \\n    public int[] sortArrayByParityII(int[] A) {\\n        int odd_p = 1;\\n        int n = A.length;\\n        \\n        for(int i=0;i<n;i+=2){\\n            if(A[i]%2 == 1){\\n                while(A[odd_p]%2 == 1)\\n                    odd_p += 2;\\n                swap(A, i, odd_p);\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349213,
                "title": "solution-in-python-3-beats-100-two-pointer-space-o-1",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n    \\tj = 1\\n    \\tfor i in range(0,len(A),2):\\n    \\t\\tif A[i] % 2 == 0: continue\\n    \\t\\twhile A[j] % 2 != 0: j += 2\\n    \\t\\tA[i], A[j] = A[j], A[i]\\n    \\treturn A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n    \\tj = 1\\n    \\tfor i in range(0,len(A),2):\\n    \\t\\tif A[i] % 2 == 0: continue\\n    \\t\\twhile A[j] % 2 != 0: j += 2\\n    \\t\\tA[i], A[j] = A[j], A[i]\\n    \\treturn A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 266823,
                "title": "java-two-pointers-one-pass-beats-99",
                "content": "```\\n`public int[] sortArrayByParityII(int[] A) {\\n        int[] res = new int[A.length];\\n        int i = 0, k = 1;\\n        for (int j = 0; j < A.length; j++) {\\n            if (A[j] % 2 == 0) {\\n                res[i] = A[j];\\n                i+=2;\\n            } \\n            else {\\n                res[k] = A[j];\\n                k+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n`public int[] sortArrayByParityII(int[] A) {\\n        int[] res = new int[A.length];\\n        int i = 0, k = 1;\\n        for (int j = 0; j < A.length; j++) {\\n            if (A[j] % 2 == 0) {\\n                res[i] = A[j];\\n                i+=2;\\n            } \\n            else {\\n                res[k] = A[j];\\n                k+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208169,
                "title": "c-this-problem-is-so-easy-that-i-code-it-fluently-with-no-change",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        \\n        for(int i=0,j=1;j<A.size();){\\n            if(A[i]%2 == 1 && A[j]%2 == 0){\\n                swap(A[i],A[j]);\\n                i=i+2;\\n                j=j+2;\\n            }else if(A[i]%2 == 0 && A[j]%2 == 0){\\n                i=i+2;\\n            }else if(A[i]%2 == 1 && A[j]%2 == 1){\\n                j=j+2;\\n            }else{\\n                i=i+2;\\n                j=j+2;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        \\n        for(int i=0,j=1;j<A.size();){\\n            if(A[i]%2 == 1 && A[j]%2 == 0){\\n                swap(A[i],A[j]);\\n                i=i+2;\\n                j=j+2;\\n            }else if(A[i]%2 == 0 && A[j]%2 == 0){\\n                i=i+2;\\n            }else if(A[i]%2 == 1 && A[j]%2 == 1){\\n                j=j+2;\\n            }else{\\n                i=i+2;\\n                j=j+2;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182755,
                "title": "javascript",
                "content": "```\nvar sortArrayByParityII = function(A) {\n    let oddIndex = 1;\n    let evenIndex = 0;\n    \n    let result = new Array(A.length);\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] % 2 == 0) {\n            result[evenIndex] = A[i];\n            evenIndex += 2;\n        } else {\n            result[oddIndex] = A[i];\n            oddIndex += 2;\n        }\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar sortArrayByParityII = function(A) {\n    let oddIndex = 1;\n    let evenIndex = 0;\n    \n    let result = new Array(A.length);\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] % 2 == 0) {\n            result[evenIndex] = A[i];\n            evenIndex += 2;\n        } else {\n            result[oddIndex] = A[i];\n            oddIndex += 2;\n        }\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733555,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0 , odd=1;\\n\\t\\t\\t\\tint n = nums.size() ;\\n\\t\\t\\t\\twhile(even < n && odd < n){\\n\\t\\t\\t\\t\\tif(nums[even]%2==0){\\n\\t\\t\\t\\t\\t\\teven += 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[odd]%2 == 1){\\n\\t\\t\\t\\t\\t\\todd+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tswap(nums[even],nums[odd]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0 , odd=1;\\n\\t\\t\\t\\tint n = nums.size() ;\\n\\t\\t\\t\\twhile(even < n && odd < n){\\n\\t\\t\\t\\t\\tif(nums[even]%2==0){\\n\\t\\t\\t\\t\\t\\teven += 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[odd]%2 == 1){\\n\\t\\t\\t\\t\\t\\todd+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tswap(nums[even],nums[odd]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440934,
                "title": "smartest-solution-with-java-beats-99-50-2-way",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n\\n        while(true){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even += 2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd += 2;\\n            }\\n            if(odd >= nums.length || even >= nums.length) break;\\n\\n            int temp = nums[odd];\\n            nums[odd] = nums[even];\\n            nums[even] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n\\n        while(true){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even += 2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd += 2;\\n            }\\n            if(odd >= nums.length || even >= nums.length) break;\\n\\n            int temp = nums[odd];\\n            nums[odd] = nums[even];\\n            nums[even] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304439,
                "title": "most-easy-way-efficient-approach-beats-95",
                "content": "# Intuition\\nAs soon as i saw the problem it was clear that we have to swap any unwanted element with respect to its index. i.e even element in odd index and odd element in even index.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers approach. Here we will take two pointers i and j, i is to find any odd element in even index, so i will start from 0 (i=0), j is to find even any element in odd index. When these both condition are true just swap i and j.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=1;\\n        while(i<n && j<n)\\n        {\\n            while(i<n && nums[i]%2==0)\\n                i+=2;\\n            while(j<n && nums[j]%2!=0)\\n                j+=2;\\n            if(i<n)\\n                swap(nums[i],nums[j]);\\n            i+=2;j+=2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=1;\\n        while(i<n && j<n)\\n        {\\n            while(i<n && nums[i]%2==0)\\n                i+=2;\\n            while(j<n && nums[j]%2!=0)\\n                j+=2;\\n            if(i<n)\\n                swap(nums[i],nums[j]);\\n            i+=2;j+=2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121590,
                "title": "beats-99-optimization-two-solution-o-2n-o-n",
                "content": "# Intuition One\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. since half of array contains even and odd numbers, and we have to place even at even elements indexes and odd elements at odd indexes so to avoid complexity we declare another vector for even and odd for easy way.\\n# Approach Number One\\n<!-- Describe your approach to solving the problem. -->\\n1. declare even and odd vector. if nums[i] is even array, pushback it in even and if it is odd then in odd array\\n2. now, in loop, check whether i is even or odd, accordingly set even elements at even indexes and odd elements at odd indexes respectively.\\n3. I have taken k and m so that i can excess even and odd array elements\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2N)-> O(N)\\n\\n# Code One\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> even;\\n        vector<int> odd;\\n\\n        //seperating even and odd elements\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1)\\n            odd.push_back(nums[i]);\\n            else \\n            even.push_back(nums[i]);\\n        }\\n        int k=0, m=0;\\n        inserting even element at even index and odd at odd index.\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(i&1)//odd\\n                nums[i]= odd[m++];\\n            else//even\\n                nums[i]= even[k++];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# Intuition Two\\nWe can solve this without declaring extra arrays, that is, even and odd. We will check directly nums[i] is even or odd and directly place it at its respective index in ans vector.\\n\\n# Approach Number Two(OPTIMIZED)\\n1. iterate throughout the array, check nums[i] is even or odd. \\n2. if nums[i] is even set it to even index and if it is odd set it to odd index.\\n\\n# Time Complexity -> O(N)\\n# Space Complexity ->O(1)\\nCode block\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int k=1, m=0;\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1) //odd\\n            {\\n                ans[k]= nums[i];\\n                k=k+2;\\n            }\\n            else//even\\n            {\\n                ans[m]=nums[i];\\n                m=m+2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// hope you like it. Upvote it please. If you find any problem, do let me know in the comment section.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> even;\\n        vector<int> odd;\\n\\n        //seperating even and odd elements\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1)\\n            odd.push_back(nums[i]);\\n            else \\n            even.push_back(nums[i]);\\n        }\\n        int k=0, m=0;\\n        inserting even element at even index and odd at odd index.\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(i&1)//odd\\n                nums[i]= odd[m++];\\n            else//even\\n                nums[i]= even[k++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821154,
                "title": "cpp-two-pointer-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int odd = 1; // pointer at odd index\\n        int even = 0; //pointer at even index \\n        \\n        while(even<nums.size()){\\n            if(nums[even] % 2 == 0){ // if even place has even value \\n                even += 2; // increment even pointer\\n            }\\n            else{ // else even place has odd value\\n                swap(nums[even], nums[odd]); // swap values such that odd pointer will surely have odd value\\n                odd += 2; // increment odd pointer\\n            }\\n        }\\n        return nums; // return your in-place solution \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int odd = 1; // pointer at odd index\\n        int even = 0; //pointer at even index \\n        \\n        while(even<nums.size()){\\n            if(nums[even] % 2 == 0){ // if even place has even value \\n                even += 2; // increment even pointer\\n            }\\n            else{ // else even place has odd value\\n                swap(nums[even], nums[odd]); // swap values such that odd pointer will surely have odd value\\n                odd += 2; // increment odd pointer\\n            }\\n        }\\n        return nums; // return your in-place solution \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755990,
                "title": "js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\nlet res = [];\\nnums = nums.sort()\\n\\n\\nlet odd = [];\\nlet even = [];\\nfor (let i = 0; i < nums.length; i++) {\\n  if(nums[i] % 2 === 0) odd.push(nums[i]);\\n  else {\\n    even.push(nums[i])\\n  }  \\n}\\nfor (let i = 0; i < nums.length; i++) {\\n  if(i % 2 === 0)\\n    res.push(odd.pop())\\n  else  res.push(even.pop())\\n}\\nreturn res\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\nlet res = [];\\nnums = nums.sort()\\n\\n\\nlet odd = [];\\nlet even = [];\\nfor (let i = 0; i < nums.length; i++) {\\n  if(nums[i] % 2 === 0) odd.push(nums[i]);\\n  else {\\n    even.push(nums[i])\\n  }  \\n}\\nfor (let i = 0; i < nums.length; i++) {\\n  if(i % 2 === 0)\\n    res.push(odd.pop())\\n  else  res.push(even.pop())\\n}\\nreturn res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703647,
                "title": "85ms-java-solution-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        \\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        \\n        for (int n : A) {\\n            if (n % 2 == 0)\\n                even.add(n);\\n            else \\n                odd.add(n);\\n        }\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % 2 == 0) {\\n                result[i] = even.remove(0);\\n            } else {\\n                result[i] = odd.remove(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        \\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        \\n        for (int n : A) {\\n            if (n % 2 == 0)\\n                even.add(n);\\n            else \\n                odd.add(n);\\n        }\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % 2 == 0) {\\n                result[i] = even.remove(0);\\n            } else {\\n                result[i] = odd.remove(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702239,
                "title": "java-easiest-solution-2-approaches-faster-than-80-online-submission-easy-understanding",
                "content": "```\\n//Approch :- 1 Runtime 9Ms Faster Than 33.3%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0,odd = 1;\\n        int[] arr = new int[nums.length];\\n        for(int i: nums){\\n            if(i%2 == 0){\\n                arr[even] = i;\\n                even+=2;\\n            }\\n            else{\\n                arr[odd] = i;\\n                odd+=2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n//Approch :- 2 Runtime 4Ms Faster Than 77.63%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even=0,odd=1;\\n        int[] arr = new int[nums.length];\\n        while(even<nums.length && odd<nums.length){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even+=2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd+=2;\\n            }\\n            if(even<nums.length && odd<nums.length){\\n                int temp = nums[even];\\n                nums[even] = nums[odd];\\n                nums[odd] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Approch :- 1 Runtime 9Ms Faster Than 33.3%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0,odd = 1;\\n        int[] arr = new int[nums.length];\\n        for(int i: nums){\\n            if(i%2 == 0){\\n                arr[even] = i;\\n                even+=2;\\n            }\\n            else{\\n                arr[odd] = i;\\n                odd+=2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n//Approch :- 2 Runtime 4Ms Faster Than 77.63%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even=0,odd=1;\\n        int[] arr = new int[nums.length];\\n        while(even<nums.length && odd<nums.length){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even+=2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd+=2;\\n            }\\n            if(even<nums.length && odd<nums.length){\\n                int temp = nums[even];\\n                nums[even] = nums[odd];\\n                nums[odd] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106494,
                "title": "c-easy-two-pointer-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n     vector<int>ans;\\n        vector<int>even;\\n        vector<int>odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even.push_back(nums[i]);\\n            }\\n            if(nums[i]%2==1){\\n                odd.push_back(nums[i]);\\n            }\\n        }\\n            int j=0;\\n            int k=0;\\n            for(int i=0;i<nums.size();i++){\\n                if(i%2==0){\\n                    ans.push_back(even[j]);\\n                    j++;\\n                }\\n                else{\\n                    ans.push_back(odd[k]);\\n                    k++;\\n                }\\n            }\\n return ans;\\n        \\n    }\\n};\\n \\n           \\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n     vector<int>ans;\\n        vector<int>even;\\n        vector<int>odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2074974,
                "title": "c-solution-simply-explained-constant-space-fast-algorithm",
                "content": "```\\nclass Solution {\\n  public:\\n    void reArrange(int arr[], int n) {\\n        //I have tried writing a simple while-loop method to swap wrongly placed odd and wrongly placed even elements.\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        while(x<n && y<n){\\n            \\n            //wrongly placed odd\\n            if(x%2==0 and arr[x]%2==1){\\n                x++;\\n            }\\n            //rightly placed even\\n            else if(x%2==0 and arr[x]%2==0){\\n                x++;\\n            }\\n            //rightly placed odd\\n            else if(x%2==1 and arr[x]%2==1){\\n                x++;\\n            }\\n            \\n            //wrongly placed even\\n            if(y%2==1 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed even\\n            else if(y%2==0 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed odd\\n            else if(y%2==1 and arr[y]%2==1){\\n                y++;\\n            }\\n            \\n            //swap wrongly placed even and wrongly placed odd\\n            if(x%2==1 and arr[x]%2==0 and y%2==0 and arr[y]%2==1){\\n                swap(arr[x],arr[y]);\\n                x++;\\n                y++;\\n            }\\n        }\\n    }\\n};\\n```\\nDo upvote and comment. Thanks.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    void reArrange(int arr[], int n) {\\n        //I have tried writing a simple while-loop method to swap wrongly placed odd and wrongly placed even elements.\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        while(x<n && y<n){\\n            \\n            //wrongly placed odd\\n            if(x%2==0 and arr[x]%2==1){\\n                x++;\\n            }\\n            //rightly placed even\\n            else if(x%2==0 and arr[x]%2==0){\\n                x++;\\n            }\\n            //rightly placed odd\\n            else if(x%2==1 and arr[x]%2==1){\\n                x++;\\n            }\\n            \\n            //wrongly placed even\\n            if(y%2==1 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed even\\n            else if(y%2==0 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed odd\\n            else if(y%2==1 and arr[y]%2==1){\\n                y++;\\n            }\\n            \\n            //swap wrongly placed even and wrongly placed odd\\n            if(x%2==1 and arr[x]%2==0 and y%2==0 and arr[y]%2==1){\\n                swap(arr[x],arr[y]);\\n                x++;\\n                y++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057475,
                "title": "python-two-pointers-o-n-time-explanation",
                "content": "<b>Success</b>\\nDetails \\nRuntime: 228 ms, faster than <b>73.41% </b>of Python3 online submissions for Sort Array By Parity II.\\nMemory Usage: 16.1 MB, less than <b>91.62%</b> of Python3 online submissions for Sort Array By Parity II.\\n\\n\\n1. Itterating i pointer over the array starting from zero and skipping one element so i will be always even.\\n2. Check if the current element is odd or even\\n3. If even we dont have to do anything\\n4. if odd chek j pointer which was initillized at 1.\\n5. Itterating j pointer over the array starting from one and skipping one element so i will be always odd.\\n6. if jth element is even we have to swap jth element with ith.\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j=1\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2!=0:\\n                while nums[j]%2!=0:\\n                    j=j+2\\n                nums[i],nums[j]=nums[j],nums[i]\\n        return nums\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j=1\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2!=0:\\n                while nums[j]%2!=0:\\n                    j=j+2\\n                nums[i],nums[j]=nums[j],nums[i]\\n        return nums\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552138,
                "title": "c-solution-two-pointer-using-bitwise-operator",
                "content": "**If the Solution helps you,please do consider upvoting it.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n      for(int i=0,j=1;i<nums.size() and j<nums.size();)\\n      {\\n          if(!(nums[i]&1))\\n              i+=2;\\n          else if(nums[j]&1)\\n              j+=2;\\n          else\\n              swap(nums[i],nums[j]);\\n      }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n      for(int i=0,j=1;i<nums.size() and j<nums.size();)\\n      {\\n          if(!(nums[i]&1))\\n              i+=2;\\n          else if(nums[j]&1)\\n              j+=2;\\n          else\\n              swap(nums[i],nums[j]);\\n      }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493808,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n\\tvector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n\\t\\tint n = nums.size();\\n\\t\\tint i = 0, j = 1;\\n\\t\\twhile(i < n && j < n)\\n        {\\n\\t\\t\\tif(nums[i] % 2 == 0)\\n            {\\n\\t\\t\\t\\ti += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[j] % 2 == 1)\\n            {\\n\\t\\t\\t\\tj += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n\\tvector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n\\t\\tint n = nums.size();\\n\\t\\tint i = 0, j = 1;\\n\\t\\twhile(i < n && j < n)\\n        {\\n\\t\\t\\tif(nums[i] % 2 == 0)\\n            {\\n\\t\\t\\t\\ti += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[j] % 2 == 1)\\n            {\\n\\t\\t\\t\\tj += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491669,
                "title": "inplace-solution-using-two-pointers-java",
                "content": "It is given that the array will have same count of even and odd numbers which means that the length of the array will always be even. \\nIf we maintain two pointers `left` and `right` at opposite ends of the array, i.e.,\\n\\n```java\\nleft = 0\\nright = n - 1\\n```\\n\\nThen we can safely say that `left` will be at even index and `right` will be at odd index. We will use this property and always make sure that the element at `left` will always be even and element at `right` will always be odd. We will move both pointers two steps ahead and behind respectively. It will result in the following three cases -\\n\\n1. If both the elements are violating the constraint, we will swap them and move both pointers\\n2. If only a single element is violating the constraint, we will move that pointer only.\\n3. If both the elements are not violating the constraint, we will just move both the pointers.\\n\\n```java\\npublic class Problem28_SortArrayByParityII {\\n\\n    public int[] sortArrayByParityII(int[] nums) {\\n        // Special case\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Length of the array\\n        int n = nums.length;\\n        // Left and right pointers\\n        int left = 0;\\n        int right = n - 1;\\n        // Loop until the condition is met\\n        while (left < n && right >= 0) {\\n            // If both the numbers at wrong positions, we will swap them\\n            if (nums[left] % 2 == 1 && nums[right] % 2 == 0) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left += 2;\\n                right -= 2;\\n            }\\n            // If the left number is at wrong position but right\\n            // number is at correct position, we will move right\\n            // pointer two steps before\\n            else if (nums[left] % 2 == 1 && nums[right] % 2 == 1) {\\n                right -= 2;\\n            }\\n            // If the right number is at wrong position but left\\n            // number is at correct position, we will move left\\n            // pointer two steps after\\n            else if (nums[left] % 2 == 0 && nums[right] % 2 == 0) {\\n                left += 2;\\n            }\\n            // If both the numbers are at correct position, we just move\\n            // both the pointers\\n            else {\\n                left += 2;\\n                right -= 2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```java\\nleft = 0\\nright = n - 1\\n```\n```java\\npublic class Problem28_SortArrayByParityII {\\n\\n    public int[] sortArrayByParityII(int[] nums) {\\n        // Special case\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Length of the array\\n        int n = nums.length;\\n        // Left and right pointers\\n        int left = 0;\\n        int right = n - 1;\\n        // Loop until the condition is met\\n        while (left < n && right >= 0) {\\n            // If both the numbers at wrong positions, we will swap them\\n            if (nums[left] % 2 == 1 && nums[right] % 2 == 0) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left += 2;\\n                right -= 2;\\n            }\\n            // If the left number is at wrong position but right\\n            // number is at correct position, we will move right\\n            // pointer two steps before\\n            else if (nums[left] % 2 == 1 && nums[right] % 2 == 1) {\\n                right -= 2;\\n            }\\n            // If the right number is at wrong position but left\\n            // number is at correct position, we will move left\\n            // pointer two steps after\\n            else if (nums[left] % 2 == 0 && nums[right] % 2 == 0) {\\n                left += 2;\\n            }\\n            // If both the numbers are at correct position, we just move\\n            // both the pointers\\n            else {\\n                left += 2;\\n                right -= 2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491222,
                "title": "c-two-pointers-inplace-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();){\\n\\t\\t\\t// If we get an odd number or  an even number which is already processed then leave that number  \\n            if(nums[i]&1 || (i<j && !(i&1))){ \\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[j]); // Placing even numbers at their right place. By doing this, the odd numbers will come in their place automatically\\n                j+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();){\\n\\t\\t\\t// If we get an odd number or  an even number which is already processed then leave that number  \\n            if(nums[i]&1 || (i<j && !(i&1))){ \\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[j]); // Placing even numbers at their right place. By doing this, the odd numbers will come in their place automatically\\n                j+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335190,
                "title": "c-solution-two-pointer-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenPointer = 0, oddPointer = 1;\\n        while(evenPointer < nums.size() && oddPointer <nums.size()){\\n            if(nums[evenPointer] %2 == 1 && nums[oddPointer]%2==0){\\n                swap(nums[evenPointer],nums[oddPointer]);\\n                evenPointer+=2;\\n                oddPointer+=2;\\n                continue;\\n            }\\n            if(nums[evenPointer]%2==0){\\n                evenPointer+=2;\\n            }\\n            if(nums[oddPointer]%2==1){\\n                oddPointer+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenPointer = 0, oddPointer = 1;\\n        while(evenPointer < nums.size() && oddPointer <nums.size()){\\n            if(nums[evenPointer] %2 == 1 && nums[oddPointer]%2==0){\\n                swap(nums[evenPointer],nums[oddPointer]);\\n                evenPointer+=2;\\n                oddPointer+=2;\\n                continue;\\n            }\\n            if(nums[evenPointer]%2==0){\\n                evenPointer+=2;\\n            }\\n            if(nums[oddPointer]%2==1){\\n                oddPointer+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003699,
                "title": "python-3-two-pointers-o-n",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\tans = [None] * len(A)\\n\\t\\tk = 0\\n\\t\\tt = 1\\n\\t\\tfor i in A:\\n\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\tans[k] = i\\n\\t\\t\\t\\tk += 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[t] = i\\n\\t\\t\\t\\tt += 2\\n\\t\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\tans = [None] * len(A)\\n\\t\\tk = 0\\n\\t\\tt = 1\\n\\t\\tfor i in A:\\n\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\tans[k] = i\\n\\t\\t\\t\\tk += 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[t] = i\\n\\t\\t\\t\\tt += 2\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767628,
                "title": "c-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i,even=0,odd=1;\\n        vector<int> B(A.size());\\n        for(i=0;i<A.size();i++)\\n        {\\n            if((A[i]%2)==0)\\n            {\\n               B[even]=A[i];\\n                even+=2;\\n            } \\n            else\\n            {\\n               B[odd]=A[i];\\n                odd+=2; \\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i,even=0,odd=1;\\n        vector<int> B(A.size());\\n        for(i=0;i<A.size();i++)\\n        {\\n            if((A[i]%2)==0)\\n            {\\n               B[even]=A[i];\\n                even+=2;\\n            } \\n            else\\n            {\\n               B[odd]=A[i];\\n                odd+=2; \\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755362,
                "title": "javascript-simple-using-filter",
                "content": "```\\nvar sortArrayByParityII = function(A) {\\n    let evenNums = A.filter((i) => i % 2 === 0);\\n    let oddNums = A.filter((i) => i % 2 !== 0);\\n    \\n    let res = [];\\n    for (let i = 0; i < A.length / 2; i++) {\\n        res.push(evenNums[i], oddNums[i]);\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nStats:\\nRuntime: 100 ms, faster than 88.97% of JavaScript online submissions for Sort Array By Parity II.\\nMemory Usage: 44.3 MB, less than 12.50% of JavaScript online submissions for Sort Array By Parity II.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(A) {\\n    let evenNums = A.filter((i) => i % 2 === 0);\\n    let oddNums = A.filter((i) => i % 2 !== 0);\\n    \\n    let res = [];\\n    for (let i = 0; i < A.length / 2; i++) {\\n        res.push(evenNums[i], oddNums[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308659,
                "title": "efficient-python-solution-with-generator",
                "content": "We only need to check every other element for violating the problem statement invariant. If that happens, we can use generator to find matching pair to swap and to also pick up where we left off on next mismatch.\\n\\n```\\ndef sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        def gen_odd():\\n            for j in range(1, len(A), 2):\\n                if not A[j] % 2: yield j\\n\\n        odd = gen_odd()\\n        for i in range(0,len(A),2):\\n            if A[i] % 2:\\n                j = next(odd)\\n                A[i], A[j] = A[j], A[i]\\n\\n        return A\\n```",
                "solutionTags": [],
                "code": "```\\ndef sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        def gen_odd():\\n            for j in range(1, len(A), 2):\\n                if not A[j] % 2: yield j\\n\\n        odd = gen_odd()\\n        for i in range(0,len(A),2):\\n            if A[i] % 2:\\n                j = next(odd)\\n                A[i], A[j] = A[j], A[i]\\n\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 223835,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(i < A.length && j < A.length)\\n        {\\n            while(i < A.length && A[i] % 2 == 0) i += 2;\\n            while(j < A.length && A[j] % 2 == 1) j += 2;\\n            \\n            if(i < A.length && j < A.length)\\n                swap(A, i, j);\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int evenIndex = 0;\\n        int oddIndex = A.length - 1;\\n        \\n        while(evenIndex < A.length && oddIndex > 0)\\n        {\\n            if(A[evenIndex] % 2 > A[oddIndex] % 2)\\n                swap(A, evenIndex, oddIndex);\\n            \\n            if(A[evenIndex] % 2 == 0) evenIndex += 2;\\n            if(A[oddIndex] % 2 == 1)  oddIndex -= 2;\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(i < A.length && j < A.length)\\n        {\\n            while(i < A.length && A[i] % 2 == 0) i += 2;\\n            while(j < A.length && A[j] % 2 == 1) j += 2;\\n            \\n            if(i < A.length && j < A.length)\\n                swap(A, i, j);\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int evenIndex = 0;\\n        int oddIndex = A.length - 1;\\n        \\n        while(evenIndex < A.length && oddIndex > 0)\\n        {\\n            if(A[evenIndex] % 2 > A[oddIndex] % 2)\\n                swap(A, evenIndex, oddIndex);\\n            \\n            if(A[evenIndex] % 2 == 0) evenIndex += 2;\\n            if(A[oddIndex] % 2 == 1)  oddIndex -= 2;\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204664,
                "title": "c-solution",
                "content": "```\\nint *sortArrayByParityII(int const *A, int ASize, int *returnSize) {\\n    int odd = 1, even = 0;\\n    int *ret = (int *) malloc(sizeof(int) * (*returnSize = ASize));\\n    for (int i = 0; i < *returnSize; ++i) {\\n        if (A[i] % 2 == 0) {\\n            ret[even] = A[i];\\n            even += 2;\\n        } else {\\n            ret[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint *sortArrayByParityII(int const *A, int ASize, int *returnSize) {\\n    int odd = 1, even = 0;\\n    int *ret = (int *) malloc(sizeof(int) * (*returnSize = ASize));\\n    for (int i = 0; i < *returnSize; ++i) {\\n        if (A[i] % 2 == 0) {\\n            ret[even] = A[i];\\n            even += 2;\\n        } else {\\n            ret[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733546,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n        int even=0;\\n        int odd=1;\\n\\n        cout<<\"Hello\";\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] % 2==0){\\n                ans[even]=nums[i];\\n                if(even+2 <= nums.size()-1){\\n                    even+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n            else{\\n                ans[odd]=nums[i];\\n                if(odd+2 <= nums.size()-1){\\n                    odd+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n        int even=0;\\n        int odd=1;\\n\\n        cout<<\"Hello\";\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] % 2==0){\\n                ans[even]=nums[i];\\n                if(even+2 <= nums.size()-1){\\n                    even+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n            else{\\n                ans[odd]=nums[i];\\n                if(odd+2 <= nums.size()-1){\\n                    odd+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2952911,
                "title": "python3-simple-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        answer=[]\\n\\n        # We split nums into even entries and odd entries\\n        even = [n for n in nums if n%2 == 0]\\n        odd =  [n for n in nums if n%2 == 1]\\n\\n        # We fill answer with even and odd entries \\n        for a, b in zip(even, odd):\\n            answer.append(a)\\n            answer.append(b)\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        answer=[]\\n\\n        # We split nums into even entries and odd entries\\n        even = [n for n in nums if n%2 == 0]\\n        odd =  [n for n in nums if n%2 == 1]\\n\\n        # We fill answer with even and odd entries \\n        for a, b in zip(even, odd):\\n            answer.append(a)\\n            answer.append(b)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933111,
                "title": "easy-with-two-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n       \\n       /* int temp=0;\\n        int k=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        \\n        if(i%2==0&&nums[i]%2==0||i%2!=0&&nums[i]%2!=0)\\n        {\\n            continue;\\n        }\\n        temp=i;\\n        for(int j=i+1;j<nums.length;j++)\\n        {\\n            if((i%2!=0 && nums[i]%2==0)||(i%2==0 && nums[i]%2!=0))\\n            {\\n               k= nums[temp];\\n               nums[temp]=nums[j];\\n               nums[j]=k;\\n                \\n\\n            }\\n        }\\n        }\\n\\n        return nums;\\n    }*/\\n    \\n        int i = 0, j = 1;\\n        int l = nums.length;\\n        int[] B = new int[l];\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k]%2 == 0){\\n                B[i] = nums[k];\\n                i+=2;\\n            }else{\\n                B[j] = nums[k];\\n                j+=2;\\n            } \\n        }\\n        return B;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n       \\n       /* int temp=0;\\n        int k=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        \\n        if(i%2==0&&nums[i]%2==0||i%2!=0&&nums[i]%2!=0)\\n        {\\n            continue;\\n        }\\n        temp=i;\\n        for(int j=i+1;j<nums.length;j++)\\n        {\\n            if((i%2!=0 && nums[i]%2==0)||(i%2==0 && nums[i]%2!=0))\\n            {\\n               k= nums[temp];\\n               nums[temp]=nums[j];\\n               nums[j]=k;\\n                \\n\\n            }\\n        }\\n        }\\n\\n        return nums;\\n    }*/\\n    \\n        int i = 0, j = 1;\\n        int l = nums.length;\\n        int[] B = new int[l];\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k]%2 == 0){\\n                B[i] = nums[k];\\n                i+=2;\\n            }else{\\n                B[j] = nums[k];\\n                j+=2;\\n            } \\n        }\\n        return B;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896465,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[]ans= new int[nums.length];\\n\\t\\tint even=0;\\n        int odd=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                ans[even]=nums[i];\\n                even=even+2;\\n            }else{\\n                ans[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[]ans= new int[nums.length];\\n\\t\\tint even=0;\\n        int odd=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                ans[even]=nums[i];\\n                even=even+2;\\n            }else{\\n                ans[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655409,
                "title": "java-two-solutions-extra-space-and-in-place",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Using extra-space (stack):\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        Stack<Integer> evens = new Stack<>();\\n        Stack<Integer> odds = new Stack<>();\\n\\n        for (int n : nums) {\\n            if (n % 2 == 0) evens.add(n);\\n            else odds.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = evens.pop();\\n            else nums[i] = odds.pop();\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. In-place: \\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i = 0, j = 1;\\n        int n = nums.length;\\n\\n        while (i < n && j < n) {\\n            while (i < n && nums[i] % 2 == 0) i += 2;\\n            while (j < n && nums[j] % 2 == 1) j += 2;\\n\\n            if (i < n && j < n) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(N), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        Stack<Integer> evens = new Stack<>();\\n        Stack<Integer> odds = new Stack<>();\\n\\n        for (int n : nums) {\\n            if (n % 2 == 0) evens.add(n);\\n            else odds.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = evens.pop();\\n            else nums[i] = odds.pop();\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i = 0, j = 1;\\n        int n = nums.length;\\n\\n        while (i < n && j < n) {\\n            while (i < n && nums[i] % 2 == 0) i += 2;\\n            while (j < n && nums[j] % 2 == 1) j += 2;\\n\\n            if (i < n && j < n) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(N), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586768,
                "title": "both-approach-optimized-brute-force-two-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n\\t***METHOD-1***\\n** 2 ptr --> Brute Force using additional space**\\n\\n       int odd = 1  ; \\n        int even = 0 ; \\n        vector<int>ans(nums.size());\\n        for(int i=0 ; i<nums.size();i++) {\\n            if(nums[i]&1) {\\n                ans[odd] = nums[i];\\n                odd+=2;\\n            }\\n           else if(!(nums[i]&1)) {\\n                ans[even] = nums[i];\\n                even+=2;\\n            }     \\n        }\\n        return ans;    \\n        \\n     \\t***METHOD-2***\\n   ** 2 ptr -->  optimized Approach  Without using additional space**\\n\\n    \\n        int odd = 1  ; \\n        int even = 0 ; \\n        int n = nums.size();\\n        while(odd<n and even<n){\\n            // odd element at odd pos \\n            if(nums[odd]&1) { odd+=2;}\\n        // even element at even pos \\n             else if(!(nums[even]&1)) {even+=2;    }\\n            // odd element at even position and even element at odd position \\n            else if(!(nums[odd]&1) || nums[even]&1){\\n                swap(nums[odd],nums[even]);\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n\\t***METHOD-1***\\n** 2 ptr --> Brute Force using additional space**\\n\\n       int odd = 1  ; \\n        int even = 0 ; \\n        vector<int>ans(nums.size());\\n        for(int i=0 ; i<nums.size();i++) {\\n            if(nums[i]&1) {\\n                ans[odd] = nums[i];\\n                odd+=2;\\n            }\\n           else if(!(nums[i]&1)) {\\n                ans[even] = nums[i];\\n                even+=2;\\n            }     \\n        }\\n        return ans;    \\n        \\n     \\t***METHOD-2***\\n   ** 2 ptr -->  optimized Approach  Without using additional space**\\n\\n    \\n        int odd = 1  ; \\n        int even = 0 ; \\n        int n = nums.size();\\n        while(odd<n and even<n){\\n            // odd element at odd pos \\n            if(nums[odd]&1) { odd+=2;}\\n        // even element at even pos \\n             else if(!(nums[even]&1)) {even+=2;    }\\n            // odd element at even position and even element at odd position \\n            else if(!(nums[odd]&1) || nums[even]&1){\\n                swap(nums[odd],nums[even]);\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417872,
                "title": "python-simple-solution",
                "content": "```\\nresult = [0]*len(nums)\\n        even = 0\\n        odd = 1\\n        for i in nums:\\n            if i % 2 == 0:\\n                result[even] = i\\n                even += 2\\n            else:\\n                result[odd] = i\\n                odd += 2\\n        return (result)\\n```",
                "solutionTags": [],
                "code": "```\\nresult = [0]*len(nums)\\n        even = 0\\n        odd = 1\\n        for i in nums:\\n            if i % 2 == 0:\\n                result[even] = i\\n                even += 2\\n            else:\\n                result[odd] = i\\n                odd += 2\\n        return (result)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403590,
                "title": "java-o-1-space-o-n-time-90-faster-easy-explained",
                "content": "A brief about logical approach:\\n* We have two poiters,\\n\\t* `i` at index 0 (for even indices)\\n\\t* `j` at index 1 (for odd indices)\\n* Now we check whether `i` has an `even` number,\\n\\t* if `nums[i]` is even : `i+=2` (move to next even index)\\n\\t* if `nums[i]` is odd: we check whether `j` has an `odd` number,\\n\\t\\t* if `nums[j]` is odd : `j+=2` (move to next odd index)\\n\\t\\t* if `nums[j]` is even: swap `nums[i]` and `nums[j]`\\n\\nThats it!\\n\\nIf you found it helpful upvote. And if you have any doubts or suggestions, comment them down. \\u270C\\n\\n\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i=0,j=1;\\n\\t\\t\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]%2==0) i+=2;\\n            else{\\n                if(nums[j]%2!=0) j+=2;\\n                else{\\n                    int temp = nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i=0,j=1;\\n\\t\\t\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]%2==0) i+=2;\\n            else{\\n                if(nums[j]%2!=0) j+=2;\\n                else{\\n                    int temp = nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387565,
                "title": "c-solution-easy-and-simple",
                "content": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        vector<int>v(n); // ans vector will be of same size as nums\\n\\t\\t\\n        int i=0; // even index\\n        int j=1; // odd index\\n\\t\\t\\n        for(int k=0; k<n; k++){\\n            if(nums[k]%2==0){\\n                v[i]=nums[k];\\n                i+=2;\\n            }\\n            else if(nums[k]%2!=0){\\n                v[j]=nums[k];\\n                j+=2;\\n            }\\n        }\\n        return v;\\n    }\\n\\t// dry run to understand best!\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        vector<int>v(n); // ans vector will be of same size as nums\\n\\t\\t\\n        int i=0; // even index\\n        int j=1; // odd index\\n\\t\\t\\n        for(int k=0; k<n; k++){\\n            if(nums[k]%2==0){\\n                v[i]=nums[k];\\n                i+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2349723,
                "title": "100-faster-code-for-the-problem",
                "content": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int result[]=new int[nums.length];\\n        int j=0,k=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[j]=nums[i];\\n                j+=2;\\n            }\\n            else{\\n                \\n            result[k]=nums[i];\\n            k+=2;\\n            }\\n        }\\n        return(result);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int result[]=new int[nums.length];\\n        int j=0,k=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[j]=nums[i];\\n                j+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2280745,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tprint(nums)\\n\\n\\t\\t\\ts=0\\n\\t\\t\\te=1\\n\\n\\t\\t\\twhile s<len(nums) and e<len(nums):\\n\\t\\t\\t\\twhile nums[s]%2==0:\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\tif s>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\t\\t\\t\\twhile nums[e]%2!=0:\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\t\\t\\tif e>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\n\\t\\t\\t\\tif s<len(nums) and e<len(nums):\\n\\t\\t\\t\\t\\tnums[e],nums[s]=nums[s],nums[e]\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\treturn nums",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tprint(nums)\\n\\n\\t\\t\\ts=0\\n\\t\\t\\te=1\\n\\n\\t\\t\\twhile s<len(nums) and e<len(nums):\\n\\t\\t\\t\\twhile nums[s]%2==0:\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\tif s>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\t\\t\\t\\twhile nums[e]%2!=0:\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\t\\t\\tif e>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\n\\t\\t\\t\\tif s<len(nums) and e<len(nums):\\n\\t\\t\\t\\t\\tnums[e],nums[s]=nums[s],nums[e]\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\treturn nums",
                "codeTag": "Java"
            },
            {
                "id": 2209673,
                "title": "basic-swapping",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        for(int i = 0, j = 1; i < nums.size();){\\n            if(nums[i]%2==0)   i+=2; //for even index we are checking whether the number is even or not \\n            else if(nums[j]%2!=0)   j+=2; //here we are checking for odd index\\n            else swap(nums[i],nums[j]);// swap if both condition doesn\\'t match\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nDon\\'t forget to like:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        for(int i = 0, j = 1; i < nums.size();){\\n            if(nums[i]%2==0)   i+=2; //for even index we are checking whether the number is even or not \\n            else if(nums[j]%2!=0)   j+=2; //here we are checking for odd index\\n            else swap(nums[i],nums[j]);// swap if both condition doesn\\'t match\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123940,
                "title": "simple-c-solution-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int a=0,b=1;\\n        while (b<nums.size()&&a<nums.size()) {\\n            if (nums[a]%2==0) a+=2;\\n            else {\\n                if (nums[b]%2==0) {\\n                    swap(nums[a],nums[b]);\\n                    a+=2;\\n                    b+=2;\\n                }\\n                else b+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int a=0,b=1;\\n        while (b<nums.size()&&a<nums.size()) {\\n            if (nums[a]%2==0) a+=2;\\n            else {\\n                if (nums[b]%2==0) {\\n                    swap(nums[a],nums[b]);\\n                    a+=2;\\n                    b+=2;\\n                }\\n                else b+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110301,
                "title": "c-easy-solution-2-pointers",
                "content": "The basic intuition is, whenever we find element at odd index as even and element at even index as odd simultaneously, we just swap them them to their original positions , else we move even and odd pointers forward.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenIndex = 0 , oddIndex = 1 ; \\n        while (evenIndex < nums.size() && oddIndex < nums.size()) {\\n            if (nums[evenIndex] % 2 == 0)  evenIndex += 2 ;\\n            else if (nums[oddIndex] % 2 != 0) oddIndex += 2 ;\\n            else  swap(nums[evenIndex] , nums[oddIndex]) ; \\n        }\\n        return nums ; \\n    }\\n};\\n```\\nPlease do **upvote** if you found this helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenIndex = 0 , oddIndex = 1 ; \\n        while (evenIndex < nums.size() && oddIndex < nums.size()) {\\n            if (nums[evenIndex] % 2 == 0)  evenIndex += 2 ;\\n            else if (nums[oddIndex] % 2 != 0) oddIndex += 2 ;\\n            else  swap(nums[evenIndex] , nums[oddIndex]) ; \\n        }\\n        return nums ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058266,
                "title": "js-easiest",
                "content": "```\\nvar sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052518,
                "title": "java-o-n-complexity-with-faster-than-99-94-submission",
                "content": "```\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 , odd = 1;\\n        while( even < nums.length && odd < nums.length) {\\n            if(nums[even] % 2 != 0) {\\n                swap(nums, even, odd);\\n                odd += 2;\\n            } else even += 2;\\n        }\\n        return nums;\\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 , odd = 1;\\n        while( even < nums.length && odd < nums.length) {\\n            if(nums[even] % 2 != 0) {\\n                swap(nums, even, odd);\\n                odd += 2;\\n            } else even += 2;\\n        }\\n        return nums;\\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945828,
                "title": "sort-array-by-parity-i-ii-c-explanation",
                "content": "**C++ solutions**\\n\\n**1. [Sort Array By Parity I](https://leetcode.com/problems/sort-array-by-parity)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        \\n        while (l < r) {\\n            // skip even numbers from left\\n            // until an odd number is found\\n            while (l < r && nums[l] & 1 == 0) l++;\\n            // skip odd numbers from right\\n            // until an even number is found\\n            while (l < r && nums[r] & 1) r--;\\n            \\n            // now swap the numbers\\n            swap(nums[l], nums[r]);\\n            // loop until all numbers have been exhausted\\n            l++, r--;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**2. [Sort Array By Parity II](https://leetcode.com/problems/sort-array-by-parity-ii/)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1, n = nums.size();\\n        \\n        while (i < n && j < n) {\\n            // skip even numbers which are at even positions\\n            while (i < n && nums[i]%2 == 0) i += 2;\\n            // skip odd numbers which are at odd positions\\n            while (j < n && nums[j]%2 != 0) j += 2;\\n            \\n            // swap numbers which weren\\'t skipped\\n            // these numbers are obviously:\\n            // even at odd position & odd at even position\\n            if (i < n && j < n) swap(nums[i], nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\nFor both:\\nTime comlexity: **O(n)**\\nSpace complexity: **O(1)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        \\n        while (l < r) {\\n            // skip even numbers from left\\n            // until an odd number is found\\n            while (l < r && nums[l] & 1 == 0) l++;\\n            // skip odd numbers from right\\n            // until an even number is found\\n            while (l < r && nums[r] & 1) r--;\\n            \\n            // now swap the numbers\\n            swap(nums[l], nums[r]);\\n            // loop until all numbers have been exhausted\\n            l++, r--;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1, n = nums.size();\\n        \\n        while (i < n && j < n) {\\n            // skip even numbers which are at even positions\\n            while (i < n && nums[i]%2 == 0) i += 2;\\n            // skip odd numbers which are at odd positions\\n            while (j < n && nums[j]%2 != 0) j += 2;\\n            \\n            // swap numbers which weren\\'t skipped\\n            // these numbers are obviously:\\n            // even at odd position & odd at even position\\n            if (i < n && j < n) swap(nums[i], nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929768,
                "title": "c-solution-beats-97-92-o-n-complexity",
                "content": "**922. Sort Array By Parity II**\\n\\nHere, we have considered two variables **o** and **e** for odd and even respectively, and going to increment \\nit by 2 so that the element at index i if even then we will increment **e** by 2 and if odd then increment **o** \\nby 2.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n      vector<int>v(nums.size());\\n        int o=1,e=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                v[e]=nums[i];\\n                e+=2;\\n            }\\n            else\\n            {\\n                v[o]=nums[i];\\n                o+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb0273e4-5cfb-4fdc-9cbb-7767d42ca7a9_1649523099.3406916.png)\\n\\n**Please do upvote**\\uD83E\\uDD17\\n**Keep Codin\\' **\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n      vector<int>v(nums.size());\\n        int o=1,e=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                v[e]=nums[i];\\n                e+=2;\\n            }\\n            else\\n            {\\n                v[o]=nums[i];\\n                o+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892677,
                "title": "python-tc-o-n-sc-o-1-easy-solution-explained",
                "content": "**Please upvote if it is useful. Thanks!**\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j = 1 # j is used to check all the odd indexes\\n        \\n        # check all the even indexes with i\\n        for i in range(0, len(nums), 2):\\n            # nums[i] is odd while it should be even\\n            if nums[i] & 1:\\n                # look for the next even number in an odd index\\n                # it\\'s guaranteed to exist because we already found\\n                # ad odd number with even index\\n                while (j < len(nums)) and (nums[j] & 1):\\n                    j += 2\\n                # now swap them\\n                # by putting even numbers in positions with even indexes\\n                # we are also putting odd numbers in odd indexes as a\\n                # consequence of the swap, all in one pass\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j = 1 # j is used to check all the odd indexes\\n        \\n        # check all the even indexes with i\\n        for i in range(0, len(nums), 2):\\n            # nums[i] is odd while it should be even\\n            if nums[i] & 1:\\n                # look for the next even number in an odd index\\n                # it\\'s guaranteed to exist because we already found\\n                # ad odd number with even index\\n                while (j < len(nums)) and (nums[j] & 1):\\n                    j += 2\\n                # now swap them\\n                # by putting even numbers in positions with even indexes\\n                # we are also putting odd numbers in odd indexes as a\\n                # consequence of the swap, all in one pass\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883643,
                "title": "java-in-place-solution",
                "content": "```\\n    \\n    // given array with half even and half odd nums\\n    // place even nums in even indices and odd nums in odd indices\\n    \\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        // in a loop check if index is even or odd - this tells us whether we need to put even or odd number in that place\\n        // if correct num is in that place move to next index\\n        // if not, have a pointer move to the next correct val and swap those two and move to next index\\n        // O(1) space O(n) time\\n        \\n        int evenIndex = 0;\\n        int oddIndex = 1;\\n        \\n        while(true) {\\n            while(evenIndex < nums.length) {\\n                if(nums[evenIndex] % 2 == 0) {\\n                    evenIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            while(oddIndex < nums.length) {\\n                if(nums[oddIndex] % 2 != 0) {\\n                    oddIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            if(evenIndex < nums.length) { // or oddIndex doesn\\'t matter\\n                int temp = nums[evenIndex];\\n                nums[evenIndex] = nums[oddIndex];\\n                nums[oddIndex] = temp;\\n                evenIndex += 2;\\n                oddIndex += 2;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return nums;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    \\n    // given array with half even and half odd nums\\n    // place even nums in even indices and odd nums in odd indices\\n    \\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        // in a loop check if index is even or odd - this tells us whether we need to put even or odd number in that place\\n        // if correct num is in that place move to next index\\n        // if not, have a pointer move to the next correct val and swap those two and move to next index\\n        // O(1) space O(n) time\\n        \\n        int evenIndex = 0;\\n        int oddIndex = 1;\\n        \\n        while(true) {\\n            while(evenIndex < nums.length) {\\n                if(nums[evenIndex] % 2 == 0) {\\n                    evenIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            while(oddIndex < nums.length) {\\n                if(nums[oddIndex] % 2 != 0) {\\n                    oddIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            if(evenIndex < nums.length) { // or oddIndex doesn\\'t matter\\n                int temp = nums[evenIndex];\\n                nums[evenIndex] = nums[oddIndex];\\n                nums[oddIndex] = temp;\\n                evenIndex += 2;\\n                oddIndex += 2;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return nums;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1755746,
                "title": "c-in-place-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        while(i < nums.size() and j < nums.size()) {\\n            while(i < nums.size() and nums[i]%2 == 0) i += 2;\\n            while(j < nums.size() and nums[j]%2 == 1) j += 2;\\n            if(i < nums.size() and j < nums.size()) swap(nums[i],nums[j]);\\n            i += 2; j += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        while(i < nums.size() and j < nums.size()) {\\n            while(i < nums.size() and nums[i]%2 == 0) i += 2;\\n            while(j < nums.size() and nums[j]%2 == 1) j += 2;\\n            if(i < nums.size() and j < nums.size()) swap(nums[i],nums[j]);\\n            i += 2; j += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716736,
                "title": "simple-java-solution-using-two-index-variables-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n\\t\\n        int even_index = 0;\\n        int odd_index = 0;\\n        \\n        int[] returned_array = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(i%2 == 0){\\n                while(nums[even_index]%2 != 0){\\n                    even_index++;\\n                }\\n                \\n                returned_array[i] = nums[even_index];\\n                even_index++;\\n                \\n            } else {\\n                while(nums[odd_index]%2 == 0){\\n                    odd_index++;\\n                }\\n                \\n                returned_array[i] = nums[odd_index];\\n                odd_index++;\\n            }\\n        }\\n        \\n        return returned_array;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n\\t\\n        int even_index = 0;\\n        int odd_index = 0;\\n        \\n        int[] returned_array = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(i%2 == 0){\\n                while(nums[even_index]%2 != 0){\\n                    even_index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1694517,
                "title": "python-easy-solution-using-two-pointers-beats-90-solutions",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        l,r=0,len(nums)-1\\n        \\n        while l<len(nums) and r>0:\\n            \\n            if nums[l]%2==0: l+=2\\n                \\n            elif nums[r]%2!=0: r-=2\\n            \\n            else:\\n                nums[l],nums[r]=nums[r],nums[l]\\n                l+=2\\n                r-=2\\n               \\n        return nums\\n     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        l,r=0,len(nums)-1\\n        \\n        while l<len(nums) and r>0:\\n            \\n            if nums[l]%2==0: l+=2\\n                \\n            elif nums[r]%2!=0: r-=2\\n            \\n            else:\\n                nums[l],nums[r]=nums[r],nums[l]\\n                l+=2\\n                r-=2\\n               \\n        return nums\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621556,
                "title": "java-solution",
                "content": "```\\npublic int[] sortArrayByParityII(int[] nums) {\\n        \\n        int length = nums.length;\\n        int[] result = new int[length];\\n        int e = 0; //for even\\n        int o = 1; //for odd\\n        \\n        for(int num: nums) {\\n            \\n            if(num%2 == 0) {\\n                result[e] = num;\\n                e+=2;\\n\\n            }\\n            else {\\n                result[o] = num;\\n                o+=2;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] nums) {\\n        \\n        int length = nums.length;\\n        int[] result = new int[length];\\n        int e = 0; //for even\\n        int o = 1; //for odd\\n        \\n        for(int num: nums) {\\n            \\n            if(num%2 == 0) {\\n                result[e] = num;\\n                e+=2;\\n\\n            }\\n            else {\\n                result[o] = num;\\n                o+=2;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558853,
                "title": "python-simple-sloution",
                "content": "\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in nums:\\n            if i%2==0:\\n                a.append(i)\\n            if i%2!=0:\\n                b.append(i)\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in nums:\\n            if i%2==0:\\n                a.append(i)\\n            if i%2!=0:\\n                b.append(i)\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c",
                "codeTag": "Python3"
            },
            {
                "id": 1538449,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        int a = 0 , b = 1;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[a] = nums[i];\\n                a += 2;\\n            }\\n            else\\n            {\\n                result[b] = nums[i];\\n                b += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        int a = 0 , b = 1;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[a] = nums[i];\\n                a += 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1492732,
                "title": "rust-two-pointers",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc0922)\\n\\n<b>Problem List</b>\\n#TwoPointers - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/2_pointers)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/sort-array-by-parity-ii/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        let len_n = nums.len();\\n        let mut nums = nums;\\n        let mut idx_even: usize = 0;\\n        let mut idx_odd: usize = 1;\\n        while idx_even < len_n && idx_odd < len_n {\\n            if nums[idx_even] % 2 == 0 {\\n                idx_even += 2;\\n            }\\n            if nums[idx_odd] % 2 == 1 {\\n                idx_odd += 2;\\n            }\\n            if idx_even < len_n && idx_odd < len_n {\\n                nums.swap(idx_even, idx_odd);\\n            }\\n        }\\n        nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/sort-array-by-parity-ii/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        let len_n = nums.len();\\n        let mut nums = nums;\\n        let mut idx_even: usize = 0;\\n        let mut idx_odd: usize = 1;\\n        while idx_even < len_n && idx_odd < len_n {\\n            if nums[idx_even] % 2 == 0 {\\n                idx_even += 2;\\n            }\\n            if nums[idx_odd] % 2 == 1 {\\n                idx_odd += 2;\\n            }\\n            if idx_even < len_n && idx_odd < len_n {\\n                nums.swap(idx_even, idx_odd);\\n            }\\n        }\\n        nums\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492207,
                "title": "c-2-pointer-in-place-solution-explained-100-time-99-space",
                "content": "This problem is not too hard even when you consider operating in place (and it would be rather trivial otherwise: just creating a new array of the same size and populating it with of 2 pointers to write there in alternate order).\\n\\nIn order to solve it, we will use 3 variables:\\n* `i` and `j` will be our pointers, respectively set to `0` and `1` initially, with the goal to find odd (the former) or even value (the latter);\\n* `lmt` is going to be the limit of our search, set to be the length of our input.\\n\\nWe will then ran an infinite loop and inside it:\\n* move `i` to find the first odd value in even positions (if any such is left);\\n* move `j` to find the first even value in odd positions (if any such is left);\\n* check if we reached the end of the input and:\\n\\t* if not, we swap the values pointed by `i` and `j`;\\n\\t* otherwise, it means we are done parsing and just `break` out of the loop.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& ns) {\\n        // support variables\\n        int i = 0, j = 1, lmt = ns.size();\\n        // parsing ns\\n        while (true) {\\n            // moving i in even positions with odd values\\n            while (i < lmt && !(ns[i] & 1)) i += 2;\\n            // moving j in odd positions with even values\\n            while (j < lmt && (ns[j] & 1)) j += 2;\\n            // swapping if needed\\n            if (i < lmt && j < lmt) swap(ns[i], ns[j]);\\n            else break;\\n        }\\n        return ns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& ns) {\\n        // support variables\\n        int i = 0, j = 1, lmt = ns.size();\\n        // parsing ns\\n        while (true) {\\n            // moving i in even positions with odd values\\n            while (i < lmt && !(ns[i] & 1)) i += 2;\\n            // moving j in odd positions with even values\\n            while (j < lmt && (ns[j] & 1)) j += 2;\\n            // swapping if needed\\n            if (i < lmt && j < lmt) swap(ns[i], ns[j]);\\n            else break;\\n        }\\n        return ns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491779,
                "title": "c-easy-solution-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0  , j = 1;\\n        while(i<nums.size() and j <nums.size()-1 || i<nums.size()-1 and j<nums.size())\\n        {\\n            if(nums[i]%2 == 0 and nums[j]%2==1)\\n            {\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==1 and nums[j]%2==0 )\\n            {\\n                swap(nums[i],nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==0 and nums[j]%2==0)\\n            {\\n                i += 2;\\n            }else \\n            {\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0  , j = 1;\\n        while(i<nums.size() and j <nums.size()-1 || i<nums.size()-1 and j<nums.size())\\n        {\\n            if(nums[i]%2 == 0 and nums[j]%2==1)\\n            {\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==1 and nums[j]%2==0 )\\n            {\\n                swap(nums[i],nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==0 and nums[j]%2==0)\\n            {\\n                i += 2;\\n            }else \\n            {\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491589,
                "title": "2-solution-inc-in-place-c-solution-easy-to-understand",
                "content": "```\\n// Solution I - In place\\nvector<int> ans;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            if(i%2==0) {\\n                if(nums[i]%2==0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2==0) {\\n                        swap(nums[i],nums[j]);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            else {\\n                if(nums[i]%2!=0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2!=0) {\\n                        swap(nums[i], nums[j]);\\n                        break;\\n                    }\\n                    else continue;\\n                }\\n            }\\n        }\\n        return nums;\\n\\t\\t// Solution 2\\n\\t\\tclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> odd, even;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int i=0,j=0;\\n        while(i<odd.size() && j<even.size()) {\\n            if(j<even.size()) {\\n                ans.push_back(even[j]);\\n                j++;\\n            }\\n            if(i<odd.size()) {\\n                ans.push_back(odd[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Solution I - In place\\nvector<int> ans;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            if(i%2==0) {\\n                if(nums[i]%2==0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2==0) {\\n                        swap(nums[i],nums[j]);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            else {\\n                if(nums[i]%2!=0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2!=0) {\\n                        swap(nums[i], nums[j]);\\n                        break;\\n                    }\\n                    else continue;\\n                }\\n            }\\n        }\\n        return nums;\\n\\t\\t// Solution 2\\n\\t\\tclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> odd, even;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int i=0,j=0;\\n        while(i<odd.size() && j<even.size()) {\\n            if(j<even.size()) {\\n                ans.push_back(even[j]);\\n                j++;\\n            }\\n            if(i<odd.size()) {\\n                ans.push_back(odd[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491123,
                "title": "c-easy-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1)\\n            {\\n                v2.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                v1.push_back(nums[i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.size() / 2; i++)\\n        {\\n            v.push_back(v1[i]);\\n            v.push_back(v2[i]);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1)\\n            {\\n                v2.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1491089,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .filter(|&num| num % 2 == 0)\\n            .zip(nums.iter().filter(|&num| num % 2 != 0))\\n            .flat_map(|(&even, &odd)| vec![even, odd].into_iter())\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .filter(|&num| num % 2 == 0)\\n            .zip(nums.iter().filter(|&num| num % 2 != 0))\\n            .flat_map(|(&even, &odd)| vec![even, odd].into_iter())\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491039,
                "title": "sort-array-by-parity-ii-inplace-o-n-time-c",
                "content": "explanation:\\nfor every no. there are two possibilities: either its correct on its position or not correct.\\nalso as there are equal no. of odd and even nos, so for every incorrect odd, there will be one incorrect even and vice-versa.\\n\\nSo we will just keep two pointers : one for odd positions and one for even positions.\\nIgnore those which are already at correct position.\\nSwap those which are at incorrect.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(i<nums.size() && j<nums.size())\\n        {\\n            while(i<nums.size() && nums[i]%2==0)\\n                i+=2;\\n            while(j<nums.size() && nums[j]%2==1)\\n                j+=2;\\n            \\n            if(i<nums.size() && j<nums.size())\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(i<nums.size() && j<nums.size())\\n        {\\n            while(i<nums.size() && nums[i]%2==0)\\n                i+=2;\\n            while(j<nums.size() && nums[j]%2==1)\\n                j+=2;\\n            \\n            if(i<nums.size() && j<nums.size())\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490976,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(i%2==0){\\n                if(nums[i]%2==0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2==0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else{\\n                if(nums[i]%2!=0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2!=0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(i%2==0){\\n                if(nums[i]%2==0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2==0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else{\\n                if(nums[i]%2!=0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2!=0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490897,
                "title": "java-one-pass-inplace",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] n) {\\n        int e = 0,o = 1;\\n        while(e<n.length && o<n.length){\\n            while(e<n.length && n[e]%2 == 0) e += 2;\\n            while(o<n.length && n[o]%2 == 1) o += 2;\\n            \\n            if(o<n.length && e<n.length){\\n                int t = n[o];\\n                n[o] = n[e];\\n                n[e] = t;\\n                o += 2;\\n                e += 2;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] n) {\\n        int e = 0,o = 1;\\n        while(e<n.length && o<n.length){\\n            while(e<n.length && n[e]%2 == 0) e += 2;\\n            while(o<n.length && n[o]%2 == 1) o += 2;\\n            \\n            if(o<n.length && e<n.length){\\n                int t = n[o];\\n                n[o] = n[e];\\n                n[e] = t;\\n                o += 2;\\n                e += 2;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445385,
                "title": "simple-java-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int out[]=new int[nums.length];\\n        int evenIndex=0,oddIndex=1;\\n        for(int i:nums){\\n            if(i%2==1){\\n                out[oddIndex]=i;\\n                oddIndex+=2;\\n            }else{\\n                out[evenIndex]=i;\\n                evenIndex+=2;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int out[]=new int[nums.length];\\n        int evenIndex=0,oddIndex=1;\\n        for(int i:nums){\\n            if(i%2==1){\\n                out[oddIndex]=i;\\n                oddIndex+=2;\\n            }else{\\n                out[evenIndex]=i;\\n                evenIndex+=2;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345921,
                "title": "c-simple-solution",
                "content": "```\\nvector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>v1,v2;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]%2==0)\\n                v1.push_back(a[i]);\\n            else\\n                v2.push_back(a[i]);\\n        }\\n        vector<int>res(a.size());\\n        int k=0,j=0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(i%2==0)\\n                res[i]=v1[k++];\\n            else\\n                res[i]=v2[j++];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>v1,v2;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]%2==0)\\n                v1.push_back(a[i]);\\n            else\\n                v2.push_back(a[i]);\\n        }\\n        vector<int>res(a.size());\\n        int k=0,j=0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(i%2==0)\\n                res[i]=v1[k++];\\n            else\\n                res[i]=v2[j++];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291804,
                "title": "in-place-python-easy-100-faster-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        j = 1\\n        n = len(nums)\\n        while i < n and j < n:\\n            if nums[i]%2 == 0:\\n                i += 2\\n            elif nums[j]%2 != 0:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        j = 1\\n        n = len(nums)\\n        while i < n and j < n:\\n            if nums[i]%2 == 0:\\n                i += 2\\n            elif nums[j]%2 != 0:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206155,
                "title": "javascript-inplace-and-using-space-90-faster",
                "content": "**Please upvote if you find this solution useful**\\n\\n**In place**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n  let even = 0;\\n    let odd = nums.length - 1;\\n    while(even < nums.length && odd >= 0){\\n        \\n        if(nums[even] % 2==0 && nums[odd] % 2 !== 0){\\n            even = even + 2;\\n            odd = odd - 2\\n        }else if(nums[even] % 2 !== 0 && nums[odd] % 2 == 0){\\n            [ nums[even] , nums[odd] ] = [ nums[odd] , nums[even] ]\\n        }else if(nums[even] % 2 ==0 ){\\n            even = even+2;\\n        }else{\\n            odd = odd - 2;\\n        }\\n    }\\n    return nums\\n};\\n```\\n\\n\\n**Using space**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    var arr = new Array(nums.length);\\n    var even  =0;\\n    var odd = 1;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            arr[even] = nums[i];\\n            even +=2;\\n        }else{\\n            arr[odd] = nums[i]\\n            odd +=2\\n        }\\n    }\\n    return arr\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n  let even = 0;\\n    let odd = nums.length - 1;\\n    while(even < nums.length && odd >= 0){\\n        \\n        if(nums[even] % 2==0 && nums[odd] % 2 !== 0){\\n            even = even + 2;\\n            odd = odd - 2\\n        }else if(nums[even] % 2 !== 0 && nums[odd] % 2 == 0){\\n            [ nums[even] , nums[odd] ] = [ nums[odd] , nums[even] ]\\n        }else if(nums[even] % 2 ==0 ){\\n            even = even+2;\\n        }else{\\n            odd = odd - 2;\\n        }\\n    }\\n    return nums\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    var arr = new Array(nums.length);\\n    var even  =0;\\n    var odd = 1;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            arr[even] = nums[i];\\n            even +=2;\\n        }else{\\n            arr[odd] = nums[i]\\n            odd +=2\\n        }\\n    }\\n    return arr\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126788,
                "title": "javascript-clean-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    const [odds, evens] = [nums.filter(n => n%2===1), nums.filter(n => n%2 === 0)]\\n    const retArr = []\\n    for(let i = 0; i<nums.length; i++){\\n       i%2 ? retArr.push(odds.pop()) : retArr.push(evens.pop())\\n    }\\n    return retArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    const [odds, evens] = [nums.filter(n => n%2===1), nums.filter(n => n%2 === 0)]\\n    const retArr = []\\n    for(let i = 0; i<nums.length; i++){\\n       i%2 ? retArr.push(odds.pop()) : retArr.push(evens.pop())\\n    }\\n    return retArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095123,
                "title": "python-using-slicing",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        ans = [0] * N\\n        ans[::2] = (x for x in nums if x % 2 == 0)\\n        ans[1::2] = (x for x in nums if x % 2 == 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        ans = [0] * N\\n        ans[::2] = (x for x in nums if x % 2 == 0)\\n        ans[1::2] = (x for x in nums if x % 2 == 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050619,
                "title": "python-sorted-runtime-73-memory-78",
                "content": "Do upvote it if you liked it\\n\\n\\n\\n\\t\\tA = sorted(A)\\n        \\n\\t\\todd = []\\n        even = []\\n\\t\\t\\n        for num in A:\\n            if num % 2 == 0:\\n                even.append(num)\\n            else:\\n                odd.append(num)\\n                \\n        A[0 : : 2], A[1 : : 2]  = even, odd\\n        \\n        return A",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Do upvote it if you liked it\\n\\n\\n\\n\\t\\tA = sorted(A)\\n        \\n\\t\\todd = []\\n        even = []\\n\\t\\t\\n        for num in A:\\n            if num % 2 == 0:\\n                even.append(num)\\n            else:\\n                odd.append(num)\\n                \\n        A[0 : : 2], A[1 : : 2]  = even, odd\\n        \\n        return A",
                "codeTag": "Unknown"
            },
            {
                "id": 971488,
                "title": "javascript-solution",
                "content": "\\tvar sortArrayByParityII = function(A) {\\n    \\n    let odd = [];\\n    let even = []\\n    \\n    for(let i = 0 ; i < A.length; i++){\\n        \\n        if(A[i] % 2 !== 0){\\n            odd.push(A[i])\\n        }else{\\n            even.push(A[i])\\n        }\\n        \\n    }\\n    \\n    let arr = [];\\n    \\n    for(let i = 0 ; i < odd.length ; i++){\\n    \\n        arr.push(even[i]);\\n        arr.push(odd[i])\\n      \\n    }\\n\\n    \\n    return arr\\n    \\n    \\n\\t};",
                "solutionTags": [],
                "code": "\\tvar sortArrayByParityII = function(A) {\\n    \\n    let odd = [];\\n    let even = []\\n    \\n    for(let i = 0 ; i < A.length; i++){\\n        \\n        if(A[i] % 2 !== 0){\\n            odd.push(A[i])\\n        }else{\\n            even.push(A[i])\\n        }\\n        \\n    }\\n    \\n    let arr = [];\\n    \\n    for(let i = 0 ; i < odd.length ; i++){\\n    \\n        arr.push(even[i]);\\n        arr.push(odd[i])\\n      \\n    }\\n\\n    \\n    return arr\\n    \\n    \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 797027,
                "title": "c-easy-and-fast",
                "content": "**Please upvote my solution if you like it**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        int ec=0,oc=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]%2==0)\\n            {\\n                ans[ec]=A[i];\\n                ec+=2;\\n            }\\n            else\\n            {\\n                ans[oc]=A[i];\\n                oc+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        int ec=0,oc=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]%2==0)\\n            {\\n                ans[ec]=A[i];\\n                ec+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 764082,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize){\\n    *returnSize = ASize;\\n    int odd = 1;\\n    int even = 0;\\n    int* arr = malloc(sizeof(int)*ASize);\\n    for (int i=0; i < ASize; i++)\\n    {\\n        if (A[i] % 2 == 0)\\n        {\\n            arr[even] = A[i];\\n            even +=2;\\n        }\\n        else\\n        {\\n            arr[odd] = A[i];\\n            odd +=2;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize){\\n    *returnSize = ASize;\\n    int odd = 1;\\n    int even = 0;\\n    int* arr = malloc(sizeof(int)*ASize);\\n    for (int i=0; i < ASize; i++)\\n    {\\n        if (A[i] % 2 == 0)\\n        {\\n            arr[even] = A[i];\\n            even +=2;\\n        }\\n        else\\n        {\\n            arr[odd] = A[i];\\n            odd +=2;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755487,
                "title": "c-single-pass-inplace-o-n-97-runtime-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i=0;\\n    int j=1;\\n    while(i<A.size() && j<A.size()){\\n        if(A[i]%2!=0 && A[j]%2==0){\\n            swap(A[i],A[j]);\\n            i=i+2;\\n            j=j+2;\\n            continue;\\n        }\\n        if(A[i]%2==0){\\n            i=i+2;\\n        }\\n        if(A[j]%2==1){\\n            j=j+2;\\n        }\\n    }\\n        return A;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i=0;\\n    int j=1;\\n    while(i<A.size() && j<A.size()){\\n        if(A[i]%2!=0 && A[j]%2==0){\\n            swap(A[i],A[j]);\\n            i=i+2;\\n            j=j+2;\\n            continue;\\n        }\\n        if(A[i]%2==0){\\n            i=i+2;\\n        }\\n        if(A[j]%2==1){\\n            j=j+2;\\n        }\\n    }\\n        return A;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 727212,
                "title": "python-3-explanation",
                "content": "* Initialise an empty array `parityArray` of the same length as `A`.\\n* Keep track of two pointers, one `even` and one `odd`, that will be incremented when a new `num` is inserted into `parityArray`.\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        parityArray = [None] * len(A)\\n        even, odd = 0, 1\\n        \\n        for num in A:\\n            if num % 2 == 0:\\n                parityArray[even] = num\\n                even += 2\\n            else:\\n                parityArray[odd] = num\\n                odd += 2\\n            \\n        return parityArray\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        parityArray = [None] * len(A)\\n        even, odd = 0, 1\\n        \\n        for num in A:\\n            if num % 2 == 0:\\n                parityArray[even] = num\\n                even += 2\\n            else:\\n                parityArray[odd] = num\\n                odd += 2\\n            \\n        return parityArray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592182,
                "title": "python-3-faster-than-97-98",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        e = 0\\n        o = 1\\n        op = []\\n        for a in A:\\n            if a%2==0:\\n                op.insert(e,a)\\n                e+= 2\\n            else:\\n                op.insert(o,a)\\n                o+= 2\\n        return op\\n```\\nDo upvote it if you liked it :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        e = 0\\n        o = 1\\n        op = []\\n        for a in A:\\n            if a%2==0:\\n                op.insert(e,a)\\n                e+= 2\\n            else:\\n                op.insert(o,a)\\n                o+= 2\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576924,
                "title": "o-n-time-with-two-pointers-javascript",
                "content": "```\\nvar sortArrayByParityII = (A) => {\\n    let oddP = 1;\\n    \\n    const swap = (i, j) => {\\n        let buf = A[i];\\n        A[i] = A[j];\\n        A[j] = buf;\\n    }\\n    \\n    for (let i = 0 ; i < A.length; i += 2) {\\n        if (A[i] & 1) {\\n            while (A[oddP] & 1) {\\n                oddP += 2;\\n            }\\n            swap(i, oddP);\\n        }\\n    }\\n    \\n    return A;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortArrayByParityII = (A) => {\\n    let oddP = 1;\\n    \\n    const swap = (i, j) => {\\n        let buf = A[i];\\n        A[i] = A[j];\\n        A[j] = buf;\\n    }\\n    \\n    for (let i = 0 ; i < A.length; i += 2) {\\n        if (A[i] & 1) {\\n            while (A[oddP] & 1) {\\n                oddP += 2;\\n            }\\n            swap(i, oddP);\\n        }\\n    }\\n    \\n    return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520221,
                "title": "very-simple-in-place-c-solution-68ms-100",
                "content": "See also my copying solution here: https://leetcode.com/problems/sort-array-by-parity-ii/discuss/520235/C%2B%2B-Copy-out-to-odd-or-even-addresses-68ms100\\n# Algorithm\\n\\nThis is a very simple modify in-place approach.\\nThe overall flow is to step 2 index counters through the input array. One indexes odd locations and the other indexes even locations, so their paths interleave and never touch the same location.\\n* Advance even indexes by 2 until an odd value is hit\\n* Advance odd indexes by 2 until an even value is hit\\n* Swap the elements at these indexes to restore the desired state of even values at even indexes and odd values at odd indexes.\\n\\n# Code\\n```\\n        static vector<int> sortArrayByParityII(vector<int> A)\\n        {\\n            const unsigned len = A.size();\\n            unsigned odd = 1u;\\n            unsigned even = 0u;\\n            while(even < len)\\n            {\\n                // Skip even numbers at even indexes:\\n                while(even < len  && (A[even] & 1u) == 0u){\\n                    even += 2u;\\n                }\\n                // Skip odd numbers at odd indexes:\\n                while((odd < len) && (A[odd]  & 1u)){\\n                    odd += 2u;\\n                }\\n                // Either we hit the end of the input or an odd number at an even address\\n                // and an even number at an odd address. If the latter, swap them:\\n                if(even < len){\\n                    swap(A[even], A[odd]);\\n                }\\n                // We always increment so that as little code as possible is inside\\n                // the branch above even though logically the increment belongs inside\\n                // it:\\n                even += 2u;\\n                odd += 2u;\\n            }\\n            return A;\\n        }\\n```\\n\\n# Results\\n\\n> Runtime: 68 ms, faster than 100.00% of C++ online submissions for Sort Array By Parity II.\\n> Memory Usage: 12 MB, less than 25.00% of C++ online submissions for Sort Array By Parity II.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        static vector<int> sortArrayByParityII(vector<int> A)\\n        {\\n            const unsigned len = A.size();\\n            unsigned odd = 1u;\\n            unsigned even = 0u;\\n            while(even < len)\\n            {\\n                // Skip even numbers at even indexes:\\n                while(even < len  && (A[even] & 1u) == 0u){\\n                    even += 2u;\\n                }\\n                // Skip odd numbers at odd indexes:\\n                while((odd < len) && (A[odd]  & 1u)){\\n                    odd += 2u;\\n                }\\n                // Either we hit the end of the input or an odd number at an even address\\n                // and an even number at an odd address. If the latter, swap them:\\n                if(even < len){\\n                    swap(A[even], A[odd]);\\n                }\\n                // We always increment so that as little code as possible is inside\\n                // the branch above even though logically the increment belongs inside\\n                // it:\\n                even += 2u;\\n                odd += 2u;\\n            }\\n            return A;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515483,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i=0,j=0;\\n        while (i< A.size() && j < A.size()){\\n            while (i< A.size() ){\\n                if (i%2==0 && A[i]%2==1) break;\\n                else i++;\\n            } \\n            while (j< A.size()){\\n                if (j%2==1 && A[j]%2==0) break;\\n                else j++;\\n            }\\n            if (i<A.size() && j<A.size()){\\n                int temp = A[i];\\n                A[i] = A[j];\\n                A[j] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i=0,j=0;\\n        while (i< A.size() && j < A.size()){\\n            while (i< A.size() ){\\n                if (i%2==0 && A[i]%2==1) break;\\n                else i++;\\n            } \\n            while (j< A.size()){\\n                if (j%2==1 && A[j]%2==0) break;\\n                else j++;\\n            }\\n            if (i<A.size() && j<A.size()){\\n                int temp = A[i];\\n                A[i] = A[j];\\n                A[j] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475103,
                "title": "python-o-n-sol-based-on-two-pointers-run-time-95-with-explanation",
                "content": "Python O( n ) sol. based on two-pointers\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        \\n        size = len(A)\\n        \\n        sorted_array = [0]*size\\n        \\n        # two pointers for even numbers, as well as odd numbers, respectively.\\n        even_index, odd_index = 0, 1\\n        \\n        for x in A:\\n            \\n            if x & 1:\\n                # odd numbers\\n                sorted_array[odd_index] = x\\n                odd_index += 2\\n            else:\\n                # even numbers\\n                sorted_array[even_index] = x\\n                even_index += 2\\n                \\n        return sorted_array\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        \\n        size = len(A)\\n        \\n        sorted_array = [0]*size\\n        \\n        # two pointers for even numbers, as well as odd numbers, respectively.\\n        even_index, odd_index = 0, 1\\n        \\n        for x in A:\\n            \\n            if x & 1:\\n                # odd numbers\\n                sorted_array[odd_index] = x\\n                odd_index += 2\\n            else:\\n                # even numbers\\n                sorted_array[even_index] = x\\n                even_index += 2\\n                \\n        return sorted_array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459869,
                "title": "simplest-c-code",
                "content": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n\\tint oddIndex = 1, evenIndex = 0;\\n\\tvector<int> res(A.size());\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t{\\n\\t\\tif (A[i] % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tres[evenIndex] = A[i];\\n\\t\\t\\tevenIndex += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres[oddIndex] = A[i];\\n\\t\\t\\toddIndex += 2;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n\\tint oddIndex = 1, evenIndex = 0;\\n\\tvector<int> res(A.size());\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t{\\n\\t\\tif (A[i] % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tres[evenIndex] = A[i];\\n\\t\\t\\tevenIndex += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres[oddIndex] = A[i];\\n\\t\\t\\toddIndex += 2;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410428,
                "title": "python-3-o-n-time-and-o-n-space-using-stack",
                "content": "```\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        d = {0:[],1:[]}\\n        for i in A:\\n            d[i%2].append(i)\\n        r= []\\n        for _ in range(0,len(A)//2):\\n            r.append(d[0].pop())\\n            r.append(d[1].pop())\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        d = {0:[],1:[]}\\n        for i in A:\\n            d[i%2].append(i)\\n        r= []\\n        for _ in range(0,len(A)//2):\\n            r.append(d[0].pop())\\n            r.append(d[1].pop())\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383747,
                "title": "rust-8ms-o-n-time-o-1-space",
                "content": "```\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(a: Vec<i32>) -> Vec<i32> {\\n        let mut even_ptr = 0;\\n        let mut odd_ptr = 1;\\n        let size = a.len();\\n        let mut res = a.clone();\\n        \\n        while even_ptr < size && odd_ptr < size {\\n            if a[even_ptr] % 2 == 0 {\\n                even_ptr += 2;\\n            } else if a[odd_ptr] % 2 != 0 {\\n                odd_ptr += 2;\\n            } else {\\n                res[even_ptr] = a[odd_ptr];\\n                res[odd_ptr] = a[even_ptr];\\n                \\n                even_ptr += 2;\\n                odd_ptr += 2;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(a: Vec<i32>) -> Vec<i32> {\\n        let mut even_ptr = 0;\\n        let mut odd_ptr = 1;\\n        let size = a.len();\\n        let mut res = a.clone();\\n        \\n        while even_ptr < size && odd_ptr < size {\\n            if a[even_ptr] % 2 == 0 {\\n                even_ptr += 2;\\n            } else if a[odd_ptr] % 2 != 0 {\\n                odd_ptr += 2;\\n            } else {\\n                res[even_ptr] = a[odd_ptr];\\n                res[odd_ptr] = a[even_ptr];\\n                \\n                even_ptr += 2;\\n                odd_ptr += 2;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265141,
                "title": "java-beats-99-2ms-quick-sort",
                "content": "```\\npublic int[] sortArrayByParityII(int[] array) {\\n    int len = 0;\\n    if(array == null || ((len = array.length) & 1) == 1){\\n        return null;\\n    }\\n    int even = 0;\\n    int odd = len - 1;\\n    while(true){\\n        while(even < len && (array[even] & 1) == 0){\\n            even += 2;\\n        }\\n        if(even == len){\\n            break;\\n        }\\n        while(odd > -1 && (array[odd] & 1) == 1){\\n            odd -= 2;\\n        }\\n        if(odd == -1){\\n            break;\\n        }\\n        swap(array, even, odd);\\n    }\\n    return array;\\n}\\n private void swap(int[] array, int i, int j){\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] array) {\\n    int len = 0;\\n    if(array == null || ((len = array.length) & 1) == 1){\\n        return null;\\n    }\\n    int even = 0;\\n    int odd = len - 1;\\n    while(true){\\n        while(even < len && (array[even] & 1) == 0){\\n            even += 2;\\n        }\\n        if(even == len){\\n            break;\\n        }\\n        while(odd > -1 && (array[odd] & 1) == 1){\\n            odd -= 2;\\n        }\\n        if(odd == -1){\\n            break;\\n        }\\n        swap(array, even, odd);\\n    }\\n    return array;\\n}\\n private void swap(int[] array, int i, int j){\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255898,
                "title": "go-golang-o-n-in-place-beat-100",
                "content": "```\\nfunc sortArrayByParityII(A []int) []int {\\n\\tfor i, j := 0, 1; i< len(A); i+=2{\\n\\t\\tif A[i]&1 == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor ;A[j]&1 != 0; j += 2 {}\\n\\t\\tA[i], A[j] = A[j], A[i]\\n\\t}\\n\\treturn A\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortArrayByParityII(A []int) []int {\\n\\tfor i, j := 0, 1; i< len(A); i+=2{\\n\\t\\tif A[i]&1 == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor ;A[j]&1 != 0; j += 2 {}\\n\\t\\tA[i], A[j] = A[j], A[i]\\n\\t}\\n\\treturn A\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255048,
                "title": "python-two-pointer-922",
                "content": "### 922. Sort Array By Parity II\\n\\n#### Two Pointer\\nTime: O(N) | Space: O(1)\\n\\nOdd\\u6307\\u9488\\u7269\\u7406\\u610F\\u4E49\\uFF1A\\u505C\\u7559\\u5728A[odd] % 2 \\u662F\\u5076\\u6570\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7B49\\u5F85\\u4EA4\\u6362\\nEven\\u6307\\u9488\\u7269\\u7406\\u610F\\u4E49\\uFF1A\\u505C\\u7559\\u5728A[odd] % 2 \\u662F\\u57FA\\u6570\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7B49\\u5F85\\u4EA4\\u6362\\n\\n\\u5F53\\u5185\\u7F6E\\u4E24\\u4E2AWhile Loop\\u8D70\\u5B8C\\uFF0C\\u4E14\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6709\\u505C\\u7559\\uFF0C\\u8BF4\\u660E\\u4ED6\\u4EEC\\u5BF9\\u5E94\\u7684Value\\u53EF\\u4EE5\\u88AB\\u5151\\u6362\\uFF0CSwap\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        odd, even = 1 , 0\\n        size = len(A)\\n        \\n        while odd < size and even < size:\\n            while odd < size and A[odd] % 2 == 1: \\n                odd += 2\\n            while even < size and A[even] % 2 == 0: \\n                even += 2\\n            if odd < size and even < size:\\n                A[odd], A[even] = A[even], A[odd]\\n                odd += 2 ; even += 2  # Optional Line\\n        return A\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        odd, even = 1 , 0\\n        size = len(A)\\n        \\n        while odd < size and even < size:\\n            while odd < size and A[odd] % 2 == 1: \\n                odd += 2\\n            while even < size and A[even] % 2 == 0: \\n                even += 2\\n            if odd < size and even < size:\\n                A[odd], A[even] = A[even], A[odd]\\n                odd += 2 ; even += 2  # Optional Line\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247428,
                "title": "java-simple-solution-beats-100-4ms",
                "content": "I am using 2 pointers corresponding to the even and odd indices. \\n```\\npublic int[] sortArrayByParityII(int[] A) {\\n\\tif(A.length<2)\\n\\t\\treturn A;\\n\\tint oddPointer = 1, evenPointer = 0;\\n\\tint result[] = new int[A.length];\\n\\tfor(int i=0;i<A.length;i++)\\n\\t{\\n\\t\\tif(A[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tresult[evenPointer] = A[i];\\n\\t\\t\\tevenPointer+=2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tresult[oddPointer] = A[i];\\n\\t\\t\\toddPointer+=2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n\\tif(A.length<2)\\n\\t\\treturn A;\\n\\tint oddPointer = 1, evenPointer = 0;\\n\\tint result[] = new int[A.length];\\n\\tfor(int i=0;i<A.length;i++)\\n\\t{\\n\\t\\tif(A[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tresult[evenPointer] = A[i];\\n\\t\\t\\tevenPointer+=2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tresult[oddPointer] = A[i];\\n\\t\\t\\toddPointer+=2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230388,
                "title": "python-one-pass-in-place-two-pointers-o-n-time-o-1-memory",
                "content": "```python\\ndef sortArrayByParityII(self, A): \\n    odd, even, n = 1, 0, len(A)\\n    while odd < n and even < n:\\n        if A[odd] % 2 == 0 and A[even] % 2:\\n            A[odd], A[even] = A[even], A[odd]\\n        if A[odd] % 2 == 1: odd += 2\\n        if A[even] % 2 == 0: even += 2\\n    return A\\n```\\n\\nInspired by awice\\'s solution to Sort Array By Parity.",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\ndef sortArrayByParityII(self, A): \\n    odd, even, n = 1, 0, len(A)\\n    while odd < n and even < n:\\n        if A[odd] % 2 == 0 and A[even] % 2:\\n            A[odd], A[even] = A[even], A[odd]\\n        if A[odd] % 2 == 1: odd += 2\\n        if A[even] % 2 == 0: even += 2\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 209017,
                "title": "java-easy-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int[] result = new int[A.length];\\n        List<Integer> evens = new ArrayList<Integer>();\\n        List<Integer> odds = new ArrayList<Integer>();\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] % 2 == 0) {\\n                evens.add(A[i]);\\n            } else {\\n                odds.add(A[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < A.length; i += 2) {\\n            result[i] = evens.get(i / 2);\\n        }\\n        \\n        for(int i = 1; i < A.length; i += 2) {\\n            result[i] = odds.get(i / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int[] result = new int[A.length];\\n        List<Integer> evens = new ArrayList<Integer>();\\n        List<Integer> odds = new ArrayList<Integer>();\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] % 2 == 0) {\\n                evens.add(A[i]);\\n            } else {\\n                odds.add(A[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < A.length; i += 2) {\\n            result[i] = evens.get(i / 2);\\n        }\\n        \\n        for(int i = 1; i < A.length; i += 2) {\\n            result[i] = odds.get(i / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203920,
                "title": "java-5ms-99-09",
                "content": "```\\n int [] res = new int[A.length];\\n        int even = 0,odd = 1;\\n        for (int i = 0;i < A.length;i++) {\\n            if (A[i]%2==0){\\n                res[even]=A[i];\\n                even += 2;\\n            } else {\\n                res[odd]=A[i];\\n                odd += 2;\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n int [] res = new int[A.length];\\n        int even = 0,odd = 1;\\n        for (int i = 0;i < A.length;i++) {\\n            if (A[i]%2==0){\\n                res[even]=A[i];\\n                even += 2;\\n            } else {\\n                res[odd]=A[i];\\n                odd += 2;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 203083,
                "title": "ruby-beats-100",
                "content": "```\\n# @param {Integer[]} a\\n# @return {Integer[]}\\ndef sort_array_by_parity_ii(arr)\\n  e,o = 0,1\\n  newarr = []\\n  arr.each do |i| \\n    if i % 2 == 0\\n      newarr[e] = i\\n      e+=2\\n    else \\n      newarr[o] = i \\n      o += 2\\n    end\\n  end\\n  newarr  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {Integer[]}\\ndef sort_array_by_parity_ii(arr)\\n  e,o = 0,1\\n  newarr = []\\n  arr.each do |i| \\n    if i % 2 == 0\\n      newarr[e] = i\\n      e+=2\\n    else \\n      newarr[o] = i \\n      o += 2\\n    end\\n  end\\n  newarr  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 182806,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun sortArrayByParityII(A: IntArray): IntArray {\\n        val even = A.filter { it % 2 == 0 }\\n        val odd = A.filter { it % 2 == 1 }\\n        return even.zip(odd).flatMap { listOf(it.first, it.second) }.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun sortArrayByParityII(A: IntArray): IntArray {\\n        val even = A.filter { it % 2 == 0 }\\n        val odd = A.filter { it % 2 == 1 }\\n        return even.zip(odd).flatMap { listOf(it.first, it.second) }.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027701,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n     \\n       int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n        if(i%2==0 && nums[i]%2!=0)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==0)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                }\\n            }\\n        }\\n            \\n        if(i%2==1 && nums[i]%2!=1)\\n        {\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==1)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n     \\n       int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n        if(i%2==0 && nums[i]%2!=0)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==0)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3658073,
                "title": "java-0ms-runtime-99-faster-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }else{\\n                result[o] = i;\\n                o += 2;       \\n            } \\n        }\\n\\n        return result;\\n\\n    }\\n    // boolean odd(int n, int i){\\n    //     return n % 2 != 0 || i % 2 != 0;\\n    // }\\n    // boolean even(int n, int i){\\n    //     return n % 2 == 0 || i % 2 == 0;\\n    // }\\n    // int odd(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 != 0 && arr[i] % 2 != 0)\\n    //          return i;\\n\\n    //     return -1;\\n    // }\\n    // int even(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 == 0 && arr[i] % 2 == 0)\\n    //          return i;\\n             \\n    //     return -1;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }else{\\n                result[o] = i;\\n                o += 2;       \\n            } \\n        }\\n\\n        return result;\\n\\n    }\\n    // boolean odd(int n, int i){\\n    //     return n % 2 != 0 || i % 2 != 0;\\n    // }\\n    // boolean even(int n, int i){\\n    //     return n % 2 == 0 || i % 2 == 0;\\n    // }\\n    // int odd(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 != 0 && arr[i] % 2 != 0)\\n    //          return i;\\n\\n    //     return -1;\\n    // }\\n    // int even(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 == 0 && arr[i] % 2 == 0)\\n    //          return i;\\n             \\n    //     return -1;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531705,
                "title": "c-o-1-easy-approach",
                "content": "Here is my c++ code for thsi problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i=0, j=1;\\n        while(i<nums.size() && j<nums.size()){\\n            if(!(nums[i]&1)){i+=2;}\\n            else if(nums[j]&1){j+=2;}\\n            else{\\n                swap(nums[i], nums[j]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i=0, j=1;\\n        while(i<nums.size() && j<nums.size()){\\n            if(!(nums[i]&1)){i+=2;}\\n            else if(nums[j]&1){j+=2;}\\n            else{\\n                swap(nums[i], nums[j]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354227,
                "title": "simple-c-code-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0) \\n            {\\n                v.push_back(even[k]);\\n                k++;\\n            }\\n            else\\n            {\\n                v.push_back(odd[l]);\\n                l++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0) \\n            {\\n                v.push_back(even[k]);\\n                k++;\\n            }\\n            else\\n            {\\n                v.push_back(odd[l]);\\n                l++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334621,
                "title": "c-2-pointer-approch-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n       int i=0,j=nums.size()-1;\\n       while(i<nums.size()) \\n       {\\n           while(i<nums.size()&&nums[i]%2==0)\\n           {\\n            i+=2;\\n           }\\n           if(i==nums.size())\\n           break;\\n           while(j>=0&&nums[j]%2==1)\\n           {\\n            j-=2;\\n           }\\n           swap(nums[i],nums[j]);\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n       int i=0,j=nums.size()-1;\\n       while(i<nums.size()) \\n       {\\n           while(i<nums.size()&&nums[i]%2==0)\\n           {\\n            i+=2;\\n           }\\n           if(i==nums.size())\\n           break;\\n           while(j>=0&&nums[j]%2==1)\\n           {\\n            j-=2;\\n           }\\n           swap(nums[i],nums[j]);\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324326,
                "title": "sort-array-by-parity-ii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int i, j=0, k=1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[j] = nums[i];\\n                j += 2;\\n            }\\n            else\\n            {\\n                ans[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int i, j=0, k=1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[j] = nums[i];\\n                j += 2;\\n            }\\n            else\\n            {\\n                ans[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166647,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n            \\n        }\\n        \\n       int j=nums.size()-2;\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                swap(nums[i],nums[j]);\\n                j-=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n            \\n        }\\n        \\n       int j=nums.size()-2;\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                swap(nums[i],nums[j]);\\n                j-=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158910,
                "title": "parity-done-easily",
                "content": "i hope you like the solution,if any doubt feel free to comment :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>odd;\\n        vector<int>even;\\n        int e=0,o=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            even.push_back(nums[i]);\\n            else\\n            odd.push_back(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            {\\n                nums[i]=even[e];\\n                e++;\\n            }\\n            else if(i%2!=0)\\n            {\\n                nums[i]=odd[o];\\n                o++;\\n            }\\n\\n        }\\n        \\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>odd;\\n        vector<int>even;\\n        int e=0,o=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            even.push_back(nums[i]);\\n            else\\n            odd.push_back(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            {\\n                nums[i]=even[e];\\n                e++;\\n            }\\n            else if(i%2!=0)\\n            {\\n                nums[i]=odd[o];\\n                o++;\\n            }\\n\\n        }\\n        \\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944868,
                "title": "beats-99-92-11ms-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size(),i,ev=0,od=1;\\n        vector<int> result(n,1);\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                result[ev]=nums[i];\\n                ev=ev+2;\\n            }\\n            else{\\n                result[od]=nums[i];\\n                od=od+2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size(),i,ev=0,od=1;\\n        vector<int> result(n,1);\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                result[ev]=nums[i];\\n                ev=ev+2;\\n            }\\n            else{\\n                result[od]=nums[i];\\n                od=od+2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657326,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                a.append(nums[i])\\n            else:\\n                b.append(nums[i])\\n        j=0\\n        for i in range(0,len(nums),2):\\n            nums[i]=a[j]\\n            nums[i+1]=b[j]\\n            j+=1\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                a.append(nums[i])\\n            else:\\n                b.append(nums[i])\\n        j=0\\n        for i in range(0,len(nums),2):\\n            nums[i]=a[j]\\n            nums[i+1]=b[j]\\n            j+=1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636042,
                "title": "two-pointers-one-for-left-and-one-for-right-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int l = 0;\\n        int r = n-1;\\n        int sa, sb;\\n        sa = sb = -1;\\n        while(l<n && r>=0)\\n        {\\n            while(l<n && r>=0 && (l%2 ==0 && a[l]%2 == 0) || l%2)\\n            {\\n                l++;  \\n            }\\n            \\n            if(l<n && r>=0 && (l%2 ==0 && a[l]%2 != 0))\\n            {\\n                sa = l;\\n            }\\n            \\n            \\n            while(l<n && r>=0 && (r%2 && a[r]%2) || r%2==0)\\n            {\\n                r--;\\n            }\\n            if(l<n && r>=0 && (r%2 && a[r]%2 == 0))\\n            {\\n                sb = r;\\n            }\\n            \\n            if(sa >=0 && sa < n && sb>=0 && sb< n)\\n            {\\n                swap(a[sa] , a[sb]);\\n                sa = sb = -1;\\n                l++;\\n                r--;\\n            }    \\n            \\n        }\\n        \\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int l = 0;\\n        int r = n-1;\\n        int sa, sb;\\n        sa = sb = -1;\\n        while(l<n && r>=0)\\n        {\\n            while(l<n && r>=0 && (l%2 ==0 && a[l]%2 == 0) || l%2)\\n            {\\n                l++;  \\n            }\\n            \\n            if(l<n && r>=0 && (l%2 ==0 && a[l]%2 != 0))\\n            {\\n                sa = l;\\n            }\\n            \\n            \\n            while(l<n && r>=0 && (r%2 && a[r]%2) || r%2==0)\\n            {\\n                r--;\\n            }\\n            if(l<n && r>=0 && (r%2 && a[r]%2 == 0))\\n            {\\n                sb = r;\\n            }\\n            \\n            if(sa >=0 && sa < n && sb>=0 && sb< n)\\n            {\\n                swap(a[sa] , a[sb]);\\n                sa = sb = -1;\\n                l++;\\n                r--;\\n            }    \\n            \\n        }\\n        \\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618009,
                "title": "two-pointers-217-ms",
                "content": "![image](https://assets.leetcode.com/users/images/193c8f75-84fc-4083-932f-a0e85e9ddf5d_1664021649.5232708.png)\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        even = 0\\n        odd = 1\\n        while (odd < n or even <n):\\n            while odd < n and nums[odd] % 2:\\n                odd += 2\\n            while even < n and not nums[even] % 2:\\n                even += 2\\n            if even < n and odd < n:\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        even = 0\\n        odd = 1\\n        while (odd < n or even <n):\\n            while odd < n and nums[odd] % 2:\\n                odd += 2\\n            while even < n and not nums[even] % 2:\\n                even += 2\\n            if even < n and odd < n:\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609225,
                "title": "c-two-clean-in-place-approaches-with-explanation",
                "content": "**1st Approach: Two Pointers**\\nThe idea behind the first approach is to to use two pointers starting from 0 and 1 respectively.\\n1. If the value in the even pointer is even then no need to swap, just increment it by 2.\\n2. Same applies for the odd value and pointer.\\n3. If those conditions aren\\'t true, then swap the values to set them in the correct position.\\n\\n**Complexity Analysis**\\nTime Complexity: `O(n)` where `n` is the size of the array.\\nSpace Complexity: `O(1)`.\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n    int i = 0, j = 1, n = nums.size();\\n    while(i < n && j < n) {\\n        if(nums[i] % 2 == 0)\\n            i += 2;\\n        else if(nums[j] % 2 != 0)\\n            j += 2;\\n        else {\\n            swap(nums[i], nums[j]);\\n            i += 2;\\n            j += 2;\\n        }\\n    }\\n    return nums;\\n}\\n```\\n\\n**2nd Approach: Partitioning and Sorting**\\nThis key of this approach is to split the array into two sorted parts. The preprocessed array should look like the following <kbd>a = {e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n/2</sub>, o<sub>1</sub>, o<sub>2</sub>, ..., o<sub>n/2</sub>}</kbd>.\\n1. Partition the array with even numbers.\\n2. Sort the array in-place based on the partitioning iterator.\\n3. Now, the array is split into even then odd numbers respectively.\\n4. Only swap the values to their corresponding position.\\n\\n**Complexity Analysis**\\nTime Complexity: `O(n)` where `n` is the size of the array.\\nSpace Complexity: `O(1)`.\\n\\n```\\nvoid sortByParity(vector<int>& nums) {\\n    auto itr = partition(nums.begin(), nums.end(), [](const int val) {\\n        return val % 2 == 0;\\n    });\\n    sort(itr, nums.end());\\n}\\n\\nvector<int> sortArrayByParityII_2(vector<int>& nums) {\\n    sortByParity(nums);\\n    int i = 1, j = nums.size() / 2;\\n    while(i < j && j < nums.size()) {\\n        swap(nums[i], nums[j]);\\n        i += 2;\\n        ++j;\\n    }\\n    return nums;\\n}\\n```\\n\\n**Please upvote if you found this helpful.**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n    int i = 0, j = 1, n = nums.size();\\n    while(i < n && j < n) {\\n        if(nums[i] % 2 == 0)\\n            i += 2;\\n        else if(nums[j] % 2 != 0)\\n            j += 2;\\n        else {\\n            swap(nums[i], nums[j]);\\n            i += 2;\\n            j += 2;\\n        }\\n    }\\n    return nums;\\n}\\n```\n```\\nvoid sortByParity(vector<int>& nums) {\\n    auto itr = partition(nums.begin(), nums.end(), [](const int val) {\\n        return val % 2 == 0;\\n    });\\n    sort(itr, nums.end());\\n}\\n\\nvector<int> sortArrayByParityII_2(vector<int>& nums) {\\n    sortByParity(nums);\\n    int i = 1, j = nums.size() / 2;\\n    while(i < j && j < nums.size()) {\\n        swap(nums[i], nums[j]);\\n        i += 2;\\n        ++j;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594685,
                "title": "python-solution-runtime-263-ms-memory-usage-16-7-mb",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        arr = [0] * len(nums)\\n        even, odd = 0,  1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                arr[even] = num\\n                even += 2\\n            else:\\n                arr[odd] = num\\n                odd += 2\\n        \\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        arr = [0] * len(nums)\\n        even, odd = 0,  1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                arr[even] = num\\n                even += 2\\n            else:\\n                arr[odd] = num\\n                odd += 2\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586921,
                "title": "easy-python-solution",
                "content": "**Please upvote \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        odd = [x for x in nums if x%2!=0]\\n        even = [x for x in nums if x%2==0]\\n        \\n        nums = []\\n        for x,y in zip(odd,even):\\n            nums.append(y)\\n            nums.append(x)\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        odd = [x for x in nums if x%2!=0]\\n        even = [x for x in nums if x%2==0]\\n        \\n        nums = []\\n        for x,y in zip(odd,even):\\n            nums.append(y)\\n            nums.append(x)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578925,
                "title": "js-simple-solution-o-n",
                "content": "```\\nvar sortArrayByParityII = function(nums) {\\n    const output = new Array(nums.length);\\n    let cursorOdd = 1;\\n    let cursorEven = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i]%2) {\\n            output[cursorOdd] = nums[i];\\n            cursorOdd+=2;\\n        } else {\\n            output[cursorEven] = nums[i];\\n            cursorEven+=2;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(nums) {\\n    const output = new Array(nums.length);\\n    let cursorOdd = 1;\\n    let cursorEven = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i]%2) {\\n            output[cursorOdd] = nums[i];\\n            cursorOdd+=2;\\n        } else {\\n            output[cursorEven] = nums[i];\\n            cursorEven+=2;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512918,
                "title": "c-cool-ans",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int j = 1;\\n        int n = nums.size();\\n        for(int i = 0; i < n ; i+=2){// even\\n            if(nums[i] % 2 != 0){\\n                while(nums[i] % 2 != 0){\\n                    swap(nums[i] , nums[j]);\\n                    j+=2;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int j = 1;\\n        int n = nums.size();\\n        for(int i = 0; i < n ; i+=2){// even\\n            if(nums[i] % 2 != 0){\\n                while(nums[i] % 2 != 0){\\n                    swap(nums[i] , nums[j]);\\n                    j+=2;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1860513,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 2038925,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 2035838,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 1937791,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 1700145,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rank Transform of an Array",
        "question_content": "<p>Given an array of integers&nbsp;<code>arr</code>, replace each element with its rank.</p>\n\n<p>The rank represents how large the element is. The rank has the following rules:</p>\n\n<ul>\n\t<li>Rank is an integer starting from 1.</li>\n\t<li>The larger the element, the larger the rank. If two elements are equal, their rank must be the same.</li>\n\t<li>Rank should be as small as possible.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [40,10,20,30]\n<strong>Output:</strong> [4,1,2,3]\n<strong>Explanation</strong>: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [100,100,100]\n<strong>Output:</strong> [1,1,1]\n<strong>Explanation</strong>: Same elements share the same rank.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [37,12,28,9,100,56,80,5,12]\n<strong>Output:</strong> [5,3,4,2,8,6,7,1,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 489753,
                "title": "java-c-python-hashmap",
                "content": "# **Explanation**\\nCopy `arr` into `A` and sort it.\\nIterate sorted array `A` and record the rank for each element in hashmap `rank`.\\nIterate `arr` again, and assign `rank[arr[i]]` to `A[i]`.\\nreturn the final result `A`.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**Java**\\nSuggested by @hiepit and @saftageorge \\n```java\\n   public int[] arrayRankTransform(int[] arr) {\\n        int[] A = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(A);\\n        HashMap<Integer, Integer> rank = new HashMap<>();\\n        for (int x : A)\\n          rank.putIfAbsent(x, rank.size() + 1);\\n        for (int i = 0; i < arr.length; ++i)\\n          A[i] = rank.get(arr[i]);\\n        return A;\\n    }\\n```\\n**C++**\\n```cpp\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A(arr);\\n        sort(A.begin(), A.end());\\n        unordered_map<int, int> rank;\\n        for (int& a : A)\\n            rank.emplace(a, rank.size() + 1);\\n        for (int i = 0; i < A.size(); ++i)\\n            A[i] = rank[arr[i]];\\n        return A;\\n    }\\n```\\n**Python:**\\n```python\\n    def arrayRankTransform(self, A):\\n        rank = {}\\n        for a in sorted(A):\\n            rank.setdefault(a, len(rank) + 1)\\n        return map(rank.get, A)\\n```\\n\\n**1-line Python**\\n```py\\n    def arrayRankTransform(self, A):\\n        return map({a: i + 1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```",
                "solutionTags": [],
                "code": "```java\\n   public int[] arrayRankTransform(int[] arr) {\\n        int[] A = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(A);\\n        HashMap<Integer, Integer> rank = new HashMap<>();\\n        for (int x : A)\\n          rank.putIfAbsent(x, rank.size() + 1);\\n        for (int i = 0; i < arr.length; ++i)\\n          A[i] = rank.get(arr[i]);\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A(arr);\\n        sort(A.begin(), A.end());\\n        unordered_map<int, int> rank;\\n        for (int& a : A)\\n            rank.emplace(a, rank.size() + 1);\\n        for (int i = 0; i < A.size(); ++i)\\n            A[i] = rank[arr[i]];\\n        return A;\\n    }\\n```\n```python\\n    def arrayRankTransform(self, A):\\n        rank = {}\\n        for a in sorted(A):\\n            rank.setdefault(a, len(rank) + 1)\\n        return map(rank.get, A)\\n```\n```py\\n    def arrayRankTransform(self, A):\\n        return map({a: i + 1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490843,
                "title": "simple-java-solution",
                "content": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : arr) {\\n            set.add(i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for (int num : set) {\\n            map.put(num, rank++);\\n        }\\n        int[] ranks = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            ranks[i] = map.get(arr[i]);\\n        }\\n        return ranks;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : arr) {\\n            set.add(i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for (int num : set) {\\n            map.put(num, rank++);\\n        }\\n        int[] ranks = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            ranks[i] = map.get(arr[i]);\\n        }\\n        return ranks;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489824,
                "title": "python-set-sorted-dict-and-scipy",
                "content": "Remove duplicates with `set`, then sort, then build a dict mapping values to ranks, then use that dict on the given list.\\n\\nTime: `O(n log n)`\\nSpace: `O(n)`\\n\\n```\\ndef arrayRankTransform(self, A):\\n    return map({a: i+1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```\\nor\\n```\\ndef arrayRankTransform(self, A):\\n    return map(dict(zip(sorted(set(A)), itertools.count(1))).get, A)\\n```\\nSciPy solution (don\\'t know the complexities, the [&rarr;doc](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rankdata.html) doesn\\'t say):\\n```\\nfrom scipy.stats import rankdata\\n\\nclass Solution(object):\\n    def arrayRankTransform(self, A):\\n        return rankdata(A, \\'dense\\')\\n```",
                "solutionTags": [],
                "code": "```\\ndef arrayRankTransform(self, A):\\n    return map({a: i+1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```\n```\\ndef arrayRankTransform(self, A):\\n    return map(dict(zip(sorted(set(A)), itertools.count(1))).get, A)\\n```\n```\\nfrom scipy.stats import rankdata\\n\\nclass Solution(object):\\n    def arrayRankTransform(self, A):\\n        return rankdata(A, \\'dense\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826051,
                "title": "c-set-map",
                "content": "**C++:**\\n```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n\\tset<int> st(arr.begin(),arr.end());\\n\\tunordered_map<int,int> m;\\n\\tint rank=1;\\n\\tfor(auto &i: st)  m[i]=rank++;\\n\\tfor(auto &i: arr) i = m[i];\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n\\tset<int> st(arr.begin(),arr.end());\\n\\tunordered_map<int,int> m;\\n\\tint rank=1;\\n\\tfor(auto &i: st)  m[i]=rank++;\\n\\tfor(auto &i: arr) i = m[i];\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489702,
                "title": "java-treemap-sorting",
                "content": "```\\n  public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        int rank = 1;\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> currentList = entry.getValue();\\n            for(int i: currentList)  arr[i] = rank;\\n            rank++;\\n        }\\n        return arr;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n  public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        int rank = 1;\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> currentList = entry.getValue();\\n            for(int i: currentList)  arr[i] = rank;\\n            rank++;\\n        }\\n        return arr;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 771861,
                "title": "python3-solution",
                "content": "\\t\\tarr_copy=arr.copy()\\n        arr_copy.sort()\\n        d={}\\n        a=[]\\n        rank=1\\n        \\n        for i in arr_copy:\\n            if i not in d:\\n                d[i]=rank\\n                rank+=1\\n            \\n        for i in arr:\\n            a.append(d[i])\\n        \\n        return a",
                "solutionTags": [],
                "code": "\\t\\tarr_copy=arr.copy()\\n        arr_copy.sort()\\n        d={}\\n        a=[]\\n        rank=1\\n        \\n        for i in arr_copy:\\n            if i not in d:\\n                d[i]=rank\\n                rank+=1\\n            \\n        for i in arr:\\n            a.append(d[i])\\n        \\n        return a",
                "codeTag": "Unknown"
            },
            {
                "id": 742765,
                "title": "javascript-es6-two-simple-2-line-solutions",
                "content": "```\\nvar arrayRankTransform = function (arr) {\\n  var sorted = Array.from(new Set(arr)).sort((a, b) => a - b);\\n  return arr.map((x) => sorted.indexOf(x) + 1);\\n};\\n```\\nThe solution below is faster:\\n```\\nvar arrayRankTransform = function (arr) {\\n var map = new Map();\\n [...new Set(arr)].sort((a, b) => a - b).map((x, i) => map.set(x, i + 1));\\n return arr.map((x) => map.get(x));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function (arr) {\\n  var sorted = Array.from(new Set(arr)).sort((a, b) => a - b);\\n  return arr.map((x) => sorted.indexOf(x) + 1);\\n};\\n```\n```\\nvar arrayRankTransform = function (arr) {\\n var map = new Map();\\n [...new Set(arr)].sort((a, b) => a - b).map((x, i) => map.set(x, i + 1));\\n return arr.map((x) => map.get(x));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493035,
                "title": "python-sol-based-on-sorting-and-dict-95-with-explanation",
                "content": "Python sol. based on sorting and dict\\n\\n---\\n\\nExample explanation\\n\\n---\\nExample_#1\\n\\ninput = [40,10,20,30]\\n\\nunique elements with ascending order = [ **10**, **20**, **30**, **40**]\\n\\nnumber-rank-dict = { 10 : **1**, 20 : **2**, 30 : **3**, 40 : **4** }\\n\\noutput = [ **4**, **1**, **2**, **3** ] by looking up number-rank-dict \\n\\n---\\nExample_#2\\n\\ninput = [100,100,100]\\n\\nunique elements with ascending order = [ **100** ]\\n\\nnumber-rank-dict = { 100 : **1** }\\n\\noutput = [ **1**, **1**, **1** ] by looking up number-rank-dict \\n\\n---\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # keep unique elements of array in ascending order\\n        elements_ascending = sorted(set(arr))\\n        \\n        # dictionary\\n        # key   : number\\n        # value : rank\\n        num_rank_dict = dict()\\n        \\n\\n        for index, num in enumerate(elements_ascending):\\n            \\n            # rank = index + 1\\n            num_rank_dict[num] = (index+1)\\n                \\n        \\n        # give each number with its corresponding rank\\n        result = [ num_rank_dict[num] for num in arr ]\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # keep unique elements of array in ascending order\\n        elements_ascending = sorted(set(arr))\\n        \\n        # dictionary\\n        # key   : number\\n        # value : rank\\n        num_rank_dict = dict()\\n        \\n\\n        for index, num in enumerate(elements_ascending):\\n            \\n            # rank = index + 1\\n            num_rank_dict[num] = (index+1)\\n                \\n        \\n        # give each number with its corresponding rank\\n        result = [ num_rank_dict[num] for num in arr ]\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552384,
                "title": "java-hashmap-array-sorting-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int[] array=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(array);\\n        int k=1;\\n        for(int i=0;i<array.length;i++){\\n            if(!map.containsKey(array[i]))\\n                map.put(array[i],k++);\\n        }\\n        int[] result=new int[array.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(arr[i]);\\n        return result;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int[] array=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(array);\\n        int k=1;\\n        for(int i=0;i<array.length;i++){\\n            if(!map.containsKey(array[i]))\\n                map.put(array[i],k++);\\n        }\\n        int[] result=new int[array.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(arr[i]);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390913,
                "title": "c-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> copy = arr;\\n        sort(copy.begin(), copy.end());\\n        int rank = 1;\\n        \\n        unordered_map<int, int> ranks;\\n        for (auto num : copy) \\n            if (ranks.find(num) == ranks.end()) ranks[num] = rank++;\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n            arr[i] = ranks[arr[i]];\\n        \\n        return arr;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> copy = arr;\\n        sort(copy.begin(), copy.end());\\n        int rank = 1;\\n        \\n        unordered_map<int, int> ranks;\\n        for (auto num : copy) \\n            if (ranks.find(num) == ranks.end()) ranks[num] = rank++;\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n            arr[i] = ranks[arr[i]];\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099391,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        Arrays.sort(temp);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0;i<temp.length;i++)\\n            map.putIfAbsent(temp[i],map.size()+1);\\n        \\n        for (int i=0;i<temp.length;i++)\\n            temp[i] = map.get(arr[i]);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        Arrays.sort(temp);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0;i<temp.length;i++)\\n            map.putIfAbsent(temp[i],map.size()+1);\\n        \\n        for (int i=0;i<temp.length;i++)\\n            temp[i] = map.get(arr[i]);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489733,
                "title": "clean-python-3-two-lines",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {ele: i + 1 for i, ele in enumerate(sorted(set(arr)))}\\n        return list(map(rank.get, arr))\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {ele: i + 1 for i, ele in enumerate(sorted(set(arr)))}\\n        return list(map(rank.get, arr))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489707,
                "title": "easy-solution-java-detailed-explanation",
                "content": "**Approach :** \\nCreate another array which has `\"value\":\"index\"` mapping. Sort it by value.\\n\\nNow iterate through this and keep assigning the rank. If the new value is same as previous one then rank doesn\\'t change, else increase rank by 1.\\n\\n**Example :**\\n\\nGiven array : [20, 30, 20, 50]\\nTransformed : [[20, 0], [20, 2], [30, 1], [50,3]]\\nrank for ->\\n\\n* \\tfirst 20 : 1, update index 0 for res\\n* \\tsecond 20 : 1, since it is same as prev, update index 2 for res\\n* \\tfirst 30 : 2, since it is different from 20, update index 1 for res\\n* \\tfirst 50 : 3, since it is different from 30, update index 3 for res\\n\\t\\n```\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] res = new int[arr.length];\\n        List<int[]> temp = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            temp.add(new int[]{arr[i], i}); // store : [value, index]\\n        }\\n        Collections.sort(temp, (a, b) -> a[0] - b[0]);\\n        int rank = 1;\\n        for (int i = 0; i < temp.size(); i++) {\\n            int idx = temp.get(i)[1];\\n            if (i == 0 || temp.get(i)[0] == temp.get(i - 1)[0]) {\\n                res[idx] = rank;\\n            } else {\\n                res[idx] = ++rank;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] res = new int[arr.length];\\n        List<int[]> temp = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            temp.add(new int[]{arr[i], i}); // store : [value, index]\\n        }\\n        Collections.sort(temp, (a, b) -> a[0] - b[0]);\\n        int rank = 1;\\n        for (int i = 0; i < temp.size(); i++) {\\n            int idx = temp.get(i)[1];\\n            if (i == 0 || temp.get(i)[0] == temp.get(i - 1)[0]) {\\n                res[idx] = rank;\\n            } else {\\n                res[idx] = ++rank;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677596,
                "title": "3-simple-c-solution",
                "content": "# **Using Set and Map :-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        set <int> s;\\n        for(int i=0;i<arr.size();i++)\\n            s.insert(arr[i]);          // making set that contains unique element in sorted order\\n        int rank = 1;\\n        for(auto &i : s)\\n            mp[i] = rank,++rank;       // assinging rank to unique elements \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\\n\\n# **Using Map & Sorting :-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        vector <int> temp = arr;\\n        int rank = 1; \\n        // sorting the array\\n        sort(temp.begin(),temp.end()); \\n        // deleting repeated element\\n        vector<int>::iterator it;\\n        it = unique(temp.begin(), temp.end());\\n        temp.resize(distance(temp.begin(), it));\\n        //assinging rank\\n        for(int i=0;i<temp.size();i++)\\n            mp[temp[i]] = rank,++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\\n\\n# **Using Map :-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        for(auto &it: arr)\\n            mp[it] = 0;\\n        int rank = 0;\\n        for(auto &it: mp)\\n            mp[it.first] = ++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        set <int> s;\\n        for(int i=0;i<arr.size();i++)\\n            s.insert(arr[i]);          // making set that contains unique element in sorted order\\n        int rank = 1;\\n        for(auto &i : s)\\n            mp[i] = rank,++rank;       // assinging rank to unique elements \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        vector <int> temp = arr;\\n        int rank = 1; \\n        // sorting the array\\n        sort(temp.begin(),temp.end()); \\n        // deleting repeated element\\n        vector<int>::iterator it;\\n        it = unique(temp.begin(), temp.end());\\n        temp.resize(distance(temp.begin(), it));\\n        //assinging rank\\n        for(int i=0;i<temp.size();i++)\\n            mp[temp[i]] = rank,++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        for(auto &it: arr)\\n            mp[it] = 0;\\n        int rank = 0;\\n        for(auto &it: mp)\\n            mp[it.first] = ++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493972,
                "title": "javascript-hash-easy-solution-with-explanation",
                "content": "**APPROACH**:\\nSince we need to replace each element with its rank, we need to find the smallest element and assigned it to the smallest rank. The easiest way to accomplish this is by sorting the input array in ascending order and then associating it with a rank. The rank initial value = 1, then we need to check if the element does not exist in our dictionary then add it to the dictionary and increase the rank by 1. \\n\\n\\nPSEUDO CODE:\\n    1. Make a copy of the array and sort it\\n    2. Assign ranks using a dictionary of key-value pairs,  ```arrayVal: index```\\n    3. transform the original array into ranks and return the result\\n\\nTime Complexity:  O(N log N)\\nSpace Complexity: O(N)\\n\\nAny feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nvar arrayRankTransform = function(ar) {\\n    if(ar.length == 0) return ar;\\n    \\n\\t/*  clone array & sort it   */\\n    let sortedAr = ar.slice().sort((a,b) => a - b);\\n    let res = [];\\n    let dic = {};\\n    \\n\\t/*  assign ranks        */\\n    let rank = 1;\\n    for(let i = 0; i < sortedAr.length; i++) {\\n        if(!dic[sortedAr[i]]) {\\n            dic[sortedAr[i]] = rank;\\n            rank++;\\n        }\\n    }\\n    \\n\\t/*  rank transform of an array  */\\n    for(let j = 0; j < ar.length; j++) {\\n        let rankVal = dic[ar[j]];\\n        res.push(rankVal)\\n    }\\n    return res; \\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```arrayVal: index```\n```\\nvar arrayRankTransform = function(ar) {\\n    if(ar.length == 0) return ar;\\n    \\n\\t/*  clone array & sort it   */\\n    let sortedAr = ar.slice().sort((a,b) => a - b);\\n    let res = [];\\n    let dic = {};\\n    \\n\\t/*  assign ranks        */\\n    let rank = 1;\\n    for(let i = 0; i < sortedAr.length; i++) {\\n        if(!dic[sortedAr[i]]) {\\n            dic[sortedAr[i]] = rank;\\n            rank++;\\n        }\\n    }\\n    \\n\\t/*  rank transform of an array  */\\n    for(let j = 0; j < ar.length; j++) {\\n        let rankVal = dic[ar[j]];\\n        res.push(rankVal)\\n    }\\n    return res; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493602,
                "title": "java-solution-treemap-or-treeset",
                "content": "Use TreeMap\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for(int x: arr) map.put(x, 1);\\n        \\n        int rank = 1;\\n        for(int key: map.keySet()) map.put(key, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nUse TreeSet\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Set<Integer> set = new TreeSet<>();\\n        for(int x: arr) set.add(x);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for(int x: set) map.put(x, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for(int x: arr) map.put(x, 1);\\n        \\n        int rank = 1;\\n        for(int key: map.keySet()) map.put(key, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Set<Integer> set = new TreeSet<>();\\n        for(int x: arr) set.add(x);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for(int x: set) map.put(x, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655612,
                "title": "java-super-easy-solution-with-comments-using-hashmap-and-sorting-works-faster",
                "content": "```\\n//Please upvote my answer if you like it \\nimport java.util.*;\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n=arr.length;\\n        int dummy[]=new int[n];\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i=0;i<n;i++) dummy[i]=arr[i];   //filling arr elements in dummy array so that we can\\'t lost our original array\\n        \\n        Arrays.sort(dummy);       //sorting the dummy array\\n       \\n        for(int i:dummy){\\n            if(!map.containsKey(i)){ //if map don\\'t contain that element then map it with it\\'s rank\\n                map.put(i,rank);\\n                rank++;\\n            } \\n            else map.put(i,map.get(i));    //if it contains that element then the rank should be that of the same element\\n        }\\n        \\n        for(int i=0;i<n;i++){    //putting the ranks from the map into array\\n            arr[i]=map.get(arr[i]);\\n        }\\n        \\n        return arr;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n=arr.length;\\n        int dummy[]=new int[n];\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i=0;i<n;i++) dummy[i]=arr[i];   //filling arr elements in dummy array so that we can\\'t lost our original array\\n        \\n        Arrays.sort(dummy);       //sorting the dummy array\\n       \\n        for(int i:dummy){\\n            if(!map.containsKey(i)){ //if map don\\'t contain that element then map it with it\\'s rank\\n                map.put(i,rank);\\n                rank++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3545754,
                "title": "hashmap-solution-easy-java",
                "content": "# Approach\\nThe given code implements a method `arrayRankTransform` that takes an integer array `arr` as input and returns a new array where each element is replaced with its rank in the sorted array. The rank represents the position of the element when the array is sorted in ascending order.\\n\\nHere\\'s the approach taken by the code:\\n\\n1. Create a copy of the input array `arr` called `rankedArray` using the `clone()` method.\\n2. Create a `LinkedHashMap` called `map` to store the elements of the array as keys and their ranks as values.\\n3. Sort the array `arr` using `Arrays.sort(arr)` to get the elements in ascending order.\\n4. Initialize a variable `rank` to 1 to keep track of the current rank.\\n5. If the length of the array is 0, return the empty array.\\n6. Initialize a variable `prev` to store the previous element in the array. Set it as the first element of the sorted array `arr[0]`.\\n7. Iterate through each element `num` in the sorted array `arr`.\\n   - If the current element `num` is different from the previous element `prev`, increment the `rank` by 1.\\n   - Put the element `num` in the map `map` if it doesn\\'t already exist, along with its corresponding `rank`.\\n   - Update the `prev` variable to the current element `num`.\\n8. Iterate through each element in the `rankedArray`.\\n   - Replace the element with its corresponding rank from the map using `map.get(rankedArray[i])`.\\n9. Return the `rankedArray`.\\n\\nOverall, the code creates a sorted map of element-rank pairs by iterating through the sorted array and assigning ranks based on the element\\'s uniqueness. Finally, it replaces the elements in the original array with their corresponding ranks from the map.\\n\\n# Complexity\\n- Time complexity:\\n    - The overall time complexity of the code is O(n log n), dominated by the sorting operation.\\n- Space complexity:\\n    - The overall space complexity of the code is O(n), where n is the length of the array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] rankedArray = arr.clone();\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        Arrays.sort(arr);\\n        int rank = 1;\\n        if(arr.length==0) return arr;\\n        int prev = arr[0];\\n        \\n        for (int num : arr) {\\n            if (prev != num) {\\n                rank++;\\n            }\\n            map.putIfAbsent(num, rank);\\n            prev = num;\\n        }\\n        \\n        for (int i = 0; i < rankedArray.length; i++) {\\n            rankedArray[i] = map.get(rankedArray[i]);\\n        }\\n        \\n        return rankedArray;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] rankedArray = arr.clone();\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        Arrays.sort(arr);\\n        int rank = 1;\\n        if(arr.length==0) return arr;\\n        int prev = arr[0];\\n        \\n        for (int num : arr) {\\n            if (prev != num) {\\n                rank++;\\n            }\\n            map.putIfAbsent(num, rank);\\n            prev = num;\\n        }\\n        \\n        for (int i = 0; i < rankedArray.length; i++) {\\n            rankedArray[i] = map.get(rankedArray[i]);\\n        }\\n        \\n        return rankedArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439696,
                "title": "o-nlogn-beginner-friendly-approach-c",
                "content": "- Approach\\n          Firstly, I declare one map which stores elements and in second loop I declare one cnt variable which starts from 1. after first loop elements stored in map is in sorted order so now I start second loop which is iterate inside map and cnt starts from 0 and second part of map is assigned to cnt variable and after each iteration increase cnt variable.\\n          Now I iterate one simple for loop in which I push back all those second part of map of arr vector(m[arr[i]]).\\n          Then I simply return that vector\\n\\n# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        int cnt=1;\\n        for(auto i : arr)\\n        {\\n            m[i]++;\\n        }\\n        for(auto i : m)\\n        {\\n            m[i.first] = cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ans.push_back(m[arr[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/59bd3797-91ef-445c-874d-752003be760c_1682046832.1349757.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        int cnt=1;\\n        for(auto i : arr)\\n        {\\n            m[i]++;\\n        }\\n        for(auto i : m)\\n        {\\n            m[i.first] = cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ans.push_back(m[arr[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469684,
                "title": "easy-java-solution-hashmap-beginner-friendly-best-method",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = arr[i];\\n        }\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int j = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],j++);\\n            }\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = map.get(arr[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = arr[i];\\n        }\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int j = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],j++);\\n            }\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = map.get(arr[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491041,
                "title": "java-o-n-memory-o-n-log-n-time",
                "content": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        if (arr.length == 0) {\\n            return arr;\\n        }\\n        if (arr.length == 1) {\\n            arr[0] = 1;\\n            return arr;\\n        }\\n        int[] copyArr = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(copyArr);\\n        Map<Integer, Integer> elementToRank = new HashMap<>();\\n        for (int i = 0, rank = 1, prevElem = -1; i < copyArr.length; i++) {\\n            int curElem = copyArr[i];\\n            if (i != 0 && curElem != prevElem) {\\n                rank++;\\n            }\\n            elementToRank.putIfAbsent(copyArr[i], rank);\\n            prevElem = curElem;\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = elementToRank.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        if (arr.length == 0) {\\n            return arr;\\n        }\\n        if (arr.length == 1) {\\n            arr[0] = 1;\\n            return arr;\\n        }\\n        int[] copyArr = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(copyArr);\\n        Map<Integer, Integer> elementToRank = new HashMap<>();\\n        for (int i = 0, rank = 1, prevElem = -1; i < copyArr.length; i++) {\\n            int curElem = copyArr[i];\\n            if (i != 0 && curElem != prevElem) {\\n                rank++;\\n            }\\n            elementToRank.putIfAbsent(copyArr[i], rank);\\n            prevElem = curElem;\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = elementToRank.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2250295,
                "title": "c-solution-hashmap-easy-to-understand",
                "content": "```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>dup=arr;\\n        int count=1;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            if(mp[arr[i]]==0){\\n                mp[arr[i]]=count;\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            dup[i]=mp[dup[i]];\\n        }\\n        return dup;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>dup=arr;\\n        int count=1;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            if(mp[arr[i]]==0){\\n                mp[arr[i]]=count;\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            dup[i]=mp[dup[i]];\\n        }\\n        return dup;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879202,
                "title": "java-easy-hashmap",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr){\\n        int[] val=arr.clone();\\n        Arrays.sort(val);\\n        Map<Integer,Integer>mpp=new HashMap<Integer,Integer>();\\n        for(int a: val) mpp.putIfAbsent(a,mpp.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=mpp.get(arr[i]);\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr){\\n        int[] val=arr.clone();\\n        Arrays.sort(val);\\n        Map<Integer,Integer>mpp=new HashMap<Integer,Integer>();\\n        for(int a: val) mpp.putIfAbsent(a,mpp.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=mpp.get(arr[i]);\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310705,
                "title": "c-using-sorting-vector-of-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if (arr.size() == 0) {\\n            return {};\\n        }\\n        if (arr.size() == 1) {\\n            return {1};\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for (int i = 0; i < arr.size(); i++) {\\n            v.push_back({arr[i], i});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        int rank = 1;\\n        int prev = v[0].first;\\n        v[0].first = rank;\\n        \\n        for (int i = 1; i < v.size(); i++) {\\n            if (v[i].first == prev) {\\n                prev = v[i].first;\\n                v[i].first = rank;\\n            }\\n            else {\\n                prev = v[i].first;\\n                v[i].first = ++rank;\\n            }\\n        }\\n        \\n        vector<int> res(arr.size(), 0);\\n        for (int i = 0; i < v.size(); i++) {\\n            res[v[i].second] = v[i].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if (arr.size() == 0) {\\n            return {};\\n        }\\n        if (arr.size() == 1) {\\n            return {1};\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for (int i = 0; i < arr.size(); i++) {\\n            v.push_back({arr[i], i});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        int rank = 1;\\n        int prev = v[0].first;\\n        v[0].first = rank;\\n        \\n        for (int i = 1; i < v.size(); i++) {\\n            if (v[i].first == prev) {\\n                prev = v[i].first;\\n                v[i].first = rank;\\n            }\\n            else {\\n                prev = v[i].first;\\n                v[i].first = ++rank;\\n            }\\n        }\\n        \\n        vector<int> res(arr.size(), 0);\\n        for (int i = 0; i < v.size(); i++) {\\n            res[v[i].second] = v[i].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285683,
                "title": "c-set-unorderd-map-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int>s(arr.begin(),arr.end()); //set to remove duplicate values\\n        unordered_map<int,int>m; // map to place rank and value\\n        vector<int>out;//output vector\\n        \\n        for(auto val:s)\\n        {\\n            //since we are giving sorted values thus... map size+1 would be the rank of next input\\n            m[val]=m.size()+1;\\n        }\\n        for(auto val:arr)\\n        {\\n            //now we took the value for the given number from map and put it into output vector\\n            out.push_back(m[val]);\\n        }\\n        return out;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int>s(arr.begin(),arr.end()); //set to remove duplicate values\\n        unordered_map<int,int>m; // map to place rank and value\\n        vector<int>out;//output vector\\n        \\n        for(auto val:s)\\n        {\\n            //since we are giving sorted values thus... map size+1 would be the rank of next input\\n            m[val]=m.size()+1;\\n        }\\n        for(auto val:arr)\\n        {\\n            //now we took the value for the given number from map and put it into output vector\\n            out.push_back(m[val]);\\n        }\\n        return out;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277703,
                "title": "python-solution-faster-then-95-71-solution",
                "content": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        l,f = dict(),list(sorted(set(arr)))\\n        for i in range(len(f)):\\n            l[f[i]]=i+1 \\n        return [l[i] for i in arr] \\n```",
                "solutionTags": [],
                "code": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        l,f = dict(),list(sorted(set(arr)))\\n        for i in range(len(f)):\\n            l[f[i]]=i+1 \\n        return [l[i] for i in arr] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1072516,
                "title": "c-solution-using-unordered-map-faster-than-85-80-of-other-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> v;\\n        unordered_map<int,int> mp;\\n        v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        mp[v[0]]=1;\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]!=v[i-1]){\\n                rank++;\\n            }\\n            mp[v[i]]=rank;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> v;\\n        unordered_map<int,int> mp;\\n        v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        mp[v[0]]=1;\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]!=v[i-1]){\\n                rank++;\\n            }\\n            mp[v[i]]=rank;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523376,
                "title": "javascript-2-line-solution",
                "content": "Runtime: 228 ms, faster than 98.85% of JavaScript online submissions\\nMemory Usage: 66.7 MB, less than 100.00% of JavaScript online submissions\\n\\n```\\nconst arrayRankTransform = arr => {\\n  const ranks = [...new Set(arr)]\\n    .sort((a, b) => a - b)\\n    .reduce((acc, curr, idx) => acc.set(curr, idx + 1), new Map());\\n  return arr.map(n => ranks.get(n));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst arrayRankTransform = arr => {\\n  const ranks = [...new Set(arr)]\\n    .sort((a, b) => a - b)\\n    .reduce((acc, curr, idx) => acc.set(curr, idx + 1), new Map());\\n  return arr.map(n => ranks.get(n));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3240108,
                "title": "python3-beats-84-44",
                "content": "# Please upvote if you find the solution helpful.\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        d = {}\\n        f_lst=[]\\n        arr1 = sorted(list(set(arr)))\\n        for i in range(len(arr1)):\\n            d[arr1[i]] = i+1\\n        for i in arr:\\n            f_lst.append(d[i])\\n        return f_lst\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        d = {}\\n        f_lst=[]\\n        arr1 = sorted(list(set(arr)))\\n        for i in range(len(arr1)):\\n            d[arr1[i]] = i+1\\n        for i in arr:\\n            f_lst.append(d[i])\\n        return f_lst\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940937,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& vec) {\\n        vector<int> arr=vec;\\n        if(vec.size()==1)return{1};\\n        if(vec.size()==0)return vec;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        int r=1;\\n        mp[arr[0]]=1;\\n        \\n\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]!=arr[i-1]){\\n                mp[arr[i]]=++r;\\n                \\n            }\\n            else{\\n                mp[arr[i]]=r;\\n                \\n            }\\n            \\n        }\\n        for(int i=0;i<vec.size();i++){\\n            vec[i]=mp[vec[i]];\\n        }\\n    return vec;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& vec) {\\n        vector<int> arr=vec;\\n        if(vec.size()==1)return{1};\\n        if(vec.size()==0)return vec;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        int r=1;\\n        mp[arr[0]]=1;\\n        \\n\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]!=arr[i-1]){\\n                mp[arr[i]]=++r;\\n                \\n            }\\n            else{\\n                mp[arr[i]]=r;\\n                \\n            }\\n            \\n        }\\n        for(int i=0;i<vec.size();i++){\\n            vec[i]=mp[vec[i]];\\n        }\\n    return vec;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823902,
                "title": "easy-python-solution-beats-95-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        #print(rank)\\n        return [rank[i] for i in arr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        #print(rank)\\n        return [rank[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614234,
                "title": "easy-code-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        //can be decoded as key and value where key is the array elem and value is it\\'s rank\\n        vector<int>temp;\\n        temp=arr;\\n        sort(temp.begin(),temp.end());\\n        map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            if(mp.find(temp[i])==mp.end())\\n            {\\n            mp[temp[i]]=rank;//storing the rank of the number\\n                rank++;\\n             }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ans.push_back(mp[arr[i]]);//value of the key \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        //can be decoded as key and value where key is the array elem and value is it\\'s rank\\n        vector<int>temp;\\n        temp=arr;\\n        sort(temp.begin(),temp.end());\\n        map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            if(mp.find(temp[i])==mp.end())\\n            {\\n            mp[temp[i]]=rank;//storing the rank of the number\\n                rank++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2450341,
                "title": "fast-short-easy-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        int[] copySort = arr.clone();\\n        Arrays.sort(copySort);\\n\\n        int index = 1;\\n        for(int i : copySort)\\n            if (map.putIfAbsent(i, index) == null)\\n                index++;\\n\\n        for(int i=0; i<arr.length; i++)\\n            arr[i]=map.get(arr[i]);\\n\\n        return arr;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421511,
                "title": "python-elegant-short-two-lines-hashmap-sorting",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*log(n))\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}\\n\\t\\t\\treturn [ranks[num] for num in arr]\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "class Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*log(n))\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}",
                "codeTag": "Java"
            },
            {
                "id": 1931825,
                "title": "python-solutions-one-liner-set-sorted-enumerate-simple-and-clean",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {}\\n        for rank, num in enumerate(sorted(set(arr))):\\n            ranks[num] = rank+1\\n        return [ranks[num] for num in arr]\\n```\\n\\n**Solution - Dictionary Comprehension**:\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {num:rank+1 for rank, num in enumerate(sorted(set(arr)))}\\n        return [ranks[num] for num in arr]\\n```\\n\\n**Solution - One-Liner**:\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        return map({n:r+1 for r,n in enumerate(sorted(set(arr)))}.get, arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {}\\n        for rank, num in enumerate(sorted(set(arr))):\\n            ranks[num] = rank+1\\n        return [ranks[num] for num in arr]\\n```\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {num:rank+1 for rank, num in enumerate(sorted(set(arr)))}\\n        return [ranks[num] for num in arr]\\n```\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        return map({n:r+1 for r,n in enumerate(sorted(set(arr)))}.get, arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561105,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        vector<int>nums=arr;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(nums[i])==0)\\n              mp[nums[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        vector<int>nums=arr;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(nums[i])==0)\\n              mp[nums[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481836,
                "title": "python-two-lines-solutions-beats-99-75",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:       \\n        ref = {k: v+1 for v, k in enumerate(sorted(set(arr)))}\\n        return [ref[i] for i in arr]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:       \\n        ref = {k: v+1 for v, k in enumerate(sorted(set(arr)))}\\n        return [ref[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191799,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        uniques = sorted(set(arr))\\n        dct = {number: rank for rank, number in enumerate(uniques, start=1)}\\n        \\n        return [dct[num] for num in arr]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        uniques = sorted(set(arr))\\n        dct = {number: rank for rank, number in enumerate(uniques, start=1)}\\n        \\n        return [dct[num] for num in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054163,
                "title": "java-easy-6-lines-beats-85-time-and-80-space",
                "content": "```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] gd=arr.clone();\\n        Arrays.sort(gd);\\n        Map<Integer,Integer> sr=new HashMap<>();\\n        for(int i=0;i<gd.length;i++){\\n            sr.putIfAbsent(gd[i],sr.size()+1);\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=sr.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] gd=arr.clone();\\n        Arrays.sort(gd);\\n        Map<Integer,Integer> sr=new HashMap<>();\\n        for(int i=0;i<gd.length;i++){\\n            sr.putIfAbsent(gd[i],sr.size()+1);\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=sr.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039492,
                "title": "min-heap-python-t-o-nlogn-s-o-n",
                "content": "My min heap solution in python. Basically we add every element and it\\'s index to heap, then one by one we extract it and add ranks at remembered index. If two adjacent elements are the same, rank will not increase.\\n\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        heap = [(x, i) for i, x in enumerate(arr)]\\n        heapify(heap)\\n        rank = 0\\n        last = inf\\n        \\n        while heap:\\n            val, idx = heappop(heap)\\n            if val != last:\\n                last = val\\n                rank += 1\\n            arr[idx] = rank\\n        return arr\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "My min heap solution in python. Basically we add every element and it\\'s index to heap, then one by one we extract it and add ranks at remembered index. If two adjacent elements are the same, rank will not increase.\\n\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        heap = [(x, i) for i, x in enumerate(arr)]\\n        heapify(heap)\\n        rank = 0\\n        last = inf\\n        \\n        while heap:\\n            val, idx = heappop(heap)\\n            if val != last:\\n                last = val\\n                rank += 1\\n            arr[idx] = rank\\n        return arr\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1002019,
                "title": "sortedset-c",
                "content": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\n            int[] aRank = new int[arr.Length];\\n\\n            Dictionary<int, int> map = new SortedSet<int>(arr)\\n               .Select((num, i) => (num, i))\\n               .ToDictionary(k => k.num, v => v.i + 1); \\n\\n            for (int i = 0; i < arr.Length; i++) {\\n                aRank[i] =map[arr[i]];                \\n            }      \\n            return aRank;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\n            int[] aRank = new int[arr.Length];\\n\\n            Dictionary<int, int> map = new SortedSet<int>(arr)\\n               .Select((num, i) => (num, i))\\n               .ToDictionary(k => k.num, v => v.i + 1); \\n\\n            for (int i = 0; i < arr.Length; i++) {\\n                aRank[i] =map[arr[i]];                \\n            }      \\n            return aRank;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582248,
                "title": "javascript-easy-solution-98-100",
                "content": "var arrayRankTransform = function(arr) {\\n\\n\\tvar unre = Array.from(new Set(arr)).sort((a,b) => a - b);\\n\\tvar obj = new Map();\\n\\n\\tfor (var i = 0; i < unre.length ; i++) {\\n\\t\\tobj.set(unre[i],i+1);\\n\\t}\\n\\t\\n\\tarr = arr.map(item => item=obj.get(item));\\n    \\n    return arr;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var arrayRankTransform = function(arr) {\\n\\n\\tvar unre = Array.from(new Set(arr)).sort((a,b) => a - b);\\n\\tvar obj = new Map();\\n\\n\\tfor (var i = 0; i < unre.length ; i++) {\\n\\t\\tobj.set(unre[i],i+1);\\n\\t}\\n\\t\\n\\tarr = arr.map(item => item=obj.get(item));\\n    \\n    return arr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 523582,
                "title": "c-beats-80-and-100-memory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector <int> aux = arr;\\n        sort(aux.begin(),aux.end());\\n        int i = 1;\\n        unordered_map <int,int> m;\\n        for(auto w : aux)\\n        {\\n            if(m.find(w) == m.end()) m[w] = i++;\\n        }\\n        i = 0;\\n        for(auto w : arr) aux[i++] = m[w];\\n        return aux;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector <int> aux = arr;\\n        sort(aux.begin(),aux.end());\\n        int i = 1;\\n        unordered_map <int,int> m;\\n        for(auto w : aux)\\n        {\\n            if(m.find(w) == m.end()) m[w] = i++;\\n        }\\n        i = 0;\\n        for(auto w : arr) aux[i++] = m[w];\\n        return aux;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522049,
                "title": "c-hashing-memory-efficient-100",
                "content": "```\\nMemory Usage: 31.2 MB, less than 100.00% of C++ online submissions for Rank Transform of an Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      set<int> arrSet(arr.begin(), arr.end());\\n      \\n      unordered_map<int, int> pos;\\n      int position = 1;\\n        \\n      for (auto num : arrSet){\\n          pos[num] = position;\\n          position++;\\n      }\\n      \\n      for (auto& num : arr){\\n          num = pos[num];\\n      }\\n        \\n      return arr;\\n    }\\n};\\n\\n//CODE BELOW FAILS FOR ONLY 1 TEST CASE\\n/*vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> arrSet(arr.begin(), arr.end());\\n        \\n        for(auto& num : arr){\\n            num = getIndex(arrSet, num);\\n        }\\n        \\n        return arr;\\n    }\\n    \\n    int getIndex(set<int> arrSet, int num){\\n        set<int>::iterator setIt = arrSet.begin();\\n\\n        for(int i = 0; i < arrSet.size(); i++){\\n            if(num == *setIt){\\n                return i + 1;\\n            }\\n            setIt++;\\n        }\\n        return 0;\\n    }\\n    */\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nMemory Usage: 31.2 MB, less than 100.00% of C++ online submissions for Rank Transform of an Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      set<int> arrSet(arr.begin(), arr.end());\\n      \\n      unordered_map<int, int> pos;\\n      int position = 1;\\n        \\n      for (auto num : arrSet){\\n          pos[num] = position;\\n          position++;\\n      }\\n      \\n      for (auto& num : arr){\\n          num = pos[num];\\n      }\\n        \\n      return arr;\\n    }\\n};\\n\\n//CODE BELOW FAILS FOR ONLY 1 TEST CASE\\n/*vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> arrSet(arr.begin(), arr.end());\\n        \\n        for(auto& num : arr){\\n            num = getIndex(arrSet, num);\\n        }\\n        \\n        return arr;\\n    }\\n    \\n    int getIndex(set<int> arrSet, int num){\\n        set<int>::iterator setIt = arrSet.begin();\\n\\n        for(int i = 0; i < arrSet.size(); i++){\\n            if(num == *setIt){\\n                return i + 1;\\n            }\\n            setIt++;\\n        }\\n        return 0;\\n    }\\n    */\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 493244,
                "title": "c-solution",
                "content": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\tvar dict = arr\\n\\t\\t.Distinct()\\n\\t\\t.OrderBy(x => x)\\n\\t\\t.Select((x, i) => (x, i))\\n\\t\\t.ToDictionary(x => x.x, x => x.i + 1);\\n\\n\\tfor (var i = 0; i < arr.Length; i++)\\n\\t\\tarr[i] = dict[arr[i]];\\n\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\tvar dict = arr\\n\\t\\t.Distinct()\\n\\t\\t.OrderBy(x => x)\\n\\t\\t.Select((x, i) => (x, i))\\n\\t\\t.ToDictionary(x => x.x, x => x.i + 1);\\n\\n\\tfor (var i = 0; i < arr.Length; i++)\\n\\t\\tarr[i] = dict[arr[i]];\\n\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491455,
                "title": "priorityqueue",
                "content": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t// (value, index)\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(\\n\\t\\t\\t\\tnew Comparator<int[]>() {\\n\\n\\t\\t\\t\\t\\t@Override\\n\\t\\t\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tpq.add(new int[] { arr[i], i });\\n\\t\\t}\\n\\t\\tint rank = 1;\\n\\t\\tint[] res = new int[arr.length];\\n\\t\\tInteger prev = null;\\n\\t\\twhile (!pq.isEmpty()) {\\n\\t\\t\\tint[] element = pq.remove();\\n\\t\\t\\tif (prev == null || prev == element[0]) {\\n\\t\\t\\t\\tres[element[1]] = rank;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[element[1]] = ++rank;\\n\\t\\t\\t}\\n\\t\\t\\tprev = element[0];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t// (value, index)\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(\\n\\t\\t\\t\\tnew Comparator<int[]>() {\\n\\n\\t\\t\\t\\t\\t@Override\\n\\t\\t\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tpq.add(new int[] { arr[i], i });\\n\\t\\t}\\n\\t\\tint rank = 1;\\n\\t\\tint[] res = new int[arr.length];\\n\\t\\tInteger prev = null;\\n\\t\\twhile (!pq.isEmpty()) {\\n\\t\\t\\tint[] element = pq.remove();\\n\\t\\t\\tif (prev == null || prev == element[0]) {\\n\\t\\t\\t\\tres[element[1]] = rank;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[element[1]] = ++rank;\\n\\t\\t\\t}\\n\\t\\t\\tprev = element[0];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489706,
                "title": "java-sort-and-keep-track",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n = arr.length;\\n        int[] brr = new int[n];\\n        for(int i = 0; i < n; i++) brr[i] = arr[i];\\n        Arrays.sort(brr);\\n        int[] rank = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int val = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(brr[i])) {\\n                val++;\\n                map.put(brr[i], val);\\n            }\\n        }\\n        for(int i = 0; i < n; i++) rank[i] = map.get(arr[i]);\\n        return rank;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n = arr.length;\\n        int[] brr = new int[n];\\n        for(int i = 0; i < n; i++) brr[i] = arr[i];\\n        Arrays.sort(brr);\\n        int[] rank = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int val = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(brr[i])) {\\n                val++;\\n                map.put(brr[i], val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3950970,
                "title": "c-easy-intution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain a set and then unordered map where we will keep the rank.\\n        set<int> array;\\n        for(auto &num : arr) array.insert(num);\\n        unordered_map<int, int> mp;\\n        int i = 1;\\n        for(auto itr = array.begin(); itr != array.end() ; itr++){ \\n            mp[*itr] = i++;\\n        }\\n        for(auto &num : arr) num = mp[num];\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain a set and then unordered map where we will keep the rank.\\n        set<int> array;\\n        for(auto &num : arr) array.insert(num);\\n        unordered_map<int, int> mp;\\n        int i = 1;\\n        for(auto itr = array.begin(); itr != array.end() ; itr++){ \\n            mp[*itr] = i++;\\n        }\\n        for(auto &num : arr) num = mp[num];\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520913,
                "title": "for-beginners-simple-java-solution",
                "content": "Solution using HashMap and sorting. \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int len = arr.length; \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n        \\n        int[] nums = new int[len]; \\n        \\n        // copy into new array nums \\n        for(int i=0; i<len; i++) {\\n            nums[i] = arr[i]; \\n        }\\n\\n        // sorting the new copy array \\n        Arrays.sort(nums); \\n\\n        // now putting this data into hashmap \\n        int rank=1; \\n        for(int i=0; i<len; i++) {\\n            if(! map.containsKey(nums[i])) { // if map does not contain key, then add it and increae the rank. \\n                map.put(nums[i], rank++); \\n            }\\n        } \\n\\n        for(int i=0; i<len; i++) {\\n            arr[i]=map.get(arr[i]); \\n        }\\n\\n        return arr; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int len = arr.length; \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n        \\n        int[] nums = new int[len]; \\n        \\n        // copy into new array nums \\n        for(int i=0; i<len; i++) {\\n            nums[i] = arr[i]; \\n        }\\n\\n        // sorting the new copy array \\n        Arrays.sort(nums); \\n\\n        // now putting this data into hashmap \\n        int rank=1; \\n        for(int i=0; i<len; i++) {\\n            if(! map.containsKey(nums[i])) { // if map does not contain key, then add it and increae the rank. \\n                map.put(nums[i], rank++); \\n            }\\n        } \\n\\n        for(int i=0; i<len; i++) {\\n            arr[i]=map.get(arr[i]); \\n        }\\n\\n        return arr; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399552,
                "title": "rank-transform-of-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int i, j, l, r, mid;\\n        vector<int> rank;\\n       \\n        unordered_set<int> set(arr.begin(), arr.end());\\n        vector<int> sorted_arr(set.begin(), set.end());\\n        sort(sorted_arr.begin(), sorted_arr.end());\\n\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            l=0, r=sorted_arr.size()-1;\\n            while(l<=r)\\n            {\\n                mid = (l+r)/2;\\n                if(sorted_arr[mid]==arr[i])\\n                {\\n                    rank.push_back(mid+1);\\n                    break;\\n                }\\n                else if(sorted_arr[mid]<arr[i])\\n                {\\n                    l = mid+1;\\n                }\\n                else\\n                {\\n                    r = mid-1;\\n                }\\n            }\\n        }\\n        return rank;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int i, j, l, r, mid;\\n        vector<int> rank;\\n       \\n        unordered_set<int> set(arr.begin(), arr.end());\\n        vector<int> sorted_arr(set.begin(), set.end());\\n        sort(sorted_arr.begin(), sorted_arr.end());\\n\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            l=0, r=sorted_arr.size()-1;\\n            while(l<=r)\\n            {\\n                mid = (l+r)/2;\\n                if(sorted_arr[mid]==arr[i])\\n                {\\n                    rank.push_back(mid+1);\\n                    break;\\n                }\\n                else if(sorted_arr[mid]<arr[i])\\n                {\\n                    l = mid+1;\\n                }\\n                else\\n                {\\n                    r = mid-1;\\n                }\\n            }\\n        }\\n        return rank;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309869,
                "title": "easiest-solution-you-ever-find-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        list1=[]\\n        x=sorted(set(arr))\\n        dict1={}\\n        for i in range(len(x)):\\n            dict1[x[i]]=i+1\\n        for j in arr:\\n            y=dict1[j]\\n            list1.append(y)\\n        return list1\\n    #please do upvote it will help alot to gain my love in coding\\n\\n```\\n# consider upvoting if found helpful![57jfh9.jpg](https://assets.leetcode.com/users/images/18e346ce-ffbb-46f1-995f-cfc301972ca0_1679115728.6807754.jpeg)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        list1=[]\\n        x=sorted(set(arr))\\n        dict1={}\\n        for i in range(len(x)):\\n            dict1[x[i]]=i+1\\n        for j in arr:\\n            y=dict1[j]\\n            list1.append(y)\\n        return list1\\n    #please do upvote it will help alot to gain my love in coding\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453766,
                "title": "98-tc-and-68-sc-easy-python-solution",
                "content": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\tc = 1\\n\\td = dict()\\n\\tfor i in sorted(list(set(arr))):\\n\\t\\td[i] = c\\n\\t\\tc += 1\\n\\tfor i in range(len(arr)):\\n\\t\\tarr[i] = d[arr[i]]\\n\\treturn arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\tc = 1\\n\\td = dict()\\n\\tfor i in sorted(list(set(arr))):\\n\\t\\td[i] = c\\n\\t\\tc += 1\\n\\tfor i in range(len(arr)):\\n\\t\\tarr[i] = d[arr[i]]\\n\\treturn arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2053787,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar arrayRankTransform = function(arr) {\\n    let keys = 0;\\n\\n    const ranks = [...arr].sort((a, b) => a - b).reduce((res, x) => {\\n        if (!res[x]) {\\n            res[x] = 1 + keys++;\\n        }\\n        \\n        return res;\\n    }, {});\\n    \\n    return arr.map(x => ranks[x]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n    let keys = 0;\\n\\n    const ranks = [...arr].sort((a, b) => a - b).reduce((res, x) => {\\n        if (!res[x]) {\\n            res[x] = 1 + keys++;\\n        }\\n        \\n        return res;\\n    }, {});\\n    \\n    return arr.map(x => ranks[x]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040619,
                "title": "26-ms-95-faster-simple-java-solution",
                "content": "java code is:\\n\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int copy[]=arr.clone();\\n        Arrays.sort(copy);\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int num : copy) if(!map.containsKey(num))map.put(num,map.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=map.get(arr[i]);\\n        return arr;\\n    }\\n## }\\n### ```\\n### Time : O(nlogn)\\n### Space : O(n) linear extra space\\n### Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int copy[]=arr.clone();\\n        Arrays.sort(copy);\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int num : copy) if(!map.containsKey(num))map.put(num,map.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=map.get(arr[i]);\\n        return arr;\\n    }\\n## }\\n### ```",
                "codeTag": "Java"
            },
            {
                "id": 1559482,
                "title": "python-simple-solution-using-hashmap-faster-than-83-32",
                "content": "\\n        a=sorted(list(set(arr)))\\n        rank=1\\n        b={}\\n        for i in a:\\n            b[i]=rank\\n            rank+=1\\n        c=[]    \\n        for i in arr:\\n            c.append(b[i])\\n        return c\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n        a=sorted(list(set(arr)))\\n        rank=1\\n        b={}\\n        for i in a:\\n            b[i]=rank\\n            rank+=1\\n        c=[]    \\n        for i in arr:\\n            c.append(b[i])\\n        return c\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1428174,
                "title": "c-easy-intuitive",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> s(arr.begin(),arr.end());\\n        int rank=1;\\n        unordered_map<int,int> mp;\\n        for(int x:s)\\n        {\\n            mp[x]=rank++;\\n        }   \\n        for(int &x:arr)\\n        {\\n            x=mp[x];    \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> s(arr.begin(),arr.end());\\n        int rank=1;\\n        unordered_map<int,int> mp;\\n        for(int x:s)\\n        {\\n            mp[x]=rank++;\\n        }   \\n        for(int &x:arr)\\n        {\\n            x=mp[x];    \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424926,
                "title": "c-easy-and-concise-map-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      map<int,int>mp;\\n      //Initializing rank of all unique elements to 0 in map\\n      for(int i=0;i<arr.size();i++) mp[arr[i]]=0;\\n      int rank=0;\\n      //Alotting rank to each unique array element\\n      for(auto i:mp) mp[i.first]=++rank;\\n      //Forming the output \\n      vector<int>result;\\n      for(int i:arr) result.push_back(mp[i]);\\n      return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      map<int,int>mp;\\n      //Initializing rank of all unique elements to 0 in map\\n      for(int i=0;i<arr.size();i++) mp[arr[i]]=0;\\n      int rank=0;\\n      //Alotting rank to each unique array element\\n      for(auto i:mp) mp[i.first]=++rank;\\n      //Forming the output \\n      vector<int>result;\\n      for(int i:arr) result.push_back(mp[i]);\\n      return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1409701,
                "title": "c-how-i-write-improved-solutions-from-complex-ones",
                "content": "```\\n//Approach-1 (Little messed solution : Naive approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        int i = 0;\\n\\t\\t//I store indices of all elements\\n        for(const int &x : arr) mp[x].push_back(i++);\\n        \\n        sort(begin(arr), end(arr));\\n        vector<int> result(arr.size());\\n        \\n        int rank = 1;\\n\\t\\t//Just put rank starting from 1\\n        for(int i = 0; i<arr.size();) {\\n\\t\\t\\t//Fill same rank for same elements\\n            for(const int& idx : mp[arr[i]]) {\\n                result[idx] = rank;\\n                i++;\\n            }\\n            rank++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Simplified and better to understand approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A = arr;\\n        sort(begin(A), end(A));\\n        \\n        unordered_map<int, int> mp;\\n        for(const int &x : A) {\\n            if(!mp.count(x))\\n                mp[x] = mp.size()+1;\\n        }\\n        \\n        for(int &x : arr)\\n            x = mp[x];\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Little messed solution : Naive approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        int i = 0;\\n\\t\\t//I store indices of all elements\\n        for(const int &x : arr) mp[x].push_back(i++);\\n        \\n        sort(begin(arr), end(arr));\\n        vector<int> result(arr.size());\\n        \\n        int rank = 1;\\n\\t\\t//Just put rank starting from 1\\n        for(int i = 0; i<arr.size();) {\\n\\t\\t\\t//Fill same rank for same elements\\n            for(const int& idx : mp[arr[i]]) {\\n                result[idx] = rank;\\n                i++;\\n            }\\n            rank++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Simplified and better to understand approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A = arr;\\n        sort(begin(A), end(A));\\n        \\n        unordered_map<int, int> mp;\\n        for(const int &x : A) {\\n            if(!mp.count(x))\\n                mp[x] = mp.size()+1;\\n        }\\n        \\n        for(int &x : arr)\\n            x = mp[x];\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391934,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        if(arr.length == 0 || arr == null) {\\n            return new int[]{};\\n        }\\n        \\n        int[] temp = arr.clone();\\n        \\n        Arrays.sort(temp);\\n        \\n        Map<Integer,Integer> map = new HashMap();\\n        \\n        for(int i = 0; i<temp.length; i++) {\\n            map.putIfAbsent(temp[i], map.size()+1);\\n        }\\n        \\n        \\n        for(int i = 0; i<arr.length; i++) {\\n            temp[i] = map.get(arr[i]);\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        if(arr.length == 0 || arr == null) {\\n            return new int[]{};\\n        }\\n        \\n        int[] temp = arr.clone();\\n        \\n        Arrays.sort(temp);\\n        \\n        Map<Integer,Integer> map = new HashMap();\\n        \\n        for(int i = 0; i<temp.length; i++) {\\n            map.putIfAbsent(temp[i], map.size()+1);\\n        }\\n        \\n        \\n        for(int i = 0; i<arr.length; i++) {\\n            temp[i] = map.get(arr[i]);\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355474,
                "title": "python3-simple-and-easy-understanding",
                "content": "\\n\\n        sorted_arr = sorted(set(arr))\\n        n = len(sorted_arr)\\n        indx = [i+1 for i in range(n)]\\n        mapping = dict(zip(sorted_arr,indx))\\n        ans = []\\n        for i in arr:\\n            ans.append(mapping[i])\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\n        sorted_arr = sorted(set(arr))\\n        n = len(sorted_arr)\\n        indx = [i+1 for i in range(n)]\\n        mapping = dict(zip(sorted_arr,indx))\\n        ans = []\\n        for i in arr:\\n            ans.append(mapping[i])\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 1286962,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] copy=new int[arr.length];\\n        copy=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(copy);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            if(!map.containsKey(copy[i]))\\n            {\\n                map.put(copy[i],rank++);\\n            }\\n        }\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            arr[i]=map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] copy=new int[arr.length];\\n        copy=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(copy);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            if(!map.containsKey(copy[i]))\\n            {\\n                map.put(copy[i],rank++);\\n            }\\n        }\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            arr[i]=map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120131,
                "title": "js-easy-to-understand-for-beginners-as-well-beats-93-comments",
                "content": "```\\nvar arrayRankTransform = function (arr) {\\n  // map to store the rank of elements\\n  let m = new Map();\\n  // creating a sorted list with unique values\\n  let sorted = [...new Set([...arr].sort((a, b) => a - b))];\\n  for (let i = 0; i < sorted.length; i++) {\\n  // assigning ranks starting from 1. We removed duplicates because if we don\\'t then same numbers will have different ranks\\n    m.set(sorted[i], i + 1);\\n  }\\n  // retrieving the assigned ranks from the map and replacing in the original input array\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = m.get(arr[i]);\\n  }\\n  return arr;\\n};\\n```\\nRuntime: 192 ms, faster than 93.87% of JavaScript online submissions for Rank Transform of an Array.\\nMemory Usage: 56.5 MB, less than 86.79% of JavaScript online submissions for Rank Transform of an Array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function (arr) {\\n  // map to store the rank of elements\\n  let m = new Map();\\n  // creating a sorted list with unique values\\n  let sorted = [...new Set([...arr].sort((a, b) => a - b))];\\n  for (let i = 0; i < sorted.length; i++) {\\n  // assigning ranks starting from 1. We removed duplicates because if we don\\'t then same numbers will have different ranks\\n    m.set(sorted[i], i + 1);\\n  }\\n  // retrieving the assigned ranks from the map and replacing in the original input array\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = m.get(arr[i]);\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045634,
                "title": "my-python-solution",
                "content": "I\\'m sure its not the best solution, but its the best I could come up with. \\n\\nThe thought process is to sort the array then keep track of the previous number and running rank while iterating through the sorted array. If we get a number that isn\\'t the same as the previous number (new number) we assign it to the running rank in a dictionary--if we get a number that is the same as the previous (a duplicate), we do nothing at all.\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        rank = 1\\n        d = {}\\n        temp = \\'\\'\\n        for num in sorted(arr):\\n            if num == temp:\\n                continue\\n            else:\\n                d[num] = rank\\n                temp = num\\n                rank += 1\\n        return [d[i] for i in arr]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        rank = 1\\n        d = {}\\n        temp = \\'\\'\\n        for num in sorted(arr):\\n            if num == temp:\\n                continue\\n            else:\\n                d[num] = rank\\n                temp = num\\n                rank += 1\\n        return [d[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994639,
                "title": "python-use-dictionary-straightforward",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        cnt = {}\\n        rank = 1\\n        for k in sorted(list(set(arr))):\\n            cnt[k] = rank\\n            rank += 1\\n        return [cnt[x] for x in arr]",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        cnt = {}",
                "codeTag": "Java"
            },
            {
                "id": 935547,
                "title": "python-one-liner-using-hashmap-and-set",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {elem: rank + 1 for rank, elem in enumerate(sorted(set(arr)))}\\n        return [ranks[key] for key in arr]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {elem: rank + 1 for rank, elem in enumerate(sorted(set(arr)))}\\n        return [ranks[key] for key in arr]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 900636,
                "title": "easy-java-with-treeset-and-hashmap",
                "content": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        if(arr == null) {\\n            return null;\\n        }\\n        \\n        Set<Integer> set = new TreeSet<>();\\n        for(int i: arr) {\\n            set.add(i);\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();        \\n        int rank = 1; \\n        \\n        for(int i: set) {\\n            map.put(i, rank++);\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        if(arr == null) {\\n            return null;\\n        }\\n        \\n        Set<Integer> set = new TreeSet<>();\\n        for(int i: arr) {\\n            set.add(i);\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();        \\n        int rank = 1; \\n        \\n        for(int i: set) {\\n            map.put(i, rank++);\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 827558,
                "title": "c-solution-using-sorting-and-binary-search",
                "content": "```c\\nint cmp(const void* a, const void* b) {\\n  int* x = (int*)a;\\n  int* y = (int*)b;\\n\\n  return *x - *y;\\n}\\n\\nint search(int* a, int size, int v) {\\n  int l = 0, h = size;\\n  while (l < h) {\\n    int mid = l + (h - l) / 2;\\n    if (a[mid] == v) {\\n      return mid;\\n    } else if (a[mid] > v) {\\n      h = mid;\\n    } else {\\n      l = mid;\\n    }\\n  }\\n\\n  return -1;\\n}\\n\\nint* arrayRankTransform(int* arr, int arrSize, int* returnSize) {\\n  *returnSize = arrSize;\\n  int* result = malloc(sizeof(int) * arrSize);\\n  if (arrSize == 0)\\n    return result;\\n\\n  int values[arrSize], ranks[arrSize];\\n  memcpy(values, arr, sizeof(values));\\n  qsort(values, arrSize, sizeof(int), cmp);\\n\\n  ranks[0] = 1;\\n  for (int i = 1; i < arrSize; i++) {\\n    if (values[i] == values[i - 1]) {\\n      ranks[i] = ranks[i - 1];\\n    } else {\\n      ranks[i] = ranks[i - 1] + 1;\\n    }\\n  }\\n\\n  for (int i = 0; i < arrSize; i++) {\\n    int j = search(values, arrSize, arr[i]);\\n    result[i] = ranks[j];\\n  }\\n\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```c\\nint cmp(const void* a, const void* b) {\\n  int* x = (int*)a;\\n  int* y = (int*)b;\\n\\n  return *x - *y;\\n}\\n\\nint search(int* a, int size, int v) {\\n  int l = 0, h = size;\\n  while (l < h) {\\n    int mid = l + (h - l) / 2;\\n    if (a[mid] == v) {\\n      return mid;\\n    } else if (a[mid] > v) {\\n      h = mid;\\n    } else {\\n      l = mid;\\n    }\\n  }\\n\\n  return -1;\\n}\\n\\nint* arrayRankTransform(int* arr, int arrSize, int* returnSize) {\\n  *returnSize = arrSize;\\n  int* result = malloc(sizeof(int) * arrSize);\\n  if (arrSize == 0)\\n    return result;\\n\\n  int values[arrSize], ranks[arrSize];\\n  memcpy(values, arr, sizeof(values));\\n  qsort(values, arrSize, sizeof(int), cmp);\\n\\n  ranks[0] = 1;\\n  for (int i = 1; i < arrSize; i++) {\\n    if (values[i] == values[i - 1]) {\\n      ranks[i] = ranks[i - 1];\\n    } else {\\n      ranks[i] = ranks[i - 1] + 1;\\n    }\\n  }\\n\\n  for (int i = 0; i < arrSize; i++) {\\n    int j = search(values, arrSize, arr[i]);\\n    result[i] = ranks[j];\\n  }\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802651,
                "title": "short-and-fast",
                "content": "```\\nvector<int> arrayRankTransform(vector<int>& a) \\n{\\n\\tvector<pair<int, int>> t(size(a));\\n\\tfor(auto i{0}; i<size(a); t[i] = {a[i], i}, ++i);\\n\\n\\tsort(begin(t), end(t));\\n\\n\\tvector<int> out(size(a), 1);\\n\\tfor(auto i{1}, c{1}; i<size(t); ++i)\\n\\t\\tout[t[i].second] = (c += t[i].first != t[i-1].first);\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& a) \\n{\\n\\tvector<pair<int, int>> t(size(a));\\n\\tfor(auto i{0}; i<size(a); t[i] = {a[i], i}, ++i);\\n\\n\\tsort(begin(t), end(t));\\n\\n\\tvector<int> out(size(a), 1);\\n\\tfor(auto i{1}, c{1}; i<size(t); ++i)\\n\\t\\tout[t[i].second] = (c += t[i].first != t[i-1].first);\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 757762,
                "title": "java-easy-to-understand-comments-video-explanation",
                "content": "Video Explanation: https://www.youtube.com/watch?v=F7O9fNeV_FM\\n\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        // Create copy array O(N) time and space\\n        int[] copyArr = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) copyArr[i] = arr[i];\\n        \\n        // Sort the copy array. O(nlogn) time complexity\\n        Arrays.sort(copyArr);\\n        \\n        // HashMap, key: number, value: rank\\n        // O(N) time to loop through. O(N) space to store all the numbers\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : copyArr) {\\n            if (!map.containsKey(num)) map.put(num, map.size() + 1);\\n        }\\n        \\n        // Use map to build rankings. O(N) time to loop through.\\n        for (int i = 0; i < arr.length; i++) arr[i] = map.get(arr[i]);\\n        \\n        return arr;\\n    }\\n}\\n\\n// Original Array: 40, 10, 20, 30\\n// Sorted Arr: 10, 20, 30, 40\\n// Map: {10, 1}, {20, 2}, {30, 3}, {40, 4}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        // Create copy array O(N) time and space\\n        int[] copyArr = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) copyArr[i] = arr[i];\\n        \\n        // Sort the copy array. O(nlogn) time complexity\\n        Arrays.sort(copyArr);\\n        \\n        // HashMap, key: number, value: rank\\n        // O(N) time to loop through. O(N) space to store all the numbers\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : copyArr) {\\n            if (!map.containsKey(num)) map.put(num, map.size() + 1);\\n        }\\n        \\n        // Use map to build rankings. O(N) time to loop through.\\n        for (int i = 0; i < arr.length; i++) arr[i] = map.get(arr[i]);\\n        \\n        return arr;\\n    }\\n}\\n\\n// Original Array: 40, 10, 20, 30\\n// Sorted Arr: 10, 20, 30, 40\\n// Map: {10, 1}, {20, 2}, {30, 3}, {40, 4}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757679,
                "title": "easy-to-understand-solution",
                "content": "I created a sorted copy of the arr and an hashMap, loop through the copy to track the ranks, check for it in the hashMap and assign it a rank if not present in the hashMap. \\nWent through the arr a second time to modify the elements with their ranks.\\n```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not arr:\\n            return []\\n\\t\\t\\t\\n        rank = 1\\n        hashMap = {}\\n        result = sorted(arr)\\n        for num in result:\\n            if num not in hashMap:\\n                hashMap[num] = rank\\n                rank += 1\\n            \\n        for idx, val in enumerate(arr):\\n            arr[idx] = hashMap[val]\\n\\t\\t\\t\\n        return arr\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not arr:\\n            return []\\n\\t\\t\\t\\n        rank = 1\\n        hashMap = {}\\n        result = sorted(arr)\\n        for num in result:\\n            if num not in hashMap:\\n                hashMap[num] = rank\\n                rank += 1\\n            \\n        for idx, val in enumerate(arr):\\n            arr[idx] = hashMap[val]\\n\\t\\t\\t\\n        return arr\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 701604,
                "title": "python-faster-than-90",
                "content": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        ranks = {v:k for k,v in enumerate(list(sorted(set(arr)))) }\\n        \\n        for i in range(len(arr)):\\n            arr[i] = ranks[arr[i]] + 1 \\n            \\n        return arr",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        ranks = {v:k for k,v in enumerate(list(sorted(set(arr)))) }",
                "codeTag": "Java"
            },
            {
                "id": 692146,
                "title": "another-2-line-javascript-solution",
                "content": "```javascript\\nconst arrayRankTransform = function (arr) {\\n  const ranks = Object.fromEntries([...new Set(arr)].sort((a, b) => a - b).map((n, i) => [n, i + 1]))\\n  return arr.map(n => ranks[n])\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst arrayRankTransform = function (arr) {\\n  const ranks = Object.fromEntries([...new Set(arr)].sort((a, b) => a - b).map((n, i) => [n, i + 1]))\\n  return arr.map(n => ranks[n])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665734,
                "title": "java-hashmap-soln-faster-than-95",
                "content": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        int[] rankMatrix = new int[arr.length];\\n        System.arraycopy(arr, 0, rankMatrix, 0, arr.length);\\n        Arrays.sort(rankMatrix);\\n            \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i : rankMatrix){\\n            if(!map.containsKey(i)){\\n                map.put(i, rank++);\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] = map.get(arr[i]);            \\n        }\\n        return arr; \\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        int[] rankMatrix = new int[arr.length];\\n        System.arraycopy(arr, 0, rankMatrix, 0, arr.length);\\n        Arrays.sort(rankMatrix);\\n            \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i : rankMatrix){\\n            if(!map.containsKey(i)){\\n                map.put(i, rank++);\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] = map.get(arr[i]);            \\n        }\\n        return arr; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 664243,
                "title": "javascript-o-n-log-n-solution-88-49-faster",
                "content": "Runtime: 232 ms, faster than 88.49% of JavaScript online submissions for Rank Transform of an Array.\\nMemory Usage: 62.9 MB, less than 100.00% of JavaScript online submissions for Rank Transform of an Array.\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let rankMap = {};\\n    //sort the array\\n    let temp = [...new Set(arr)].sort((a,b)=>a-b);\\n    for(let i=0;i<temp.length;i++)\\n        rankMap[temp[i]]=i+1;\\n    return arr.reduce((acc,cur)=>{\\n        acc.push(rankMap[cur]);\\n        return acc\\n    },[]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let rankMap = {};\\n    //sort the array\\n    let temp = [...new Set(arr)].sort((a,b)=>a-b);\\n    for(let i=0;i<temp.length;i++)\\n        rankMap[temp[i]]=i+1;\\n    return arr.reduce((acc,cur)=>{\\n        acc.push(rankMap[cur]);\\n        return acc\\n    },[]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621912,
                "title": "java-simple-solution-using-tree-set-and-hashmap",
                "content": "```\\n        int[] rankMatrix = new int[arr.length];\\n        Set<Integer> set = new TreeSet<>();\\n        for (int num : arr) {\\n            set.add(num);\\n        }\\n        int rank = 1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : set) {\\n            map.put(i, rank++);\\n        }\\n        int incr = 0;\\n        for (int i : arr) {\\n            rankMatrix[incr++] = map.get(i);\\n        }\\n        return rankMatrix;",
                "solutionTags": [],
                "code": "```\\n        int[] rankMatrix = new int[arr.length];\\n        Set<Integer> set = new TreeSet<>();\\n        for (int num : arr) {\\n            set.add(num);\\n        }\\n        int rank = 1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : set) {\\n            map.put(i, rank++);\\n        }\\n        int incr = 0;\\n        for (int i : arr) {\\n            rankMatrix[incr++] = map.get(i);\\n        }\\n        return rankMatrix;",
                "codeTag": "Unknown"
            },
            {
                "id": 540140,
                "title": "python-clean-code-hashmap",
                "content": "```\\n    def arrayRankTransform(self, arr):\\n\\n        tmp = sorted(set(arr))\\n        hashmap = {}\\n        rank = 1\\n        \\n        for each in tmp:\\n            hashmap[each] = rank\\n            rank += 1\\n\\n            \\n        return [ hashmap[each] for each in arr]\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def arrayRankTransform(self, arr):\\n\\n        tmp = sorted(set(arr))\\n        hashmap = {}\\n        rank = 1\\n        \\n        for each in tmp:\\n            hashmap[each] = rank\\n            rank += 1\\n\\n            \\n        return [ hashmap[each] for each in arr]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 523487,
                "title": "c-344-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int[] ArrayRankTransform(int[] arr)\\n        {\\n            if (arr == null)\\n            {\\n                return null;\\n            }\\n\\n            // eliminate duplicates\\n            var set = new HashSet<int>(arr);\\n\\n            // sort for rank\\n            var array = set.ToArray();\\n            Array.Sort(array);\\n            \\n            // rank dictionary\\n            var rank = new Dictionary<int, int>();\\n            for (int i = 0; i < array.Length; i++)\\n            {\\n                rank[array[i]] = i + 1;\\n            }\\n\\n            // look up the ranks\\n            var res = new int[arr.Length];\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                res[i] = rank[arr[i]];\\n            }\\n            return res;\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int[] ArrayRankTransform(int[] arr)\\n        {\\n            if (arr == null)\\n            {\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 503326,
                "title": "c-2-line-solution-binarysearch",
                "content": "```\\n    public int[] ArrayRankTransform(int[] arr)\\n    {\\n      var wk = arr.OrderBy(x => x).ToHashSet().ToList();\\n      return arr.Select(i => wk.BinarySearch(i) + 1).ToArray();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] ArrayRankTransform(int[] arr)\\n    {\\n      var wk = arr.OrderBy(x => x).ToHashSet().ToList();\\n      return arr.Select(i => wk.BinarySearch(i) + 1).ToArray();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501716,
                "title": "swift-hashmap-solution",
                "content": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var sArr = arr.sorted()\\n        var map:[Int:Int] = [:]\\n        for item in sArr{\\n            if map[item] == nil{ map[item] = map.count + 1 }\\n        }\\n        var res:[Int] = []\\n        for item in arr{\\n            res.append(map[item]!)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var sArr = arr.sorted()\\n        var map:[Int:Int] = [:]\\n        for item in sArr{\\n            if map[item] == nil{ map[item] = map.count + 1 }\\n        }\\n        var res:[Int] = []\\n        for item in arr{\\n            res.append(map[item]!)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499887,
                "title": "python-hashmap-93",
                "content": "Thank you guys for the help. cheers\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hash_map = {}\\n        copy_arr = sorted(set(arr))\\n        rank = 1\\n        \\n        for i in copy_arr:\\n            hash_map[i] = rank\\n            rank += 1\\n            \\n        re = []\\n        for i in arr:\\n            re.append(hash_map[i])\\n            \\n        return re\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hash_map = {}\\n        copy_arr = sorted(set(arr))\\n        rank = 1\\n        \\n        for i in copy_arr:\\n            hash_map[i] = rank\\n            rank += 1\\n            \\n        re = []\\n        for i in arr:\\n            re.append(hash_map[i])\\n            \\n        return re\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492324,
                "title": "javascript-solution",
                "content": "``` js\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let uniqArr = Array.from(new Set(arr));\\n    const hashTable = {};\\n    uniqArr.sort((x, y) => x > y ? 1 : x == y ? 0 : -1);\\n    uniqArr.forEach((x, idx) => {\\n        hashTable[x] = idx + 1;\\n    });\\n    \\n    return arr.map(x => hashTable[x]);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "``` js\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let uniqArr = Array.from(new Set(arr));\\n    const hashTable = {};\\n    uniqArr.sort((x, y) => x > y ? 1 : x == y ? 0 : -1);\\n    uniqArr.forEach((x, idx) => {\\n        hashTable[x] = idx + 1;\\n    });\\n    \\n    return arr.map(x => hashTable[x]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490705,
                "title": "java-commented-100-faster-sort-map",
                "content": "Sort the array for getting ranks.\\nMap the values to ranks.\\nRetrive the values for getting ranks in correct order.\\n\\n```java\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int len = arr.length;\\n        if(len == 0)    return new int[0];\\n        \\n        int[] sortedArr = arr.clone();\\n        \\n        Arrays.sort(sortedArr);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int[] rankList = new int[len];\\n        int rank = 1;\\n        map.put(sortedArr[0], rank);\\n    \\n\\t\\t//Map the values to ranks.\\n        for(int i = 1 ; i < len; i++)\\n            if(sortedArr[i] != sortedArr[i-1])\\n            {\\n                rank++;\\n                map.put(sortedArr[i], rank);\\n            }\\n\\n\\t\\t//Retrive the values for getting ranks in correct order.\\n        for(int i = 0 ; i < len; i++)\\n            rankList[i] = map.get(arr[i]);\\n\\n        return rankList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int len = arr.length;\\n        if(len == 0)    return new int[0];\\n        \\n        int[] sortedArr = arr.clone();\\n        \\n        Arrays.sort(sortedArr);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int[] rankList = new int[len];\\n        int rank = 1;\\n        map.put(sortedArr[0], rank);\\n    \\n\\t\\t//Map the values to ranks.\\n        for(int i = 1 ; i < len; i++)\\n            if(sortedArr[i] != sortedArr[i-1])\\n            {\\n                rank++;\\n                map.put(sortedArr[i], rank);\\n            }\\n\\n\\t\\t//Retrive the values for getting ranks in correct order.\\n        for(int i = 0 ; i < len; i++)\\n            rankList[i] = map.get(arr[i]);\\n\\n        return rankList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490395,
                "title": "c-map-for-sorted-unique-values-short-and-simple",
                "content": "Intuition: \\n - we need unique values sorted in ascending order\\n - for each value we need just one rank\\n\\nSo we keep positions for each value in a vector and we sort the values using a map. \\nThen go through values and step the rank when going to the next value.\\n\\n```\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,vector<int>> m; // value -> positions\\n        vector<int> res(arr.size());\\n        for(int i=0;i<arr.size();i++) m[arr[i]].push_back(i);\\n        int rank=1;\\n        for(auto& it:m) {\\n            for(int pos:it.second) {\\n                res[pos] = rank;\\n            }\\n            rank++;\\n        }\\n        return res;\\n    }\\n```\\nComplexity: memory O(N), speed O(NLogN) caused by inserting into the map",
                "solutionTags": [],
                "code": "```\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,vector<int>> m; // value -> positions\\n        vector<int> res(arr.size());\\n        for(int i=0;i<arr.size();i++) m[arr[i]].push_back(i);\\n        int rank=1;\\n        for(auto& it:m) {\\n            for(int pos:it.second) {\\n                res[pos] = rank;\\n            }\\n            rank++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490025,
                "title": "javascript-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    const sorted = arr.slice().sort((a, b) => a - b);\\n    const rank = {};\\n    for (let i = 0, r = 0; i < sorted.length; i += 1) {\\n        if (sorted[i] !== sorted[i - 1]) {\\n            r += 1;\\n            rank[sorted[i]] = r;\\n        }\\n    }\\n    \\n    return arr.map(v => rank[v]);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    const sorted = arr.slice().sort((a, b) => a - b);\\n    const rank = {};\\n    for (let i = 0, r = 0; i < sorted.length; i += 1) {\\n        if (sorted[i] !== sorted[i - 1]) {\\n            r += 1;\\n            rank[sorted[i]] = r;\\n        }\\n    }\\n    \\n    return arr.map(v => rank[v]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489709,
                "title": "cpp-map-one-of-the-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        sort(arr.begin(), arr.end());                  //sort original array\\n        int rank=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                m[arr[i]] = rank++;\\n            else if(arr[i]==arr[i-1])\\n                continue;\\n            else\\n                m[arr[i]] = rank++;                                  //store element and its rank in map\\n        }\\n        //cout<<n<<endl;\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n            res.push_back(m[v[i]]);                            //find rank of saved elements in v\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        sort(arr.begin(), arr.end());                  //sort original array\\n        int rank=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                m[arr[i]] = rank++;\\n            else if(arr[i]==arr[i-1])\\n                continue;\\n            else\\n                m[arr[i]] = rank++;                                  //store element and its rank in map\\n        }\\n        //cout<<n<<endl;\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n            res.push_back(m[v[i]]);                            //find rank of saved elements in v\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 489705,
                "title": "kotlin-simple-6-lines",
                "content": "```\\nfun arrayRankTransform(arr: IntArray): IntArray {\\n    var sorted = arr.copyOf().sortedArray()\\n    var map = mutableMapOf<Int, Int>()\\n    var rank = 1\\n    for(i in sorted.indices) if(i > 0 && sorted[i] > sorted[i-1]) map.put(sorted[i], ++rank) else map.put(sorted[i], rank)\\n    for(i in arr.indices) arr[i] = map.get(arr[i])!!\\n    return arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun arrayRankTransform(arr: IntArray): IntArray {\\n    var sorted = arr.copyOf().sortedArray()\\n    var map = mutableMapOf<Int, Int>()\\n    var rank = 1\\n    for(i in sorted.indices) if(i > 0 && sorted[i] > sorted[i-1]) map.put(sorted[i], ++rank) else map.put(sorted[i], rank)\\n    for(i in arr.indices) arr[i] = map.get(arr[i])!!\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842447,
                "title": "solution",
                "content": "# Intuition\\nstore the value with their index in vector\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     \\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int n=arr.size();\\n       if(arr.empty()){\\n            return {};\\n        }\\n        vector<pair<int,int>>temp;\\n        for(int i=0;i<n;i++){\\n            temp.push_back({arr[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        int rank=1;\\n        \\n        for(int i=0;i<n-1;i++){\\n             if(temp[i].first==temp[i+1].first){\\n                 arr[temp[i].second]=rank;\\n             }\\n             else{\\n                 arr[temp[i].second]=rank;\\n                  rank++;\\n             }\\n        }\\n        if(!temp.empty()){\\n            arr[temp.back().second]=rank;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n     \\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int n=arr.size();\\n       if(arr.empty()){\\n            return {};\\n        }\\n        vector<pair<int,int>>temp;\\n        for(int i=0;i<n;i++){\\n            temp.push_back({arr[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        int rank=1;\\n        \\n        for(int i=0;i<n-1;i++){\\n             if(temp[i].first==temp[i+1].first){\\n                 arr[temp[i].second]=rank;\\n             }\\n             else{\\n                 arr[temp[i].second]=rank;\\n                  rank++;\\n             }\\n        }\\n        if(!temp.empty()){\\n            arr[temp.back().second]=rank;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805417,
                "title": "c-beats-100-solution",
                "content": "# Intuition\\nmake a pair of vector copy all arr index with value and sort using custom operator \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nOverall, the dominant time complexity is O(N log N) due to the sorting step\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     struct compare {\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2) {\\n            return p1.first < p2.first;\\n        }\\n    };\\n\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.empty()){\\n            return {};\\n        }\\n      vector<pair<int,int>>arr1;\\n      for(int i =0;i<arr.size();i++){\\n          arr1.push_back(make_pair(arr[i],i));\\n      }\\n       sort(arr1.begin(), arr1.end(), compare());\\n      int rank =1 ;\\n      for(int i = 0 ;i<arr1.size()-1;i++){\\n          if(arr1[i].first!=arr1[i+1].first){\\n              arr[arr1[i].second]=rank;\\n              rank++;\\n          }else{\\n               arr[arr1[i].second]=rank;\\n          }\\n      }\\n       if (!arr1.empty()) {\\n            arr[arr1.back().second] = rank;\\n       }\\n      return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n     struct compare {\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2) {\\n            return p1.first < p2.first;\\n        }\\n    };\\n\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.empty()){\\n            return {};\\n        }\\n      vector<pair<int,int>>arr1;\\n      for(int i =0;i<arr.size();i++){\\n          arr1.push_back(make_pair(arr[i],i));\\n      }\\n       sort(arr1.begin(), arr1.end(), compare());\\n      int rank =1 ;\\n      for(int i = 0 ;i<arr1.size()-1;i++){\\n          if(arr1[i].first!=arr1[i+1].first){\\n              arr[arr1[i].second]=rank;\\n              rank++;\\n          }else{\\n               arr[arr1[i].second]=rank;\\n          }\\n      }\\n       if (!arr1.empty()) {\\n            arr[arr1.back().second] = rank;\\n       }\\n      return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748468,
                "title": "python-easy-solution-sorting-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn) \\nBecause of sorting\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        dic={}\\n        lis=list(set(arr))\\n        lis.sort()\\n        for i in range(len(lis)):\\n            dic[lis[i]]=i\\n        for i in range(len(arr)):\\n            arr[i]=(dic[arr[i]]+1)\\n        return arr        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        dic={}\\n        lis=list(set(arr))\\n        lis.sort()\\n        for i in range(len(lis)):\\n            dic[lis[i]]=i\\n        for i in range(len(arr)):\\n            arr[i]=(dic[arr[i]]+1)\\n        return arr        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649581,
                "title": "best-menthod",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int n = size(arr);\\n\\n        vector<int> ans = arr;\\n        sort(begin(ans), end(ans));\\n\\n        int rank=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mp.find(ans[i]) == mp.end()){\\n                mp[ans[i]] = rank;\\n                rank++;\\n            }\\n        }\\n\\n        ans.clear();\\n        for(auto i:arr)\\n        {\\n            ans.push_back(mp[i]);\\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/1ea84f20-4d96-4955-8fdb-c394300ce2ca_1687027269.8888555.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int n = size(arr);\\n\\n        vector<int> ans = arr;\\n        sort(begin(ans), end(ans));\\n\\n        int rank=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mp.find(ans[i]) == mp.end()){\\n                mp[ans[i]] = rank;\\n                rank++;\\n            }\\n        }\\n\\n        ans.clear();\\n        for(auto i:arr)\\n        {\\n            ans.push_back(mp[i]);\\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402210,
                "title": "java-hashmap-60-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer, Integer> hmap = new HashMap<>();\\n        int ans[] = new int[arr.length];\\n        ans = arr.clone();\\n        Arrays.sort(arr);\\n        int res[] = Arrays.stream(arr)\\n                                    .distinct()\\n                                    .toArray();\\n        for(int i=1;i<=res.length;i++)\\n            hmap.put(res[i-1], i);\\n        \\n        for(int i=0;i<ans.length;i++)\\n            ans[i] = hmap.get(ans[i]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer, Integer> hmap = new HashMap<>();\\n        int ans[] = new int[arr.length];\\n        ans = arr.clone();\\n        Arrays.sort(arr);\\n        int res[] = Arrays.stream(arr)\\n                                    .distinct()\\n                                    .toArray();\\n        for(int i=1;i<=res.length;i++)\\n            hmap.put(res[i-1], i);\\n        \\n        for(int i=0;i<ans.length;i++)\\n            ans[i] = hmap.get(ans[i]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329126,
                "title": "javascript-beats-100",
                "content": "# Intuition\\nBeats 100%\\n\\n# Approach\\noptimised apporach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arrr) {\\n    let map=new Map()\\n    let arr=[...arrr]\\n    arr.sort((a,b)=>a-b)\\n    let count=0\\n   for(let i=0;i<arr.length;i++){\\n      if(!map.has(arr[i])){\\n          count++\\n          map.set(arr[i],count)\\n      }\\n   }\\n    for(let i=0;i<arrr.length;i++){\\n        let newVar=map.get(arrr[i])\\n        arrr[i]=newVar\\n    }\\n    return arrr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arrr) {\\n    let map=new Map()\\n    let arr=[...arrr]\\n    arr.sort((a,b)=>a-b)\\n    let count=0\\n   for(let i=0;i<arr.length;i++){\\n      if(!map.has(arr[i])){\\n          count++\\n          map.set(arr[i],count)\\n      }\\n   }\\n    for(let i=0;i<arrr.length;i++){\\n        let newVar=map.get(arrr[i])\\n        arrr[i]=newVar\\n    }\\n    return arrr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233977,
                "title": "easy-python-code-for-beginners",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        copy = sorted(arr)\\n        ranks = {}\\n        rank = 1\\n        # storing the rank of every elements in hashtable ranks\\n        for n in copy:\\n            if n not in ranks:\\n                ranks[n] = rank\\n                rank += 1\\n                \\n        for i in range(len(arr)):\\n            arr[i] = ranks[arr[i]]\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        copy = sorted(arr)\\n        ranks = {}\\n        rank = 1\\n        # storing the rank of every elements in hashtable ranks\\n        for n in copy:\\n            if n not in ranks:\\n                ranks[n] = rank\\n                rank += 1\\n                \\n        for i in range(len(arr)):\\n            arr[i] = ranks[arr[i]]\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070230,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> minheap;\\n        for(int i=0;i<arr.size();i++){\\n            minheap.push(arr[i]);\\n        }\\n        unordered_map<int,int> ourmap;\\n        int rank=1;\\n        while(minheap.size()!=0){\\n            \\n            int data=minheap.top();\\n            minheap.pop();\\n            if(ourmap.find(data)==ourmap.end()){\\n                ourmap[data]=rank;\\n                rank++;\\n            }\\n        }\\n        int n=arr.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<arr.size();i++){\\n            ans[i]=ourmap[arr[i]];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> minheap;\\n        for(int i=0;i<arr.size();i++){\\n            minheap.push(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2940015,
                "title": "java-88-faster-hashmap-with-explanation",
                "content": "# Intuition\\nStore the unique numbers as key in a HashMap and add thier rank as values.[Key(40):Value(4)].\\n\\n# Approach\\n1. Create a HashMap\\n2. Make a copy of the original Array A = arr. Because we will sort the temp array A so that we can put it in a map easily by incrementing rank.\\n3. Put the number from array \"A\" in the HashMap if number is not present already and increment the value(rank) by 1. \\n4. Explanation: \\nWe are putting the numbers as key and rank as values because we can easily get the value from a map by using map.get().\\nThere is no such direct method available to get key of a map.\\n\\n5. Print map just to check how map stores key:value\\n6. Store the rank in our temp array \"A\" by fetching the rank from HashMap with the help of map.get(key) -> returns value(rank).\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) -> Arrays.sort takes (nlogn) time\\n\\n- Space complexity:\\nO(n) -> map takes O(n) spaces\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int A[] = Arrays.copyOf(arr, arr.length);\\n\\n        Arrays.sort(A);\\n\\n        for(Integer n : A){\\n            map.putIfAbsent(n,map.size()+1);\\n        }\\n\\n        System.out.println(map);\\n\\n        for(int i=0;i<arr.length;i++){\\n            A[i] = map.get(arr[i]);\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int A[] = Arrays.copyOf(arr, arr.length);\\n\\n        Arrays.sort(A);\\n\\n        for(Integer n : A){\\n            map.putIfAbsent(n,map.size()+1);\\n        }\\n\\n        System.out.println(map);\\n\\n        for(int i=0;i<arr.length;i++){\\n            A[i] = map.get(arr[i]);\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837994,
                "title": "1331-rank-transform-of-an-array-using-python-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        return [rank[i] for i in arr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        return [rank[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687632,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed Set for new unique and sorted array and binary search to find the position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n80%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n60% \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> arr2;\\n        set<int> st;\\n        for(auto i:arr){\\n            st.insert(i);\\n        }\\n        for(auto i:st){\\n            arr2.push_back(i);\\n        }\\n        vector<int> sol;\\n        for(auto i:arr){\\n            int s = 0,e=arr2.size()-1;\\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                if(arr2[mid]==i){\\n                    sol.push_back(mid+1);\\n                    break;\\n                }else if(arr2[mid]<i){\\n                    s = mid+1;\\n                }else{\\n                    e = mid-1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> arr2;\\n        set<int> st;\\n        for(auto i:arr){\\n            st.insert(i);\\n        }\\n        for(auto i:st){\\n            arr2.push_back(i);\\n        }\\n        vector<int> sol;\\n        for(auto i:arr){\\n            int s = 0,e=arr2.size()-1;\\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                if(arr2[mid]==i){\\n                    sol.push_back(mid+1);\\n                    break;\\n                }else if(arr2[mid]<i){\\n                    s = mid+1;\\n                }else{\\n                    e = mid-1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605058,
                "title": "java-solution-using-priority-queue-and-hashmap",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t\\t//USING PRIORITY QUEUE AND HASHMAP\\n\\t\\t\\tint n= arr.length;\\n\\t\\t\\tPriorityQueue<Integer> pq= new PriorityQueue<>();\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t   pq.add(arr[i]);\\n\\t\\t\\tHashMap<Integer,Integer> map= new HashMap<>();\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(!pq.isEmpty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val= pq.remove();\\n\\t\\t\\t\\tif(!map.containsKey(val))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmap.put(val,count);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tarr[i]=map.get(arr[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn arr;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t\\t//USING PRIORITY QUEUE AND HASHMAP\\n\\t\\t\\tint n= arr.length;\\n\\t\\t\\tPriorityQueue<Integer> pq= new PriorityQueue<>();\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t   pq.add(arr[i]);\\n\\t\\t\\tHashMap<Integer,Integer> map= new HashMap<>();\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(!pq.isEmpty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val= pq.remove();\\n\\t\\t\\t\\tif(!map.containsKey(val))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmap.put(val,count);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2597031,
                "title": "c-easy-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        //map\\n        int rank=1;               //to assign the rank to the elements\\n        map<int,vector<int>>mp;   //why map->to ensure the sorted nature of the elements\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int>v;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            v=it->second;   //this vector<int> will have basically all the index of the it->first\\n            int idx;\\n            for(int i=0;i<v.size();i++)\\n            {\\n                idx=v[i];\\n                arr[idx]=rank;\\n            }\\n            rank++;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        //map\\n        int rank=1;               //to assign the rank to the elements\\n        map<int,vector<int>>mp;   //why map->to ensure the sorted nature of the elements\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int>v;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            v=it->second;   //this vector<int> will have basically all the index of the it->first\\n            int idx;\\n            for(int i=0;i<v.size();i++)\\n            {\\n                idx=v[i];\\n                arr[idx]=rank;\\n            }\\n            rank++;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543530,
                "title": "c-easy-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        auto vec = arr;\\n        sort(vec.begin(), vec.end());\\n        unordered_map<int, int>mp;\\n        int rank = 1;\\n        for(int num : vec)\\n        {\\n            if(mp[num])\\n                continue;\\n            mp[num] = rank;      \\n            rank++;\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            arr[i] = mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        auto vec = arr;\\n        sort(vec.begin(), vec.end());\\n        unordered_map<int, int>mp;\\n        int rank = 1;\\n        for(int num : vec)\\n        {\\n            if(mp[num])\\n                continue;\\n            mp[num] = rank;      \\n            rank++;\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            arr[i] = mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439469,
                "title": "my-solution-java-using-hashmap",
                "content": "\\n\\t HashMap<Integer, Integer> res = new HashMap<Integer, Integer>();\\n        int[] blu = arr.clone();\\n        Arrays.sort(blu);\\n        \\n        if(arr.length == 0)\\n            return arr;\\n        \\n        int ble = 1;\\n        for(int i = 0; i < arr.length-1; i++){\\n            if(blu[i] == blu[i+1]){\\n                res.put(blu[i], ble);\\n                continue;\\n            }\\n            res.put(blu[i], ble);\\n            ble++;\\n        }\\n        res.put(blu[arr.length-1], ble);\\n\\n        int[] glu = new int[arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            glu[i] = res.get(arr[i]);\\n        }\\n        \\n        return glu;\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\t HashMap<Integer, Integer> res = new HashMap<Integer, Integer>();\\n        int[] blu = arr.clone();\\n        Arrays.sort(blu);\\n        \\n        if(arr.length == 0)\\n            return arr;\\n        \\n        int ble = 1;\\n        for(int i = 0; i < arr.length-1; i++){\\n            if(blu[i] == blu[i+1]){\\n                res.put(blu[i], ble);\\n                continue;\\n            }\\n            res.put(blu[i], ble);\\n            ble++;\\n        }\\n        res.put(blu[arr.length-1], ble);\\n\\n        int[] glu = new int[arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            glu[i] = res.get(arr[i]);\\n        }\\n        \\n        return glu;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2423829,
                "title": "c-simple-and-clean-implementation",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nvector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if(arr.size()==0)\\n            return arr;\\n        vector<int> copy = arr;\\n        sort(copy.begin(),copy.end());\\n        unordered_map<int,int> mp;\\n        int rank=0;\\n        for(int i=0;i<copy.size()-1;i++)\\n        {\\n            if(copy[i]!=copy[i+1])\\n            {\\n                rank++;\\n            }\\n            mp[copy[i]]=rank;\\n        }\\n        mp[copy[copy.size()-1]]=rank+1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if(arr.size()==0)\\n            return arr;\\n        vector<int> copy = arr;\\n        sort(copy.begin(),copy.end());\\n        unordered_map<int,int> mp;\\n        int rank=0;\\n        for(int i=0;i<copy.size()-1;i++)\\n        {\\n            if(copy[i]!=copy[i+1])\\n            {\\n                rank++;\\n            }\\n            mp[copy[i]]=rank;\\n        }\\n        mp[copy[copy.size()-1]]=rank+1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379360,
                "title": "python-3-lines-solution-o-n-log-n",
                "content": "```\\nfrom itertools import count\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank_dict = dict(zip(sorted(set(arr)), count(1)))  # mapping from element to rank\\n        return [rank_dict[e] for e in arr]",
                "solutionTags": [],
                "code": "```\\nfrom itertools import count\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank_dict = dict(zip(sorted(set(arr)), count(1)))  # mapping from element to rank\\n        return [rank_dict[e] for e in arr]",
                "codeTag": "Java"
            },
            {
                "id": 2374542,
                "title": "python-simplest-solution-o-nlog-n",
                "content": "```class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        new = sorted(arr)\\n        rank = {}\\n        score = 1\\n        for i in range(len(arr)):\\n            if not (new[i] in rank):\\n                rank[new[i]] = score\\n                score += 1\\n        new = []\\n        for i in range(len(arr)):\\n            new += [rank[arr[i]]]\\n        return new",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        new = sorted(arr)\\n        rank = {}",
                "codeTag": "Java"
            },
            {
                "id": 2314328,
                "title": "java-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        Map<Integer, List<Integer>> elememtsToIndicesMap = new TreeMap();\\n        \\n        for (int idx=0; idx < arr.length; idx++) {\\n            List<Integer> indices = elememtsToIndicesMap.getOrDefault(arr[idx], new ArrayList());\\n            indices.add(idx);\\n            elememtsToIndicesMap.put(arr[idx], indices);\\n        }\\n                \\n        int rank = 1;\\n        \\n        for (int key: elememtsToIndicesMap.keySet()) {\\n            for (int index: elememtsToIndicesMap.get(key)) {\\n                arr[index] = rank;\\n            }\\n            rank++;\\n        }\\n        \\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        Map<Integer, List<Integer>> elememtsToIndicesMap = new TreeMap();\\n        \\n        for (int idx=0; idx < arr.length; idx++) {\\n            List<Integer> indices = elememtsToIndicesMap.getOrDefault(arr[idx], new ArrayList());\\n            indices.add(idx);\\n            elememtsToIndicesMap.put(arr[idx], indices);\\n        }\\n                \\n        int rank = 1;\\n        \\n        for (int key: elememtsToIndicesMap.keySet()) {\\n            for (int index: elememtsToIndicesMap.get(key)) {\\n                arr[index] = rank;\\n            }\\n            rank++;\\n        }\\n        \\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287552,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        arrx = [i for i in set(arr)]\\n        arrx.sort()\\n        \\n        hp={}\\n        for i in range(len(arrx)):\\n            if arrx[i] in hp:\\n                continue\\n            else:\\n                hp[arrx[i]] = i+1 \\n                \\n        print(hp)        \\n        for j in range(len(arr)):\\n            arr[j] = hp[arr[j]]\\n            \\n        return arr\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        arrx = [i for i in set(arr)]\\n        arrx.sort()\\n        \\n        hp={}\\n        for i in range(len(arrx)):\\n            if arrx[i] in hp:\\n                continue\\n            else:\\n                hp[arrx[i]] = i+1 \\n                \\n        print(hp)        \\n        for j in range(len(arr)):\\n            arr[j] = hp[arr[j]]\\n            \\n        return arr\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102551,
                "title": "code-smells-python-solution-it-s-very-easy-to-use",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = dict(zip(sorted(set(arr)), [i + 1 for i in range(len(set(arr)))]))\\n        return [ranks[num] for num in arr]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = dict(zip(sorted(set(arr)), [i + 1 for i in range(len(set(arr)))]))\\n        return [ranks[num] for num in arr]",
                "codeTag": "Java"
            },
            {
                "id": 2066034,
                "title": "non-hashmap-solution-java",
                "content": "```\\npublic static int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        int[] rank = new int[arr.length];\\n        if(arr.length==0) return arr;\\n        Arrays.sort(temp);\\n        rank[0] = 1;\\n        for (int i = 1; i < rank.length; i++) {\\n            if(temp[i]==temp[i-1]){\\n                rank[i] = rank[i-1];\\n            }\\n            else{\\n                rank[i] = rank[i-1] + 1;\\n            }\\n        }\\n        for (int i = 0; i < rank.length; i++) {\\n            arr[i] = Arrays.binarySearch(temp, arr[i]);\\n            arr[i] = rank[arr[i]];\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        int[] rank = new int[arr.length];\\n        if(arr.length==0) return arr;\\n        Arrays.sort(temp);\\n        rank[0] = 1;\\n        for (int i = 1; i < rank.length; i++) {\\n            if(temp[i]==temp[i-1]){\\n                rank[i] = rank[i-1];\\n            }\\n            else{\\n                rank[i] = rank[i-1] + 1;\\n            }\\n        }\\n        for (int i = 0; i < rank.length; i++) {\\n            arr[i] = Arrays.binarySearch(temp, arr[i]);\\n            arr[i] = rank[arr[i]];\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989339,
                "title": "python-simple-maths",
                "content": "\\n    def arrayRankTransform(self, arr):\\n        new_arr, dict1, res = sorted(list(set(arr))), defaultdict(int), []\\n        \\n        for i, j in enumerate(new_arr):\\n            dict1[j] = i+1\\n            \\n        for i in arr:\\n            res += [dict1[i]]\\n            \\n        return res\\n",
                "solutionTags": [],
                "code": "\\n    def arrayRankTransform(self, arr):\\n        new_arr, dict1, res = sorted(list(set(arr))), defaultdict(int), []\\n        \\n        for i, j in enumerate(new_arr):\\n            dict1[j] = i+1\\n            \\n        for i in arr:\\n            res += [dict1[i]]\\n            \\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1985251,
                "title": "python-optimised-using-dict-and-set-simple-explaination",
                "content": "Logic is quite simple . Take a unique set, sort it and use position in sorted DS to define the result. \\n\\nHowever if we keep sorted result in a list it will be a problem and raise time complexity to O(n\\\\*\\\\*2). Which with the help of dict is brought back to (nLogn). \\n\\nPlease find the solution with complexity explaination as below.\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # Overall complexity is O(nlogn) which is due to sorting requirement\\n        \\n        # O(n)\\n        unique_list = list(set(arr))\\n        \\n        # O(nlogn)\\n        unique_list.sort()\\n        \\n        dicts = dict()\\n        \\n        # O(n)\\n        for i in range(len(unique_list)):\\n            dicts[unique_list[i]] = i+1\\n        \\n        result = [] \\n        \\n        #This is O(n)\\n        # Earlier in place of dict a list.index was being used making t = O(n**2)\\n        for ele in arr:\\n            result.append(dicts[ele])\\n            \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # Overall complexity is O(nlogn) which is due to sorting requirement\\n        \\n        # O(n)\\n        unique_list = list(set(arr))\\n        \\n        # O(nlogn)\\n        unique_list.sort()\\n        \\n        dicts = dict()\\n        \\n        # O(n)\\n        for i in range(len(unique_list)):\\n            dicts[unique_list[i]] = i+1\\n        \\n        result = [] \\n        \\n        #This is O(n)\\n        # Earlier in place of dict a list.index was being used making t = O(n**2)\\n        for ele in arr:\\n            result.append(dicts[ele])\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910048,
                "title": "c-priority-queue-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pq.push({-1*arr[i],i});\\n        }\\n        \\n        \\n        vector<int> ans(arr.size(),0);\\n        int i=1;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            \\n            ans[temp.second]=i;\\n            if(!pq.empty()){\\n                int ele=pq.top().first;\\n            if(temp.first!=ele)\\n            {\\n                i++;\\n            }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pq.push({-1*arr[i],i});\\n        }\\n        \\n        \\n        vector<int> ans(arr.size(),0);\\n        int i=1;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            \\n            ans[temp.second]=i;\\n            if(!pq.empty()){\\n                int ele=pq.top().first;\\n            if(temp.first!=ele)\\n            {\\n                i++;\\n            }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905432,
                "title": "python-easy-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ind = [x+1 for x in range(len(arr))]\\n        ranks = dict(zip(sorted(set(arr)), ind))\\n        res = []\\n        for i in arr:\\n            res.append(ranks[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ind = [x+1 for x in range(len(arr))]\\n        ranks = dict(zip(sorted(set(arr)), ind))\\n        res = []\\n        for i in arr:\\n            res.append(ranks[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1855002,
                "title": "c-easy-to-grab-using-map-93-faster-solution",
                "content": "\\t\\t unordered_map<int,int>mp;\\n        vector<int>v(arr);\\n        sort(v.begin(),v.end());\\n        int count=1;//initial rank\\n        for(int i=0;i<v.size();i++)\\n        {\\n           auto it=mp.find(v[i]);//maintaining same rank for duplicates\\n            if(it!=mp.end())\\n                continue;\\n            else\\n            {\\n                mp[v[i]]=count;\\n                count++;//increment in rank for another element\\n            }\\n        }\\n        v.clear();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            auto it=mp.find(arr[i]);\\n            v.push_back(it->second);\\n        }\\n        return v;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\t\\t unordered_map<int,int>mp;\\n        vector<int>v(arr);\\n        sort(v.begin(),v.end());\\n        int count=1;//initial rank\\n        for(int i=0;i<v.size();i++)\\n        {\\n           auto it=mp.find(v[i]);//maintaining same rank for duplicates\\n            if(it!=mp.end())\\n                continue;\\n            else\\n            {\\n                mp[v[i]]=count;\\n                count++;//increment in rank for another element\\n            }\\n        }\\n        v.clear();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            auto it=mp.find(arr[i]);\\n            v.push_back(it->second);\\n        }\\n        return v;",
                "codeTag": "Unknown"
            },
            {
                "id": 1771278,
                "title": "5-lines-c-easy-clean-explained",
                "content": "**C++ Solutions :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& a,int n=1) {\\n        set<int>s(begin(a),end(a));\\n        unordered_map<int,int>m;\\n        for(auto &i:s)m[i]=n++;\\n        for(auto &i:a)i=m[i];\\n        return a;\\n    }\\n};\\n```\\n**If you like / help this solutions , please upvote for my motivations ^</>^**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& a,int n=1) {\\n        set<int>s(begin(a),end(a));\\n        unordered_map<int,int>m;\\n        for(auto &i:s)m[i]=n++;\\n        for(auto &i:a)i=m[i];\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713877,
                "title": "javascript-easy-understanding",
                "content": "```\\nvar arrayRankTransform = function(arr) {\\n  let num=new Set(arr);\\n  let num1=[...num].sort((a,b)=>(a-b));\\n   let pos=[];\\n    for(i=0;i<arr.length;i++){\\n        pos.push(num1.indexOf(arr[i])+1)\\n    }\\n    return pos\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n  let num=new Set(arr);\\n  let num1=[...num].sort((a,b)=>(a-b));\\n   let pos=[];\\n    for(i=0;i<arr.length;i++){\\n        pos.push(num1.indexOf(arr[i])+1)\\n    }\\n    return pos\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1702731,
                "title": "c-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\treturn {};\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tv.push_back(arr[i]);\\n\\t\\t\\t}\\n\\t\\t\\tsort(v.begin(), v.end());\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tm[v[0]] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tif(v[i] == v[i-1]){\\n\\t\\t\\t\\t\\tm[v[i]] = m[v[i - 1]];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tm[v[i]] = m[v[i - 1]] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> res;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tres.push_back(m[arr[i]]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\treturn {}",
                "codeTag": "Java"
            },
            {
                "id": 1702321,
                "title": "c-using-maps",
                "content": "Given an array of integers our task is to assign rank to each integer based on size.\\n\\nSmaller than number, smaller the rank  \\nlarger the number, larger the rank\\nIf two numbers are same their rank should also be same.\\nRank starts from 1.\\nEg: [4, 7, 3, 8]\\no/p: [2, 3, 1, 4]\\n\\nIdea is to use map so that elements will be in the sorted order and it is easier to assign ranks that way.\\n\\n```\\nvector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        map<int,int>mp;\\n        for(auto x:arr) //push every elements of the array into the map\\n            mp[x]++;\\n        \\n        int rank=1;\\n        for(auto x:mp)\\n        {\\n            mp[x.first]=rank; //assign rank 1,2 and so on\\n            rank++;\\n        }\\n        \\n        for(int i=0;i<arr.size();i++) //Now copy back the ranks to the array\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n```\\nT.C-> O(N*LOGN) , Since in maps the sorting factor is involved in the background\\nS.C-> O(N)",
                "solutionTags": [],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        map<int,int>mp;\\n        for(auto x:arr) //push every elements of the array into the map\\n            mp[x]++;\\n        \\n        int rank=1;\\n        for(auto x:mp)\\n        {\\n            mp[x.first]=rank; //assign rank 1,2 and so on\\n            rank++;\\n        }\\n        \\n        for(int i=0;i<arr.size();i++) //Now copy back the ranks to the array\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699580,
                "title": "java-easy-solution-sort-map-rank-array",
                "content": "\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\n        int[] tmp = Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(tmp);\\n        HashMap<Integer,Integer> mp = new HashMap<Integer,Integer>();\\n        int i = 1;\\n        for(Integer x:tmp){\\n            if(!mp.containsKey(x)) mp.put(x,i++);\\n        }\\n        \\n        i=0;\\n        for(Integer x:arr){\\n            arr[i++] = mp.get(x);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\n        int[] tmp = Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(tmp);\\n        HashMap<Integer,Integer> mp = new HashMap<Integer,Integer>();\\n        int i = 1;\\n        for(Integer x:tmp){\\n            if(!mp.containsKey(x)) mp.put(x,i++);\\n        }\\n        \\n        i=0;\\n        for(Integer x:arr){\\n            arr[i++] = mp.get(x);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1681592,
                "title": "java-treemap-simple",
                "content": "**T/S:** O(n lg n)/O(n)\\n```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\tvar ranks = new int[arr.length];\\n\\tfindRanks(getIntLocations(arr), ranks);\\n\\treturn ranks;\\n}\\n\\nprivate TreeMap<Integer, List<Integer>> getIntLocations(int[] arr) {\\n\\tvar locationsByNum = new TreeMap<Integer, List<Integer>>();\\n\\tfor (var i = 0; i < arr.length; i++)\\n\\t\\tlocationsByNum.computeIfAbsent(arr[i], (k) -> new ArrayList<>()).add(i);\\n\\treturn locationsByNum;\\n}\\n\\nprivate void findRanks(Map<Integer, List<Integer>> locationsByNum, int[] ranks) {\\n\\tvar i = 1;\\n\\tfor (var key : locationsByNum.keySet()) {\\n\\t\\tfor (var j : locationsByNum.get(key))\\n\\t\\t\\tranks[j] = i;\\n\\t\\ti++;\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\tvar ranks = new int[arr.length];\\n\\tfindRanks(getIntLocations(arr), ranks);\\n\\treturn ranks;\\n}\\n\\nprivate TreeMap<Integer, List<Integer>> getIntLocations(int[] arr) {\\n\\tvar locationsByNum = new TreeMap<Integer, List<Integer>>();\\n\\tfor (var i = 0; i < arr.length; i++)\\n\\t\\tlocationsByNum.computeIfAbsent(arr[i], (k) -> new ArrayList<>()).add(i);\\n\\treturn locationsByNum;\\n}\\n\\nprivate void findRanks(Map<Integer, List<Integer>> locationsByNum, int[] ranks) {\\n\\tvar i = 1;\\n\\tfor (var key : locationsByNum.keySet()) {\\n\\t\\tfor (var j : locationsByNum.get(key))\\n\\t\\t\\tranks[j] = i;\\n\\t\\ti++;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679595,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int>mp;//so that arr element will be in sorted order\\n        for(auto k:arr)\\n            mp[k]++;\\n        int rank=0;\\n        for(auto k:mp){\\n            mp[k.first]=++rank;//map is in sorted order so 10->1,20->2 mapped like this\\n        }\\n        for(int i=0;i<arr.size();i++)\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int>mp;//so that arr element will be in sorted order\\n        for(auto k:arr)\\n            mp[k]++;\\n        int rank=0;\\n        for(auto k:mp){\\n            mp[k.first]=++rank;//map is in sorted order so 10->1,20->2 mapped like this\\n        }\\n        for(int i=0;i<arr.size();i++)\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643601,
                "title": "c-solution-using-map-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int, int>m;\\n\\n        for(auto ele: arr)\\n            m[ele]++;\\n        \\n        int rank = 0;\\n        for(auto it: m)\\n            m[it.first] = ++rank;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = m[arr[i]];\\n            \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int, int>m;\\n\\n        for(auto ele: arr)\\n            m[ele]++;\\n        \\n        int rank = 0;\\n        for(auto it: m)\\n            m[it.first] = ++rank;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = m[arr[i]];\\n            \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641155,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {num: i + 1 for i, num in enumerate(sorted(set(arr)))}\\n\\n        return [rank[num] for num in arr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {num: i + 1 for i, num in enumerate(sorted(set(arr)))}\\n\\n        return [rank[num] for num in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624577,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int temp[]=arr.clone();\\n        Arrays.sort(arr);\\n        int rank=1;\\n        for(int i:arr) if(!map.containsKey(i)) map.put(i,rank++);\\n        int result[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(temp[i]);\\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int temp[]=arr.clone();\\n        Arrays.sort(arr);\\n        int rank=1;\\n        for(int i:arr) if(!map.containsKey(i)) map.put(i,rank++);\\n        int result[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(temp[i]);\\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611031,
                "title": "java-solution-sorting-hashmap",
                "content": "Kindly upvote, if it helps you!\\n```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = Arrays.copyOf(arr, arr.length);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(temp);\\n        for(int i = 0; i< temp.length; i++){\\n            if(!map.containsKey(temp[i])){\\n                map.put(temp[i], map.size()+1);\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = Arrays.copyOf(arr, arr.length);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(temp);\\n        for(int i = 0; i< temp.length; i++){\\n            if(!map.containsKey(temp[i])){\\n                map.put(temp[i], map.size()+1);\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1580348,
                "title": "c-93-time-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            if(m.find(v[i])==m.end())\\n                m[v[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=m[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            if(m.find(v[i])==m.end())\\n                m[v[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=m[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522526,
                "title": "2-efficient-python-solutions",
                "content": "```\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        arr_sorted = sorted(list(set(arr)))\\n        hashmap = {}\\n        \\n        for i in range(0,len(arr_sorted)):\\n            hashmap[arr_sorted[i]] = i+1\\n            \\n        nums = []\\n        \\n        for j in range(0,len(arr)):\\n            nums.append(hashmap[arr[j]])\\n        \\n        return nums\\n\\n\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hashmap = {}\\n        nums = []\\n        \\n        for i in sorted(arr):\\n            if i not in hashmap:\\n                hashmap[i] = len(hashmap) + 1\\n                \\n        for j in arr:\\n            nums.append(hashmap[j])\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        arr_sorted = sorted(list(set(arr)))\\n        hashmap = {}\\n        \\n        for i in range(0,len(arr_sorted)):\\n            hashmap[arr_sorted[i]] = i+1\\n            \\n        nums = []\\n        \\n        for j in range(0,len(arr)):\\n            nums.append(hashmap[arr[j]])\\n        \\n        return nums\\n\\n\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hashmap = {}\\n        nums = []\\n        \\n        for i in sorted(arr):\\n            if i not in hashmap:\\n                hashmap[i] = len(hashmap) + 1\\n                \\n        for j in arr:\\n            nums.append(hashmap[j])\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448998,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i: arr)\\n            set.add(i);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int rank = 1;\\n        for(int i: set){\\n            hm.put(i, rank);\\n            rank++;\\n        }\\n        \\n        int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n          res[i] = hm.get(arr[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```\\n**OR**\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n         int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n            res[i] = arr[i];\\n        }\\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int rank = 1;\\n        for(int i: arr){\\n            if(!hm.containsKey(i)){\\n            hm.put(i, rank);\\n            rank++;\\n            }\\n        }\\n        \\n        for(int i=0; i<res.length; i++){\\n          res[i] = hm.get(res[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i: arr)\\n            set.add(i);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int rank = 1;\\n        for(int i: set){\\n            hm.put(i, rank);\\n            rank++;\\n        }\\n        \\n        int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n          res[i] = hm.get(arr[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n         int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n            res[i] = arr[i];\\n        }\\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int rank = 1;\\n        for(int i: arr){\\n            if(!hm.containsKey(i)){\\n            hm.put(i, rank);\\n            rank++;\\n            }\\n        }\\n        \\n        for(int i=0; i<res.length; i++){\\n          res[i] = hm.get(res[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437346,
                "title": "c-amazon-code-assessment-leetcode-premium-hashset-list-list-sort-api",
                "content": "Aug. 31, 2021\\n**Introduction**\\nI decided to subscribe Leetcode premium, so that I can quickly warmup some algorithms to prepare for online assessment. \\n\\n**Ranking**\\nIt is interesting to apply ranking in a given array, the idea is to put all elements in the array into a hashset, so that only unique values are stored, and then convert to a C# SortedSet, and then convert to a List, and then save a hashmap to find the index by looking up element value. \\n\\n```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null)\\n        {\\n            return arr;\\n        }\\n        \\n        var set = new HashSet<int>(arr);\\n        var sorted = new SortedSet<int>(set);\\n        \\n        var list = sorted.ToList();\\n        var map = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i);\\n        }\\n        \\n        var result = new int[arr.Length];\\n        \\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            result[i] = map[arr[i]] + 1;\\n        }\\n        \\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null)\\n        {\\n            return arr;\\n        }\\n        \\n        var set = new HashSet<int>(arr);\\n        var sorted = new SortedSet<int>(set);\\n        \\n        var list = sorted.ToList();\\n        var map = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i);\\n        }\\n        \\n        var result = new int[arr.Length];\\n        \\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            result[i] = map[arr[i]] + 1;\\n        }\\n        \\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420178,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {}\\n        answer = arr \\n        curr_rank = 1\\n        \\n        for n in sorted(arr):\\n            if n not in ranks:\\n                ranks[n] = curr_rank\\n                curr_rank += 1\\n                \\n        for i in range(len(arr)):\\n            answer[i] = ranks[arr[i]]\\n            \\n        return answer\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {}\\n        answer = arr \\n        curr_rank = 1\\n        \\n        for n in sorted(arr):\\n            if n not in ranks:\\n                ranks[n] = curr_rank\\n                curr_rank += 1\\n                \\n        for i in range(len(arr)):\\n            answer[i] = ranks[arr[i]]\\n            \\n        return answer\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1410118,
                "title": "simple-python-solution",
                "content": "```\\n        arrSorted = sorted(set(arr))\\n        ranks = [r for r in xrange(1,len(arrSorted)+1)]\\n        rankArrDict = {arr : rank for arr, rank in zip(arrSorted, ranks)}\\n        return [rankArrDict[val] for val in arr]\\n```",
                "solutionTags": [],
                "code": "```\\n        arrSorted = sorted(set(arr))\\n        ranks = [r for r in xrange(1,len(arrSorted)+1)]\\n        rankArrDict = {arr : rank for arr, rank in zip(arrSorted, ranks)}\\n        return [rankArrDict[val] for val in arr]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407904,
                "title": "23-ms-faster-than-89-60-of-java-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int[] newArr = new  int[arr.length];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            newArr[i]=arr[i];\\n        }\\n       Arrays.sort(newArr);\\n        \\n       HashMap<Integer,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0,k=0;i<newArr.length;i++){\\n             if( hmap.containsKey(newArr[i])){\\n                hmap.put(newArr[i],hmap.get(newArr[i]));\\n            }\\n           else {\\n               hmap.put(newArr[i],k);\\n               k++;\\n           }  \\n         }\\n         for(int i=0;i<arr.length;i++){\\n           arr[i]=hmap.get(arr[i])+1;\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int[] newArr = new  int[arr.length];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            newArr[i]=arr[i];\\n        }\\n       Arrays.sort(newArr);\\n        \\n       HashMap<Integer,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0,k=0;i<newArr.length;i++){\\n             if( hmap.containsKey(newArr[i])){\\n                hmap.put(newArr[i],hmap.get(newArr[i]));\\n            }\\n           else {\\n               hmap.put(newArr[i],k);\\n               k++;\\n           }  \\n         }\\n         for(int i=0;i<arr.length;i++){\\n           arr[i]=hmap.get(arr[i])+1;\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391509,
                "title": "python-simple-solution-rank-transform-of-an-array",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        if len(set(arr)) == 1:\\n            return [1]*len(arr)\\n        \\n        temp = copy.deepcopy(arr)\\n        temp.sort()\\n        \\n        d = {}\\n        rank = 0\\n        for i in range(len(temp)):\\n            if temp[i] not in d:\\n                rank = rank + 1\\n                d[temp[i]] = rank\\n                \\n        final = [0]*len(temp)\\n        \\n        for i in range(len(arr)):\\n            final[i] = d[arr[i]]\\n            \\n        return final",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        if len(set(arr)) == 1:\\n            return [1]*len(arr)\\n        \\n        temp = copy.deepcopy(arr)\\n        temp.sort()\\n        \\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1385504,
                "title": "javascript-o-nlogn",
                "content": "```\\nvar arrayRankTransform = function(arr) {\\n    const copy = arr.slice();\\n    copy.sort((a, b) => a-b);\\n    const map = {};\\n    let rank = 1;\\n    for (let i = 1; i < copy.length; i++) {\\n        map[copy[i-1]] = rank;\\n        rank = copy[i] > copy[i-1] ? rank + 1 : rank;\\n    }\\n    map[copy[copy.length-1]] = rank\\n    for (let i = 0; i < copy.length; i++) {\\n        arr[i] = map[arr[i]];\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n    const copy = arr.slice();\\n    copy.sort((a, b) => a-b);\\n    const map = {};\\n    let rank = 1;\\n    for (let i = 1; i < copy.length; i++) {\\n        map[copy[i-1]] = rank;\\n        rank = copy[i] > copy[i-1] ? rank + 1 : rank;\\n    }\\n    map[copy[copy.length-1]] = rank\\n    for (let i = 0; i < copy.length; i++) {\\n        arr[i] = map[arr[i]];\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275142,
                "title": "very-simple-python-faster-than-100-of-python-online-submissions",
                "content": "def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        a=list(sorted(set(arr)))\\n        p={}\\n        for i,j in enumerate(a):\\n            p[j]=i+1                        \\n        return [p[x] for x in arr]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        a=list(sorted(set(arr)))\\n        p={}\\n        for i,j in enumerate(a):\\n            p[j]=i+1                        \\n        return [p[x] for x in arr]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1240692,
                "title": "java-faster-than-99-hashmap-sorting",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        if(arr.length==0) return new int[0];\\n        int temp[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++) \\n            temp[i]=arr[i];\\n        Arrays.sort(temp); //10,20,30,40 \\n        int rank[]=new int[arr.length];\\n        Map<Integer,Integer> ranks=new HashMap<>();\\n        int r=1;\\n        for(int i=0;i<temp.length;i++){\\n            if(i-1>=0 && temp[i]!=temp[i-1])\\n                ranks.put(temp[i],r=r+1);\\n            else if(i-1>=0 && temp[i]==temp[i-1])\\n                ranks.put(temp[i],r);  \\n            else\\n                ranks.put(temp[i],r); // 10 -> 1\\n        }\\n        for(int i=0;i<arr.length;i++)\\n            rank[i]=ranks.get(arr[i]);\\n        return rank;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        if(arr.length==0) return new int[0];\\n        int temp[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++) \\n            temp[i]=arr[i];\\n        Arrays.sort(temp); //10,20,30,40 \\n        int rank[]=new int[arr.length];\\n        Map<Integer,Integer> ranks=new HashMap<>();\\n        int r=1;\\n        for(int i=0;i<temp.length;i++){\\n            if(i-1>=0 && temp[i]!=temp[i-1])\\n                ranks.put(temp[i],r=r+1);\\n            else if(i-1>=0 && temp[i]==temp[i-1])\\n                ranks.put(temp[i],r);  \\n            else\\n                ranks.put(temp[i],r); // 10 -> 1\\n        }\\n        for(int i=0;i<arr.length;i++)\\n            rank[i]=ranks.get(arr[i]);\\n        return rank;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222330,
                "title": "python3-nlogn-in-two-lines",
                "content": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = sorted(set(arr))\\n        return [bisect_left(ranks, x) + 1 for x in arr]\\n```",
                "solutionTags": [],
                "code": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = sorted(set(arr))\\n        return [bisect_left(ranks, x) + 1 for x in arr]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1216480,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        set<int>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        vector<int>vec;\\n        for(auto t : st)\\n        {\\n            vec.push_back(t);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int ind=lower_bound(vec.begin(),vec.end(),arr[i])-vec.begin();\\n            arr[i]=ind+1;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        set<int>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        vector<int>vec;\\n        for(auto t : st)\\n        {\\n            vec.push_back(t);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int ind=lower_bound(vec.begin(),vec.end(),arr[i])-vec.begin();\\n            arr[i]=ind+1;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212836,
                "title": "golang-solution-with-quick-walk-through",
                "content": "[1331. Rank Transform of an Array](https://leetcode.com/problems/rank-transform-of-an-array/)\\n\\nThe idea of this solution is to:\\n\\n* Copy `arr`.\\n* Then sort the copy\\n* Then loop through the copy and add all the values and indexes of the copy to a map called `m`.\\n* Then loop through `0` to `len(arr) - 1`, and make `arr[i] = m[arr[i]]`.\\n* Then return `arr`.\\n\\n``` go\\nfunc arrayRankTransform(arr []int) []int {\\n\\tg := make([]int, len(arr))\\n\\tm := make(map[int]int)\\n\\tcounter := 1\\n\\n\\tcopy(g, arr)\\n\\tsort.Ints(g)\\n\\n\\tfor i := range g {\\n\\t\\tif i >= 1 && g[i] == g[i-1] {\\n\\t\\t\\tcounter -= 1\\n\\t\\t}\\n\\t\\tm[g[i]] = counter\\n\\t\\tcounter++\\n\\t}\\n\\n\\tfor i := range arr {\\n\\t\\tarr[i] = m[arr[i]]\\n\\t}\\n\\n\\treturn arr\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc arrayRankTransform(arr []int) []int {\\n\\tg := make([]int, len(arr))\\n\\tm := make(map[int]int)\\n\\tcounter := 1\\n\\n\\tcopy(g, arr)\\n\\tsort.Ints(g)\\n\\n\\tfor i := range g {\\n\\t\\tif i >= 1 && g[i] == g[i-1] {\\n\\t\\t\\tcounter -= 1\\n\\t\\t}\\n\\t\\tm[g[i]] = counter\\n\\t\\tcounter++\\n\\t}\\n\\n\\tfor i := range arr {\\n\\t\\tarr[i] = m[arr[i]]\\n\\t}\\n\\n\\treturn arr\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187867,
                "title": "80ms-c-solution-using-maps-beats-82-19-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> original=arr;\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int,int> m;\\n        \\n        int rank=1;\\n        m[arr[0]]=rank;\\n        if(arr.size()>1){\\n          for(int i=1;i<arr.size();i++){\\n            if(arr[i]==arr[i-1]){\\n                m[arr[i]]=m[arr[i-1]];\\n            }else{\\n                rank+=1;\\n                m[arr[i]]=rank;\\n            }\\n        }  \\n        }\\n        \\n        vector<int> res;\\n        for(auto x:original){\\n            res.push_back(m[x]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> original=arr;\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int,int> m;\\n        \\n        int rank=1;\\n        m[arr[0]]=rank;\\n        if(arr.size()>1){\\n          for(int i=1;i<arr.size();i++){\\n            if(arr[i]==arr[i-1]){\\n                m[arr[i]]=m[arr[i-1]];\\n            }else{\\n                rank+=1;\\n                m[arr[i]]=rank;\\n            }\\n        }  \\n        }\\n        \\n        vector<int> res;\\n        for(auto x:original){\\n            res.push_back(m[x]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140757,
                "title": "c-128ms-35-hashset-and-hashmap",
                "content": "Runtime: 128 ms, faster than 35.43% of C++ online submissions for Rank Transform of an Array.\\nMemory Usage: 46.2 MB, less than 17.86% of C++ online submissions for Rank Transform of an Array.\\n```\\nclass Solution {\\npublic:\\n  vector<int> arrayRankTransform(vector<int>& arr) {\\n    set<int>st(arr.begin(),arr.end());\\n    unordered_map<int,int> mp;\\n    int i = 0;\\n    \\n    for(auto &t : st) mp[t] = ++i;\\n    \\n    vector<int> answer(arr.size());\\n    for(i = 0 ; i != arr.size(); i++)\\n      answer[i] = mp[arr[i]];\\n    \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> arrayRankTransform(vector<int>& arr) {\\n    set<int>st(arr.begin(),arr.end());\\n    unordered_map<int,int> mp;\\n    int i = 0;\\n    \\n    for(auto &t : st) mp[t] = ++i;\\n    \\n    vector<int> answer(arr.size());\\n    for(i = 0 ; i != arr.size(); i++)\\n      answer[i] = mp[arr[i]];\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102554,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\t\\tunordered_map <int,int> m;\\n\\t\\t\\t\\tvector<int> temp = arr;\\n\\t\\t\\t\\tint rank = 1;\\n\\t\\t\\t\\tsort(temp.begin(),temp.end());\\n\\t\\t\\t\\tfor(int i = 0; i < temp.size();i++){\\n\\t\\t\\t\\t\\tif(m.find(temp[i]) == m.end()) {\\n\\t\\t\\t\\t\\t\\tm[temp[i]] = rank;\\n\\t\\t\\t\\t\\t\\trank++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto &val:arr){\\n\\t\\t\\t\\t\\tval = m[val];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn arr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\t\\tunordered_map <int,int> m;\\n\\t\\t\\t\\tvector<int> temp = arr;\\n\\t\\t\\t\\tint rank = 1;\\n\\t\\t\\t\\tsort(temp.begin(),temp.end());\\n\\t\\t\\t\\tfor(int i = 0; i < temp.size();i++){\\n\\t\\t\\t\\t\\tif(m.find(temp[i]) == m.end()) {\\n\\t\\t\\t\\t\\t\\tm[temp[i]] = rank;\\n\\t\\t\\t\\t\\t\\trank++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1081958,
                "title": "python-4-lines-solution-98",
                "content": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        s = sorted(set(arr)) # to map 1,2, ..., N to array elements, we get sorted version of arr\\n        s = dict(zip(s, range(1,len(s)+1))) # now we have the rankings \\n        for i, val in enumerate(arr): # we can replace now.\\n            arr[i] = s[val]\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        s = sorted(set(arr)) # to map 1,2, ..., N to array elements, we get sorted version of arr\\n        s = dict(zip(s, range(1,len(s)+1))) # now we have the rankings \\n        for i, val in enumerate(arr): # we can replace now.\\n            arr[i] = s[val]\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1072073,
                "title": "c-sorting-distinct-values-2-18-2021",
                "content": "Feb. 18, 2021\\nThe idea is simple. First put all numbers in the array to a hashset, so all distinct values are saved. Next convert the hashset to a list, sort them in ascending order. Save all values and the order in a C# hashmap. Last, it is easy to figure out each number\\'s ranking based on C# hashmap. \\n\\n```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null || arr.Length == 0)\\n            return new int[0];\\n        \\n        var set = new HashSet<int>(arr);\\n        \\n        var list = set.ToList(); \\n        list.Sort(); \\n        var map = new Dictionary<int, int>(); \\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i + 1); \\n        }\\n        \\n        var length = arr.Length; \\n        var smallest = new int[length];\\n        for(int i = 0; i < length; i++)\\n        {\\n            smallest[i] = map[arr[i]];\\n        }\\n        \\n        return smallest; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null || arr.Length == 0)\\n            return new int[0];\\n        \\n        var set = new HashSet<int>(arr);\\n        \\n        var list = set.ToList(); \\n        list.Sort(); \\n        var map = new Dictionary<int, int>(); \\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i + 1); \\n        }\\n        \\n        var length = arr.Length; \\n        var smallest = new int[length];\\n        for(int i = 0; i < length; i++)\\n        {\\n            smallest[i] = map[arr[i]];\\n        }\\n        \\n        return smallest; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971879,
                "title": "javascript-solution-with-explanation-using-sort-indexof-and-set",
                "content": "```\\nvar arrayRankTransform = function(arr) {\\n\\t//make a set of arr to remove duplicate\\n    var set = new Set(arr)\\n\\t//convert the set to new array\\n    let array = Array.from(set);\\n    //sort the array in ascending order\\n\\tvar sorted = [...array].sort((a,b) => a-b)\\n    var rank = []\\n    for(var i = 0; i < arr.length; i++){\\n\\t\\t//assign the rank or current arr element according to index position of the sorted arr\\n        rank[i] = sorted.indexOf(arr[i]) + 1\\n    }\\n    return rank\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n\\t//make a set of arr to remove duplicate\\n    var set = new Set(arr)\\n\\t//convert the set to new array\\n    let array = Array.from(set);\\n    //sort the array in ascending order\\n\\tvar sorted = [...array].sort((a,b) => a-b)\\n    var rank = []\\n    for(var i = 0; i < arr.length; i++){\\n\\t\\t//assign the rank or current arr element according to index position of the sorted arr\\n        rank[i] = sorted.indexOf(arr[i]) + 1\\n    }\\n    return rank\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 962112,
                "title": "python-91-28-time-88-space",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        rank = {}\\n        start = 1\\n        \\n        for each in sorted(arr):\\n            if each in rank:\\n                continue\\n            else:\\n                rank[each] = start\\n                start += 1\\n            \\n        return [rank[each] for each in arr]\\n        \\n        \\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def arrayRankTransform(self, arr):\\n        rank = {}",
                "codeTag": "Java"
            },
            {
                "id": 924345,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var dictionary = [Int : Int]()\\n        for case let element in arr {\\n            if let value = dictionary[element] {\\n                dictionary[element] = value + 1 \\n            } else {\\n                dictionary[element] = 1 \\n            }\\n        }\\n        var rankArray = dictionary.keys.sorted()\\n        var rankDict = [Int : Int]()\\n        var index = 0 \\n        while index < rankArray.count {\\n            rankDict[rankArray[index]] = index + 1\\n            index += 1\\n        }\\n        var result = [Int]()\\n        for case let element in arr {\\n            result.append(rankDict[element] ?? 1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var dictionary = [Int : Int]()\\n        for case let element in arr {\\n            if let value = dictionary[element] {\\n                dictionary[element] = value + 1 \\n            } else {\\n                dictionary[element] = 1 \\n            }\\n        }\\n        var rankArray = dictionary.keys.sorted()\\n        var rankDict = [Int : Int]()\\n        var index = 0 \\n        while index < rankArray.count {\\n            rankDict[rankArray[index]] = index + 1\\n            index += 1\\n        }\\n        var result = [Int]()\\n        for case let element in arr {\\n            result.append(rankDict[element] ?? 1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891107,
                "title": "simple-fast-python-solution-using-set-and-dictionary",
                "content": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        srt = {}\\n        for i, val in enumerate(sorted(list(set(arr)))):\\n            srt[val] = i + 1\\n        return [srt[x] for x in arr]\\n```",
                "solutionTags": [],
                "code": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        srt = {}\\n        for i, val in enumerate(sorted(list(set(arr)))):\\n            srt[val] = i + 1\\n        return [srt[x] for x in arr]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 885943,
                "title": "python-binary-search-solution-using-bisect",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        temp = sorted(set(arr))\\n        op = []\\n        for n in arr:\\n            idx = bisect_left(temp, n)\\n            op.append(idx + 1)\\n        return op\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        temp = sorted(set(arr))\\n        op = []\\n        for n in arr:\\n            idx = bisect_left(temp, n)\\n            op.append(idx + 1)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872458,
                "title": "c-sort-unorderedmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if (arr.size() == 0) {\\n            return arr;\\n        }\\n        vector<int> arrUnsorted = arr;\\n        sort(arr.begin(), arr.end());\\n        int rank = 1;\\n        unordered_map<int, int> numRankMap;\\n        numRankMap[arr[0]] = rank;\\n        for (int i = 1; i < arr.size(); i++) {\\n            if (arr[i] != arr[i - 1]) {\\n                rank++;\\n            }\\n            numRankMap[arr[i]] = rank;\\n        }\\n        for (int i = 0; i < arrUnsorted.size(); i++) {\\n            arrUnsorted[i] = numRankMap[arrUnsorted[i]];\\n        }\\n        return arrUnsorted;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if (arr.size() == 0) {\\n            return arr;\\n        }\\n        vector<int> arrUnsorted = arr;\\n        sort(arr.begin(), arr.end());\\n        int rank = 1;\\n        unordered_map<int, int> numRankMap;\\n        numRankMap[arr[0]] = rank;\\n        for (int i = 1; i < arr.size(); i++) {\\n            if (arr[i] != arr[i - 1]) {\\n                rank++;\\n            }\\n            numRankMap[arr[i]] = rank;\\n        }\\n        for (int i = 0; i < arrUnsorted.size(); i++) {\\n            arrUnsorted[i] = numRankMap[arrUnsorted[i]];\\n        }\\n        return arrUnsorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872266,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> v;\\n        set<int> s;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        vector<int> z=arr;\\n        map<int,int> m;\\n        int k=1;\\n        for(auto it=s.begin();it!=s.end();++it){\\n            m.insert({(*it),k++});\\n        }\\n        \\n        for(int i=0;i<z.size();i++){\\n        cout<<m[z[i]];\\n            v.push_back(m[z[i]]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> v;\\n        set<int> s;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        vector<int> z=arr;\\n        map<int,int> m;\\n        int k=1;\\n        for(auto it=s.begin();it!=s.end();++it){\\n            m.insert({(*it),k++});\\n        }\\n        \\n        for(int i=0;i<z.size();i++){\\n        cout<<m[z[i]];\\n            v.push_back(m[z[i]]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1793538,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1792498,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963663,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574054,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573906,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2068086,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1977020,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963672,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1934717,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1930197,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793538,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1792498,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963663,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574054,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573906,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2068086,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1977020,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963672,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1934717,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1930197,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "🟢 could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]