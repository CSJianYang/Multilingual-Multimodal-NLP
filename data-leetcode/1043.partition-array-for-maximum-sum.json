[
    {
        "title": "Partition Array for Maximum Sum",
        "question_content": "Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\nReturn the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.\n&nbsp;\nExample 1:\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\nExample 2:\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\nExample 3:\nInput: arr = [1], k = 1\nOutput: 1\n&nbsp;\nConstraints:\n\t1 <= arr.length <= 500\n\t0 <= arr[i] <= 109\n\t1 <= k <= arr.length",
        "solutions": [
            {
                "id": 290863,
                "title": "java-c-python-dp-o-k-space",
                "content": "# **Explanation**\\n\\n`dp[i]` record the maximum sum we can get considering `A[0] ~ A[i-1]`\\nTo get `dp[i]`, we will try to change `k` last numbers separately to the maximum of them,\\nwhere `k = 1` to `k = K`.\\n\\n# **Solution 1, O(N) space**\\nTime `O(NK)`\\nSpace `O(N)`\\n\\n**Java:**\\n```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N + 1];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best;\\n        }\\n        return dp[N];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best; \\n        }\\n        return dp[N];\\n    }\\n```\\n**Python:**\\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * (N + 1)\\n        for i in xrange(1, N + 1):\\n            curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\\n        return dp[N]\\n```\\n\\n# **Solution 2, O(K) space**\\nTime `O(NK)`\\nSpace `O(K)`\\n\\n**Java:**\\n```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[K];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best;\\n        }\\n        return dp[N % K];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(K);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best; \\n        }\\n        return dp[N % K];\\n    }\\n```\\n**Python:**\\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * K\\n        for i in xrange(1, N + 1):\\n            best = curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                best = max(best, dp[(i - k) % K] + curMax * k)\\n            dp[i % K] = best\\n        return dp[N % K]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N + 1];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best;\\n        }\\n        return dp[N];\\n    }\\n```\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best; \\n        }\\n        return dp[N];\\n    }\\n```\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * (N + 1)\\n        for i in xrange(1, N + 1):\\n            curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\\n        return dp[N]\\n```\n```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[K];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best;\\n        }\\n        return dp[N % K];\\n    }\\n```\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(K);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best; \\n        }\\n        return dp[N % K];\\n    }\\n```\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * K\\n        for i in xrange(1, N + 1):\\n            best = curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                best = max(best, dp[(i - k) % K] + curMax * k)\\n            dp[i % K] = best\\n        return dp[N % K]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 291057,
                "title": "java-visualize-the-pattern",
                "content": "Code is same as others, but I found a way to visualize the pattern. Alfter all, the goal is to derive the rule.\\n\\n```java\\nclass Solution {\\n    // Let k be 2\\n    // Focus on \"growth\" of the pattern\\n    // Define A\\' to be a partition over A that gives max sum\\n    \\n    // #0\\n    // A = {1}\\n    // A\\'= {1} => 1\\n    \\n    // #1\\n    // A = {1, 2}\\n    // A\\'= {1}{2} => 1 + 2 => 3 X\\n    // A\\'= {1, 2} => {2, 2} => 4 AC\\n        \\n    // #2\\n    // A = {1, 2, 9}\\n    // A\\'= {1, 2}{9} => {2, 2}{9} => 4 + 9 => 13 X\\n    // A\\'= {1}{2, 9} => {1}{9, 9} => 1 + 18 => 19 AC\\n    \\n    // #3\\n    // A = {1, 2, 9, 30}\\n    // A\\'= {1}{2, 9}{30} => {1}{9, 9}{30} => 19 + 30 => 49 X\\n    // A\\'= {1, 2}{9, 30} => {2, 2}{30, 30} => 4 + 60 => 64 AC\\n    \\n    // Now, label each instance. Use F1() to represent how A is partitioned and use F2() to represent\\n    // the AC value of that partition. F2() is the dp relation we are looking for.\\n    \\n    // #4\\n    // A = {1, 2, 9, 30, 5}\\n    // A\\'= F1(#3){5} => F2(#3) + 5 => 69 X\\n    // A\\'= F1(#2){30, 5} => F2(#2) + 30 + 30 => 79 AC\\n    // => F2(#4) = 79\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N];\\n        for (int i = 0; i < N; ++i) {\\n            int curMax = 0;\\n            for (int k = 1; k <= K && i - k + 1 >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k + 1]);\\n                dp[i] = Math.max(dp[i], (i >= k ? dp[i - k] : 0) + curMax * k);\\n            }\\n        }\\n        return dp[N - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // Let k be 2\\n    // Focus on \"growth\" of the pattern\\n    // Define A\\' to be a partition over A that gives max sum\\n    \\n    // #0\\n    // A = {1}\\n    // A\\'= {1} => 1\\n    \\n    // #1\\n    // A = {1, 2}\\n    // A\\'= {1}{2} => 1 + 2 => 3 X\\n    // A\\'= {1, 2} => {2, 2} => 4 AC\\n        \\n    // #2\\n    // A = {1, 2, 9}\\n    // A\\'= {1, 2}{9} => {2, 2}{9} => 4 + 9 => 13 X\\n    // A\\'= {1}{2, 9} => {1}{9, 9} => 1 + 18 => 19 AC\\n    \\n    // #3\\n    // A = {1, 2, 9, 30}\\n    // A\\'= {1}{2, 9}{30} => {1}{9, 9}{30} => 19 + 30 => 49 X\\n    // A\\'= {1, 2}{9, 30} => {2, 2}{30, 30} => 4 + 60 => 64 AC\\n    \\n    // Now, label each instance. Use F1() to represent how A is partitioned and use F2() to represent\\n    // the AC value of that partition. F2() is the dp relation we are looking for.\\n    \\n    // #4\\n    // A = {1, 2, 9, 30, 5}\\n    // A\\'= F1(#3){5} => F2(#3) + 5 => 69 X\\n    // A\\'= F1(#2){30, 5} => F2(#2) + 30 + 30 => 79 AC\\n    // => F2(#4) = 79\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N];\\n        for (int i = 0; i < N; ++i) {\\n            int curMax = 0;\\n            for (int k = 1; k <= K && i - k + 1 >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k + 1]);\\n                dp[i] = Math.max(dp[i], (i >= k ? dp[i - k] : 0) + curMax * k);\\n            }\\n        }\\n        return dp[N - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299443,
                "title": "java-o-nk-faster-than-99-82-less-memory-than-100-with-explanation",
                "content": "The dynamic programming solution works here because the problem has an optimal substructure and overlapping subproblems as in the following example:\\n\\nLet `A = [9, 10, 2, 5]` and `K = 3`\\n\\nLet `S[n1, n2, ..., ni]` be the solution to subarray `[n1, n2, ..., ni]`.\\nThe following are base cases to initialize the memo array:\\n```\\nS[9] = 9 (i.e., memo[0] = 9)\\nS[9, 10] = 20 (i.e., memo[1] = 20)\\nS[9, 10, 2] = 30 (i.e., memo[2] = 30)\\n```\\n\\nHere we do the real work, where you need to \"loop\" through a K-sized window before the new value to be considered, including the new value, which in this case the new value is 5:\\n```\\nS[9, 10, 2, 5] = max(S[9] + S[10, 2, 5], S[9, 10] + S[2, 5], S[9, 10, 2] + S[5]) = 39\\n```\\nThe window we \"looped\" through above is [10, 2, 5].\\n\\nFrom the formula above, we see that the overlapping subproblem is in using the solutions from previous solutions stored in the memo, e.g., `S[9]`, `S[9, 10]`, and `S[9, 10, 2]`. The optimal substructure comes from the fact that the solution to `S[9, 10, 2, 5]` is solved by using solutions to previously calculated solutions.\\n\\n```\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] memo = new int[A.length];\\n        memo[0] = A[0];\\n        int initMax = A[0];\\n\\n        for(int i = 1; i < K; ++i) {\\n            if (A[i] > initMax) {\\n                initMax = A[i];\\n            }\\n            memo[i] = (i+1) * initMax;\\n        }\\n\\n        for (int i = K; i < A.length; ++i) {\\n            int cur = 0;\\n            int kIntervalMax = A[i];\\n\\t\\t\\t// Backtrack up to K-1 indices to calculate current maximum for memo[i].\\n            for (int j = 1; j <= K; ++j) {\\n\\t\\t\\t    // Keep track of the current maximum in the window [i-j+1, i].\\n                if (A[i-j+1] > kIntervalMax) {\\n                    kIntervalMax = A[i-j+1];\\n                }\\n\\t\\t\\t\\t// cur is the candidate for the solution to memo[i] as we backtrack the K-1 window.\\n                cur = memo[i-j] + j * kIntervalMax;\\n\\n                if (cur > memo[i]) {\\n                    memo[i] = cur;\\n                }\\n            }\\n        }\\n        return memo[A.length-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nS[9] = 9 (i.e., memo[0] = 9)\\nS[9, 10] = 20 (i.e., memo[1] = 20)\\nS[9, 10, 2] = 30 (i.e., memo[2] = 30)\\n```\n```\\nS[9, 10, 2, 5] = max(S[9] + S[10, 2, 5], S[9, 10] + S[2, 5], S[9, 10, 2] + S[5]) = 39\\n```\n```\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] memo = new int[A.length];\\n        memo[0] = A[0];\\n        int initMax = A[0];\\n\\n        for(int i = 1; i < K; ++i) {\\n            if (A[i] > initMax) {\\n                initMax = A[i];\\n            }\\n            memo[i] = (i+1) * initMax;\\n        }\\n\\n        for (int i = K; i < A.length; ++i) {\\n            int cur = 0;\\n            int kIntervalMax = A[i];\\n\\t\\t\\t// Backtrack up to K-1 indices to calculate current maximum for memo[i].\\n            for (int j = 1; j <= K; ++j) {\\n\\t\\t\\t    // Keep track of the current maximum in the window [i-j+1, i].\\n                if (A[i-j+1] > kIntervalMax) {\\n                    kIntervalMax = A[i-j+1];\\n                }\\n\\t\\t\\t\\t// cur is the candidate for the solution to memo[i] as we backtrack the K-1 window.\\n                cur = memo[i-j] + j * kIntervalMax;\\n\\n                if (cur > memo[i]) {\\n                    memo[i] = cur;\\n                }\\n            }\\n        }\\n        return memo[A.length-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370807,
                "title": "dfs-solution-using-memoization-super-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int dfs(int[] A, int K, int start, int[] dp) {\\n        int n = A.length;\\n        if (start >= n) return 0;\\n        if (dp[start] != 0) {\\n            return dp[start];\\n        }\\n        int maxSum = 0, maxEle = 0;\\n        for (int i = start; i < Math.min(n, start + K); i++) {\\n            maxEle = Math.max(maxEle, A[i]);\\n            maxSum = Math.max(maxSum, maxEle * (i - start + 1) + dfs(A, K, i + 1, dp));\\n        }\\n        dp[start] = maxSum;\\n        return maxSum;\\n    }\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length;\\n        int[] dp = new int[n];\\n        return dfs(A, K, 0, dp);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int dfs(int[] A, int K, int start, int[] dp) {\\n        int n = A.length;\\n        if (start >= n) return 0;\\n        if (dp[start] != 0) {\\n            return dp[start];\\n        }\\n        int maxSum = 0, maxEle = 0;\\n        for (int i = start; i < Math.min(n, start + K); i++) {\\n            maxEle = Math.max(maxEle, A[i]);\\n            maxSum = Math.max(maxSum, maxEle * (i - start + 1) + dfs(A, K, i + 1, dp));\\n        }\\n        dp[start] = maxSum;\\n        return maxSum;\\n    }\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length;\\n        int[] dp = new int[n];\\n        return dfs(A, K, 0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621079,
                "title": "python-easy-dp-with-visualization-and-examples",
                "content": "\\nHow to approach:\\n\\nAssume we only look ***back*** for dividing groups\\n\\nTake an example to see how to calculate and roll over:\\n![image](https://assets.leetcode.com/users/images/2fe51237-f8ad-4224-b8d6-d9a23c04187b_1639118918.889263.png)\\n\\nThen the states and transition function is as below:\\n-\\tFirst is to calculate a result for all cases:\\n```\\ncurr = []  # current sub-list\\nfor m in range(k):  # in total m cases\\n\\tcurr += dp[i][j-m-1] + max(arr[(j-m):(j+i)]) * (m+1)\\n```\\ndp[i][j-m-1] : is to use the previous dp result for the previous sum\\narr[(j-m):(j+i)] : by looking back m+1 numbers to find the max and repeat m+1 times\\n\\n-\\tThen is to choose the max result\\n```\\ndp[i][j] = max(curr)\\n```\\n\\n- Since index i in not necessary, we only need j (index of arr), and m (index of k), the script is as below:\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*n\\n        \\n        # handle the first k indexes differently\\n        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)\\n        \\n        # we can get rid of index i by running i times\\n        for j in range(k,n):\\n            curr = []\\n            for m in range(k):\\n                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))\\n            dp[j] = max(curr)\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ncurr = []  # current sub-list\\nfor m in range(k):  # in total m cases\\n\\tcurr += dp[i][j-m-1] + max(arr[(j-m):(j+i)]) * (m+1)\\n```\n```\\ndp[i][j] = max(curr)\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*n\\n        \\n        # handle the first k indexes differently\\n        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)\\n        \\n        # we can get rid of index i by running i times\\n        for j in range(k,n):\\n            curr = []\\n            for m in range(k):\\n                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))\\n            dp[j] = max(curr)\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028098,
                "title": "java-recursive-to-memoization-to-dp",
                "content": "**Recursive**\\n\\n>you should partition the array into (contiguous) subarrays of length at most k\\n\\nAt each index **i** of the array, we have **k** decision to make on how to partition the array as follows,\\n0 - Partition at index **i** so we will have array of size 1.\\n1 - Partition at index **i + 1** so we will have array of size 2.\\n.\\n.\\nk-1 - Partition at index **i + k - 1** so we will have array of size k.\\n\\n>After partitioning, each subarray has their values changed to become the maximum value of that subarray\\n\\nSince the problem says all the elements in the partition become the maximum value. We maintain the partition array running max and multiply the max with number of elements in the partition.\\n\\nAfter each partition the array we get on the right side of the partition is a sub problem (**optimal substructure**) so we call the recursion on it (with starting index of right partion) and add the result with previously computed current left array partition max sum.\\nSince the problem asks to find the largest, we take the maximum on the **k** decisions we made early.\\n\\n\\n\\nTree diagram for input [1, 15, 7, 9] with k = 2.\\nIt is possible to see the **overlapping subproblems** marked with star symbol.\\n\\n![image](https://assets.leetcode.com/users/images/81394224-f839-4cf0-b7ca-7cf667988d7a_1611250596.0235531.png)\\n\\n\\n```\\n\\tpublic int maxSumAfterPartitioning_r(int[] arr, int k) {\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) { // k decision to partition the array\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) { // stop partition when we we reach end of the array\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]); // Running maximum of left partition array\\n\\t\\t\\tint leftPartionSum = currMax * (j + 1); // sum of left partition\\n\\t\\t\\tint rightPartionMaxSum = maxSumAfterPartitioning(arr, k, to + 1); // Max Sum of right partition - Sub problem\\n\\t\\t\\tsumMax = Math.max(sumMax, leftPartionSum + rightPartionMaxSum); // Since problem asks for largest sum, we track the largest sum of k decisions we are making in this loop.\\n\\t\\t}\\n\\t\\treturn sumMax;\\n\\t}\\n```\\n\\n**Memoization**\\nAs previously pointed, we have repeating subproblems for same index of **i**, to avoid recomputation we want to store the result and use it when needed. What is the state based on which we can store the result? If we see the recursive method signature the only variable (state) that is changing is **i**. So we create a array of same size that of the input and use it for memoization.\\n```\\n\\tpublic int maxSumAfterPartitioning_memo(int[] arr, int k) {\\n\\t\\tInteger[] memo = new Integer[arr.length];\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0, memo);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i, Integer[] memo) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (memo[i] != null) {\\n\\t\\t\\treturn memo[i];\\n\\t\\t}\\n\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]);\\n\\t\\t\\tsumMax = Math.max(sumMax, (currMax * (j + 1)) + maxSumAfterPartitioning(arr, k, to + 1, memo));\\n\\t\\t}\\n\\t\\treturn memo[i] = sumMax;\\n\\t}\\n```\\n\\n**DP**\\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\tint[] dp = new int[arr.length];\\n\\t\\tfor (int to = 0; to < arr.length; to++) {\\n\\t\\t\\tint currMax = 0;\\n\\t\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\t\\tint from = to - j;\\n\\t\\t\\t\\tif (from < 0) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrMax = Math.max(currMax, arr[from]);\\n\\t\\t\\t\\tint newSplitVal = (currMax * (j + 1)) + getVal(dp, from - 1);\\n\\t\\t\\t\\tdp[to] = Math.max(dp[to], newSplitVal);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[arr.length - 1];\\n\\t}\\n\\n\\tprivate int getVal(int[] dp, int i) {\\n\\t\\tif (i < 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn dp[i];\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tpublic int maxSumAfterPartitioning_r(int[] arr, int k) {\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) { // k decision to partition the array\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) { // stop partition when we we reach end of the array\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]); // Running maximum of left partition array\\n\\t\\t\\tint leftPartionSum = currMax * (j + 1); // sum of left partition\\n\\t\\t\\tint rightPartionMaxSum = maxSumAfterPartitioning(arr, k, to + 1); // Max Sum of right partition - Sub problem\\n\\t\\t\\tsumMax = Math.max(sumMax, leftPartionSum + rightPartionMaxSum); // Since problem asks for largest sum, we track the largest sum of k decisions we are making in this loop.\\n\\t\\t}\\n\\t\\treturn sumMax;\\n\\t}\\n```\n```\\n\\tpublic int maxSumAfterPartitioning_memo(int[] arr, int k) {\\n\\t\\tInteger[] memo = new Integer[arr.length];\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0, memo);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i, Integer[] memo) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (memo[i] != null) {\\n\\t\\t\\treturn memo[i];\\n\\t\\t}\\n\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]);\\n\\t\\t\\tsumMax = Math.max(sumMax, (currMax * (j + 1)) + maxSumAfterPartitioning(arr, k, to + 1, memo));\\n\\t\\t}\\n\\t\\treturn memo[i] = sumMax;\\n\\t}\\n```\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\tint[] dp = new int[arr.length];\\n\\t\\tfor (int to = 0; to < arr.length; to++) {\\n\\t\\t\\tint currMax = 0;\\n\\t\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\t\\tint from = to - j;\\n\\t\\t\\t\\tif (from < 0) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrMax = Math.max(currMax, arr[from]);\\n\\t\\t\\t\\tint newSplitVal = (currMax * (j + 1)) + getVal(dp, from - 1);\\n\\t\\t\\t\\tdp[to] = Math.max(dp[to], newSplitVal);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[arr.length - 1];\\n\\t}\\n\\n\\tprivate int getVal(int[] dp, int i) {\\n\\t\\tif (i < 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn dp[i];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299049,
                "title": "dp-python-commented-code",
                "content": "So essentially, the subproblem is\\n\\nSuppose you are at position X of the array\\nWhat is the maximum possible sum to this point?\\nso you go back K-1 step\\n\\nyou choose the maximum from the following combinations:\\n\\ndp_sum[X - 1] +  max(A[X])*1\\ndp_sum[X - 2] +  max(A[X-1], A[X])*2\\ndp_sum[X - 3] + max(A[X-2], A[X-1], A[X])*3\\n.....\\ndp_sum[X - (k-1)] + max(A[X-(k-2)] ..... A[X])*(k-1)\\n\\n\\n```\\n\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        # initialization\\n        dp_sum = [0 for x in range(len(A))]\\n        dp_sum[0] = A[0]\\n        max_so_far = A[0]\\n        for x in range(1,K):\\n            max_so_far = max(max_so_far, A[x])\\n            dp_sum[x] = (x+1)*max_so_far\\n\\n        \\n        # find the maximum sum so far as if this is the end of a partition\\n        for ind in range(K, len(dp_sum)):\\n            \\n            # go back K-1 steps to find the maximum so far\\n            \\n            partition_max = 0\\n            for back in range(K):\\n                partition_max = max(partition_max, A[ind - back])\\n                prev_sum = dp_sum[ind - back - 1]\\n                \\n                dp_sum[ind] = max(dp_sum[ind], prev_sum + (back+1)*partition_max)\\n        \\n        \\n        return dp_sum[-1]\\n\\t\\t\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        # initialization\\n        dp_sum = [0 for x in range(len(A))]\\n        dp_sum[0] = A[0]\\n        max_so_far = A[0]\\n        for x in range(1,K):\\n            max_so_far = max(max_so_far, A[x])\\n            dp_sum[x] = (x+1)*max_so_far\\n\\n        \\n        # find the maximum sum so far as if this is the end of a partition\\n        for ind in range(K, len(dp_sum)):\\n            \\n            # go back K-1 steps to find the maximum so far\\n            \\n            partition_max = 0\\n            for back in range(K):\\n                partition_max = max(partition_max, A[ind - back])\\n                prev_sum = dp_sum[ind - back - 1]\\n                \\n                dp_sum[ind] = max(dp_sum[ind], prev_sum + (back+1)*partition_max)\\n        \\n        \\n        return dp_sum[-1]\\n\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859099,
                "title": "recursive-memoization-dp-building-dp-solutions-from-recursion-c",
                "content": "**Recursion** \\nFirst think a simple recursion solution on seeing the problem. In this question we have to consider subarrays of at most k length. Start thinking like if you do the work considering 0,1,2..k elements in every next step, the recursion brings you the answer for the rest part.\\n\\nRelation :  Loop i from 0 to k: R(0,n) = Work(0,i) + R(i+1,n)\\n\\n```\\nint helper(vector<int>& arr, int s,int k){\\n\\n        if(s >= arr.size())\\n            return 0;\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(s+k,arr.size());i++){    /// Work You Do\\n           \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));    /// Work you pass to recursion\\n            \\n        }\\n        return sum;\\n        \\n    }\\n```\\n\\n**Memoization**\\nStart thinking of the overlapping subproblems. Try to make the recursion tree and identify overlapping subproblems. Now use memoization to reduce the recursive function calls.\\n\\n```\\n int helper(vector<int>& arr, int s,int k,int* memo){\\n        \\n        if(s >= arr.size())\\n            return 0;\\n        if(memo[s] != -1)    /// Memoization\\n            return memo[s];\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(arr.size(),s+k);i++){\\n      \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));\\n            \\n        }\\n        memo[s] = sum;   /// Saving the answer for future use.\\n        return sum;\\n        \\n    }\\n```\\n\\n\\n**DP**\\nNow, Try to build your solution from Bottom-Up. (It\\'ll be way easier now.)\\n\\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n      \\n        int n = arr.size();\\n        int* dp = new int[n];\\n        for(int i=0;i<n;i++){\\n            dp[i] = -1;\\n         }\\n        for(int i = n-1;i>=0;i--){\\n            int sum = INT_MIN;\\n            int max_ele = INT_MIN;\\n            for(int j = i;j<n && j<i+k;j++){\\n                max_ele = max(max_ele,arr[j]);\\n                int cand = j+1 < n ? dp[j+1] + max_ele*(j-i+1) : max_ele*(j-i+1); \\n                sum = max(sum , cand);\\n            }\\n            dp[i] = sum;\\n        }\\n        return dp[0];\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint helper(vector<int>& arr, int s,int k){\\n\\n        if(s >= arr.size())\\n            return 0;\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(s+k,arr.size());i++){    /// Work You Do\\n           \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));    /// Work you pass to recursion\\n            \\n        }\\n        return sum;\\n        \\n    }\\n```\n```\\n int helper(vector<int>& arr, int s,int k,int* memo){\\n        \\n        if(s >= arr.size())\\n            return 0;\\n        if(memo[s] != -1)    /// Memoization\\n            return memo[s];\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(arr.size(),s+k);i++){\\n      \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));\\n            \\n        }\\n        memo[s] = sum;   /// Saving the answer for future use.\\n        return sum;\\n        \\n    }\\n```\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n      \\n        int n = arr.size();\\n        int* dp = new int[n];\\n        for(int i=0;i<n;i++){\\n            dp[i] = -1;\\n         }\\n        for(int i = n-1;i>=0;i--){\\n            int sum = INT_MIN;\\n            int max_ele = INT_MIN;\\n            for(int j = i;j<n && j<i+k;j++){\\n                max_ele = max(max_ele,arr[j]);\\n                int cand = j+1 < n ? dp[j+1] + max_ele*(j-i+1) : max_ele*(j-i+1); \\n                sum = max(sum , cand);\\n            }\\n            dp[i] = sum;\\n        }\\n        return dp[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281273,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        //dp[i] stores the sum at index i\\n        int n=arr.size();\\n        vector<int> dp(n);\\n        int maxi=arr[0];\\n        for(int i=0;i<k;i++)\\n        {\\n            maxi=max(arr[i],maxi);\\n            dp[i]=(maxi*(i+1));\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            dp[i]=arr[i]+dp[i-1];\\n            maxi=arr[i];\\n            //check if a partition can result into the maximum sum\\n            for(int j=i-1;j>i-k;j--)\\n            {\\n                //get the maximum element\\n                maxi=max(maxi,arr[j]);\\n                dp[i]=max(dp[i],dp[j-1]+ (i-j+1)*maxi);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        //dp[i] stores the sum at index i\\n        int n=arr.size();\\n        vector<int> dp(n);\\n        int maxi=arr[0];\\n        for(int i=0;i<k;i++)\\n        {\\n            maxi=max(arr[i],maxi);\\n            dp[i]=(maxi*(i+1));\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            dp[i]=arr[i]+dp[i-1];\\n            maxi=arr[i];\\n            //check if a partition can result into the maximum sum\\n            for(int j=i-1;j>i-k;j--)\\n            {\\n                //get the maximum element\\n                maxi=max(maxi,arr[j]);\\n                dp[i]=max(dp[i],dp[j-1]+ (i-j+1)*maxi);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290850,
                "title": "c-rolling-max-dp",
                "content": "# Top-Down Solution\\nFor each position ```pos```, increase your subarray size ```i``` from ```1``` to ```k```, tracking the maximum value ```mv``` so far. The sum of the subarray is ```mv * i```.\\n\\nThen, call our function recursively for position ```pos + i```.\\n\\nTo avoid re-calculating the same input, use memoisation to track the maximum sum for the position (```dp```).\\n```\\nint dp[501] = {};\\nint maxSumAfterPartitioning(vector<int>& A, int K, int pos = 0, int res = 0) {\\n  if (pos < A.size() && dp[pos] != 0) return dp[pos];\\n  for (int i = 1, mv = 0; i <= K && pos + i <= A.size(); ++i) {\\n    mv = max(mv, A[pos + i - 1]);\\n    res = max(res, mv * i + maxSumAfterPartitioning(A, K, pos + i));\\n  }\\n  return dp[pos] = res;\\n}\\n```",
                "solutionTags": [],
                "code": "```pos```\n```i```\n```1```\n```k```\n```mv```\n```mv * i```\n```pos + i```\n```dp```\n```\\nint dp[501] = {};\\nint maxSumAfterPartitioning(vector<int>& A, int K, int pos = 0, int res = 0) {\\n  if (pos < A.size() && dp[pos] != 0) return dp[pos];\\n  for (int i = 1, mv = 0; i <= K && pos + i <= A.size(); ++i) {\\n    mv = max(mv, A[pos + i - 1]);\\n    res = max(res, mv * i + maxSumAfterPartitioning(A, K, pos + i));\\n  }\\n  return dp[pos] = res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306945,
                "title": "o-nk-dp-with-explanation",
                "content": "Problem asks for to partition array in some parts (each partition of length at most K) such that replace each element in partition by max element in that partition then total sum should be maximised.\\n\\nFor K  = 1, trivial solution to consider each element as one partition then max sum = Sum of all elements\\nFor K  = 2,  check for previous k - 1 elements i.e. previous 1 element.\\nThen decide between whether or not increase size of partition\\ne.g.  For each two elements,  Max of  (2 * max element,  sum of each element with k - 1)\\nFor K = 3, check for previous k - 1 elements i.e. previous 2 elements.\\n e.g.  For each three elements,  Max of  (3 * max element,  earlier result of partition of size 2 of first two or last two elements  + remaining element)\\n \\nFrom pattern we have overlapping subproblem of computation of parition of size of k - 1 and optimal substructure (finding max sum), this calls for dynamic programming. \\n\\n\\n``` csharp\\npublic int MaxSumAfterPartitioning(int[] A, int K)\\n{\\n\\tint[] d = new int[A.Length];\\n\\n\\tfor (int i = 0; i < A.Length; i++)\\n\\t{\\n\\t\\tint partitionMax = 0;\\n\\t\\tfor (int k = 1; k <= K && (k - 1) <= i; k++)\\n\\t\\t{\\n\\t\\t\\tpartitionMax = Math.Max(partitionMax, A[i - (k - 1)]);\\n\\t\\t\\td[i] = Math.Max(d[i], (i >= k ? d[i - k] : 0) + k * partitionMax);\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[A.Length - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic int MaxSumAfterPartitioning(int[] A, int K)\\n{\\n\\tint[] d = new int[A.Length];\\n\\n\\tfor (int i = 0; i < A.Length; i++)\\n\\t{\\n\\t\\tint partitionMax = 0;\\n\\t\\tfor (int k = 1; k <= K && (k - 1) <= i; k++)\\n\\t\\t{\\n\\t\\t\\tpartitionMax = Math.Max(partitionMax, A[i - (k - 1)]);\\n\\t\\t\\td[i] = Math.Max(d[i], (i >= k ? d[i - k] : 0) + k * partitionMax);\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[A.Length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387825,
                "title": "easy-to-understand-c-memoization",
                "content": "Basically, we have to calculate all possibilites of partition i.e for a given K, the subarray could be of length 1,2,3.....K. That\\'s where Dynamic Programming comes into picture.\\n\\nFor that we need some variables to store necessary information i.e length of the current subarray(len),maximum in the current subarray(maxm), and ofcourse the index of the element being visited.\\n\\nAt every index we have to check 2 major possibilites:\\n* **Make a partition**( current subarray sum= maxm* length of subarray)\\n*  **Don\\'t make a partition**(only possible if current subarray length <K)\\n\\nWe can call the function again by incrementing or resetting values of the variables and continue visiting every index further till end of the array. \\nWe can cache the sums of corresponding index and array length as shown.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int find(int index,int maxm,int len,vector<int>& arr, int k)\\n    {\\n        if(index==arr.size())\\n        {\\n            return len*maxm;       \\n        }\\n        \\n        int part=0,noPart=0;\\n        maxm=max(maxm,arr[index]);\\n        len++;\\n        \\n        if(dp[index][len]!=-1)\\n            return dp[index][len];\\n        \\n        if(len<k)\\n        {\\n            noPart=find(index+1,maxm,len,arr,k);    \\n        }\\n        part=len*maxm+find(index+1,INT_MIN,0,arr,k);\\n        \\n        return dp[index][len]=max(part,noPart);\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        dp.resize(n+1,vector<int>(k+1,-1));\\n        \\n        return find(0,INT_MIN,0,arr,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int find(int index,int maxm,int len,vector<int>& arr, int k)\\n    {\\n        if(index==arr.size())\\n        {\\n            return len*maxm;       \\n        }\\n        \\n        int part=0,noPart=0;\\n        maxm=max(maxm,arr[index]);\\n        len++;\\n        \\n        if(dp[index][len]!=-1)\\n            return dp[index][len];\\n        \\n        if(len<k)\\n        {\\n            noPart=find(index+1,maxm,len,arr,k);    \\n        }\\n        part=len*maxm+find(index+1,INT_MIN,0,arr,k);\\n        \\n        return dp[index][len]=max(part,noPart);\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        dp.resize(n+1,vector<int>(k+1,-1));\\n        \\n        return find(0,INT_MIN,0,arr,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168667,
                "title": "c-recursion-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size(), -1);\\n        return dfs(arr, k, 0, dp);\\n    }\\n    \\n    int dfs(vector<int>&arr, int k, int start, vector<int>& dp){\\n        int n = arr.size();\\n        if(start>=n)\\n            return 0;\\n        if(dp[start]!=-1) return dp[start];\\n        int maxsum = arr[start];\\n        int maxno = arr[start];\\n        for(int end = start;end<start+k && end<n;end++)\\n        {\\n            maxno = max(maxno,arr[end]);\\n            maxsum = max(maxsum,(maxno*(end-start+1)+dfs(arr,k,end+1,dp)));\\n        }\\n        return dp[start] = maxsum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size(), -1);\\n        return dfs(arr, k, 0, dp);\\n    }\\n    \\n    int dfs(vector<int>&arr, int k, int start, vector<int>& dp){\\n        int n = arr.size();\\n        if(start>=n)\\n            return 0;\\n        if(dp[start]!=-1) return dp[start];\\n        int maxsum = arr[start];\\n        int maxno = arr[start];\\n        for(int end = start;end<start+k && end<n;end++)\\n        {\\n            maxno = max(maxno,arr[end]);\\n            maxsum = max(maxsum,(maxno*(end-start+1)+dfs(arr,k,end+1,dp)));\\n        }\\n        return dp[start] = maxsum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150881,
                "title": "c-easy-bottom-up-solution-with-intution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k) {\\n        int n=a.size();\\n        int dp[n];//to store maximum sum ending at particular index\\n        memset(dp,0,sizeof(dp));\\n        int m=a[0];\\n        //Base Case\\n        for(int i=0;i<k;i++){//storing the result for upto first k numbers by finding the maximum among them\\n            m=max(m,a[i]);\\n            dp[i]=m*(i+1);\\n        }\\n        //Now Calculating the solution\\n        for(int i=k;i<n;i++){\\n            m=a[i];//initialising as the current max\\n            for(int j = 1;j <= k;j++){\\n                m=max(m,a[i-j+1]);//finding the maximum till here\\n                //recurrence relation here is found by dp[i] \\n                // means maximum sum ended at i\\n                //dp[i-1]+A[i]\\n                //dp[i-2]+max(A[i-1],A[i])*2\\n                // and so on till the window of size k\\n                dp[i]=max(dp[i],dp[i-j]+(m*j));\\n            }\\n        }\\n        return dp[n-1];//finally returning the answer\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k) {\\n        int n=a.size();\\n        int dp[n];//to store maximum sum ending at particular index\\n        memset(dp,0,sizeof(dp));\\n        int m=a[0];\\n        //Base Case\\n        for(int i=0;i<k;i++){//storing the result for upto first k numbers by finding the maximum among them\\n            m=max(m,a[i]);\\n            dp[i]=m*(i+1);\\n        }\\n        //Now Calculating the solution\\n        for(int i=k;i<n;i++){\\n            m=a[i];//initialising as the current max\\n            for(int j = 1;j <= k;j++){\\n                m=max(m,a[i-j+1]);//finding the maximum till here\\n                //recurrence relation here is found by dp[i] \\n                // means maximum sum ended at i\\n                //dp[i-1]+A[i]\\n                //dp[i-2]+max(A[i-1],A[i])*2\\n                // and so on till the window of size k\\n                dp[i]=max(dp[i],dp[i-j]+(m*j));\\n            }\\n        }\\n        return dp[n-1];//finally returning the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881385,
                "title": "dp-python-bottom-up-top-down",
                "content": "This problem is extremely hard to grasp. It\\'s a variation on dynamic programming, but the subproblems are hard to see when you first look at it. I\\'d say this is a \\'Hard\\' difficulty, not a \\'Medium.\\'\\n\\nBeginning with the original array [1, 15, 7, 9, 2, 5, 10], the answer to this problem is:\\nmax(1x1 + f([15, 7, 9, 2, 5, 10]), 2x15 + f([7, 9, 2, 5, 10]), + 3x15 + f([9, 2, 5, 10]).\\nThe product at the front is the current \\'K\\' value we are on, multiplied by the maximum value of the first K elements in the array. We have to update the maximum seen so far to multiply it by up to K values of it. \\n\\nThe subproblems themselves just repeat until we reach the empty list, whose answer is 0. After seeing the subproblem, the hard part is getting the indexing correct. Memoization doesn\\'t require this since we can just use a hashtable and store whatever index we are on, but the bottom-up approach does require precise indexing.\\n\\nWe initialize an array of length len(A) + 1. The last element is 0 to represent the base case of the empty list. The element before that is set as A[len(A)-1]. This is because the list with one element\\'s answer is just the one element itself. Each dp[i] represents the answer to the subproblem for the subarray starting at index i. We go in reverse, and using the current max product, we add it to dp[i+k] where k is our offset between 1 and K. We keep taking the max of each iteration.\\n\\nWe check K values per element in our array, so O(NK) runtime. O(N) space.\\n\\nTOP-DOWN\\n```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            # base case\\n            if start == len(arr):\\n                return 0\\n            \\n            cur_max = float(\\'-inf\\')\\n            res = 0\\n            \\n            # we want to loop over k elements, take the maximum and multiply\\n            # then add it to the corresponding subproblem with the reduced\\n            # array\\n            for i in range(K):\\n                if start+i == len(arr):\\n                    break\\n                cur_max = max(cur_max, arr[start+i])\\n                # take the max of all possibilities\\n                if start+i+1 in memo:\\n                    res = max(res, (i+1)*cur_max + memo[start+i+1])\\n                else:\\n                    res = max(res, (i+1)*cur_max + recur(arr, start+i+1, memo))\\n                    \\n            # return the final result\\n            memo[start] = res\\n            return res\\n        \\n        memo = {}\\n        recur(A, 0, memo)\\n        return memo[0]\\n```\\n\\nBOTTOM-UP\\n```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        dp = [float(\\'-inf\\') for i in range(len(A)+1)]\\n        dp[-1] = 0\\n        dp[-2] = A[-1]\\n        \\n        for j in reversed(range(len(A)-1)):\\n            cur_max = float(\\'-inf\\')\\n            for k in range(K):\\n                if j+k == len(A):\\n                    break\\n                cur_max = max(cur_max, A[j+k])\\n                dp[j] = max(dp[j], (k+1)*cur_max + dp[j+k+1])\\n        \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            # base case\\n            if start == len(arr):\\n                return 0\\n            \\n            cur_max = float(\\'-inf\\')\\n            res = 0\\n            \\n            # we want to loop over k elements, take the maximum and multiply\\n            # then add it to the corresponding subproblem with the reduced\\n            # array\\n            for i in range(K):\\n                if start+i == len(arr):\\n                    break\\n                cur_max = max(cur_max, arr[start+i])\\n                # take the max of all possibilities\\n                if start+i+1 in memo:\\n                    res = max(res, (i+1)*cur_max + memo[start+i+1])\\n                else:\\n                    res = max(res, (i+1)*cur_max + recur(arr, start+i+1, memo))\\n                    \\n            # return the final result\\n            memo[start] = res\\n            return res\\n        \\n        memo = {}\\n        recur(A, 0, memo)\\n        return memo[0]\\n```\n```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        dp = [float(\\'-inf\\') for i in range(len(A)+1)]\\n        dp[-1] = 0\\n        dp[-2] = A[-1]\\n        \\n        for j in reversed(range(len(A)-1)):\\n            cur_max = float(\\'-inf\\')\\n            for k in range(K):\\n                if j+k == len(A):\\n                    break\\n                cur_max = max(cur_max, A[j+k])\\n                dp[j] = max(dp[j], (k+1)*cur_max + dp[j+k+1])\\n        \\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2278681,
                "title": "c-recursion-memoization-basic-dp-mcm-pattern",
                "content": "```\\n// The Solution is Totally Based on MCM Technique i.e. Partioning Technique.\\n// What I did is Totally Based on that First I wrote Recursive Code and then memoize it to remove any TLE.\\n// So Its Simple and Intutive I need to get the ans for any values and rest the recursion will do its work.\\n// So lets Take the example\\n// [1,15,7,9,2,5,10] , k = 3\\n// So here I will first choose 1 and for rest of the Array that is for 15,7,9,2,5,10 recursion will give me its ans now loop will progress i will now take 1,15 and for that my maximum value is 15 which into length will give me its answer and for rest of the array i will get the soltuion this is my another valid solution and similarly I did that again and finally when i will choose 1,15,7 then further Breakdown is not possible becuase at most k elements are allowed.And then I memoize the code.\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>&arr , int i , int j, int k)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(j-i==k)\\n        {\\n            int max1 = 0;\\n            if(j+1 > arr.size())\\n            {\\n                max1= *max_element(arr.begin() + i , arr.end());\\n                return (max1*k);\\n            }\\n           max1 = *max_element(arr.begin() + i , arr.begin() + j + 1);\\n           return (max1*k);\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans = 0;\\n        for(int p = i ; p < j ; p++)\\n        {\\n            if(p-i < k)\\n            {   \\n                int max2 = *max_element(arr.begin() + i , arr.begin() + p + 1);\\n                max2 = max2*(p-i+1);\\n                ans = max(ans , max2 + solve(arr , p+1 , j , k));\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(arr , 0 , arr.size() , k);\\n    }\\n};\\n```\\n**Please Upvote the Solution if you like it.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// The Solution is Totally Based on MCM Technique i.e. Partioning Technique.\\n// What I did is Totally Based on that First I wrote Recursive Code and then memoize it to remove any TLE.\\n// So Its Simple and Intutive I need to get the ans for any values and rest the recursion will do its work.\\n// So lets Take the example\\n// [1,15,7,9,2,5,10] , k = 3\\n// So here I will first choose 1 and for rest of the Array that is for 15,7,9,2,5,10 recursion will give me its ans now loop will progress i will now take 1,15 and for that my maximum value is 15 which into length will give me its answer and for rest of the array i will get the soltuion this is my another valid solution and similarly I did that again and finally when i will choose 1,15,7 then further Breakdown is not possible becuase at most k elements are allowed.And then I memoize the code.\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>&arr , int i , int j, int k)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(j-i==k)\\n        {\\n            int max1 = 0;\\n            if(j+1 > arr.size())\\n            {\\n                max1= *max_element(arr.begin() + i , arr.end());\\n                return (max1*k);\\n            }\\n           max1 = *max_element(arr.begin() + i , arr.begin() + j + 1);\\n           return (max1*k);\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans = 0;\\n        for(int p = i ; p < j ; p++)\\n        {\\n            if(p-i < k)\\n            {   \\n                int max2 = *max_element(arr.begin() + i , arr.begin() + p + 1);\\n                max2 = max2*(p-i+1);\\n                ans = max(ans , max2 + solve(arr , p+1 , j , k));\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(arr , 0 , arr.size() , k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522001,
                "title": "python3-with-explanation",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, K):\\n        # 0) Initialization\\n        #    best_a is used to keep past computation result\\n        #    best_a[i] is to keep local optimal result of A[0:i-1]\\n        best_a = [0] * len(A)\\n        best_a[0] = A[0]\\n\\n        # 1) Iteratively fill the best_a with local optimal result\\n        #    best_a[0] = A[0]\\n        #    best_a[1] = max(best_a[0] + A[1], max(A[0:2]) * 2)\\n        #    best_a[2] = max(best_a[1] + A[2], best_a[0] + max(A[1:3]) * 2, max(A[0:3]) * 3)\\n        #    ...\\n        #    best_a[n] = max(best_a[n-1] + A[n], best_a[n-2] + max(A[n-1:n+1]) * 2, ..., max(A[n-K+1:n+1]) * K)\\n        for i in range(1, len(A)):\\n            max_v = 0\\n            for j in range(i, max(-1, i-K), -1):\\n                sa = A[j:i+1]\\n                v = best_a[j-1] + max(sa) * len(sa)\\n                if v > max_v:\\n                    max_v = v\\n\\n            best_a[i] = max_v\\n\\n        # 3) The global optimal result is kept in last element\\n        return best_a[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, K):\\n        # 0) Initialization\\n        #    best_a is used to keep past computation result\\n        #    best_a[i] is to keep local optimal result of A[0:i-1]\\n        best_a = [0] * len(A)\\n        best_a[0] = A[0]\\n\\n        # 1) Iteratively fill the best_a with local optimal result\\n        #    best_a[0] = A[0]\\n        #    best_a[1] = max(best_a[0] + A[1], max(A[0:2]) * 2)\\n        #    best_a[2] = max(best_a[1] + A[2], best_a[0] + max(A[1:3]) * 2, max(A[0:3]) * 3)\\n        #    ...\\n        #    best_a[n] = max(best_a[n-1] + A[n], best_a[n-2] + max(A[n-1:n+1]) * 2, ..., max(A[n-K+1:n+1]) * K)\\n        for i in range(1, len(A)):\\n            max_v = 0\\n            for j in range(i, max(-1, i-K), -1):\\n                sa = A[j:i+1]\\n                v = best_a[j-1] + max(sa) * len(sa)\\n                if v > max_v:\\n                    max_v = v\\n\\n            best_a[i] = max_v\\n\\n        # 3) The global optimal result is kept in last element\\n        return best_a[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744173,
                "title": "easy-to-understand-memo-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& A, int dp[], int k, int i){\\n        if(i>=A.size()) return 0;\\n        int & ans  = dp[i];\\n        if(ans!=-1) return ans;\\n        int maxx  = A[i];\\n        \\n        for(int j = 0; j<k&& (i+j)<A.size() ; j++){\\n            maxx = max(A[i+j], maxx);\\n            ans = max(ans, maxx*(j+1) + find(A, dp, k, i+j+1) );\\n            \\n        }\\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int n = A.size();\\n        int dp[n+1];\\n        memset(dp,-1,sizeof(dp));\\n        return find(A,dp, K, 0);\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(vector<int>& A, int dp[], int k, int i){\\n        if(i>=A.size()) return 0;\\n        int & ans  = dp[i];\\n        if(ans!=-1) return ans;\\n        int maxx  = A[i];\\n        \\n        for(int j = 0; j<k&& (i+j)<A.size() ; j++){\\n            maxx = max(A[i+j], maxx);\\n            ans = max(ans, maxx*(j+1) + find(A, dp, k, i+j+1) );\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1519101,
                "title": "dp-matrix-chain-multiplication-format-c-pseudo-code-of-mcm",
                "content": "This is the pseudo code used to solve any MCM problem..just find the pattern of MCM and apply this logic\\nExplanation:-\\n![image](https://assets.leetcode.com/users/images/fe6ffbf3-245c-43df-85e0-00191d8d9068_1634111288.2755802.png)\\n\\nThe code :-\\n```\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, int k, vector<int>& arr){\\n        //  base case\\n        if(j < i) // size of array = 0\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int currmax=0;\\n        int len=1;\\n        int ans=0;\\n        for(int t=i ; t<=j && len<=k; t++, len++){\\n            \\n            // calculate maximum till you reach k elements\\n            currmax = max(currmax, arr[t]);\\n            // solve thr answer for right subarray\\n            int r = solve(t+1, j, k, arr);\\n            // solve the answer fot current partition\\n            ans = max(ans, currmax*len + r);\\n        \\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    \\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k){\\n        \\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        // using Dynamic programming\\n        // similar to matrix chain multiplication format :)\\n        // break at every k from i to j\\n        return solve(0, n-1, k, arr);\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, int k, vector<int>& arr){\\n        //  base case\\n        if(j < i) // size of array = 0\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int currmax=0;\\n        int len=1;\\n        int ans=0;\\n        for(int t=i ; t<=j && len<=k; t++, len++){\\n            \\n            // calculate maximum till you reach k elements\\n            currmax = max(currmax, arr[t]);\\n            // solve thr answer for right subarray\\n            int r = solve(t+1, j, k, arr);\\n            // solve the answer fot current partition\\n            ans = max(ans, currmax*len + r);\\n        \\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    \\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k){\\n        \\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        // using Dynamic programming\\n        // similar to matrix chain multiplication format :)\\n        // break at every k from i to j\\n        return solve(0, n-1, k, arr);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249327,
                "title": "java-solution-o-nk-time-o-n-space-dp-approach",
                "content": "```\\n public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N=arr.length;\\n        if(N==1) return arr[0];\\n        int[] dp = new int[N+1];\\n        \\n        for(int i=1;i<=N;i++){\\n            int currMax=0; int maxSumK=0;\\n            for(int sub=1;sub<=k && i-sub>=0;sub++){\\n                currMax=Math.max(currMax,arr[i-sub]);\\n                maxSumK=Math.max(maxSumK,dp[i-sub]+(currMax*sub));\\n            }\\n            dp[i]=maxSumK;\\n        }\\n        return dp[N];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N=arr.length;\\n        if(N==1) return arr[0];\\n        int[] dp = new int[N+1];\\n        \\n        for(int i=1;i<=N;i++){\\n            int currMax=0; int maxSumK=0;\\n            for(int sub=1;sub<=k && i-sub>=0;sub++){\\n                currMax=Math.max(currMax,arr[i-sub]);\\n                maxSumK=Math.max(maxSumK,dp[i-sub]+(currMax*sub));\\n            }\\n            dp[i]=maxSumK;\\n        }\\n        return dp[N];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151452,
                "title": "rust-0-ms-dp-with-explanation-on-example",
                "content": "As in most dynamic programming questions we will start from solving base case.\\nOur example input will be ```arr=[1,15,7,9,2,5,10] k=3``` and our max possible sums will be at ```dp = [0,0,0,0,0,0,0]```\\nOur base case is solved from 3 first values of array.\\nFor first 3 arr values our max sum is as follows [1,30,45,0,0,0,0] since 15 is bigger than 1 and 7 and we calculate it like that:\\n```\\nfor i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n```\\nNow that we have base case solved, we can continue by walking arr from k to n. \\n[1, 15, 7,   9, 2, 5, 10] arr\\n[1, 30, 45, 0, 0, 0,   0] dp\\nSo now to get max sum for 9 we should check  in loop which is bigger: ```9*1+45``` or ```9*2+30```(since 9 is bigger than 7) or ```15*3+1```(since 15 is bigger than 7 and 9) the answer is 54 so we choose 54 and now we have\\n[1, 15,  7,   9, 2, 5, 10] arr\\n[1, 30, 45, 54, 0, 0,   0] dp\\nNow let\\'s do same for 2.  We need to choose biggest from these```2*1+54``` or ```9*2+45``` or ```9*3+30``` the answer is 63 so now we have\\n[1, 15,  7,   9, 2, 5, 10] arr\\n[1, 30, 45, 54, 63, 0,   0] dp\\nContinuing these steps we will have\\n[1, 15, 7, 9, 2, 5, 10] arr\\n[1, 30, 45, 54, 63, 72, 84] dp\\nAnd the answer is dp[last_index]\\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_sum_after_partitioning(arr: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let n = arr.len();\\n        let mut dp = vec![0;n];\\n        dp[0] = arr[0];\\n        let mut local_max = arr[0];\\n        for i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n        for i in k..n{\\n            local_max = 0;\\n            for j in 1..k+1{\\n                local_max = max(local_max,arr[i+1-j]);\\n                dp[i] = max(dp[i], dp[i-j]+local_max*(j as i32));// for 9 in our example this means choose biggest of  45+9*1 or 30+9*2 or 1+15*3\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```arr=[1,15,7,9,2,5,10] k=3```\n```dp = [0,0,0,0,0,0,0]```\n```\\nfor i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n```\n```9*1+45```\n```9*2+30```\n```15*3+1```\n```2*1+54```\n```9*2+45```\n```9*3+30```\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_sum_after_partitioning(arr: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let n = arr.len();\\n        let mut dp = vec![0;n];\\n        dp[0] = arr[0];\\n        let mut local_max = arr[0];\\n        for i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n        for i in k..n{\\n            local_max = 0;\\n            for j in 1..k+1{\\n                local_max = max(local_max,arr[i+1-j]);\\n                dp[i] = max(dp[i], dp[i-j]+local_max*(j as i32));// for 9 in our example this means choose biggest of  45+9*1 or 30+9*2 or 1+15*3\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924268,
                "title": "c-dynamic-programming-98-98-fast",
                "content": "```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int dp[n];\\n       \\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0] = arr[0];\\n        int maxi = arr[0];\\n        //filling 1-(k-1) of dp array\\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);  \\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxi = arr[i];//MINIMIUM VALUE\\n            for(int j=1;j<=k;j++)\\n            {\\n               maxi = max(maxi,arr[i-j+1]);\\n                dp[i] = max(dp[i],dp[i-j] + maxi*j);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n        \\n    }\\n\\t\\n```\\n\\nit took me many readings of the statement only actually understanding the problem though!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int dp[n];\\n       \\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0] = arr[0];\\n        int maxi = arr[0];\\n        //filling 1-(k-1) of dp array\\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);  \\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxi = arr[i];//MINIMIUM VALUE\\n            for(int j=1;j<=k;j++)\\n            {\\n               maxi = max(maxi,arr[i-j+1]);\\n                dp[i] = max(dp[i],dp[i-j] + maxi*j);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n        \\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851374,
                "title": "javascript-dynamic-programming-memoization-with-explanation",
                "content": "```\\n/**\\n * DYNAMIC PROGRAMMING + MEMOIZATION\\n * \\n * Creates a memo[] that holds all the max results for each index from 0....end of arr.length-1.\\n * For each number in the arr[i] it \"tries on\" different partition sizes from 1 to k, all the while\\n * holding the biggest number within that partition.\\n * Then sees if it will produce the max sum by multiplying that max num by the partition size, \\n * and adding that to the max sum that\\'s alrady been calculated until that partition (in memo[i - partition size]).\\n * \\n * For example: arr=[8, 4, 7], k=2\\n * memo[0] = can only have partition size of 1 so it will be the value 8\\n * memo[1] = which is bigger? partition size 1 (max num is 4) or 2 (max num between {8,4} is 8? =>\\n *          memo[1-1]+4*1 or memo[1-2]+8*2 =>\\n *          memo[0]+4 or memo[-1]+16 (memo[-1] doesn\\'t exist so take 0 instead) =>\\n *          8+4 or 0+16 => \\n *          12 or 16 => 16\\n * memo[2] = which is bigger? partition size 1 (max num 7) or 2 (max num between {7, 4} is 7)? =>\\n *          memo[2-1]+7*1 or memo[2-2]+7*2 =>\\n *          memo[1]+7 or memo[0]+14 => 16+7 or 8+14 => 24 or 22 => 24\\n * so the answer is the memo[] of the last index: 24.\\n * \\n * Runtime complexity - say N=arr.length then complexity is O(N*k). Each number in array tries different partition sizes.\\n * Space complexityy - O(N) for memo[] for every value in arr[].\\n * \\n * \\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumAfterPartitioning = function (arr, k) {\\n    let result = 0;\\n\\n    if (arr && (arr.length >= 1) && (arr.length <= 500) && (k >= 1) && (k <= arr.length)) {\\n        let currMaxForPartition;\\n        let memo = [];\\n        // the only partition size to use for the first number can only be 1, so the max sum is that number\\n        memo[0] = arr[0]; \\n\\n        // for every number in the array fill the memo[]\\n        for (let i = 1; i < arr.length; i++) {\\n            // init the max num for the partition as the lowest possible number that could be in arr[]\\n            currMaxForPartition = 0;\\n            // init memo[] as a placeholder value as minimal sum possible\\n            memo[i] = 0;\\n\\n            // for each partition size from 1 until k, keeping in mind that \\n            // the partition size can\\'t be bigger than the current index\\n            for (let a = 1; (a <= k) && ((i - a + 1) >= 0); a++) {\\n                // find the biggest number in that partition in arr[]\\n                currMaxForPartition = Math.max(currMaxForPartition, arr[i - a + 1]);\\n\\n                // multiply the currMaxForPartition by partition size and add that the max sum before that\\n                // partition. if it\\'s bigger than the last max sum, override it.\\n                // if i is smaller than the partition size, use 0 as previous max sum\\n                memo[i] = Math.max(memo[i], ((i >= k) ? memo[i - a] : 0) + (a * currMaxForPartition));\\n            }\\n        }\\n\\n        // last value in memo\\n        result = memo[arr.length - 1];\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * DYNAMIC PROGRAMMING + MEMOIZATION\\n * \\n * Creates a memo[] that holds all the max results for each index from 0....end of arr.length-1.\\n * For each number in the arr[i] it \"tries on\" different partition sizes from 1 to k, all the while\\n * holding the biggest number within that partition.\\n * Then sees if it will produce the max sum by multiplying that max num by the partition size, \\n * and adding that to the max sum that\\'s alrady been calculated until that partition (in memo[i - partition size]).\\n * \\n * For example: arr=[8, 4, 7], k=2\\n * memo[0] = can only have partition size of 1 so it will be the value 8\\n * memo[1] = which is bigger? partition size 1 (max num is 4) or 2 (max num between {8,4} is 8? =>\\n *          memo[1-1]+4*1 or memo[1-2]+8*2 =>\\n *          memo[0]+4 or memo[-1]+16 (memo[-1] doesn\\'t exist so take 0 instead) =>\\n *          8+4 or 0+16 => \\n *          12 or 16 => 16\\n * memo[2] = which is bigger? partition size 1 (max num 7) or 2 (max num between {7, 4} is 7)? =>\\n *          memo[2-1]+7*1 or memo[2-2]+7*2 =>\\n *          memo[1]+7 or memo[0]+14 => 16+7 or 8+14 => 24 or 22 => 24\\n * so the answer is the memo[] of the last index: 24.\\n * \\n * Runtime complexity - say N=arr.length then complexity is O(N*k). Each number in array tries different partition sizes.\\n * Space complexityy - O(N) for memo[] for every value in arr[].\\n * \\n * \\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumAfterPartitioning = function (arr, k) {\\n    let result = 0;\\n\\n    if (arr && (arr.length >= 1) && (arr.length <= 500) && (k >= 1) && (k <= arr.length)) {\\n        let currMaxForPartition;\\n        let memo = [];\\n        // the only partition size to use for the first number can only be 1, so the max sum is that number\\n        memo[0] = arr[0]; \\n\\n        // for every number in the array fill the memo[]\\n        for (let i = 1; i < arr.length; i++) {\\n            // init the max num for the partition as the lowest possible number that could be in arr[]\\n            currMaxForPartition = 0;\\n            // init memo[] as a placeholder value as minimal sum possible\\n            memo[i] = 0;\\n\\n            // for each partition size from 1 until k, keeping in mind that \\n            // the partition size can\\'t be bigger than the current index\\n            for (let a = 1; (a <= k) && ((i - a + 1) >= 0); a++) {\\n                // find the biggest number in that partition in arr[]\\n                currMaxForPartition = Math.max(currMaxForPartition, arr[i - a + 1]);\\n\\n                // multiply the currMaxForPartition by partition size and add that the max sum before that\\n                // partition. if it\\'s bigger than the last max sum, override it.\\n                // if i is smaller than the partition size, use 0 as previous max sum\\n                memo[i] = Math.max(memo[i], ((i >= k) ? memo[i - a] : 0) + (a * currMaxForPartition));\\n            }\\n        }\\n\\n        // last value in memo\\n        result = memo[arr.length - 1];\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774195,
                "title": "java-recursive-memoization-bottom-up",
                "content": "```\\n- For each of the starting point \\'i\\', we are able to choose the values from \\'i -> i + k - 1\\'\\n\\t- Then convert all of the values to the largest element within the range\\n\\t\\t- We will easily calculate the total sum within the current range by using this equation \\'# of elements in range x largest number\\'\\n\\t- Then our next range will start right after our current range\\n- We will want to pick the choice which will give us the highest sum\\n```\\n```\\npublic class PartitionArrayForMaximumSumRecursiveApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K) {\\n        if (start >= A.length) return 0;\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K) + (i - start + 1) * max);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\\n```\\npublic class PartitionArrayForMaximumSumMemoizationApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K, new int[A.length]);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K, int[] memo) {\\n        if (start >= A.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K, memo) + (i - start + 1) * max);\\n        }\\n\\n        memo[start] = maxSum;\\n        return maxSum;\\n    }\\n}\\n```\\n```\\npublic class PartitionArrayForMaximumSumBottomUp {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] sum = new int[A.length + 1];\\n\\n        for (int start = A.length - 1; start >= 0; start--) {\\n            int max = 0;\\n\\n            for (int i = start; i < Math.min(A.length, start + K); i++) {\\n                max = Math.max(max, A[i]);\\n                sum[start] = Math.max(sum[start], sum[i + 1] + (i - start + 1) * max);\\n            }\\n        }\\n\\n        return sum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- For each of the starting point \\'i\\', we are able to choose the values from \\'i -> i + k - 1\\'\\n\\t- Then convert all of the values to the largest element within the range\\n\\t\\t- We will easily calculate the total sum within the current range by using this equation \\'# of elements in range x largest number\\'\\n\\t- Then our next range will start right after our current range\\n- We will want to pick the choice which will give us the highest sum\\n```\n```\\npublic class PartitionArrayForMaximumSumRecursiveApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K) {\\n        if (start >= A.length) return 0;\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K) + (i - start + 1) * max);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class PartitionArrayForMaximumSumMemoizationApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K, new int[A.length]);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K, int[] memo) {\\n        if (start >= A.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K, memo) + (i - start + 1) * max);\\n        }\\n\\n        memo[start] = maxSum;\\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class PartitionArrayForMaximumSumBottomUp {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] sum = new int[A.length + 1];\\n\\n        for (int start = A.length - 1; start >= 0; start--) {\\n            int max = 0;\\n\\n            for (int i = start; i < Math.min(A.length, start + K); i++) {\\n                max = Math.max(max, A[i]);\\n                sum[start] = Math.max(sum[start], sum[i + 1] + (i - start + 1) * max);\\n            }\\n        }\\n\\n        return sum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672793,
                "title": "java-simple-dp",
                "content": "```\\npublic int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length, dp[] = new int[n + 1];  //dp[i] max sum of first i ele, 0 ... A[i -1];\\n        for (int i = 1; i < dp.length; i++) {  // dp[0] = 0;\\n            for (int j = 0, max = 0; i - j - 1 >= 0 && j < K; j++) {\\n                max = Math.max(max, A[i - j - 1]);  // subarray from i - j - 1, i - 1;\\n                dp[i] = Math.max(dp[i], max * (j + 1) + dp[i - j - 2 + 1]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length, dp[] = new int[n + 1];  //dp[i] max sum of first i ele, 0 ... A[i -1];\\n        for (int i = 1; i < dp.length; i++) {  // dp[0] = 0;\\n            for (int j = 0, max = 0; i - j - 1 >= 0 && j < K; j++) {\\n                max = Math.max(max, A[i - j - 1]);  // subarray from i - j - 1, i - 1;\\n                dp[i] = Math.max(dp[i], max * (j + 1) + dp[i - j - 2 + 1]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435555,
                "title": "c-dp-with-explanation",
                "content": "Phew! This one was tough for me. I spent a couple days tearing apart other solutions on here, trying to understand how they worked. After much calcuation, and thinking, I came up with a solution slightly different from the others, but I feel it\\'s far more readable than many of the others.\\n\\n```\\n        public int MaxSumAfterPartitioning(int[] A, int K)\\n        {\\n            var previousMaxSums = new int[A.Length];\\n\\n            // Iterating through the value array\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // Setup the current maximum for this partition.\\n                int maxInPartition = 0;\\n\\n                // J represents a distance from i.\\n                for (int j = 0; j < K; j++)\\n                {\\n                    // If we are out of bounds, break the loop\\n                    // This could have been a loop condition too, but it seems\\n                    // more readable here.\\n                    if (i - j < 0)\\n                        break;\\n\\n                    // We are currently looking at previousSums[i - j], if there are\\n                    // elements in the array before that range, add them here, other wise, 0\\n                    var possibleSum = i - (j + 1) >= 0 ? previousMaxSums[i - (j + 1)] : 0;\\n\\n                    // If we\\'ve discovered a better max, use it.\\n                    maxInPartition = Math.Max(maxInPartition, A[i - j]);\\n\\n                    // Add the max, spread across however big our partition is to the\\n                    // previous elements. We had + 1 to account for previousSum[i],\\n                    // as J represents the distance FROM i, but not including it.\\n                    possibleSum += maxInPartition * (j + 1);\\n\\n                    // Which is more, the current value, or the new one?\\n                    previousMaxSums[i] = Math.Max(previousMaxSums[i], possibleSum);\\n                }\\n            }\\n\\n            return previousMaxSums[previousMaxSums.Length - 1];\\n        }\\n```\\n\\nHere are some extra tips that helped me solve this:\\n\\n- The \\'DP\\' array is a historical list of the maximum sum, with the index corresponding to the number of available elements in the A collection. It\\'s a record of \\'We made the best with X amount of elements\\'. We will never \\'go back\\' (i - 1) and change this once its calculated. I realize some DP problems update elements of an array, then when finished, search for a solution... not the case so much here.\\n- At each index we start a partition going backward. If you want to visualize what that might look like, its something like this:\\n\\t```\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x, x] + parition[x] | j = 1\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x] + parition[x, x] | j = 2\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x] + parition[x, x, x] | j = 3\\n\\t```\\n- The example problem has an array like `[1, 15, 7, 9... 10]`, I had a hard time working out the logic of how we would know to replace `[15, 15, 15]` over indices `0, 1, 2` rather than indices `1, 2, 3` or something. Here\\'s how that logic worked out. When `i = 3`, and `j = 2`, the `maxInPartition`  was 15. Why did we not then use 15 instead of 9? Well, if our parition was currently 3 in size, using 15, meant we had a partition value of 45. However since the partition was 3 elements big, that means thats 2 elements we couldn\\'t use from the historical, `previousMaxSums` array. At this point our `previousMaxSums` array looked something like this: [1, 30, 45...] - we would have had to use the value at index 0 (since we were looking at using 3 elements from our partition) + the partition value, which would have equaled `46`. Simply adding the `A[3] = 9` to the previous 45, using a partition size of 1 was a much better idea, giving us a sum of `54`.",
                "solutionTags": [],
                "code": "```\\n        public int MaxSumAfterPartitioning(int[] A, int K)\\n        {\\n            var previousMaxSums = new int[A.Length];\\n\\n            // Iterating through the value array\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // Setup the current maximum for this partition.\\n                int maxInPartition = 0;\\n\\n                // J represents a distance from i.\\n                for (int j = 0; j < K; j++)\\n                {\\n                    // If we are out of bounds, break the loop\\n                    // This could have been a loop condition too, but it seems\\n                    // more readable here.\\n                    if (i - j < 0)\\n                        break;\\n\\n                    // We are currently looking at previousSums[i - j], if there are\\n                    // elements in the array before that range, add them here, other wise, 0\\n                    var possibleSum = i - (j + 1) >= 0 ? previousMaxSums[i - (j + 1)] : 0;\\n\\n                    // If we\\'ve discovered a better max, use it.\\n                    maxInPartition = Math.Max(maxInPartition, A[i - j]);\\n\\n                    // Add the max, spread across however big our partition is to the\\n                    // previous elements. We had + 1 to account for previousSum[i],\\n                    // as J represents the distance FROM i, but not including it.\\n                    possibleSum += maxInPartition * (j + 1);\\n\\n                    // Which is more, the current value, or the new one?\\n                    previousMaxSums[i] = Math.Max(previousMaxSums[i], possibleSum);\\n                }\\n            }\\n\\n            return previousMaxSums[previousMaxSums.Length - 1];\\n        }\\n```\n```\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x, x] + parition[x] | j = 1\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x] + parition[x, x] | j = 2\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x] + parition[x, x, x] | j = 3\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 290853,
                "title": "java-dp-solution-o-n-k",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n        \\n        for(int i=1;i<A.length;i++) {\\n            int maxSum = A[i]+dp[i-1], maxVal = A[i];\\n            for(int j=i-1;j>=0 && j>i-K;j--) {\\n                maxVal = Math.max(maxVal, A[j]);\\n                if(j==0) {\\n                    maxSum = Math.max(maxSum, maxVal*(i-j+1));\\n                } else {\\n                    maxSum = Math.max(maxVal*(i-j+1)+dp[j-1], maxSum);\\n                }\\n                \\n            }\\n            dp[i] = maxSum;\\n        }\\n        \\n        return dp[A.length-1];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n        \\n        for(int i=1;i<A.length;i++) {\\n            int maxSum = A[i]+dp[i-1], maxVal = A[i];\\n            for(int j=i-1;j>=0 && j>i-K;j--) {\\n                maxVal = Math.max(maxVal, A[j]);\\n                if(j==0) {\\n                    maxSum = Math.max(maxSum, maxVal*(i-j+1));\\n                } else {\\n                    maxSum = Math.max(maxVal*(i-j+1)+dp[j-1], maxSum);\\n                }\\n                \\n            }\\n            dp[i] = maxSum;\\n        }\\n        \\n        return dp[A.length-1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929046,
                "title": "c-solution-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&arr,int k,vector<int>&dp){\\n        int n = arr.size();\\n        if(i==n)\\n            return 0;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int maxSum = INT_MIN;\\n        int len = 0,maxi=INT_MIN;\\n        for(int z=i;z<min(n,i+k);z++){\\n            len++;\\n            maxi= max(maxi,arr[z]);\\n            int sum = len*maxi + solve(z+1,arr,k,dp);\\n            maxSum = max(sum,maxSum);\\n        }\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,arr,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&arr,int k,vector<int>&dp){\\n        int n = arr.size();\\n        if(i==n)\\n            return 0;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int maxSum = INT_MIN;\\n        int len = 0,maxi=INT_MIN;\\n        for(int z=i;z<min(n,i+k);z++){\\n            len++;\\n            maxi= max(maxi,arr[z]);\\n            int sum = len*maxi + solve(z+1,arr,k,dp);\\n            maxSum = max(sum,maxSum);\\n        }\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,arr,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539902,
                "title": "python-concise-code-dp",
                "content": "DP[i] denotes: the max value it can get to index i -1 in arr . (inlcuding i-1)\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0] * (n+1)\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, k+1):\\n                if i - j >= 0:\\n                    dp[i] = max(\\n                        dp[i-j] + max(arr[i-j: i]) * j ,\\n                        dp[i]\\n                    )\\n        return dp[-1]\\n",
                "solutionTags": [],
                "code": "DP[i] denotes: the max value it can get to index i -1 in arr . (inlcuding i-1)\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0] * (n+1)\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, k+1):\\n                if i - j >= 0:\\n                    dp[i] = max(\\n                        dp[i-j] + max(arr[i-j: i]) * j ,\\n                        dp[i]\\n                    )\\n        return dp[-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2239967,
                "title": "c-easy-front-partition-recursion-memo-to-tabulation-dp",
                "content": "**\\u2705Please upvote if you find the post useful\\u2705**\\n\\nIt is pretty easy to understand that greedy will not work here and we have to find all possible partitions and take the maximum amongst them.\\n\\nNow, to find all possible partitions, we have to write a recursive function.\\n\\n**Let\\'s define our recursive function as F where F(i) denotes the maximum sum we can get from index i till last index.**\\n\\nAt any index i, we can make partitions of length 1, 2, 3....k. Hence we will loop at every index and try all k partitions. Refer to the pseudo code below.\\n\\n***Base Condition** : When i == n we have exhausted the array hence we will return 0.*\\n\\nLet\\'s try to write the pseudo code.\\n```\\nF(i) {\\n\\tsum = INT_MIN\\n\\tfor(j = i to i + k)\\n\\t\\tcurrent sum = max element in current partition * length of current partition\\n\\t\\t\\t\\t\\t\\t\\t\\t+ F(j + 1)\\n\\t\\tsum = max(sum, current sum)\\n\\treturn sum\\n}\\n```\\n\\n***Here F(0) will give us the answer***\\n\\nNow (i + k) can go out of bound that is when i + k >= n, (n = length of arr). So we have to handle that case as well.\\n`Hence j can go from i to min(n, i + k)`\\n\\n---\\n\\n### Recursion + Memo\\nNow, as we understand the pseudo code, we can write the recursive one as well.\\n```\\nclass Solution {\\n    int partition(int i, int k, vector<int>&arr, vector<int>&dp) {\\n        int n = arr.size();\\n        if(i == n) return 0; //base case\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        int max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n        for(int j = i; j < min(n, i + k); j++) {\\n            length++; //increase length in each partition\\n            max_num = max(max_num, arr[j]); //update maximum number in each partition\\n            int curr_sum = length * max_num + partition(j + 1, k, arr, dp);\\n            max_sum = max(max_sum, curr_sum);\\n        }\\n        \\n        return dp[i] = max_sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int>dp(n + 1, -1);\\n        int ans = partition(0, k, arr, dp);\\n        return ans;\\n    }\\n};\\n```\\n**TC : O(N^2)\\nSC : O(N)**\\n\\n---\\n\\n### Tabulation\\nNow, as we have written the recursive code, writing the tabulation is pretty easy. \\nIn recursion our i varied from 0 to n - 1. Hence, in tabulation, we will just go the other way around.\\nAs per our base condition, dp[n] = 0;\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size(), max_sum, max_num, length;\\n        \\n        int dp[n + 1];\\n        dp[n] = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n            for(int j = i; j < min(n, i + k); j++) {\\n                length++;\\n                max_num = max(max_num, arr[j]);\\n                int curr_sum = length * max_num + dp[j + 1];\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n\\n            dp[i] = max_sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n**TC : O(N^2)\\nSC : O(N)**\\n\\n**\\u2705Please upvote if you find the post useful\\u2705**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nF(i) {\\n\\tsum = INT_MIN\\n\\tfor(j = i to i + k)\\n\\t\\tcurrent sum = max element in current partition * length of current partition\\n\\t\\t\\t\\t\\t\\t\\t\\t+ F(j + 1)\\n\\t\\tsum = max(sum, current sum)\\n\\treturn sum\\n}\\n```\n```\\nclass Solution {\\n    int partition(int i, int k, vector<int>&arr, vector<int>&dp) {\\n        int n = arr.size();\\n        if(i == n) return 0; //base case\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        int max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n        for(int j = i; j < min(n, i + k); j++) {\\n            length++; //increase length in each partition\\n            max_num = max(max_num, arr[j]); //update maximum number in each partition\\n            int curr_sum = length * max_num + partition(j + 1, k, arr, dp);\\n            max_sum = max(max_sum, curr_sum);\\n        }\\n        \\n        return dp[i] = max_sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int>dp(n + 1, -1);\\n        int ans = partition(0, k, arr, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size(), max_sum, max_num, length;\\n        \\n        int dp[n + 1];\\n        dp[n] = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n            for(int j = i; j < min(n, i + k); j++) {\\n                length++;\\n                max_num = max(max_num, arr[j]);\\n                int curr_sum = length * max_num + dp[j + 1];\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n\\n            dp[i] = max_sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078593,
                "title": "recursive-memoization-solution-with-clean-code",
                "content": "class Solution {\\npublic:\\n\\n    int m;\\n    vector<int> v;\\n    int t[502];//memoization array...\\n    int rec(int i,int n){\\n        if(i>=n) return 0;//base function....\\n        if(t[i]) return t[i];\\n        int mx=0,cur=0;\\n        for(int p=0;p<m;p++){\\n            if(i+p>=n) break;//if limit exceeds..\\n            mx=max(mx,v[i+p]);\\n            cur=max(cur,mx*(p+1)+rec(i+p+1,n));//condition to be satisfied....\\n        }\\n        return t[i]=cur;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        v=arr;//assign to global vector....\\n        m=k;//assign to global variable....\\n        return rec(0,v.size());\\n    }\\n};\\nIf you like the solution please upvote \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09.....",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int m;\\n    vector<int> v;\\n    int t[502];//memoization array...\\n    int rec(int i,int n){\\n        if(i>=n) return 0;//base function....\\n        if(t[i]) return t[i];\\n        int mx=0,cur=0;\\n        for(int p=0;p<m;p++){\\n            if(i+p>=n) break;//if limit exceeds..\\n            mx=max(mx,v[i+p]);\\n            cur=max(cur,mx*(p+1)+rec(i+p+1,n));//condition to be satisfied....\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838637,
                "title": "java-solution-dp-bottom-up-approach",
                "content": "\\'\\'\\'\\n\\n\\n\\n\\n     class Solution {\\n      public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n       \\n        int[] dp=new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            int max=0;\\n            int val=0;\\n            for(int j=1;j<=Math.min(i,k);j++){\\n                max=Math.max(max,arr[i-j]);\\n                \\n                val=Math.max(dp[i-j]+max*j,val);\\n                \\n            }\\n            dp[i]=val;\\n        }\\n        return dp[n];\\n    }\\n}   \\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n      public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n       \\n        int[] dp=new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            int max=0;\\n            int val=0;\\n            for(int j=1;j<=Math.min(i,k);j++){\\n                max=Math.max(max,arr[i-j]);\\n                \\n                val=Math.max(dp[i-j]+max*j,val);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1539213,
                "title": "simple-python-solution-with-explanation",
                "content": "Explanation : https://github.com/midnightbot/leetcode_solutions/blob/main/1043.%20Partition%20Array%20for%20Maximum%20Sum(DP).pdf\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        #opt[i] be optimal ans for 0..i\\n        \\n        memo = [-1] * len(arr)\\n        memo[0] = arr[0]\\n        #memo[1] = max(arr[0],arr[1])*2\\n        #memo[2] = max(arr[0],arr[1],arr[2])*3\\n        \\n        for y in range(1,k): ##initialization\\n            \\n            memo[y] = max(arr[0:y+1]) * (y+1)\\n        \\n        for x in range(k,len(arr)):\\n            #print(memo)\\n            maxs = max(arr[x-k+1:x+1])\\n            for z in range(1,k+1):\\n                maxs = max(arr[x-z+1:x+1])\\n                memo[x] = max(memo[x],memo[x-1] + arr[x], maxs*z + memo[x-z])\\n        #print(memo)    \\n        return memo[len(arr)-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        #opt[i] be optimal ans for 0..i\\n        \\n        memo = [-1] * len(arr)\\n        memo[0] = arr[0]\\n        #memo[1] = max(arr[0],arr[1])*2\\n        #memo[2] = max(arr[0],arr[1],arr[2])*3\\n        \\n        for y in range(1,k): ##initialization\\n            \\n            memo[y] = max(arr[0:y+1]) * (y+1)\\n        \\n        for x in range(k,len(arr)):\\n            #print(memo)\\n            maxs = max(arr[x-k+1:x+1])\\n            for z in range(1,k+1):\\n                maxs = max(arr[x-z+1:x+1])\\n                memo[x] = max(memo[x],memo[x-1] + arr[x], maxs*z + memo[x-z])\\n        #print(memo)    \\n        return memo[len(arr)-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474132,
                "title": "python-recursion-intuitive-code",
                "content": "Note that we can have a sub-array of at most k elements.\\n\\nFor example: [1,15,7] and k = 2\\n\\n```\\nidx: 0  1 2\\nval: 1 15 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      .\\n\\t\\t       max([1])*1+R([15,7])               max[1,15]*2+R([7]\\nmax([15])*1 + R([7])      max([15,7]*2 + R([])              max([7]*1) + R([])\\nmax([7]*1 + R([]))\\n```\\n\\nMemoization can be added later using lru_cache or a dictionary.\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\n        @lru_cache(maxsize = None)\\n        def recurse(i):\\n            #base case\\n            if i >= len(arr):\\n                return 0\\n            \\n            ret = 0\\n            for j in range(i+1,min(i+1+k, len(arr)+1)):\\n                temp = max(arr[i:j])*(j-i)\\n                ret = max(ret, temp+recurse(j))\\n            \\n            return ret\\n        \\n        return recurse(0)\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nidx: 0  1 2\\nval: 1 15 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      .\\n\\t\\t       max([1])*1+R([15,7])               max[1,15]*2+R([7]\\nmax([15])*1 + R([7])      max([15,7]*2 + R([])              max([7]*1) + R([])\\nmax([7]*1 + R([]))\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\n        @lru_cache(maxsize = None)\\n        def recurse(i):\\n            #base case\\n            if i >= len(arr):\\n                return 0\\n            \\n            ret = 0\\n            for j in range(i+1,min(i+1+k, len(arr)+1)):\\n                temp = max(arr[i:j])*(j-i)\\n                ret = max(ret, temp+recurse(j))\\n            \\n            return ret\\n        \\n        return recurse(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211040,
                "title": "java-progressive-solution",
                "content": "**Method 1:** Brute force\\n* At each level of recursion, index will advance by 1 and the logic will branch into k branches.\\n* What the recursion tree looks like for arr = [1, 15, 7, 9], k = 2\\n![image](https://assets.leetcode.com/users/images/9d28806a-26be-497b-98a1-dedc1db437fb_1621139418.690102.jpeg)\\n\\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k);\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k) {\\n\\tif (start >= arr.length)\\n\\t\\treturn 0;\\n\\tvar localMax = 0;\\n\\tvar globalMax = 0;\\n\\t// the loop condition here means, I want the loop to run through the subArray, from start to start + k (end),\\n\\t// but not go out of bounds in the process.\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\t// (i - start + 1) is the paritioned subArray size, all the elements of which have to \"flipped\" \\n\\t\\t// (count in total as that max value) to the max element of that subarray\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k));\\n\\t}\\n\\treturn globalMax;\\n}\\n```\\n\\n**Method 2:** Inject Memoization into method 1, i.e. right before you return a result, hash it.\\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k, new HashMap<>());\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k, Map<Integer, Integer> map) {\\n\\tif (start == arr.length)\\n\\t\\treturn 0;\\n\\tif (map.containsKey(start))\\n\\t\\treturn map.get(start);\\n\\tvar globalMax = 0;\\n\\tvar localMax = 0;\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k, map));\\n\\t}\\n\\tmap.put(start, globalMax);\\n\\treturn globalMax;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k);\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k) {\\n\\tif (start >= arr.length)\\n\\t\\treturn 0;\\n\\tvar localMax = 0;\\n\\tvar globalMax = 0;\\n\\t// the loop condition here means, I want the loop to run through the subArray, from start to start + k (end),\\n\\t// but not go out of bounds in the process.\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\t// (i - start + 1) is the paritioned subArray size, all the elements of which have to \"flipped\" \\n\\t\\t// (count in total as that max value) to the max element of that subarray\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k));\\n\\t}\\n\\treturn globalMax;\\n}\\n```\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k, new HashMap<>());\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k, Map<Integer, Integer> map) {\\n\\tif (start == arr.length)\\n\\t\\treturn 0;\\n\\tif (map.containsKey(start))\\n\\t\\treturn map.get(start);\\n\\tvar globalMax = 0;\\n\\tvar localMax = 0;\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k, map));\\n\\t}\\n\\tmap.put(start, globalMax);\\n\\treturn globalMax;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192230,
                "title": "java-bottom-up-dp-solution",
                "content": "Suppose  we know answers ans[] i.e max sum for  arr[0], arr[0..1], arr[0..2] .... arr[0....n-1] , \\nlet ans[i] = max sum for arr[0....i]\\nthen when n th element is added, the max sum for new array i.e arr[0....n] would be max of { ans[n-j] + j * max element in arr[n-j ... n] ) } for j belongs to (0 .. k).\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length + 1];\\n        for(int i = 1; i <= arr.length; i++){\\n            int dpMax = Integer.MIN_VALUE;\\n            int max= Integer.MIN_VALUE;\\n            for(int j = 0; j < k; j++){\\n                \\n                if(i - j - 1 >= 0){\\n                    max = Math.max(max, arr[i-j-1]);\\n                    dpMax = Math.max(dpMax, dp[i-j-1] + (j + 1)*max );\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            dp[i] = dpMax;\\n        }\\n        return dp[arr.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length + 1];\\n        for(int i = 1; i <= arr.length; i++){\\n            int dpMax = Integer.MIN_VALUE;\\n            int max= Integer.MIN_VALUE;\\n            for(int j = 0; j < k; j++){\\n                \\n                if(i - j - 1 >= 0){\\n                    max = Math.max(max, arr[i-j-1]);\\n                    dpMax = Math.max(dpMax, dp[i-j-1] + (j + 1)*max );\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            dp[i] = dpMax;\\n        }\\n        return dp[arr.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012677,
                "title": "python-top-down-dp",
                "content": "Let dp[n] = the largest sum of the array arr[:n] after partitioning.\\nBase case: (i) n == 0, dp[0] = 0\\n                    (ii) n <= k, just one partition, n * max(arr[:n])\\nRecurrence:\\nn > k, the last partition has k choices: 1 number, 2 numbers, ..., k numbers,\\nthus, dp[n] = max([dp[n-i] + i * max(arr[n-i:n]) for i in range(1, k + 1)])\\n```\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def recursive(n):\\n            if n == 0:\\n                return 0\\n            if n <= k:\\n                return max(arr[:n]) * n\\n            if n in dp:\\n                return dp[n]\\n            curr_max = arr[n-1]\\n            dp[n] = recursive(n - 1) + curr_max\\n            for i in range(2, k + 1):\\n                curr_max = max(curr_max, arr[n - i])\\n                dp[n] = max(dp[n], recursive(n - i) + curr_max * i)\\n            return dp[n]\\n        \\n        dp = dict()\\n        return recursive(len(arr))\\n```\\nTime complexity: O(n * k)",
                "solutionTags": [],
                "code": "```\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def recursive(n):\\n            if n == 0:\\n                return 0\\n            if n <= k:\\n                return max(arr[:n]) * n\\n            if n in dp:\\n                return dp[n]\\n            curr_max = arr[n-1]\\n            dp[n] = recursive(n - 1) + curr_max\\n            for i in range(2, k + 1):\\n                curr_max = max(curr_max, arr[n - i])\\n                dp[n] = max(dp[n], recursive(n - i) + curr_max * i)\\n            return dp[n]\\n        \\n        dp = dict()\\n        return recursive(len(arr))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 778772,
                "title": "java-dp-with-comments",
                "content": "class Solution {\\n    \\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n    \\n        int[] dp = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            \\n            /**\\n                We want to partition the array\\n                in such a way that we expand \\n                the current window to size K\\n                backwards and use the dp value\\n                at i - K if it exists in our solution\\n            \\n            **/\\n            \\n            int windowMax = 0;\\n            \\n            // k is my window size\\n            // k can be almost of size K - max window size available\\n            // current position - window size should be greater than equal to 0\\n            // we don\\'t want the window to skid through the first position\\n            \\n            for (int k = 1; k <= K && (i - (k -1) >= 0); k++) {\\n                \\n                windowMax = Math.max(windowMax, A[i - (k -1)]);\\n                \\n                dp[i] = Math.max(dp[i], (i-k >= 0 ? dp[i-k] : 0) + windowMax * k);\\n                \\n            }\\n\\n        }\\n         \\n        return dp[A.length - 1];\\n    }\\n   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n    \\n        int[] dp = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            \\n            /**\\n                We want to partition the array\\n                in such a way that we expand \\n                the current window to size K\\n                backwards and use the dp value\\n                at i - K if it exists in our solution\\n            \\n            **/\\n            \\n            int windowMax = 0;\\n            \\n            // k is my window size\\n            // k can be almost of size K - max window size available\\n            // current position - window size should be greater than equal to 0\\n            // we don\\'t want the window to skid through the first position\\n            \\n            for (int k = 1; k <= K && (i - (k -1) >= 0); k++) {\\n                \\n                windowMax = Math.max(windowMax, A[i - (k -1)]);\\n                \\n                dp[i] = Math.max(dp[i], (i-k >= 0 ? dp[i-k] : 0) + windowMax * k);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 391648,
                "title": "java-solution-with-dynamic-programming",
                "content": "if `i` less than `K`, dp[i] = max(A[0], ..., A[i]) * i, else dp[i] = max(dp[i - j] + max(A[i - j + 1]) * j) while `j` from 1 to K.\\n\\n```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int len = A.length;\\n        int[] dp = new int[len];\\n        \\n        int max = A[0];\\n        for(int i = 0; i < K; i++){\\n            max = Math.max(max, A[i]);\\n            dp[i] = max * (i+1);\\n        }\\n        \\n        for(int i = K;i < len; i++){\\n            max = A[i];\\n            for(int j = 1; j <= K; j++){\\n                max = Math.max(max, A[i - j + 1]);\\n                dp[i] = Math.max(dp[i], dp[i - j] + max * j);\\n            }\\n        }\\n        \\n        return dp[len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int len = A.length;\\n        int[] dp = new int[len];\\n        \\n        int max = A[0];\\n        for(int i = 0; i < K; i++){\\n            max = Math.max(max, A[i]);\\n            dp[i] = max * (i+1);\\n        }\\n        \\n        for(int i = K;i < len; i++){\\n            max = A[i];\\n            for(int j = 1; j <= K; j++){\\n                max = Math.max(max, A[i - j + 1]);\\n                dp[i] = Math.max(dp[i], dp[i - j] + max * j);\\n            }\\n        }\\n        \\n        return dp[len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291575,
                "title": "python-o-nk-time-o-n-space-solution",
                "content": "dp[i] means the maximum result we can get in A[ : i]\\n```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        curMax = 0\\n        for i in range(n):\\n            if i < K: \\n                curMax = max(curMax, A[i])\\n                dp[i] = curMax * (i + 1)\\n            else:\\n                curMax = 0\\n                for j in range(1, K + 1):\\n                    curMax = max(A[i - j + 1], curMax)\\n                    dp[i] = max(dp[i], dp[i - j] + curMax * j)\\n        return dp[n - 1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        curMax = 0\\n        for i in range(n):\\n            if i < K: \\n                curMax = max(curMax, A[i])\\n                dp[i] = curMax * (i + 1)\\n            else:\\n                curMax = 0\\n                for j in range(1, K + 1):\\n                    curMax = max(A[i - j + 1], curMax)\\n                    dp[i] = max(dp[i], dp[i - j] + curMax * j)\\n        return dp[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290939,
                "title": "c-short-solution",
                "content": "```\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size() + 1, 0);\\n        \\n        for(int i = 1; i <= A.size(); i++) {\\n            int max = A[i-1];\\n            for(int j = i; j > i-K && j > 0; j--) {\\n                max = std::max(max, A[j-1]);\\n                dp[i] = std::max(dp[i], max*(i-j+1) + dp[j-1]);\\n            }\\n        }\\n        \\n        return dp[A.size()];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size() + 1, 0);\\n        \\n        for(int i = 1; i <= A.size(); i++) {\\n            int max = A[i-1];\\n            for(int j = i; j > i-K && j > 0; j--) {\\n                max = std::max(max, A[j-1]);\\n                dp[i] = std::max(dp[i], max*(i-j+1) + dp[j-1]);\\n            }\\n        }\\n        \\n        return dp[A.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640812,
                "title": "recursive-memoization-cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Iterate over each index in the array and consider it as the starting point of a partition. Within each partition, find the maximum element and calculate the sum by multiplying the maximum element with the size of the partition. Update the maximum sum found so far.\\n\\n- Use dynamic programming to store and reuse the results of subproblems. Before calculating the sum for a particular index, check if it has already been computed and stored in the dynamic programming array. If so, retrieve the result directly instead of recomputing it. This optimization helps avoid redundant calculations and improves efficiency.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The solve function is a recursive helper function that calculates the maximum possible sum after partitioning the array arr. It takes the following parameters:\\n\\n- arr: A reference to the input vector of integers.\\n- ind: The current index in the array.\\n- k: The maximum size of each partition.\\n- n: The total number of elements in the array.\\n- dp: A reference to a vector that stores previously calculated results for dynamic programming.\\n\\n- The first condition if(ind>=n) return 0; checks if the current index ind is beyond the last index of the array. If so, it means we have reached the end of the array, and there are no more elements to process. In this case, the function returns 0, indicating that there are no elements to add to the sum.\\n\\n- The second condition if(dp[ind]!=-1) return dp[ind]; checks if the result for the current index ind has already been calculated and stored in the dynamic programming vector dp. If the value is not equal to -1, it means the result is already known and can be directly returned without further computation.\\n\\n- The variables max_ele and sum are initialized. max_ele is set to the minimum possible value (INT_MIN) to keep track of the maximum element within the current partition. sum is initially set to 0 and will store the maximum sum found so far.\\n\\n- The for loop iterates over the elements from the current index ind up to the minimum of ind+k and n (to ensure we don\\'t go beyond the array boundaries or the maximum partition size).\\n\\n- Inside the loop, max_ele is updated by comparing its current value with the element at the current index arr[i]. If arr[i] is greater than max_ele, max_ele is updated to arr[i].\\n\\n- The variable sum is updated by recursively calling the solve function with the next index i+1. The result of the recursive call is added to (i-ind+1)*max_ele, which represents the sum of the current partition multiplied by the maximum element within that partition. The max function is used to keep track of the maximum value of sum obtained during the iterations of the loop.\\n\\n- Finally, the value of sum is stored in the dp vector at the current index ind before returning it.\\n\\n- The maxSumAfterPartitioning function is the entry point for the problem. It takes the input array arr and the maximum partition size k. It initializes a dynamic programming vector dp with size n+1 and fills it with -1 to indicate that no results have been computed yet.\\n\\n- The function calls the solve function with the initial index 0 and returns the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`The time complexity of the solution is O(n * k), where n is the number of elements in the array and k is the maximum partition size. This is because for each index, we iterate up to k elements to find the maximum element within the partition.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`The space complexity is O(n), as we use a dynamic programming array of size n+1 to store the results of subproblems.`\\n\\n# Recursive Code\\n```\\nint solve(vector<int>& arr, int ind, int k, int n)\\n    {\\n        if(ind>=n) return 0;\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n)+(i-ind+1)*max_ele);\\n        }\\n        return sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        return solve(arr,0,k,n);\\n    }\\n```\\n\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int ind, int k, int n,vector<int>& dp)\\n    {\\n        if(ind>=n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n,dp)+(i-ind+1)*max_ele);\\n        }\\n        return dp[ind] = sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(arr,0,k,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int>& arr, int ind, int k, int n)\\n    {\\n        if(ind>=n) return 0;\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n)+(i-ind+1)*max_ele);\\n        }\\n        return sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        return solve(arr,0,k,n);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int ind, int k, int n,vector<int>& dp)\\n    {\\n        if(ind>=n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n,dp)+(i-ind+1)*max_ele);\\n        }\\n        return dp[ind] = sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(arr,0,k,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681126,
                "title": "c-recursion-memoization-tabulation",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/8ed9036b-20bd-4ba5-8a9c-ed5bca2fc081_1665314833.9614336.png)\\n\\n**T->O(n^k) && S->O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& arr,int k,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\tint op=(j+1)*maxi+f(i+j+1,arr,k,n);\\n\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\treturn f(0,arr,k,n);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# Method -2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/99955af2-3dfa-4b3b-9667-2760066c6453_1665314840.2871518.png)\\n\\n**T->O(nk) && S->O(nk) + O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& arr,int k,int n,vector<int>& dp){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\tint op=(j+1)*maxi+f(i+j+1,arr,k,n,dp);\\n\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i]=ans;\\n\\t\\t}\\n\\n\\t\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp(n,-1);\\n\\t\\t\\treturn f(0,arr,k,n,dp);\\n\\t\\t}\\n\\t};\\n\\n# Method -3 [Tabulation]\\n![image](https://assets.leetcode.com/users/images/0bad273e-2223-424f-8846-7bbb62dd63f0_1665315382.794784.png)\\n\\n**T->O(nk) && S->O(nk)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp(n+k,0);\\n\\t\\t\\tfor(int i=n+k-1;i>=0;i--){\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\t\\tint op=(j+1)*maxi+dp[i+j+1];\\n\\t\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i]=ans;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0];\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& arr,int k,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\tint op=(j+1)*maxi+f(i+j+1,arr,k,n);\\n\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2290264,
                "title": "c-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> arr;\\n    int k;\\n    int n;\\n    \\n    // state - index\\n    int dp[505];\\n    \\n    int rec(int level){\\n        // base case\\n        if(level == n){\\n            return 0;\\n        }\\n        if(dp[level] != -1) return dp[level];\\n        int ans = 0;\\n        \\n        // to maintain max of subarray\\n        int mx = 0;\\n        for(int i=0;i<k;i++){\\n            // if index goes out of bound\\n            if(level+i>=n) break;\\n            \\n            // maintaining max\\n            mx = max(mx,arr[level+i]);\\n            \\n            // transition -> parition from level to level+i, so now start subarray from level+i+1\\n            // we add mx*(i+1) as max of subarray from level to level+i is mx and its length is i+1\\n            ans = max(ans,mx*(i+1) +rec(level+i+1));\\n        }\\n        return dp[level] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& _arr, int _k) {\\n        arr = _arr;\\n        k = _k;\\n        n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> arr;\\n    int k;\\n    int n;\\n    \\n    // state - index\\n    int dp[505];\\n    \\n    int rec(int level){\\n        // base case\\n        if(level == n){\\n            return 0;\\n        }\\n        if(dp[level] != -1) return dp[level];\\n        int ans = 0;\\n        \\n        // to maintain max of subarray\\n        int mx = 0;\\n        for(int i=0;i<k;i++){\\n            // if index goes out of bound\\n            if(level+i>=n) break;\\n            \\n            // maintaining max\\n            mx = max(mx,arr[level+i]);\\n            \\n            // transition -> parition from level to level+i, so now start subarray from level+i+1\\n            // we add mx*(i+1) as max of subarray from level to level+i is mx and its length is i+1\\n            ans = max(ans,mx*(i+1) +rec(level+i+1));\\n        }\\n        return dp[level] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& _arr, int _k) {\\n        arr = _arr;\\n        k = _k;\\n        n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889336,
                "title": "recursion-linear-dp-solution-with-explanation",
                "content": "# 1. Recursion approach:\\n\\n=> Suppose that we have to conisder a subarray starting from ith index. \\n=> Lets consider ith element only (single element subarray) for the current subarray. Now, our problem gets reduced finding maximum sum from i + 1 to n - 1 (after partition).\\n\\nHence, the recurrence relation comes out to be equal to:\\nsubproblem1 = maximumOfOne + findSum(i + 1)\\nWhere maximumOfOne is the maximum element in the range i to i.\\n\\n=> Lets consider ith element and i + 1 element for the current subarray. Now, our problem gets reduced finding maximum sum from i + 2 to n - 1 (after partition).\\n\\nHence, the recurrence relation comes out to be equal to:\\nsubproblem2 = maximumOfTwo + findSum(i + 2)\\n\\nWhere maximumOfTwo is the maximum element in the range i to i + 1.\\n\\n................................................................................................................................................\\n\\n................................................................................................................................................\\n\\n................................................................................................................................................\\n\\n=> Lets consider ith element, i + 1, .. , i + k - 1 element for the current subarray. Now, our problem gets reduced finding maximum sum from i+ k to n - 1 (after partition).\\n\\nHence, the recurrence relation comes out to be equal to:\\nsubproblem= maximumOfCurrentSize + findSum(i + k)\\n\\nThus, we need to find and return maximum of (subproblem1, subproblem2, ...., subproblemk)\\n\\nTime Complexity: Exponential\\nSpace: Exponential\\n\\n**Source Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n```\\n\\n# 2. Dynamic Programming approach:\\n\\nThe program will produce TLE. Thus, we need to optimize our code. Note that we can solve this problem using dynamic programming. To solve a problem using dynamic programming it must fulfill two basic requirements:\\n\\n* Optimal Substructure\\n* Overlapping Subproblem\\n\\nIf you look closely you may notice that finding the maximum sum for elements from i = 0 to n - 1 has the same structure as finding the maximum sum for elements from i = 1 to i = n - 1, i = 2 to i = n - 1, and so on. Thus, Optimal Substructure exists in the problem.\\n\\n\\nAlso, suppose that we want to consider one element in the current subarray lets say arr[i] element. Now lets say again we want to consider only one element for the next subbary that is arr[i + 1]. Now we will call  findSum(i + 2) {That, is maximum sum after partition when elements from i + 2 to n - 1 are considered}.\\n\\nTaking another example, lets say we want to consider first two elements in the current subarray let say arr[i] and arr[i + 1].  So we will call  findSum(i + 2) {That, is maximum sum after partition when elements from i + 2 to n - 1 are considered}.\\n\\nAs you can see for the above two examples, we are calling findSum() function for the same parameter (i + 2). Hence, Overlapping Subproblem exists in the problem.\\n\\nThus, we can now think about a dynamic problem approach.\\n\\nThe simple way is to memoize the recursion approach as discussed above. We can create a 1D dp vector in which dp[i] stores the maximum sum after splitting when element from arr[i] to arr[n - 1] are considered.\\n\\n**Source Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n\\n```\\n\\nTime Complexity: O(N) as we are iterating over a 1D vector only.\\nSpace: O(N) as call stack is used\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428374,
                "title": "c-dp-7-lines",
                "content": "```\\n\\n```public:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            int m=0;\\n            int ans=0;\\n            for(int j=i-1;j>=0&&j>=i-k;j--)\\n            {\\n                m=max(m,arr[j]);\\n                ans=max(ans,m*(i-j)+dp[j]);\\n            }\\n            dp[i]=ans;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327920,
                "title": "nice-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int dp[500];\\n    int maxsum(vector<int>& arr,int  start, int k){\\n    \\n        if(start>=n) return 0;\\n        \\n        if(dp[start]!=-1) return dp[start];\\n        int temp=0;\\n        int ans=0;\\n        for(int i=start;i<n&&i<=start+k-1;i++){\\n            \\n            temp=max(temp,arr[i]);\\n            ans =max(ans, temp* (i-start+1)+ maxsum(arr,i+1,k) );\\n        }\\n        \\n        return  dp[start]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        \\n        for(int i=0;i<500;i++) dp[i]=-1;\\n        return maxsum(arr,0,k);\\n    }\\n};\\n```\\n\\n////writing iteratively \\n\\n\\n \\n```\\n \\n class Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[501]={};\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int temp=0;\\n            int ans=0;\\n            \\n            for(int j=i;j<min(n,i+k);j++){\\n               temp=max(temp,arr[j]);\\n                 \\n                ans=max(ans,temp*(j-i+1)+dp[j+1]);\\n            }\\n            dp[i]=ans;\\n        }\\n        \\n       return dp[0]; \\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int dp[500];\\n    int maxsum(vector<int>& arr,int  start, int k){\\n    \\n        if(start>=n) return 0;\\n        \\n        if(dp[start]!=-1) return dp[start];\\n        int temp=0;\\n        int ans=0;\\n        for(int i=start;i<n&&i<=start+k-1;i++){\\n            \\n            temp=max(temp,arr[i]);\\n            ans =max(ans, temp* (i-start+1)+ maxsum(arr,i+1,k) );\\n        }\\n        \\n        return  dp[start]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        \\n        for(int i=0;i<500;i++) dp[i]=-1;\\n        return maxsum(arr,0,k);\\n    }\\n};\\n```\n```\\n \\n class Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[501]={};\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int temp=0;\\n            int ans=0;\\n            \\n            for(int j=i;j<min(n,i+k);j++){\\n               temp=max(temp,arr[j]);\\n                 \\n                ans=max(ans,temp*(j-i+1)+dp[j+1]);\\n            }\\n            dp[i]=ans;\\n        }\\n        \\n       return dp[0]; \\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243253,
                "title": "c-dp-solution-tabulation-approach-by-kushalatolia",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0]=arr[0];\\n        int max1=arr[0];\\n        for(int i=1;i<k;i++)\\n        {\\n             max1=max(max1,arr[i]);\\n            dp[i]=max1*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            int subarraymax=arr[i];\\n            for(int subarraysize=1;subarraysize<=k;subarraysize++)\\n            {\\n                subarraymax=max(subarraymax,arr[i-subarraysize+1]);\\n                dp[i]=max(dp[i],dp[i-subarraysize]+(subarraymax*subarraysize));\\n            }\\n        }\\n                    return dp[n-1];\\n\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6af5e6b8-5e92-4659-bed8-cb26eaee1fc0_1622832389.5839505.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0]=arr[0];\\n        int max1=arr[0];\\n        for(int i=1;i<k;i++)\\n        {\\n             max1=max(max1,arr[i]);\\n            dp[i]=max1*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            int subarraymax=arr[i];\\n            for(int subarraysize=1;subarraysize<=k;subarraysize++)\\n            {\\n                subarraymax=max(subarraymax,arr[i-subarraysize+1]);\\n                dp[i]=max(dp[i],dp[i-subarraysize]+(subarraymax*subarraysize));\\n            }\\n        }\\n                    return dp[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106205,
                "title": "c-simple-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int K;\\n    int dp[501][501];\\n    int util(vector<int>& arr,int s,int e){\\n        if(s>e) return 0;\\n        if(s==e) return dp[s][e]=arr[s];\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        int ans=INT_MIN;\\n        int max_till_here=INT_MIN;\\n        for(int i=s;i<=min(s+K-1,e);i++){\\n            max_till_here=max(arr[i],max_till_here);\\n            ans=max((i-s+1)*max_till_here+util(arr,i+1,e),ans);\\n        }\\n        return dp[s][e]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        K=k;\\n        int n=arr.size();\\n        return util(arr,0,n-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int K;\\n    int dp[501][501];\\n    int util(vector<int>& arr,int s,int e){\\n        if(s>e) return 0;\\n        if(s==e) return dp[s][e]=arr[s];\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        int ans=INT_MIN;\\n        int max_till_here=INT_MIN;\\n        for(int i=s;i<=min(s+K-1,e);i++){\\n            max_till_here=max(arr[i],max_till_here);\\n            ans=max((i-s+1)*max_till_here+util(arr,i+1,e),ans);\\n        }\\n        return dp[s][e]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        K=k;\\n        int n=arr.size();\\n        return util(arr,0,n-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060832,
                "title": "c-recursion-with-memorization-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo(vector<int>& a,int i,int k,int K,int n,int maxi,int dp[][505])\\n    {\\n        if(i>=n)\\n            return 0;\\n        maxi=max(maxi,a[i]);\\n        if(k==K)\\n            return memo(a,i+1,1,K,n,0,dp)+(maxi*k);\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        return dp[i][k]=max(memo(a,i+1,k+1,K,n,maxi,dp),memo(a,i+1,1,K,n,0,dp)+(maxi*k));\\n    }\\n    int maxSumAfterPartitioning(vector<int>& a, int K) {\\n        int n=a.size();\\n        int dp[n+1][505];\\n        memset(dp,-1,sizeof(dp));\\n        return memo(a,0,1,K,n,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo(vector<int>& a,int i,int k,int K,int n,int maxi,int dp[][505])\\n    {\\n        if(i>=n)\\n            return 0;\\n        maxi=max(maxi,a[i]);\\n        if(k==K)\\n            return memo(a,i+1,1,K,n,0,dp)+(maxi*k);\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        return dp[i][k]=max(memo(a,i+1,k+1,K,n,maxi,dp),memo(a,i+1,1,K,n,0,dp)+(maxi*k));\\n    }\\n    int maxSumAfterPartitioning(vector<int>& a, int K) {\\n        int n=a.size();\\n        int dp[n+1][505];\\n        memset(dp,-1,sizeof(dp));\\n        return memo(a,0,1,K,n,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037520,
                "title": "easy-python-high-speed-3-approaches-o-k-space-complexity",
                "content": "**Easy Python | High Speed | 3 Approaches | O(k) space complexity**\\n\\n\\n**A) Pure Recursion + Memoization**\\n\\nSpace complexity: O(A)\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  {}\\n        \\n        def dp(i):\\n            \\n            if i==L:\\n                return 0\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                m     =  max(A[j],m)\\n                \\n                s     =  (j-i+1)*m + dp(j+1)\\n                \\n                best  =  max(best,s)\\n            \\n            memo[i] = best\\n            return best\\n        \\n        return dp(0)\\n```\\n\\n**B) Clean Array Building  (bottom-up Dynamic Programming)**\\n\\nSpace complexity: O(A)\\n\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(L+1) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                m    = max(m,A[j])\\n                s    = (j-i+1)*m + memo[j+1]\\n                best = max(best,s)\\n            \\n            memo[i] = best\\n        \\n        return memo[0]\\n```\\n\\n**C) High Speed, Reduced Memory Usage, Dynamic Programming (bottom-up)**\\n\\nSpace complexity: O(k)\\nTime complexity: O( A * k )\\n\\nLeetcode speed ratings of 90%+ are easily achievable.\\n\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(k) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                if A[j] > m:\\n                    m  = A[j]\\n                \\n                s  =  (j-i+1)*m + memo[(j+1)%k]\\n                \\n                if s > best:\\n                    best  =  s\\n            \\n            memo[i%k] = best\\n        \\n        return memo[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  {}\\n        \\n        def dp(i):\\n            \\n            if i==L:\\n                return 0\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                m     =  max(A[j],m)\\n                \\n                s     =  (j-i+1)*m + dp(j+1)\\n                \\n                best  =  max(best,s)\\n            \\n            memo[i] = best\\n            return best\\n        \\n        return dp(0)\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(L+1) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                m    = max(m,A[j])\\n                s    = (j-i+1)*m + memo[j+1]\\n                best = max(best,s)\\n            \\n            memo[i] = best\\n        \\n        return memo[0]\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(k) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                if A[j] > m:\\n                    m  = A[j]\\n                \\n                s  =  (j-i+1)*m + memo[(j+1)%k]\\n                \\n                if s > best:\\n                    best  =  s\\n            \\n            memo[i%k] = best\\n        \\n        return memo[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941440,
                "title": "cpp-recursion-memoisation-very-easy-to-understand-with-explanation",
                "content": "In this question we have two choices.\\n\\n1. For each index, start a new subarray and add the value we have\\n2. For each index, extend the same subarray but this subarray length must not be greater than k\\n\\n**The first Choice is **\\n\\tExtend the same subarray and keep a track of the maximum element in that subarray and previous start point of the same subarray.\\n\\t\\n\\t max(element, arr[current] ) this part will keep track of the the maximum element in a particular of window\\n\\tint option_a = solve(A, current + 1, prev,  max(element, arr[current] ) ); \\n\\n**The second choice**\\n\\nStart a new subarray and make sure to add the result of previous subarray window.\\n    **int option_a = element * (current -  prev) +  solve(A, current + 1, current,  arr[curent] )**\\t\\n\\t\\n\\tNow we are starting a new subarray at this point , so the only element we have is arr[current] and our starting window of this subarray is index current.\\n\\t\\n\\tNow we have two choices we have to find the maximum of them.\\n```\\nclass Solution {\\npublic:\\n  \\n    int dp[501][501];\\n  \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n      memset(dp, -1, sizeof dp);\\n      \\n      return solve(arr, 0, 0, k, arr[0]);\\n    }\\n  \\n    int solve(vector<int> &A, int i, int j, int k, int ele) {\\n      \\n      if(i - j > k)\\n        return INT_MIN;\\n      \\n      if(i == A.size())\\n        return ele*(i - j);\\n      \\n      if(dp[i][j] != -1)\\n        return dp[i][j];\\n      \\n      int opt_1 = solve(A, i + 1, j, k, max(A[i], ele));\\n      int opt_2 = ele*(i - j)  + solve(A, i + 1, i, k, A[i]);\\n      \\n      return dp[i][j] =  max(opt_1, opt_2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int dp[501][501];\\n  \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n      memset(dp, -1, sizeof dp);\\n      \\n      return solve(arr, 0, 0, k, arr[0]);\\n    }\\n  \\n    int solve(vector<int> &A, int i, int j, int k, int ele) {\\n      \\n      if(i - j > k)\\n        return INT_MIN;\\n      \\n      if(i == A.size())\\n        return ele*(i - j);\\n      \\n      if(dp[i][j] != -1)\\n        return dp[i][j];\\n      \\n      int opt_1 = solve(A, i + 1, j, k, max(A[i], ele));\\n      int opt_2 = ele*(i - j)  + solve(A, i + 1, i, k, A[i]);\\n      \\n      return dp[i][j] =  max(opt_1, opt_2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901220,
                "title": "python-short-and-simple-top-down-dp-explained",
                "content": "**Thoughts:**\\nAt each index there are at most two choices:\\n1. Continue extending the subarray if the current subarray is shorter than k.\\n2. Start a new subarray and add max(subbarray) &middot; len(subarray) to the total.\\n\\nA recursive function is used to try both options and the result of each option is added to **choices**.  \\nThen take the choice that has the highest total.  \\n\\n<br>\\n\\n**Notes:**\\nj is the end of the current subarray and i is the beginning of the current subarray\\nwe use j and i to keep track of the length of the subarray\\nmaxi is the maximum value in the current subarray\\n\\n<br>\\n\\n**Written for readability:**\\n```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\n\\tif k == 1: return sum(A)\\n\\tif k == len(A): return len(A)*max(A)\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tnonlocal k\\n\\t\\t\\n\\t\\t# reached the end of the array, we must close the current subarray\\n\\t\\tif j == len(A):\\n\\t\\t\\treturn maxi * (j - i)\\n\\n\\t\\tchoices = []\\n\\n\\t\\t# choice 1: extend subarray\\n\\t\\tif (j - i) < k:\\n\\t\\t\\tchoices.append(helper(j+1, max(A[j], maxi), i))\\n\\n\\t\\t# choice 2: start a new subarray\\n\\t\\tchoices.append(maxi * (j - i) + helper(j+1, A[j], j))\\n\\n\\t\\treturn max(choices)\\n\\n\\treturn helper(1, A[0], 0)\\n```\\n\\n<br>\\n\\n**More Concicely:**\\n```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tif j - i > k: return float(\\'-inf\\')\\n\\t\\tif j == len(A): return maxi * (j - i)\\n\\t\\treturn max(maxi * (j - i) + helper(j+1, A[j], j), helper(j+1, max(A[j], maxi), i))\\n\\treturn helper(1, A[0], 0)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\n\\tif k == 1: return sum(A)\\n\\tif k == len(A): return len(A)*max(A)\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tnonlocal k\\n\\t\\t\\n\\t\\t# reached the end of the array, we must close the current subarray\\n\\t\\tif j == len(A):\\n\\t\\t\\treturn maxi * (j - i)\\n\\n\\t\\tchoices = []\\n\\n\\t\\t# choice 1: extend subarray\\n\\t\\tif (j - i) < k:\\n\\t\\t\\tchoices.append(helper(j+1, max(A[j], maxi), i))\\n\\n\\t\\t# choice 2: start a new subarray\\n\\t\\tchoices.append(maxi * (j - i) + helper(j+1, A[j], j))\\n\\n\\t\\treturn max(choices)\\n\\n\\treturn helper(1, A[0], 0)\\n```\n```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tif j - i > k: return float(\\'-inf\\')\\n\\t\\tif j == len(A): return maxi * (j - i)\\n\\t\\treturn max(maxi * (j - i) + helper(j+1, A[j], j), helper(j+1, max(A[j], maxi), i))\\n\\treturn helper(1, A[0], 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 842464,
                "title": "recursion-memoization-approach-with-full-explanation",
                "content": "**Idea:**\\n* Think this way, how much is the maximum sum obtained from index `i`? This can be calculated recursively. And we can expand the window k times before going to any recursion.\\n* Whatever is the result obtained from the recursion, add it with `current window\\'s maximum x window size`\\n* cache the computation, so that it can be used in future recursions.\\n\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        Map<Integer, Integer> cache = new HashMap<>();\\n        return helper(arr, k, 0, cache);\\n    }\\n    \\n    private int helper(int[] arr, int k, int idx, Map<Integer, Integer> cache) {\\n        if (idx == arr.length) {\\n            return 0;\\n            \\n        } else if (cache.containsKey(idx)) {\\n            return cache.get(idx);\\n            \\n        }\\n        \\n        int maxSoFar = 0,\\n            maxSumSoFar = 0;\\n        \\n        for (int i = idx; i < idx + k && i < arr.length; i++) {\\n            maxSoFar = Math.max(maxSoFar, arr[i]);\\n            maxSumSoFar = Math.max(maxSumSoFar, maxSoFar*(i - idx + 1) + helper(arr, k, i+1, cache));\\n        }\\n        \\n        cache.put(idx, maxSumSoFar);\\n        return maxSumSoFar;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        Map<Integer, Integer> cache = new HashMap<>();\\n        return helper(arr, k, 0, cache);\\n    }\\n    \\n    private int helper(int[] arr, int k, int idx, Map<Integer, Integer> cache) {\\n        if (idx == arr.length) {\\n            return 0;\\n            \\n        } else if (cache.containsKey(idx)) {\\n            return cache.get(idx);\\n            \\n        }\\n        \\n        int maxSoFar = 0,\\n            maxSumSoFar = 0;\\n        \\n        for (int i = idx; i < idx + k && i < arr.length; i++) {\\n            maxSoFar = Math.max(maxSoFar, arr[i]);\\n            maxSumSoFar = Math.max(maxSumSoFar, maxSoFar*(i - idx + 1) + helper(arr, k, i+1, cache));\\n        }\\n        \\n        cache.put(idx, maxSumSoFar);\\n        return maxSumSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797535,
                "title": "javascript-solution-top-down-approach-with-memoization-and-dynamic-programming-approach",
                "content": "**Top Down with Memoization**\\n\\n```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const memo = new Map();\\n    \\n    return findMaxSum(n - 1, 0, 0);\\n    \\n    function findMaxSum(index, maxVal, k) {\\n        const key = `${index}#${maxVal}#${k}`;\\n        \\n        // base case\\n        if (index < 0) return k * maxVal;\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let include = 0;\\n        let partition = 0;\\n        \\n        if (k < K) {\\n            include = findMaxSum(index - 1, Math.max(maxVal, A[index]), k + 1);\\n        }\\n        \\n        partition = (k * maxVal) + findMaxSum(index - 1, A[index], 1);\\n        \\n        const max = Math.max(partition, include);\\n        memo.set(key, max);\\n        \\n        return max;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n**Bottom Up (Dynamic Programming) Approach**\\n\\n```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const dp = new Array(n + 1).fill(0);\\n    dp[0] = 0;\\n    dp[1] = A[0];\\n    \\n    for (let i = 2; i <= n; i++) {\\n        let maxVal = A[i - 1];\\n        dp[i] = maxVal + dp[i - 1];\\n        \\n        for (let j = i - 1; j > 0 && i - j + 1 <= K; j--) {\\n            maxVal = Math.max(A[j - 1], maxVal);\\n            \\n            const len = i - j + 1;\\n            \\n            dp[i] = Math.max((len * maxVal) + dp[j - 1], dp[i]);\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const memo = new Map();\\n    \\n    return findMaxSum(n - 1, 0, 0);\\n    \\n    function findMaxSum(index, maxVal, k) {\\n        const key = `${index}#${maxVal}#${k}`;\\n        \\n        // base case\\n        if (index < 0) return k * maxVal;\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let include = 0;\\n        let partition = 0;\\n        \\n        if (k < K) {\\n            include = findMaxSum(index - 1, Math.max(maxVal, A[index]), k + 1);\\n        }\\n        \\n        partition = (k * maxVal) + findMaxSum(index - 1, A[index], 1);\\n        \\n        const max = Math.max(partition, include);\\n        memo.set(key, max);\\n        \\n        return max;\\n    }\\n};\\n```\n```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const dp = new Array(n + 1).fill(0);\\n    dp[0] = 0;\\n    dp[1] = A[0];\\n    \\n    for (let i = 2; i <= n; i++) {\\n        let maxVal = A[i - 1];\\n        dp[i] = maxVal + dp[i - 1];\\n        \\n        for (let j = i - 1; j > 0 && i - j + 1 <= K; j--) {\\n            maxVal = Math.max(A[j - 1], maxVal);\\n            \\n            const len = i - j + 1;\\n            \\n            dp[i] = Math.max((len * maxVal) + dp[j - 1], dp[i]);\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777041,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int k) {\\n        int n = A.size();\\n        vector<int> dp(n);\\n        dp[0] = A[0];\\n        for(int i = 1; i < n; i++) {\\n            int mx = A[i];\\n            int curr = INT_MIN;\\n            for(int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                mx = max(mx, A[i - j + 1]);\\n                if(i - j + 1 == 0)\\n                    curr = max(curr, j * mx);\\n                else\\n                    curr = max(curr, dp[i - j] + j * mx);\\n            }\\n            dp[i] = curr;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int k) {\\n        int n = A.size();\\n        vector<int> dp(n);\\n        dp[0] = A[0];\\n        for(int i = 1; i < n; i++) {\\n            int mx = A[i];\\n            int curr = INT_MIN;\\n            for(int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                mx = max(mx, A[i - j + 1]);\\n                if(i - j + 1 == 0)\\n                    curr = max(curr, j * mx);\\n                else\\n                    curr = max(curr, dp[i - j] + j * mx);\\n            }\\n            dp[i] = curr;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957717,
                "title": "python-91-42-faster-dp-memo-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            return maxAns\\n        n=len(arr)\\n        return solve(0)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n) + O(n)\\nclass Solution2:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            dp[ind]=maxAns\\n            return dp[ind]\\n        n=len(arr)\\n        dp=[-1]*n\\n        return solve(0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+dp[j+1]\\n                maxAns=max(maxAns,s)An upvotew will be encouraging\\n            dp[ind]=maxAns        \\n        return dp[0]\\n```\\n**An upvotew will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            return maxAns\\n        n=len(arr)\\n        return solve(0)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n) + O(n)\\nclass Solution2:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            dp[ind]=maxAns\\n            return dp[ind]\\n        n=len(arr)\\n        dp=[-1]*n\\n        return solve(0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+dp[j+1]\\n                maxAns=max(maxAns,s)An upvotew will be encouraging\\n            dp[ind]=maxAns        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422938,
                "title": "c-90-fast-dp-memoization-tabulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int k, int i, vector<int> &DP){\\n        if(i >= arr.size()) return 0;\\n        if(DP[i] != -1) return DP[i];\\n\\n        int maxi = -1, ans = -1;\\n        for(int j=i; j < arr.size() && j < i + k; j++){\\n            maxi = max(maxi, arr[j]);\\n            int len = j - i + 1;\\n\\n            ans = max(ans, len*maxi + solve(arr, k, j+1, DP));\\n        }\\n\\n        return DP[i] = ans;\\n    }\\n\\n    int solveTab(vector<int>& arr, int k){\\n        vector<int> DP(arr.size()+1, 0);\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int maxi = -1, ans = -1;\\n            for(int j=i; j < arr.size() && j < i + k; j++){\\n                maxi = max(maxi, arr[j]);\\n                int len = j - i + 1;\\n\\n                ans = max(ans, len*maxi + DP[j+1]);\\n            }\\n\\n            DP[i] = ans;\\n        }\\n\\n        return DP[0];\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        // vector<int> DP(arr.size(), -1);\\n        // return solve(arr, k, 0, DP);\\n\\n        return solveTab(arr, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int k, int i, vector<int> &DP){\\n        if(i >= arr.size()) return 0;\\n        if(DP[i] != -1) return DP[i];\\n\\n        int maxi = -1, ans = -1;\\n        for(int j=i; j < arr.size() && j < i + k; j++){\\n            maxi = max(maxi, arr[j]);\\n            int len = j - i + 1;\\n\\n            ans = max(ans, len*maxi + solve(arr, k, j+1, DP));\\n        }\\n\\n        return DP[i] = ans;\\n    }\\n\\n    int solveTab(vector<int>& arr, int k){\\n        vector<int> DP(arr.size()+1, 0);\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int maxi = -1, ans = -1;\\n            for(int j=i; j < arr.size() && j < i + k; j++){\\n                maxi = max(maxi, arr[j]);\\n                int len = j - i + 1;\\n\\n                ans = max(ans, len*maxi + DP[j+1]);\\n            }\\n\\n            DP[i] = ans;\\n        }\\n\\n        return DP[0];\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        // vector<int> DP(arr.size(), -1);\\n        // return solve(arr, k, 0, DP);\\n\\n        return solveTab(arr, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419083,
                "title": "c-dp-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int dp[n];\\n        int maxOfThree = arr[0];\\n\\n        for(int i = 0; i < k; i++)\\n        {\\n            maxOfThree = max(arr[i], maxOfThree);\\n            dp[i] = (maxOfThree*(i+1));\\n        }\\n        for(int i = k; i < n; i++)\\n        {\\n            maxOfThree = arr[i];\\n            dp[i] = maxOfThree + dp[i-1];\\n\\n            for(int j = i-1; j > i-k; j--)\\n            {\\n                maxOfThree = max(maxOfThree,arr[j]); \\n                dp[i] = max(dp[i], dp[j-1] + (i-j+1)*maxOfThree);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int dp[n];\\n        int maxOfThree = arr[0];\\n\\n        for(int i = 0; i < k; i++)\\n        {\\n            maxOfThree = max(arr[i], maxOfThree);\\n            dp[i] = (maxOfThree*(i+1));\\n        }\\n        for(int i = k; i < n; i++)\\n        {\\n            maxOfThree = arr[i];\\n            dp[i] = maxOfThree + dp[i-1];\\n\\n            for(int j = i-1; j > i-k; j--)\\n            {\\n                maxOfThree = max(maxOfThree,arr[j]); \\n                dp[i] = max(dp[i], dp[j-1] + (i-j+1)*maxOfThree);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318861,
                "title": "c-dp-memoization-tabulation",
                "content": "Here is my c++ code for this problem.\\n\\n# Memoization\\n# Complexity\\n- Time complexity:$$O(n*k)$$\\n\\n- Space complexity:$$O(n)+O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, int n, vector<int>&dp, vector<int>&arr){\\n        if(i==arr.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi=INT_MIN, ans=INT_MIN, l=0;\\n        for(int j=i; j<min(n, k+i); j++){\\n            l++;\\n            maxi=max(maxi, arr[j]);\\n            int cnt=l*maxi+f(j+1, k, n, dp, arr);\\n            ans=max(ans, cnt);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n, -1);\\n        return f(0, k, n, dp, arr);\\n    }\\n};\\n```\\n# Tabulation\\n# Complexity\\n- Time complexity:$$O(n*k)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            int ans=INT_MIN, maxi=INT_MIN, l=0;\\n            for(int j=i; j<min(n, i+k); j++){\\n                l++;\\n                maxi=max(maxi, arr[j]);\\n                int cnt=l*maxi+dp[j+1];\\n                ans=max(ans, cnt);\\n            }\\n            dp[i]=ans;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int k, int n, vector<int>&dp, vector<int>&arr){\\n        if(i==arr.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi=INT_MIN, ans=INT_MIN, l=0;\\n        for(int j=i; j<min(n, k+i); j++){\\n            l++;\\n            maxi=max(maxi, arr[j]);\\n            int cnt=l*maxi+f(j+1, k, n, dp, arr);\\n            ans=max(ans, cnt);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n, -1);\\n        return f(0, k, n, dp, arr);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            int ans=INT_MIN, maxi=INT_MIN, l=0;\\n            for(int j=i; j<min(n, i+k); j++){\\n                l++;\\n                maxi=max(maxi, arr[j]);\\n                int cnt=l*maxi+dp[j+1];\\n                ans=max(ans, cnt);\\n            }\\n            dp[i]=ans;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901589,
                "title": "python-easy-and-beautiful-dfs-cache",
                "content": "```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        @cache\\n        def dfs(i):\\n            if i == len(arr):\\n                return 0\\n\\n            m = 0\\n            v = arr[i]\\n\\n            for j in range(i, min(i + k, len(arr))):\\n                v = max(v, arr[j])   \\n                n = j - i + 1\\n                m = max(m, dfs(j + 1) + v*n)\\n\\n            return m\\n\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        @cache\\n        def dfs(i):\\n            if i == len(arr):\\n                return 0\\n\\n            m = 0\\n            v = arr[i]\\n\\n            for j in range(i, min(i + k, len(arr))):\\n                v = max(v, arr[j])   \\n                n = j - i + 1\\n                m = max(m, dfs(j + 1) + v*n)\\n\\n            return m\\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642654,
                "title": "easy-cpp-solution-based-on-matrix-chain-multiplication-approach",
                "content": "**Recursive approach (gives TLE):**\\n```\\n\\tint solve(vector<int>&arr,int i,int j,int k){\\n        if(i>j)return 0;\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        return solve(arr,0,n-1,k);\\n    }\\n```\\n\\n**Memoized approach (Accepted):**\\n```\\n\\tint solve(vector<int>&arr,int i,int j,int k,vector<vector<int>>&memo){\\n        if(i>j)return 0;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k,memo);\\n            maxans=max(maxans,sum);\\n        }\\n        return memo[i][j]=maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<vector<int>>memo(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,k,memo);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint solve(vector<int>&arr,int i,int j,int k){\\n        if(i>j)return 0;\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        return solve(arr,0,n-1,k);\\n    }\\n```\n```\\n\\tint solve(vector<int>&arr,int i,int j,int k,vector<vector<int>>&memo){\\n        if(i>j)return 0;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k,memo);\\n            maxans=max(maxans,sum);\\n        }\\n        return memo[i][j]=maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<vector<int>>memo(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,k,memo);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515946,
                "title": "best-solution-easy-approch-from-scratch",
                "content": "# Memoisation :\\n```\\nclass Solution:\\n    def f(self,ind,arr,n,k,dp):\\n        if ind==n:\\n            return 0\\n        if dp[ind]!=-1:\\n            return dp[ind]\\n        maxi=float(\"-inf\")\\n        length=0\\n        maxans=float(\"-inf\")\\n        for j in range(ind,min(n,ind+k)):       #j for partition\\n            length+=1\\n            maxi=max(maxi,arr[j])\\n            summ=length*maxi + self.f(j+1,arr,n,k,dp)\\n            maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[ind]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1 for i in range(n)]\\n        return self.f(0,arr,n,k,dp)\\n```\\n\\n# Tabulation : Accepted\\n```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[0]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            maxi=float(\"-inf\")\\n            length=0\\n            maxans=float(\"-inf\")\\n            for j in range(ind,min(n,ind+k)):       #j for partition\\n                length+=1\\n                maxi=max(maxi,arr[j])\\n                summ=length*maxi + dp[j+1]\\n                maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[0]\\n```\\n\\n# Upvote if you liked",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,ind,arr,n,k,dp):\\n        if ind==n:\\n            return 0\\n        if dp[ind]!=-1:\\n            return dp[ind]\\n        maxi=float(\"-inf\")\\n        length=0\\n        maxans=float(\"-inf\")\\n        for j in range(ind,min(n,ind+k)):       #j for partition\\n            length+=1\\n            maxi=max(maxi,arr[j])\\n            summ=length*maxi + self.f(j+1,arr,n,k,dp)\\n            maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[ind]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1 for i in range(n)]\\n        return self.f(0,arr,n,k,dp)\\n```\n```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[0]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            maxi=float(\"-inf\")\\n            length=0\\n            maxans=float(\"-inf\")\\n            for j in range(ind,min(n,ind+k)):       #j for partition\\n                length+=1\\n                maxi=max(maxi,arr[j])\\n                summ=length*maxi + dp[j+1]\\n                maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423344,
                "title": "memoization-tabulation-front-partition-dp-java",
                "content": "1. Memoization\\nTn : O(n^2)\\nSn : O(n) + O(n)\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }\\n        return partitionsum(0, N ,arr,k,dp);\\n    }\\n    int partitionsum(int ind, int N, int []arr,int k,int[]dp){\\n        if(ind == N){\\n            return 0;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int maxi = -(int)1e7;\\n        int len=0;\\n        int maxSum = -(int)1e7;\\n        for(int j=ind;j<Math.min(N, ind+k);j++){\\n            len++;\\n            maxi = Math.max(arr[j],maxi);\\n            int sum = (len*maxi) + partitionsum(j+1,N,arr,k,dp);\\n            maxSum = Math.max(sum,maxSum);\\n        }\\n        dp[ind] = maxSum;\\n        return dp[ind];\\n    }\\n}\\n```\\n2. Tabulation\\nTn : O(n^2)\\nSn:O(n)\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N+1];\\n        for(int i=0;i<N+1;i++){\\n            dp[i] = 0;\\n        }\\n        for(int ind = N-1;ind>=0;ind--){\\n            int maxi = -(int)1e7;\\n            int len=0;\\n            int maxSum = -(int)1e7;\\n            for(int j=ind;j<Math.min(N, ind+k);j++){\\n                len++;\\n                maxi = Math.max(arr[j],maxi);\\n                int sum = (len*maxi) + dp[j+1];\\n                maxSum = Math.max(sum,maxSum);\\n            }\\n            dp[ind] = maxSum;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }\\n        return partitionsum(0, N ,arr,k,dp);\\n    }\\n    int partitionsum(int ind, int N, int []arr,int k,int[]dp){\\n        if(ind == N){\\n            return 0;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int maxi = -(int)1e7;\\n        int len=0;\\n        int maxSum = -(int)1e7;\\n        for(int j=ind;j<Math.min(N, ind+k);j++){\\n            len++;\\n            maxi = Math.max(arr[j],maxi);\\n            int sum = (len*maxi) + partitionsum(j+1,N,arr,k,dp);\\n            maxSum = Math.max(sum,maxSum);\\n        }\\n        dp[ind] = maxSum;\\n        return dp[ind];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N+1];\\n        for(int i=0;i<N+1;i++){\\n            dp[i] = 0;\\n        }\\n        for(int ind = N-1;ind>=0;ind--){\\n            int maxi = -(int)1e7;\\n            int len=0;\\n            int maxSum = -(int)1e7;\\n            for(int j=ind;j<Math.min(N, ind+k);j++){\\n                len++;\\n                maxi = Math.max(arr[j],maxi);\\n                int sum = (len*maxi) + dp[j+1];\\n                maxSum = Math.max(sum,maxSum);\\n            }\\n            dp[ind] = maxSum;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324223,
                "title": "simple-c-memoization-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> dp;\\n    int fun(int idx,vector<int>& arr,int k){\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int m = -1, sum = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            if(i+idx >= arr.size())\\n                continue;\\n            \\n            m = max(m,arr[i+idx]);\\n            sum = max(sum, (m*(i+1)) + fun(idx+i+1,arr,k));\\n        }\\n        \\n        return dp[idx] = sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        dp = vector<int> (arr.size()+1,-1);\\n        return fun(0,arr,k);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> dp;\\n    int fun(int idx,vector<int>& arr,int k){\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int m = -1, sum = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            if(i+idx >= arr.size())\\n                continue;\\n            \\n            m = max(m,arr[i+idx]);\\n            sum = max(sum, (m*(i+1)) + fun(idx+i+1,arr,k));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2226191,
                "title": "c-well-explained-recursion-memo-mcm-variation",
                "content": "so here we want to partition array in subarrays having size not more than k , therefore as we want to check for all subarrays having size 1,2,3.......k => this means that we will have to explore all paths through recursion , and as we have to partition , then our mind should automatically think of MCM pattern .\\n\\nBASE CASE : \\nas we start from 0th index therefore when we will go out of array , then return 0;\\n ```\\n if(index>=n)\\n            return 0;\\n```\\n\\t\\t\\t\\nRECURRENCE RELATION:\\n\\nso as the subarray \\'s sum will be its ( max element * length of subarray ) , therefore we will keep a track of length , maxElement of subarray , and our ans , which will be total sum of the array after partionting .\\n\\nnow we will see from where should we start our for loop , as we can have a subarray of size 1 , therefore we will start at index . Now as we know that we cant have a subrray size of more than k , therefore the loop will run till the minimum of index+k and n (size. of arr) , so that we check if it doesnt go out of bound .\\n\\n```\\n int len=0;\\n        int maxElement=INT_MIN;\\n        int ans=INT_MIN;\\n        \\n        for(int j=index ; j<min(n,index+k)  ;j++){\\n            len++;\\n            maxElement=max(maxElement,arr[j]);\\n            \\n            int sum=len*maxElement+solve(arr,k,j+1,n);\\n            \\n            ans=max(ans,sum);\\n            \\n        }\\n        \\n        return ans;\\n```\\nand we will update the length , maxelement , and for every value of j , at last we will compare the sum of the whole array after partitioning , with our answer\\n\\n\\nTIME COMPLEXITY: exponential \\nSPACE COMPLEXITY: O(N)   =>auxillary stack space  \\n\\nafter memoization:\\nTIME COMPLEXITY:  O(N) * O(K)\\n```\\nSPACE COMPLEXITY: O(N)      +        O(N)\\n                |                         |\\n               ^                        ^\\n        1D DP ARRAY \\t  AUXILLARY STACK SPACE\\n\\t\\t\\t\\t\\t\\t\\n```\\n\\n\\nMEMOIZED CODE:\\n```\\nclass Solution {\\npublic:\\n     int t[501];\\n    int solve(vector<int>& arr, int k,int index,int n){\\n        if(index>=n)\\n            return 0;\\n        \\n        int len=0;\\n        int maxElement=INT_MIN;\\n        int ans=INT_MIN;\\n        \\n        if(t[index]!=-1)\\n            return t[index];\\n        for(int j=index ; j<min(n,index+k)  ;j++){\\n            len++;\\n            maxElement=max(maxElement,arr[j]);\\n            \\n            int sum=len*maxElement+solve(arr,k,j+1,n);\\n            \\n            ans=max(ans,sum);\\n            \\n        }\\n        \\n        return t[index]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        memset(t,-1,sizeof(t));\\n        return solve(arr,k,0,n);\\n    }\\n};\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n if(index>=n)\\n            return 0;\\n```\n```\\n int len=0;\\n        int maxElement=INT_MIN;\\n        int ans=INT_MIN;\\n        \\n        for(int j=index ; j<min(n,index+k)  ;j++){\\n            len++;\\n            maxElement=max(maxElement,arr[j]);\\n            \\n            int sum=len*maxElement+solve(arr,k,j+1,n);\\n            \\n            ans=max(ans,sum);\\n            \\n        }\\n        \\n        return ans;\\n```\n```\\nSPACE COMPLEXITY: O(N)      +        O(N)\\n                |                         |\\n               ^                        ^\\n        1D DP ARRAY \\t  AUXILLARY STACK SPACE\\n\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184421,
                "title": "java-recursive-memoization-tabulation",
                "content": "**Recursive Solution**\\n\\n```\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            return f(num, k, 0, n);\\n        }\\n        public int f (int[] num, int k, int i, int n) {\\n            if (i == n)\\n                return 0;\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return maxSum;\\n        }\\n    }\\n```\\n\\nTime Complexity : Exponential\\nSpace Complexity : O(N) (auxilary stack space)\\n\\n**Memoization (Top-down DP)**\\n\\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n];\\n            Arrays.fill(dp, -1);\\n            return f(num, k, 0, n, dp);\\n        }\\n        public int f (int[] num, int k, int i, int n, int[] dp) {\\n            if (i == n)\\n                return 0;\\n            if (dp[i] != -1)\\n                return dp[i];\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n, dp);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return dp[i] = maxSum;\\n        }\\n    }\\n```\\n\\nTime Complexity : O(N + k)\\nSpace Complexity : O(N) + O(N) (auxilary stack space)\\n\\n**Tabulation (Bottom-up DP)**\\n\\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n + 1];\\n            for (int i = n - 1; i >= 0; i--) {\\n                int maxSum = Integer.MIN_VALUE;\\n                int len = 0;\\n                int maxi = Integer.MIN_VALUE;\\n                for (int j = i; j < Math.min(n, i + k); j++) {\\n                    len++;\\n                    maxi = Math.max(maxi, num[j]);\\n                    int sum = (len * maxi) + dp[j + 1];\\n                    maxSum = Math.max(maxSum, sum);\\n                }\\n                dp[i] = maxSum;\\n            }\\n            return dp[0];\\n        }\\n    }\\n```\\n\\nTime Complexity : O(N + k)\\nSpace Complexity : O(N)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            return f(num, k, 0, n);\\n        }\\n        public int f (int[] num, int k, int i, int n) {\\n            if (i == n)\\n                return 0;\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return maxSum;\\n        }\\n    }\\n```\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n];\\n            Arrays.fill(dp, -1);\\n            return f(num, k, 0, n, dp);\\n        }\\n        public int f (int[] num, int k, int i, int n, int[] dp) {\\n            if (i == n)\\n                return 0;\\n            if (dp[i] != -1)\\n                return dp[i];\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n, dp);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return dp[i] = maxSum;\\n        }\\n    }\\n```\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n + 1];\\n            for (int i = n - 1; i >= 0; i--) {\\n                int maxSum = Integer.MIN_VALUE;\\n                int len = 0;\\n                int maxi = Integer.MIN_VALUE;\\n                for (int j = i; j < Math.min(n, i + k); j++) {\\n                    len++;\\n                    maxi = Math.max(maxi, num[j]);\\n                    int sum = (len * maxi) + dp[j + 1];\\n                    maxSum = Math.max(maxSum, sum);\\n                }\\n                dp[i] = maxSum;\\n            }\\n            return dp[0];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105488,
                "title": "c-o-n-k-bottom-up-top-down",
                "content": "recursion + memoization\\n```\\nclass Solution {\\nprivate:\\n    int findMaxSum(vector<int>& arr, int n, int idx, int k, vector<int>& dp){\\n        if(idx >= n)\\n            return 0;\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int sum = 0, maxTillNow = 0, len = 0;\\n        for(int i = idx; i < min(n, idx + k); ++i){\\n            ++len;\\n            maxTillNow = max(maxTillNow, arr[i]);\\n            int cost = maxTillNow * len + findMaxSum(arr, n, i + 1, k, dp);\\n            \\n            sum = max(sum, cost);\\n        }\\n        \\n        return dp[idx] = sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int > dp(n + 1, -1);\\n        int maxSum = findMaxSum(arr, n, 0, k, dp);\\n        \\n        return maxSum;\\n    }\\n};\\n```\\n\\njust a shuttle change in the recursive code and you are able to do tabulation dp\\nand it will also reduces the auxilary stack space.\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int> dp(n + 1, 0);\\n        for(int idx = n - 1; idx >= 0; --idx){\\n            int len = 0;\\n            int maxTillNow = 0;\\n            \\n            int sum = 0;\\n            for(int j = idx; j < min(n, idx + k); ++j){\\n                ++len;\\n                maxTillNow = max(maxTillNow, arr[j]);\\n                \\n                int cost = len * maxTillNow + dp[j + 1];\\n                sum = max(sum, cost);\\n            }\\n            \\n            dp[idx] = sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\nupvote if you like :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int findMaxSum(vector<int>& arr, int n, int idx, int k, vector<int>& dp){\\n        if(idx >= n)\\n            return 0;\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int sum = 0, maxTillNow = 0, len = 0;\\n        for(int i = idx; i < min(n, idx + k); ++i){\\n            ++len;\\n            maxTillNow = max(maxTillNow, arr[i]);\\n            int cost = maxTillNow * len + findMaxSum(arr, n, i + 1, k, dp);\\n            \\n            sum = max(sum, cost);\\n        }\\n        \\n        return dp[idx] = sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int > dp(n + 1, -1);\\n        int maxSum = findMaxSum(arr, n, 0, k, dp);\\n        \\n        return maxSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int> dp(n + 1, 0);\\n        for(int idx = n - 1; idx >= 0; --idx){\\n            int len = 0;\\n            int maxTillNow = 0;\\n            \\n            int sum = 0;\\n            for(int j = idx; j < min(n, idx + k); ++j){\\n                ++len;\\n                maxTillNow = max(maxTillNow, arr[j]);\\n                \\n                int cost = len * maxTillNow + dp[j + 1];\\n                sum = max(sum, cost);\\n            }\\n            \\n            dp[idx] = sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041761,
                "title": "python-sol-well-explained-easy-recursion-memo",
                "content": "# EXPLANATION\\n\\n\\n```\\nWe will try to make every unique pairs of subarrays possible\\n\\nWe can se we have a choice to either continue the subarray or create new , this gives the idea\\nof DP ( multiple recursions are happending)\\n\\nNow dp needs recursion and memoization\\n\\nRecursion requires recursive cases and base case\\n\\nRECURSIVE CASES\\n\\nFor every index we have two choices:\\n1. Continue the subarray \\n2. Break the subarray and start a new one\\n\\nfor 1st case we can continue if and only if size of subarray is less than k\\n\\nBASE CASE\\n\\nWhen index == len(arr) : we return max in subarray * size of subarray\\n\\nMEMOIZATION\\nNow all we need to do is to apply DP memoization\\nwe memoize the parameters which are variable (changing) \\n```\\n\\n# CODE\\n\\n```\\nclass Solution:\\n    def recursion(self,idx,arr,n,maxx,size,k):\\n        if idx == n:\\n            return maxx * size  \\n        if (idx,size,maxx) in self.dp: return self.dp[(idx,size,maxx)]\\n        ch1 = self.recursion(idx+1,arr,n,max(maxx,arr[idx]),size+1,k) if size < k else 0\\n        ch2 = self.recursion(idx+1,arr,n,arr[idx],1,k) + maxx*size\\n        best = ch1 if ch1 > ch2 else ch2\\n        self.dp[(idx,size,maxx)] = best\\n        return best\\n        \\n        \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # we will try partitioning in every way possible\\n        self.dp = {}\\n        return self.recursion(1,arr,len(arr),arr[0],1,k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nWe will try to make every unique pairs of subarrays possible\\n\\nWe can se we have a choice to either continue the subarray or create new , this gives the idea\\nof DP ( multiple recursions are happending)\\n\\nNow dp needs recursion and memoization\\n\\nRecursion requires recursive cases and base case\\n\\nRECURSIVE CASES\\n\\nFor every index we have two choices:\\n1. Continue the subarray \\n2. Break the subarray and start a new one\\n\\nfor 1st case we can continue if and only if size of subarray is less than k\\n\\nBASE CASE\\n\\nWhen index == len(arr) : we return max in subarray * size of subarray\\n\\nMEMOIZATION\\nNow all we need to do is to apply DP memoization\\nwe memoize the parameters which are variable (changing) \\n```\n```\\nclass Solution:\\n    def recursion(self,idx,arr,n,maxx,size,k):\\n        if idx == n:\\n            return maxx * size  \\n        if (idx,size,maxx) in self.dp: return self.dp[(idx,size,maxx)]\\n        ch1 = self.recursion(idx+1,arr,n,max(maxx,arr[idx]),size+1,k) if size < k else 0\\n        ch2 = self.recursion(idx+1,arr,n,arr[idx],1,k) + maxx*size\\n        best = ch1 if ch1 > ch2 else ch2\\n        self.dp[(idx,size,maxx)] = best\\n        return best\\n        \\n        \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # we will try partitioning in every way possible\\n        self.dp = {}\\n        return self.recursion(1,arr,len(arr),arr[0],1,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919540,
                "title": "c-recursive-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&arr,int idx,vector<int>&dp,int k){\\n        if(idx==arr.size())\\n            return 0;\\n        else if(dp[idx]!=0)\\n            return dp[idx];\\n        else{\\n            int res=-1;\\n            for(int i=idx;i<arr.size()&&i<idx+k;i++){\\n                res=max(res,arr[i]);\\n                if(i-idx+1<=k){\\n                    dp[idx]=max(dp[idx],res*(i-idx+1)+maxsum(arr,i+1,dp,k));\\n                }\\n            }\\n            return dp[idx];\\n        }\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n        int n=arr.size();\\n        vector<int> dp(n,0);\\n        int sum=maxsum(arr,0,dp,k);\\n        return sum;\\n\\t\\t\\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int maxsum(vector<int>&arr,int idx,vector<int>&dp,int k){\\n        if(idx==arr.size())\\n            return 0;\\n        else if(dp[idx]!=0)\\n            return dp[idx];\\n        else{\\n            int res=-1;\\n            for(int i=idx;i<arr.size()&&i<idx+k;i++){\\n                res=max(res,arr[i]);\\n                if(i-idx+1<=k){\\n                    dp[idx]=max(dp[idx],res*(i-idx+1)+maxsum(arr,i+1,dp,k));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1562342,
                "title": "c-easy-solution-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n      int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int ma  = arr[i];\\n            for(int j=i;j>(i-k) && j>=0;j--)\\n            {\\n                ma  = max(arr[j], ma);\\n                if(j-1>=0)\\n                dp[i] = max(dp[i], dp[j-1] + ma*(i-j+1));\\n                else\\n                {\\n                    dp[i] = max(dp[i], ma*(i-j+1));\\n                }\\n            } \\n        }\\n     \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n      int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int ma  = arr[i];\\n            for(int j=i;j>(i-k) && j>=0;j--)\\n            {\\n                ma  = max(arr[j], ma);\\n                if(j-1>=0)\\n                dp[i] = max(dp[i], dp[j-1] + ma*(i-j+1));\\n                else\\n                {\\n                    dp[i] = max(dp[i], ma*(i-j+1));\\n                }\\n            } \\n        }\\n     \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395821,
                "title": "c-solution-dp-approach",
                "content": "c++ solution || dp approach || \\n\\n```\\n\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n       int dp[n];\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i] = 0;\\n        }\\n        \\n        int maxi = arr[0];\\n        \\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);\\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxiSubA=arr[i];\\n            for(int j=1;j<=k;j++)\\n            {\\n                maxiSubA = max(maxiSubA,arr[i-j+1]);\\n                \\n                dp[i] = max(dp[i], dp[i-j] + maxiSubA*j);\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1];\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "c++ solution || dp approach || \\n\\n```\\n\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n       int dp[n];\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i] = 0;\\n        }\\n        \\n        int maxi = arr[0];\\n        \\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);\\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxiSubA=arr[i];\\n            for(int j=1;j<=k;j++)\\n            {\\n                maxiSubA = max(maxiSubA,arr[i-j+1]);\\n                \\n                dp[i] = max(dp[i], dp[i-j] + maxiSubA*j);\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1];\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1395252,
                "title": "c-memoisation-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n//     DP(Tabulation)\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)        {\\n        int n=arr.size();\\n        vector<int> dp(n+1);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=arr[i-1];\\n            int val=0;\\n            for(int j=1;j<=k && i-j>=0;j++){\\n                val=max(val,arr[i-j]);\\n                dp[i]=max(dp[i],val*j+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\n//        Memoisation\\n// class Solution {\\n//     vector<int> memo;\\n//     int rec(vector<int>& arr,int k ,int i){\\n//         if(i<=0) return 0;\\n//         if(memo[i]!=-1) return memo[i];\\n//         int val=arr[i-1],ans=0;\\n//         for(int j=1;j<=k && i-j>=0;j++){\\n//             val=max(val,arr[i-j]);\\n//             ans=max(ans,val*j+rec(arr,k,i-j));\\n//         }\\n//         return memo[i]=ans;\\n//     }\\n// public:\\n//     int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n//         int n=arr.size();\\n//         memo.resize(n+1,-1);\\n//         return rec(arr,k,n);\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//     DP(Tabulation)\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)        {\\n        int n=arr.size();\\n        vector<int> dp(n+1);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=arr[i-1];\\n            int val=0;\\n            for(int j=1;j<=k && i-j>=0;j++){\\n                val=max(val,arr[i-j]);\\n                dp[i]=max(dp[i],val*j+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\n//        Memoisation\\n// class Solution {\\n//     vector<int> memo;\\n//     int rec(vector<int>& arr,int k ,int i){\\n//         if(i<=0) return 0;\\n//         if(memo[i]!=-1) return memo[i];\\n//         int val=arr[i-1],ans=0;\\n//         for(int j=1;j<=k && i-j>=0;j++){\\n//             val=max(val,arr[i-j]);\\n//             ans=max(ans,val*j+rec(arr,k,i-j));\\n//         }\\n//         return memo[i]=ans;\\n//     }\\n// public:\\n//     int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n//         int n=arr.size();\\n//         memo.resize(n+1,-1);\\n//         return rec(arr,k,n);\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266328,
                "title": "dp-mcm-pattern",
                "content": "This is just a variation of MCM problem and can be understood just by building recursion tree as we generally do for MCM type problems. \\nWe can further modify the recursive implementation as shown below...\\n\\nclass Solution {\\npublic:\\n    \\n    //mcm\\n    //Build partition tree first.\\n    //Implement using modified mcm.\\n    \\n    int getMax(vector<int> &arr,int start,int end){\\n        \\n        int mx = 0;\\n        for(int i=start;i<=end;i++){\\n            mx = max(mx,arr[i]);\\n        }\\n        \\n        return mx;\\n        \\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        int C[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int mx = 0;\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if(i-j <= k)\\n                    mx = max(mx , C[j] + getMax(arr,j+1,i)*(i-j));\\n                \\n            }\\n            \\n            if(i+1 <= k)\\n                C[i] = max(mx , getMax(arr,0,i)*(i+1));\\n            else\\n                C[i] = mx;\\n\\n        }\\n        \\n        return C[n-1];\\n        \\n        \\n    }\\n};\\n\\n\\nYou can further optimize **getMax()** using your own methods - one can be using segment tree.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    //mcm\\n    //Build partition tree first.\\n    //Implement using modified mcm.\\n    \\n    int getMax(vector<int> &arr,int start,int end){\\n        \\n        int mx = 0;\\n        for(int i=start;i<=end;i++){\\n            mx = max(mx,arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1145019,
                "title": "java-easy-to-understand-dp-solution-beginner-concise-explanation",
                "content": "Refer to this solution for explanation (https://leetcode.com/problems/partition-array-for-maximum-sum/discuss/522001/Python3-with-explanation) and upvote the original post if you liked it\\n\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length,i,j;\\n        \\n        int dp[] = new int[n+1];\\n        \\n        for(i=1;i<=n;++i){\\n            int maxInWindow = 0, bestInWindow = 0;\\n            for(j=1;j<=k && i-j>=0;j++){\\n                maxInWindow = Math.max(maxInWindow, arr[i-j]);\\n                bestInWindow = Math.max(bestInWindow, dp[i-j]+maxInWindow*j);\\n            }\\n            dp[i] = bestInWindow;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length,i,j;\\n        \\n        int dp[] = new int[n+1];\\n        \\n        for(i=1;i<=n;++i){\\n            int maxInWindow = 0, bestInWindow = 0;\\n            for(j=1;j<=k && i-j>=0;j++){\\n                maxInWindow = Math.max(maxInWindow, arr[i-j]);\\n                bestInWindow = Math.max(bestInWindow, dp[i-j]+maxInWindow*j);\\n            }\\n            dp[i] = bestInWindow;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116387,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n + 1);\\n        for(int i = 1; i <= n; i++) {\\n            int max_value = arr[i - 1];\\n            for(int j = i; j > 0 && i - j + 1 <= k; j--) {\\n                max_value = max(max_value, arr[j - 1]);\\n                dp[i] = max(dp[i], dp[j - 1] + (i - j + 1) * max_value);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n + 1);\\n        for(int i = 1; i <= n; i++) {\\n            int max_value = arr[i - 1];\\n            for(int j = i; j > 0 && i - j + 1 <= k; j--) {\\n                max_value = max(max_value, arr[j - 1]);\\n                dp[i] = max(dp[i], dp[j - 1] + (i - j + 1) * max_value);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115228,
                "title": "2-simple-and-intuitive-java-solution-with-explanation",
                "content": "\\t/*\\n\\t   approach 1 : \\n\\t\\t --> we have 2 divide array into different subarrays.\\n\\t\\t --> we will use 2 pointer techinque : l,r. l represents index of starting element and r represents ending index for a particular subarray\\n\\t\\t --> we can make subarrays haveing elements upto k\\n\\t\\t --> so if we have less than k elements, we have 2 choices:\\n\\t\\t\\t --> either to close current subarray or to continue adding elements to it\\n\\t\\t\\t --> if we  choose to close, we will find sum for current subarry( # of elements * max value) and start a new subarray : f(r+1,r+1)\\n\\t\\t\\t --> if we want to continue adding elements we goto : f(l,r+1).\\n\\t\\t--> if we have exactly k elements, we need to create a new subarray : l=r+1,r=r+1.\\n\\t */\\n\\t class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t return helper(arr,0,0,k);\\n\\t\\t }\\n\\t\\t private int helper(int [] arr,int l,int r,int k){\\n\\t\\t\\t if(r==arr.length)return 0;\\n\\t\\t\\t if(r-l+1<=k){\\n\\t\\t\\t\\t int max = 0;\\n\\t\\t\\t\\t for(int i=l;i<=r;i++)max = Math.max(max,arr[i]);\\n\\t\\t\\t\\t return Math.max((r-l+1)*max + helper(arr,r+1,r+1,k),helper(arr,l,r+1,k));\\n\\t\\t\\t }\\n\\t\\t\\t return helper(arr,r+1,r+1,k);\\n\\t\\t }\\n\\t }\\n\\t // memoization with time and space complexity : O(n^2)\\n\\t // instead of calculating max in btw l to r, we will pre calculate it and store it in max[].\\n\\t // So finding max Value in range l to r takes O(1) time.\\n\\t class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t int n = arr.length;\\n\\t\\t\\t int[][] max = new int[n][n];\\n\\t\\t\\t for(int l=0;l<n;l++){\\n\\t\\t\\t\\t max[l][l] = arr[l];\\n\\t\\t\\t\\t for(int r=l+1;r<n;r++)\\n\\t\\t\\t\\t\\t max[l][r] = Math.max(max[l][r-1],arr[r]);\\n\\t\\t\\t }\\n\\t\\t\\t int[][] dp = new int[n][n];\\n\\t\\t\\t for(int i=0;i<n;i++)\\n\\t\\t\\t\\t Arrays.fill(dp[i],-1);\\n\\t\\t\\t return helper(arr,0,0,k,dp,max);\\n\\t\\t }\\n\\t\\t private int helper(int [] arr,int l,int r,int k,int[][] dp,int[][] max){\\n\\t\\t\\t if(r==arr.length)return 0;\\n\\t\\t\\t if(dp[l][r]!=-1)return dp[l][r];\\n\\t\\t\\t if(r-l+1<=k){\\n\\t\\t\\t\\t int maxVal = max[l][r];\\n\\t\\t\\t\\t return dp[l][r] = Math.max((r-l+1)*maxVal + helper(arr,r+1,r+1,k,dp,max),helper(arr,l,r+1,k,dp,max));\\n\\t\\t\\t }\\n\\t\\t\\t return  dp[l][r] = helper(arr,r+1,r+1,k,dp,max);\\n\\t\\t }\\n\\t }\\n\\t // another faster approach with time complexity O(nk) and space complexity : O(n)\\n\\t /*\\n\\t   approach :\\n\\t\\t   --> let say our current subarray ends at index i. How many subarrays can be created such that it will end at index i?\\n\\t\\t   --> exactly k subarray are there.\\n\\t\\t   --> so for every i in range o to n-1, we will assume that our current subarray ends at index i.\\n\\t\\t   --> we will find all such possible subarray j = [i-k+1,i], where j is starting of subarray and i in ending of subarray.\\n\\t\\t   --> let say dp[i] stores maximum sum possible ending at arr[i].\\n\\t\\t   --> so we will find all possible answers for a subarray ending at i. and we take max of all to find maxinum sum ending at i.\\n\\t\\t   --> for a particular subarray starting at j and ending at i, we find max sum ending at (j-1) + # of elements in [j,i]* max element in (j,i).\\n\\t\\t   --> for a particular [j,i]. dp[i] = dp[j-1] + (i-j+1) * max in range(j,i).\\n\\n\\t */\\n\\t class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t int n = arr.length;\\n\\t\\t\\t int[] dp = new int[n];\\n\\t\\t\\t for(int i=0;i<n;i++){\\n\\t\\t\\t\\t int max = 0;\\n\\t\\t\\t\\t for(int j=i;j>=i-k+1 && j>=0;j--){\\n\\t\\t\\t\\t\\t max = Math.max(max,arr[j]);\\n\\t\\t\\t\\t\\t dp[i] = Math.max(dp[i],(i-j+1)*max + (j==0? 0 : dp[j-1]));\\n\\t\\t\\t\\t }   \\n\\t\\t\\t }\\n\\t\\t\\t return dp[n-1];\\n\\t\\t }\\n\\n\\t }",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t return helper(arr,0,0,k);\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1083866,
                "title": "c-dp",
                "content": "```cpp\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int> dp(arr.size() + 1);\\n\\tfor (int i=1; i<=arr.size(); i++) {\\n\\t\\tfor (int j=i-1, m = 0; j >= i-k && j>=0; j--) {\\n\\t\\t\\tm = max(m, arr[j]);    \\n\\t\\t\\tdp[i] = max(dp[j] + m * (i-j), dp[i]);    \\n\\t\\t}\\n\\t}\\n\\treturn dp[arr.size()];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int> dp(arr.size() + 1);\\n\\tfor (int i=1; i<=arr.size(); i++) {\\n\\t\\tfor (int j=i-1, m = 0; j >= i-k && j>=0; j--) {\\n\\t\\t\\tm = max(m, arr[j]);    \\n\\t\\t\\tdp[i] = max(dp[j] + m * (i-j), dp[i]);    \\n\\t\\t}\\n\\t}\\n\\treturn dp[arr.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042173,
                "title": "detailed-dp-explanation-for-newbies",
                "content": "Given that we have an array `[1,2,3,4,5]` and `k = 3` \\nTo calculate `dp[4]` or `maxSum([1,2,3,4,5])`, we need to calculate max of `a,b,c`\\n```\\na = maxSum([1,2,3,4]) + maxSum([5])\\nb = maxSum([1,2,3]) + maxSum([4,5])\\nc = maxSum([1,2]) + maxSum([3,4,5])\\n\\n// we don\\'t consider d because max sub array length is 3 and [2,3,4,5] has length 4\\nd = maxSum([1,2,3,4,5]) = maxSum([1]) + maxSum([2,3,4,5])\\n\\n// and we have\\ndp[4] = max(a,b,c)\\n```\\n\\nNow in c, we have ` maxSum([3,4,5])` = `max(3,4,5) * 3`, since the length is less than or equal to k. Now we have\\n```\\na = maxSum([1,2,3,4]) + max(5)*1 = maxSum([1,2,3,4]) + 5\\nb = max(1,2,3)*3 +  max(4,5)*2 = 19\\nc = max(1,2)*2 + max(3,4,5)*3 = 19\\n```\\n\\nSimilarly, to calculate `maxSum([1,2,3,4])`  or `dp[3]` in a\\n```\\ne = maxSum([1,2,3]) +  maxSum([4]) = 13\\nf = maxSum([1,2]) + , maxSum([3,4]) = 12\\ng = maxSum([1] +  maxSum([2,3,4]) = 13\\n\\ndp[3] = max(e,f,g) = 13\\na = maxSum([1,2,3,4]) + 5 = dp[3] + 5 = 13 + 5 = 18\\n```\\n\\nFinally, `dp[4] = max(a,b,c) = max(18, 19, 19) = 19`",
                "solutionTags": [],
                "code": "```\\na = maxSum([1,2,3,4]) + maxSum([5])\\nb = maxSum([1,2,3]) + maxSum([4,5])\\nc = maxSum([1,2]) + maxSum([3,4,5])\\n\\n// we don\\'t consider d because max sub array length is 3 and [2,3,4,5] has length 4\\nd = maxSum([1,2,3,4,5]) = maxSum([1]) + maxSum([2,3,4,5])\\n\\n// and we have\\ndp[4] = max(a,b,c)\\n```\n```\\na = maxSum([1,2,3,4]) + max(5)*1 = maxSum([1,2,3,4]) + 5\\nb = max(1,2,3)*3 +  max(4,5)*2 = 19\\nc = max(1,2)*2 + max(3,4,5)*3 = 19\\n```\n```\\ne = maxSum([1,2,3]) +  maxSum([4]) = 13\\nf = maxSum([1,2]) + , maxSum([3,4]) = 12\\ng = maxSum([1] +  maxSum([2,3,4]) = 13\\n\\ndp[3] = max(e,f,g) = 13\\na = maxSum([1,2,3,4]) + 5 = dp[3] + 5 = 13 + 5 = 18\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985086,
                "title": "java-dfs-memoization",
                "content": "At each index try all combinations of K starting from 1.\\n\\n```\\n\\nclass Solution {\\n    int[] dp;\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        dp = new int[A.length + 1];\\n        return helper(A, 0, K);\\n    }\\n    \\n    private int helper(int[] A, int idx, int K){\\n        if(idx == A.length) return 0;\\n        if(dp[idx] != 0) return dp[idx];\\n        \\n        int maxSum = 0, maxVal = 0;\\n        for(int j = idx, i = 1 ; j < A.length && i <= K ; j++, i++){\\n            maxVal = Math.max(maxVal , A[j]);\\n            maxSum = Math.max(maxSum, i * maxVal + helper(A, j + 1, K));\\n        }\\n        return dp[idx] = maxSum;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int[] dp;\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        dp = new int[A.length + 1];\\n        return helper(A, 0, K);\\n    }\\n    \\n    private int helper(int[] A, int idx, int K){\\n        if(idx == A.length) return 0;\\n        if(dp[idx] != 0) return dp[idx];\\n        \\n        int maxSum = 0, maxVal = 0;\\n        for(int j = idx, i = 1 ; j < A.length && i <= K ; j++, i++){\\n            maxVal = Math.max(maxVal , A[j]);\\n            maxSum = Math.max(maxSum, i * maxVal + helper(A, j + 1, K));\\n        }\\n        return dp[idx] = maxSum;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948233,
                "title": "better-indexing-than-the-highest-voted-answer",
                "content": "```js\\nconst maxSumAfterPartitioning = function(nums, K) {\\n  const n = nums.length;\\n  //  dp(i) = the max sum of the first i numbers.\\n  const dp = Array(n + 1);\\n  \\n  let sum = 0;\\n  for (let i = 0; i <= n; i += 1) {\\n    dp[i] = sum;\\n    sum += nums[i];\\n  }\\n  \\n  for (let i = 1; i <= n; i += 1) {\\n    let max = 0;\\n    // k is window size\\n    for (let k = 1; k <= K && i - k >= 0; k += 1) {\\n      max = Math.max(max, nums[i - k]);\\n      const sum = dp[i - k] + k * max;\\n      dp[i] = Math.max(sum, dp[i]);\\n    }\\n  }\\n  \\n  \\n  return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maxSumAfterPartitioning = function(nums, K) {\\n  const n = nums.length;\\n  //  dp(i) = the max sum of the first i numbers.\\n  const dp = Array(n + 1);\\n  \\n  let sum = 0;\\n  for (let i = 0; i <= n; i += 1) {\\n    dp[i] = sum;\\n    sum += nums[i];\\n  }\\n  \\n  for (let i = 1; i <= n; i += 1) {\\n    let max = 0;\\n    // k is window size\\n    for (let k = 1; k <= K && i - k >= 0; k += 1) {\\n      max = Math.max(max, nums[i - k]);\\n      const sum = dp[i - k] + k * max;\\n      dp[i] = Math.max(sum, dp[i]);\\n    }\\n  }\\n  \\n  \\n  return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908765,
                "title": "java-solution-with-explanation-3ms-faster-than-98-of-submissions",
                "content": "since its asking maximum sum, we can think of using DP.\\n\\nwhat we can do is go bottom up.  we can make a separate array callsed dp of same size of arr.\\ndp[i] represent the maximum sum up to the index i;\\nif we get the value of dp[n-1] we will get the answer.\\n\\nalso we can write in general.\\ndp[i]= max(dp[i], dp[i- possible size limit i.e from 1 to k] + maxelement * size)\\n\\ncode can we written as \\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n    int n= arr.length;\\n        int[] dp = new int[n] ;\\n        dp[0]= arr[0] ;\\n        int maxvar=arr[0] ;\\n\\n        // divide the dp[i] calculation into 2 parts\\n        //1) from 0-(k-1) \\n        // 2) from k to (n-1) ;\\n        \\n        // part 1\\n        for(int i=0;i<k;i++)\\n        {\\n            maxvar= Math.max(maxvar,arr[i]) ;\\n            dp[i] =maxvar*(i+1) ;\\n            \\n        }\\n        \\n        // part 2\\n        for(int i=k;i<n;i++)\\n        {   \\n             maxvar= arr[i] ;\\n            for(int j=1; j<=k;j++)\\n            {\\n                maxvar= Math.max(maxvar, arr[i-j+1]) ;\\n                dp[i]= Math.max(dp[i],(dp[i-j]+ maxvar*j) ) ;\\n            }\\n        }\\n        return dp[n-1] ;\\n    }\\n}\\n```\\n\\nhope it helps.\\nkeep the streak.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n    int n= arr.length;\\n        int[] dp = new int[n] ;\\n        dp[0]= arr[0] ;\\n        int maxvar=arr[0] ;\\n\\n        // divide the dp[i] calculation into 2 parts\\n        //1) from 0-(k-1) \\n        // 2) from k to (n-1) ;\\n        \\n        // part 1\\n        for(int i=0;i<k;i++)\\n        {\\n            maxvar= Math.max(maxvar,arr[i]) ;\\n            dp[i] =maxvar*(i+1) ;\\n            \\n        }\\n        \\n        // part 2\\n        for(int i=k;i<n;i++)\\n        {   \\n             maxvar= arr[i] ;\\n            for(int j=1; j<=k;j++)\\n            {\\n                maxvar= Math.max(maxvar, arr[i-j+1]) ;\\n                dp[i]= Math.max(dp[i],(dp[i-j]+ maxvar*j) ) ;\\n            }\\n        }\\n        return dp[n-1] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891490,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int w = k+1;\\n        vector<int> dp(w);\\n        for(int i = 0; i<arr.size(); i++) {\\n            int curMax = 0;\\n            for(int j =1; j <= min(k, i+1); j++) {\\n                curMax = max(curMax, arr[i - j + 1]);\\n                dp[i%w] = max(dp[i%w], ((i >= k) ? dp[(i-j)%w] : 0) + curMax * j);\\n            }\\n        }\\n        return dp[(arr.size()-1) % w];\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int w = k+1;\\n        vector<int> dp(w);\\n        for(int i = 0; i<arr.size(); i++) {\\n            int curMax = 0;\\n            for(int j =1; j <= min(k, i+1); j++) {\\n                curMax = max(curMax, arr[i - j + 1]);\\n                dp[i%w] = max(dp[i%w], ((i >= k) ? dp[(i-j)%w] : 0) + curMax * j);\\n            }\\n        }\\n        return dp[(arr.size()-1) % w];\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832917,
                "title": "java-solution-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n        int dp[]=new int[n]; //dp[i] represents max sum till i-th position\\n        int max=0;\\n        int i=0;\\n        //Fill the first k positions with max element till i-th position times number of elements\\n        for(;i<k&&i<n;i++){\\n            max=Math.max(max,arr[i]);\\n            dp[i]=max*(i+1);\\n        }\\n        //Start filling the rest of dp array\\n        for(;i<n;i++){\\n            max=0;\\n            int sum=0; //sum to keep max sum possible\\n            \\n            //j will iterate till i-k-1th element \\n            //For example if k=3 and i=4 then j will be 4,3,2\\n            //Every time new element is considered, \\n            //update max and make sum = maxelement*number of elements considered\\n            for(int j=i;j>i-k;j--){\\n                max=Math.max(max,arr[j]);\\n                sum=Math.max(sum,dp[j-1]+max*(i-j+1));\\n            }\\n            //update dp[i] with the max sum possible\\n            dp[i]=sum;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n        int dp[]=new int[n]; //dp[i] represents max sum till i-th position\\n        int max=0;\\n        int i=0;\\n        //Fill the first k positions with max element till i-th position times number of elements\\n        for(;i<k&&i<n;i++){\\n            max=Math.max(max,arr[i]);\\n            dp[i]=max*(i+1);\\n        }\\n        //Start filling the rest of dp array\\n        for(;i<n;i++){\\n            max=0;\\n            int sum=0; //sum to keep max sum possible\\n            \\n            //j will iterate till i-k-1th element \\n            //For example if k=3 and i=4 then j will be 4,3,2\\n            //Every time new element is considered, \\n            //update max and make sum = maxelement*number of elements considered\\n            for(int j=i;j>i-k;j--){\\n                max=Math.max(max,arr[j]);\\n                sum=Math.max(sum,dp[j-1]+max*(i-j+1));\\n            }\\n            //update dp[i] with the max sum possible\\n            dp[i]=sum;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686778,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<int> dp(n+1, INT_MIN);\\n        int maxA = INT_MIN;\\n        for (int i = 1; i <= K; i++) {\\n            maxA = max(maxA, A[i - 1]);\\n            dp[i] = maxA * i;\\n        }\\n        for (int i = K + 1; i < n + 1; i++) {\\n            maxA = INT_MIN;\\n            for (int len = 1; len <= K; len++) {\\n                maxA = max(maxA, A[i - len]);\\n                dp[i] = max(dp[i], maxA * len + dp[i - len]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n/* \\ndp[n]: Partition Array for Maximum Sum from A[0], A[1], ... A[n-1].\\ndp[0] = 0\\ndp[1] = A[0]\\ndp[2] = max(A[1], A[0]) * 2\\n...\\ndp[K] = max(A[k-1], ..., A[0]) * K\\ndp[i] = max(A[i-1] + dp[i-1], max(A[i-1], A[i-2])*2 + dp[i-2], ..., max(A[i-1], ..., A[i-k])*k + dp[i-k])\\ndp[A.size()]\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<int> dp(n+1, INT_MIN);\\n        int maxA = INT_MIN;\\n        for (int i = 1; i <= K; i++) {\\n            maxA = max(maxA, A[i - 1]);\\n            dp[i] = maxA * i;\\n        }\\n        for (int i = K + 1; i < n + 1; i++) {\\n            maxA = INT_MIN;\\n            for (int len = 1; len <= K; len++) {\\n                maxA = max(maxA, A[i - len]);\\n                dp[i] = max(dp[i], maxA * len + dp[i - len]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n/* \\ndp[n]: Partition Array for Maximum Sum from A[0], A[1], ... A[n-1].\\ndp[0] = 0\\ndp[1] = A[0]\\ndp[2] = max(A[1], A[0]) * 2\\n...\\ndp[K] = max(A[k-1], ..., A[0]) * K\\ndp[i] = max(A[i-1] + dp[i-1], max(A[i-1], A[i-2])*2 + dp[i-2], ..., max(A[i-1], ..., A[i-k])*k + dp[i-k])\\ndp[A.size()]\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521629,
                "title": "c-memoization-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> memo(A.size()+1,-1);\\n        return maxSum(memo,A,K,0);\\n    }\\n    \\n    int maxSum(vector<int>& memo, vector<int>& A, int& K, int pos){\\n        if (pos >= A.size())return 0;\\n        if (memo[pos] != -1)return memo[pos];\\n        int range_max = A[pos], rightsum = 0;\\n        \\n        //For all possible sizes of subarray extending right from this point, get sum of the array plus\\n        //cumulative sum of values to the right of the array\\'s right bound.\\n        for (int i = pos; i < A.size() && i < pos+K; i++){\\n            if (A[i] > range_max){\\n                range_max = A[i];\\n            }\\n            rightsum = max(rightsum,range_max*(i-pos+1)+maxSum(memo,A,K,i+1));     //keep track of max observed sum\\n        }\\n        return memo[pos] = rightsum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> memo(A.size()+1,-1);\\n        return maxSum(memo,A,K,0);\\n    }\\n    \\n    int maxSum(vector<int>& memo, vector<int>& A, int& K, int pos){\\n        if (pos >= A.size())return 0;\\n        if (memo[pos] != -1)return memo[pos];\\n        int range_max = A[pos], rightsum = 0;\\n        \\n        //For all possible sizes of subarray extending right from this point, get sum of the array plus\\n        //cumulative sum of values to the right of the array\\'s right bound.\\n        for (int i = pos; i < A.size() && i < pos+K; i++){\\n            if (A[i] > range_max){\\n                range_max = A[i];\\n            }\\n            rightsum = max(rightsum,range_max*(i-pos+1)+maxSum(memo,A,K,i+1));     //keep track of max observed sum\\n        }\\n        return memo[pos] = rightsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372853,
                "title": "scala-solution-with-dynamic-programming",
                "content": "```\\n  /**\\n    * Use dynamic programming and use memoization to figure out max sum at A[i] as this sub problem will occur many times.\\n    * At each step we figure out if it is best to use a partition of 1, 2, ... k\\n    */\\n  object Solution {\\n    import scala.collection.mutable\\n    def maxSumAfterPartitioning(A: Array[Int], K: Int): Int = {\\n      val solutions: mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\\n\\n      def maxSumAfterPartitioning(index: Int): Int = {\\n        if (index >= A.length) 0\\n        else {\\n          solutions.getOrElse(index, {\\n            solutions(index) = Range(K, 0, -1)\\n              .map(K => {\\n                val items: Array[Int] = A.slice(index, index + K)\\n                (items.length * items.max) + maxSumAfterPartitioning(index + items.length)\\n              })\\n              .max\\n\\n            solutions(index)\\n          })\\n        }\\n      }\\n\\n      maxSumAfterPartitioning(0)\\n    }\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\n  /**\\n    * Use dynamic programming and use memoization to figure out max sum at A[i] as this sub problem will occur many times.\\n    * At each step we figure out if it is best to use a partition of 1, 2, ... k\\n    */\\n  object Solution {\\n    import scala.collection.mutable\\n    def maxSumAfterPartitioning(A: Array[Int], K: Int): Int = {\\n      val solutions: mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\\n\\n      def maxSumAfterPartitioning(index: Int): Int = {\\n        if (index >= A.length) 0\\n        else {\\n          solutions.getOrElse(index, {\\n            solutions(index) = Range(K, 0, -1)\\n              .map(K => {\\n                val items: Array[Int] = A.slice(index, index + K)\\n                (items.length * items.max) + maxSumAfterPartitioning(index + items.length)\\n              })\\n              .max\\n\\n            solutions(index)\\n          })\\n        }\\n      }\\n\\n      maxSumAfterPartitioning(0)\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 344900,
                "title": "java-time-beat-95",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        dp[1] = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            int curMax = A[i];\\n            // j is the length of subarray that contains A[i]\\n            for (int j = 1; j <= K; j++) {\\n                int k = i - j + 1; // start index of subarray\\n                if (k < 0) break;\\n                curMax = Math.max(curMax, A[k]);\\n                dp[i + 1] = Math.max(dp[i + 1], j * curMax + dp[k]);\\n            }\\n        }\\n        return dp[A.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        dp[1] = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            int curMax = A[i];\\n            // j is the length of subarray that contains A[i]\\n            for (int j = 1; j <= K; j++) {\\n                int k = i - j + 1; // start index of subarray\\n                if (k < 0) break;\\n                curMax = Math.max(curMax, A[k]);\\n                dp[i + 1] = Math.max(dp[i + 1], j * curMax + dp[k]);\\n            }\\n        }\\n        return dp[A.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330464,
                "title": "dp-java-o-n-k-time-and-o-n-space",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        for(int i = A.length - 1; i >= 0; i --){\\n            int maxOne = A[i];\\n            dp[i] = A[i] + dp[i+1];\\n            for(int j = 1; j < K && i+j < A.length; j++){\\n                maxOne = Math.max(A[i+j], maxOne);\\n                dp[i] = Math.max(dp[i], maxOne*(j+1) + dp[i+j+1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        for(int i = A.length - 1; i >= 0; i --){\\n            int maxOne = A[i];\\n            dp[i] = A[i] + dp[i+1];\\n            for(int j = 1; j < K && i+j < A.length; j++){\\n                maxOne = Math.max(A[i+j], maxOne);\\n                dp[i] = Math.max(dp[i], maxOne*(j+1) + dp[i+j+1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 296668,
                "title": "javascript-dp",
                "content": "```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    let l = A.length;\\n    let dp = new Array(l + 1).fill(0);\\n    for (let i = 1 ; i < l + 1; i++) {\\n        let m = Number.MIN_VALUE;\\n        for (let j = 1; j < Math.min(i, K) + 1; j++) {\\n            m = Math.max(m, A[i - j]);\\n            dp[i] = Math.max(dp[i], dp[i - j] + m * j);\\n        }\\n    }\\n    return dp[l];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    let l = A.length;\\n    let dp = new Array(l + 1).fill(0);\\n    for (let i = 1 ; i < l + 1; i++) {\\n        let m = Number.MIN_VALUE;\\n        for (let j = 1; j < Math.min(i, K) + 1; j++) {\\n            m = Math.max(m, A[i - j]);\\n            dp[i] = Math.max(dp[i], dp[i - j] + m * j);\\n        }\\n    }\\n    return dp[l];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 292674,
                "title": "c-super-simple-and-clean-8-line-solution-beats-100",
                "content": "```\\n\\tint maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size()+1, 0);\\n        for(int i=1;i<=A.size();i++) {\\n            int m=0;\\n            for(int j=i-1;j>=0&&j>=i-K;j--) {\\n                m=max(m, A[j]);\\n                dp[i]=max(dp[i], dp[j]+m*(i-j));\\n            }\\n        }\\n        return dp.back();\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tint maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size()+1, 0);\\n        for(int i=1;i<=A.size();i++) {\\n            int m=0;\\n            for(int j=i-1;j>=0&&j>=i-K;j--) {\\n                m=max(m, A[j]);\\n                dp[i]=max(dp[i], dp[j]+m*(i-j));\\n            }\\n        }\\n        return dp.back();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 290917,
                "title": "easy-python-o-nk-2-dp-solution",
                "content": "Idea: dp[i] means the max sum after partition in index i\\nin each loop, `dp[i] = max(dp[i-1] + max(A[i-1:i]) * 1, dp[i-2] + max(A[i-2:i]) * 2, ..., dp[i-k] + max(A[i-k:i]) * k`\\nThen we get the solution.\\n\\n```python\\nclass Solution:\\n    # dp\\n    # Onk^2 time O n space\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        if len(A) == 0:\\n            return 0\\n        dp = [0 for _ in A]\\n        dp[0] = A[0]\\n        curMax = 0\\n        for i in range(1, len(A)):\\n            if i <= K-1:\\n                dp[i]= max(A[:i+1]) * (i+1)\\n            else:\\n                dp[i] = max(A[i-K+1:i+1])\\n                for j in range(1, K+1):\\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j+1:i+1]) * j)\\n        return dp[len(A)-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    # dp\\n    # Onk^2 time O n space\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        if len(A) == 0:\\n            return 0\\n        dp = [0 for _ in A]\\n        dp[0] = A[0]\\n        curMax = 0\\n        for i in range(1, len(A)):\\n            if i <= K-1:\\n                dp[i]= max(A[:i+1]) * (i+1)\\n            else:\\n                dp[i] = max(A[i-K+1:i+1])\\n                for j in range(1, K+1):\\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j+1:i+1]) * j)\\n        return dp[len(A)-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 290880,
                "title": "python-memoization",
                "content": "*(It looks my solution is not better than others\\'. But just want to provide another way to analyze this problem.)*\\n\\nUse memoization to implement DP. `helper(i, j)` returns and **caches** the max result of the range [i, j).\\nIf the range [i, j) is shorter than or equal to K, replace all elements with the maximum.\\nIf the range [i, j) is longer than K, try all possible `newj` such that [i, newj) is not longer than K. Then return the maximum of `helper(i, newj) + helper(newj, j)` for all possible `newj`.\\n```\\nimport functools\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(i, j):\\n            # The helper finds the max result of the range [i, j)\\n            if j - i <= K:\\n                return (j - i) * max(A[i:j])\\n            return max(helper(i, newj) + helper(newj, j) for newj in range(i + 1, i + 1 + K))\\n        \\n        return helper(0, len(A))\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(i, j):\\n            # The helper finds the max result of the range [i, j)\\n            if j - i <= K:\\n                return (j - i) * max(A[i:j])\\n            return max(helper(i, newj) + helper(newj, j) for newj in range(i + 1, i + 1 + K))\\n        \\n        return helper(0, len(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290857,
                "title": "task-teamwork-dp",
                "content": "It turns out this problem was copied directly from the USACO Gold Round this year December. I would have not noticed if it were not for the test case being exactly the same. I went back to check on my old CP notes and it was there, verbatim. Here\\'s the original problem: http://usaco.org/current/data/sol_teamwork_gold_dec18.html. Here\\'s my solution.\\n\\n```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n\\t    for(int i = 1; i < A.length; i++) {\\n\\t\\t    int curr = A[i];\\n\\t\\t    for(int j = i; j >= 0 && (i + 1 - j) <= K; j--) {\\n\\t\\t\\t    curr = Math.max(curr, A[j]);\\n\\t\\t\\t    if(j == 0) {\\n                    dp[i] = Math.max(dp[i], curr*(i + 1 - j));\\n                }\\n\\t\\t\\t    else {\\n                    dp[i] = Math.max(dp[i], dp[j - 1] + curr*(i + 1 - j));\\n                }\\n\\t\\t    }\\n    \\t}\\n        return dp[A.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n\\t    for(int i = 1; i < A.length; i++) {\\n\\t\\t    int curr = A[i];\\n\\t\\t    for(int j = i; j >= 0 && (i + 1 - j) <= K; j--) {\\n\\t\\t\\t    curr = Math.max(curr, A[j]);\\n\\t\\t\\t    if(j == 0) {\\n                    dp[i] = Math.max(dp[i], curr*(i + 1 - j));\\n                }\\n\\t\\t\\t    else {\\n                    dp[i] = Math.max(dp[i], dp[j - 1] + curr*(i + 1 - j));\\n                }\\n\\t\\t    }\\n    \\t}\\n        return dp[A.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917776,
                "title": "intuition-very-similar-to-aditya-verma-mcm-question",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& arr, int i , int j , int kk,vector<vector<int> > &dp){\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        if(i > j){\\n            return 0;\\n        }\\n        if(i == j){\\n            return arr[i];\\n        }\\n        if(j - i + 1 == kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n        if(j - i + 1 < kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int k = i ; k < i+kk && k < j; k++){\\n            ans = max(ans,solve(arr,i,k,kk,dp) + solve(arr,k+1,j,kk,dp));\\n        }   \\n\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n\\n\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<vector<int> > dp(arr.size()+1, vector<int>(arr.size()+1,-1));\\n        int i = 0, j = arr.size() - 1;\\n        return solve(arr,i,j,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& arr, int i , int j , int kk,vector<vector<int> > &dp){\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        if(i > j){\\n            return 0;\\n        }\\n        if(i == j){\\n            return arr[i];\\n        }\\n        if(j - i + 1 == kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n        if(j - i + 1 < kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int k = i ; k < i+kk && k < j; k++){\\n            ans = max(ans,solve(arr,i,k,kk,dp) + solve(arr,k+1,j,kk,dp));\\n        }   \\n\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n\\n\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<vector<int> > dp(arr.size()+1, vector<int>(arr.size()+1,-1));\\n        int i = 0, j = arr.size() - 1;\\n        return solve(arr,i,j,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916668,
                "title": "two-ways-partition-dp-front-row-partition-dp-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[510];\\n    // time Complexity = O(n*n*n*k) - Verdict - TLE\\n    // int solve(int i, int j,  vector<int> &arr, int t){\\n    //     if(i > j) return 0;\\n    //     if(dp[i][j] != -1) return dp[i][j];\\n    //     if(i == j) return arr[i];\\n    //     if(j - i + 1 <= t){\\n    //         int mx = INT_MIN;\\n    //         for(int x = i; x<=j; x++)mx = max(mx, arr[x]);\\n    //         return (j-i+1)*mx;\\n    //     }\\n    //     int ans = 0;\\n    //     for(int k = i; k<j; k++){\\n    //         ans = max(ans,  solve(i, k, arr, t) + solve(k+1, j, arr, t));\\n    //     }\\n    //     return dp[i][j] = ans;\\n    // }\\n\\n    // using Front Row Partition Dp - Time Complexity = O(n*k)\\n    int solve(int i, int k, vector<int> &arr){\\n        if(i == arr.size()) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ans = 0;\\n        int mx = 0;\\n        for(int j = i; j < i + k && j < arr.size(); j++){\\n            mx = max(mx, arr[j]);\\n            ans = max(ans, mx*(j-i+1) + solve(j+1, k, arr));\\n        }\\n        return dp[i] = ans;\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, k, arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[510];\\n    // time Complexity = O(n*n*n*k) - Verdict - TLE\\n    // int solve(int i, int j,  vector<int> &arr, int t){\\n    //     if(i > j) return 0;\\n    //     if(dp[i][j] != -1) return dp[i][j];\\n    //     if(i == j) return arr[i];\\n    //     if(j - i + 1 <= t){\\n    //         int mx = INT_MIN;\\n    //         for(int x = i; x<=j; x++)mx = max(mx, arr[x]);\\n    //         return (j-i+1)*mx;\\n    //     }\\n    //     int ans = 0;\\n    //     for(int k = i; k<j; k++){\\n    //         ans = max(ans,  solve(i, k, arr, t) + solve(k+1, j, arr, t));\\n    //     }\\n    //     return dp[i][j] = ans;\\n    // }\\n\\n    // using Front Row Partition Dp - Time Complexity = O(n*k)\\n    int solve(int i, int k, vector<int> &arr){\\n        if(i == arr.size()) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ans = 0;\\n        int mx = 0;\\n        for(int j = i; j < i + k && j < arr.size(); j++){\\n            mx = max(mx, arr[j]);\\n            ans = max(ans, mx*(j-i+1) + solve(j+1, k, arr));\\n        }\\n        return dp[i] = ans;\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, k, arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754823,
                "title": "java-dp-memoization",
                "content": "# Memoization\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp, -1);\\n        return helper(arr, 0, k, dp);\\n    }\\n\\n    private int helper(int[] arr, int ind, int k, int[] dp) {\\n        if (ind >= arr.length) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxSum = 0, maxValue = 0;\\n        for (int i = ind; i < Math.min(ind + k, arr.length); i++) {\\n            maxValue = Math.max(maxValue, arr[i]);\\n            maxSum = Math.max((i - ind + 1) * maxValue + helper(arr, i + 1, k, dp), maxSum);\\n        }\\n\\n        return dp[ind] = maxSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp, -1);\\n        return helper(arr, 0, k, dp);\\n    }\\n\\n    private int helper(int[] arr, int ind, int k, int[] dp) {\\n        if (ind >= arr.length) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxSum = 0, maxValue = 0;\\n        for (int i = ind; i < Math.min(ind + k, arr.length); i++) {\\n            maxValue = Math.max(maxValue, arr[i]);\\n            maxSum = Math.max((i - ind + 1) * maxValue + helper(arr, i + 1, k, dp), maxSum);\\n        }\\n\\n        return dp[ind] = maxSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649204,
                "title": "easy-intuitive-dp-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int solve(vector<int> &arr, int i, int k) {\\n\\n        if(i >= arr.size()) {\\n            return 0;\\n        }\\n        if(dp[i] != -1) {\\n            return dp[i];\\n        }\\n        int ans = INT_MIN;\\n        for(int j = i; j < i + k and j < arr.size(); j++) {\\n            int maxx = INT_MIN;\\n            for(int k = i; k < j+1; k++) {\\n                maxx = max(maxx, arr[k]);\\n            }\\n            int temp = maxx * (j-i+1);\\n            int nextAns = solve(arr, j+1, k);\\n            ans = max(ans, temp + nextAns);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(arr, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int solve(vector<int> &arr, int i, int k) {\\n\\n        if(i >= arr.size()) {\\n            return 0;\\n        }\\n        if(dp[i] != -1) {\\n            return dp[i];\\n        }\\n        int ans = INT_MIN;\\n        for(int j = i; j < i + k and j < arr.size(); j++) {\\n            int maxx = INT_MIN;\\n            for(int k = i; k < j+1; k++) {\\n                maxx = max(maxx, arr[k]);\\n            }\\n            int temp = maxx * (j-i+1);\\n            int nextAns = solve(arr, j+1, k);\\n            ans = max(ans, temp + nextAns);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(arr, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559973,
                "title": "golang-solution",
                "content": "```\\nfunc maxSumAfterPartitioning(arr []int, k int) int {\\n\\tdp := make([]int, len(arr))\\n\\tdp[0] = arr[0]\\n\\tfor i := 1; i < len(arr); i++ {\\n\\t\\tmax, maxValue := 0, 0\\n\\t\\tfor j := i; j >= Max(0, i-k+1); j-- {\\n\\t\\t\\tmaxValue = Max(arr[j], maxValue)\\n\\t\\t\\tcalc := (i - j + 1) * maxValue\\n\\t\\t\\tif j > 0 {\\n\\t\\t\\t\\tmax = Max(max, calc+dp[j-1])\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tmax = Max(max, calc)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = max\\n\\t}\\n\\treturn dp[len(arr)-1]\\n}\\n\\n\\nfunc Max(a, b int) int{\\n\\tif a > b{\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSumAfterPartitioning(arr []int, k int) int {\\n\\tdp := make([]int, len(arr))\\n\\tdp[0] = arr[0]\\n\\tfor i := 1; i < len(arr); i++ {\\n\\t\\tmax, maxValue := 0, 0\\n\\t\\tfor j := i; j >= Max(0, i-k+1); j-- {\\n\\t\\t\\tmaxValue = Max(arr[j], maxValue)\\n\\t\\t\\tcalc := (i - j + 1) * maxValue\\n\\t\\t\\tif j > 0 {\\n\\t\\t\\t\\tmax = Max(max, calc+dp[j-1])\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tmax = Max(max, calc)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = max\\n\\t}\\n\\treturn dp[len(arr)-1]\\n}\\n\\n\\nfunc Max(a, b int) int{\\n\\tif a > b{\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3308105,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp)\\n    {\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++)\\n        {\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k)\\n     {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp)\\n    {\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++)\\n        {\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k)\\n     {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040967,
                "title": "c-recursion-memoization-tabulation",
                "content": "# Recursion\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        return f(0, n, k, arr);  \\n    }\\n};\\n```\\n\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v, vector<int> &dp)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v, dp);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, -1);\\n\\n        return f(0, n, k, arr, dp); \\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, 0);\\n\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n\\n            for (int j = i; j < min(i + k, n); j++)\\n            {\\n                length++;\\n                maxi = max(maxi, arr[j]);\\n                sum = length * maxi + dp[j + 1];\\n                maxSum = max(maxSum, sum);\\n            }\\n            dp[i] = maxSum;\\n        }\\n\\n        return dp[0];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        return f(0, n, k, arr);  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v, vector<int> &dp)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v, dp);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, -1);\\n\\n        return f(0, n, k, arr, dp); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, 0);\\n\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n\\n            for (int j = i; j < min(i + k, n); j++)\\n            {\\n                length++;\\n                maxi = max(maxi, arr[j]);\\n                sum = length * maxi + dp[j + 1];\\n                maxSum = max(maxSum, sum);\\n            }\\n            dp[i] = maxSum;\\n        }\\n\\n        return dp[0];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658807,
                "title": "python-recursion-memoization-super-easy-partition-array-for-maximum-sum",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @cache\\n        def max_sum_after_partitioning(k, index):\\n            if index == len(arr):\\n                return 0\\n            current_max = float(\\'-inf\\')\\n            ans = float(\\'-inf\\')\\n            length = 0\\n            for i in range(index, min(len(arr),index+k)):\\n                length += 1\\n\\n                current_max = max(current_max, arr[i])\\n                ans = max(ans, current_max*length + max_sum_after_partitioning(k, i+1))\\n\\n\\n            return ans\\n        return max_sum_after_partitioning(k, 0)\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @cache\\n        def max_sum_after_partitioning(k, index):\\n            if index == len(arr):\\n                return 0\\n            current_max = float(\\'-inf\\')\\n            ans = float(\\'-inf\\')\\n            length = 0\\n            for i in range(index, min(len(arr),index+k)):\\n                length += 1\\n\\n                current_max = max(current_max, arr[i])\\n                ans = max(ans, current_max*length + max_sum_after_partitioning(k, i+1))\\n\\n\\n            return ans\\n        return max_sum_after_partitioning(k, 0)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586925,
                "title": "c-simple-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp){\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++){\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k) {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp){\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++){\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k) {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461264,
                "title": "python-solution-dp-practically-brute-force",
                "content": "I spent some time to get the indicies right though\\n```\\nclass Solution:\\n    # This is a DP problem\\n    # 1 <= arr.length <= 500 -> Can look for n^2 (or nk) algorithms\\n    # dp[i] = largest sum of arr[:i+1] after partitioning\\n    # subproblem structure: in principle, for each [j:i+1] subwindow (i-j+1 <= k), we need to look for the max of dp[j] + (i-j)*max(arr[j:i+1])\\n    # To do this efficiently, we can use a variable currMax to scan for max seen from arr[i] back to arr[j:i+1]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            curr_max = 0\\n            for j in range(i-1, max(i-k-1, -1), -1):\\n                curr_max = max(curr_max, arr[j])\\n                dp[i] = max(dp[i], dp[j] + (i-j)*curr_max)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This is a DP problem\\n    # 1 <= arr.length <= 500 -> Can look for n^2 (or nk) algorithms\\n    # dp[i] = largest sum of arr[:i+1] after partitioning\\n    # subproblem structure: in principle, for each [j:i+1] subwindow (i-j+1 <= k), we need to look for the max of dp[j] + (i-j)*max(arr[j:i+1])\\n    # To do this efficiently, we can use a variable currMax to scan for max seen from arr[i] back to arr[j:i+1]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            curr_max = 0\\n            for j in range(i-1, max(i-k-1, -1), -1):\\n                curr_max = max(curr_max, arr[j])\\n                dp[i] = max(dp[i], dp[j] + (i-j)*curr_max)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445808,
                "title": "partition-dp-memoization",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int fun(int st,int n,int k,vector<int>&arr){\\n        if(dp[st]!=-1)return dp[st];\\n        if(st>=n)return dp[st]=0;\\n        int mx=arr[st];\\n        int max_ans=-1;\\n        for(int i=st;i<n and i-st<k;i++){\\n            mx=max(mx,arr[i]);\\n            int ans=(i-st+1)*mx+fun(i+1,n,k,arr);\\n            max_ans=max(max_ans,ans);\\n        }\\n        return  dp[st]=max_ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        dp.resize(arr.size()+1,-1);\\n        return fun(0,arr.size(),k,arr);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int fun(int st,int n,int k,vector<int>&arr){\\n        if(dp[st]!=-1)return dp[st];\\n        if(st>=n)return dp[st]=0;\\n        int mx=arr[st];\\n        int max_ans=-1;\\n        for(int i=st;i<n and i-st<k;i++){\\n            mx=max(mx,arr[i]);\\n            int ans=(i-st+1)*mx+fun(i+1,n,k,arr);\\n            max_ans=max(max_ans,ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2418299,
                "title": "dynamic-programming-mcm-variation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n    \\n          int start=0;\\n          dp.resize(arr.size(),-1);\\n          return fun(arr,k,start);\\n    }\\n    int fun(vector<int>&arr,int &k,int idx)\\n    {\\n        if(idx>=arr.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int max_val=INT_MIN;\\n        int ans=INT_MIN;\\n        int len=0;\\n        \\n        for(int i=idx;i<(idx+k) and i<arr.size() ;i++)\\n        {\\n            max_val=max(max_val,arr[i]);  //max till the length\\n            len++;\\n            \\n            dp[idx]=max(dp[idx],(max_val*len)+fun(arr,k,i+1));\\n        }\\n        return dp[idx];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n    \\n          int start=0;\\n          dp.resize(arr.size(),-1);\\n          return fun(arr,k,start);\\n    }\\n    int fun(vector<int>&arr,int &k,int idx)\\n    {\\n        if(idx>=arr.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int max_val=INT_MIN;\\n        int ans=INT_MIN;\\n        int len=0;\\n        \\n        for(int i=idx;i<(idx+k) and i<arr.size() ;i++)\\n        {\\n            max_val=max(max_val,arr[i]);  //max till the length\\n            len++;\\n            \\n            dp[idx]=max(dp[idx],(max_val*len)+fun(arr,k,i+1));\\n        }\\n        return dp[idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359326,
                "title": "c-recursion-memoization-tabulation-dp-similar-front-partitioning-dp",
                "content": "Recursion + memoization : \\n\\nFor every subarray of size \\'k\\' we have an option to partition it at the current index and recur for the remaining array while adding  **currPartitionLength*localMax** to the answer .\\nWe take the max of all possible combinations of such subarrays and return the max answer.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int recur(vector<int>& arr, int index, int k, vector<int> &memo)\\n    {\\n        \\n        int n=arr.size();\\n        \\n        if(index == n)\\n        {\\n            return 0;\\n        }\\n        \\n        if(memo[index] != -1)\\n        {\\n           return memo[index];\\n        }\\n        \\n        int currPartitionLength, maxCost, localMax;\\n        currPartitionLength = 0;\\n        maxCost=0;\\n        localMax = INT_MIN;\\n        \\n        for(int j=index; j < min(index+k, n); j++)\\n        {\\n            currPartitionLength++;\\n            localMax = max(localMax, arr[j]);\\n            int cost = currPartitionLength*localMax+recur(arr, j+1, k, memo);\\n            maxCost = max(maxCost, cost);\\n        }\\n        \\n        return memo[index] = maxCost;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> memo(arr.size()+1, -1);\\n        return recur(arr, 0, k, memo);\\n    }\\n};\\n```\\n\\nConverting the top down recursion to tabulation, we get : \\n\\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\n        int n = arr.size();\\n        vector<int> dp(n+1, 0);\\n        dp[n] = 0;\\n        \\n        for(int index = n-1; index>=0; index--)\\n        {\\n            int currPartitionLength, maxCost, localMax;\\n            currPartitionLength = 0;\\n            maxCost=0;\\n            localMax = INT_MIN;\\n\\n            for(int j=index; j < min(index+k, n); j++)\\n            {\\n                currPartitionLength++;\\n                localMax = max(localMax, arr[j]);\\n                int cost = currPartitionLength*localMax+dp[j+1];\\n                maxCost = max(maxCost, cost);\\n            }\\n\\n            dp[index] = maxCost;\\n        }\\n        \\n        return dp[0];\\n    }\\n```\\n\\nFor tabulation, we simply reverse the direction of traversal and replace recursion calls with dp array.\\n\\nHappy learning!\\nDo comment if you have any doubts.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int recur(vector<int>& arr, int index, int k, vector<int> &memo)\\n    {\\n        \\n        int n=arr.size();\\n        \\n        if(index == n)\\n        {\\n            return 0;\\n        }\\n        \\n        if(memo[index] != -1)\\n        {\\n           return memo[index];\\n        }\\n        \\n        int currPartitionLength, maxCost, localMax;\\n        currPartitionLength = 0;\\n        maxCost=0;\\n        localMax = INT_MIN;\\n        \\n        for(int j=index; j < min(index+k, n); j++)\\n        {\\n            currPartitionLength++;\\n            localMax = max(localMax, arr[j]);\\n            int cost = currPartitionLength*localMax+recur(arr, j+1, k, memo);\\n            maxCost = max(maxCost, cost);\\n        }\\n        \\n        return memo[index] = maxCost;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> memo(arr.size()+1, -1);\\n        return recur(arr, 0, k, memo);\\n    }\\n};\\n```\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\n        int n = arr.size();\\n        vector<int> dp(n+1, 0);\\n        dp[n] = 0;\\n        \\n        for(int index = n-1; index>=0; index--)\\n        {\\n            int currPartitionLength, maxCost, localMax;\\n            currPartitionLength = 0;\\n            maxCost=0;\\n            localMax = INT_MIN;\\n\\n            for(int j=index; j < min(index+k, n); j++)\\n            {\\n                currPartitionLength++;\\n                localMax = max(localMax, arr[j]);\\n                int cost = currPartitionLength*localMax+dp[j+1];\\n                maxCost = max(maxCost, cost);\\n            }\\n\\n            dp[index] = maxCost;\\n        }\\n        \\n        return dp[0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358999,
                "title": "c-solution-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ret_sum(vector<int> &arr, int start, int end)\\n    {\\n        int maxi = 0, sum = 0;\\n        for(int i=start; i<end+1; i++) maxi = max(maxi, arr[i]);\\n        return (maxi*(end+1-start));\\n    }\\n    \\n    int func(vector<int> &dp, vector<int> &arr, int index, int k)\\n    {\\n        if(index > arr.size()-1) return 0;\\n        \\n        if(dp[index] != -1) return dp[index];\\n        \\n        int maxm = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            if(index+i > arr.size()-1) break;\\n            maxm = max(maxm, ret_sum(arr, index, index+i) + func(dp, arr, index+i+1, k));\\n        }\\n        return dp[index] = maxm;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size()+1, -1);\\n        return func(dp, arr, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ret_sum(vector<int> &arr, int start, int end)\\n    {\\n        int maxi = 0, sum = 0;\\n        for(int i=start; i<end+1; i++) maxi = max(maxi, arr[i]);\\n        return (maxi*(end+1-start));\\n    }\\n    \\n    int func(vector<int> &dp, vector<int> &arr, int index, int k)\\n    {\\n        if(index > arr.size()-1) return 0;\\n        \\n        if(dp[index] != -1) return dp[index];\\n        \\n        int maxm = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            if(index+i > arr.size()-1) break;\\n            maxm = max(maxm, ret_sum(arr, index, index+i) + func(dp, arr, index+i+1, k));\\n        }\\n        return dp[index] = maxm;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size()+1, -1);\\n        return func(dp, arr, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242821,
                "title": "c-solution-dp-tabulation-explained-via-comments",
                "content": "class Solution {\\npublic:\\n    \\n    // Tabulation Code\\n    \\n    \\n    // function to find maximum in the partition\\n    \\n    int search(int i,int j,vector<int>&nums){\\n        int maxi=-1e9;\\n        while(i<=j){\\n            maxi=max(maxi,nums[i++]);\\n        }\\n        return maxi;\\n    }\\n    \\n    \\n    \\n    \\n    int maxSumAfterPartitioning(vector<int>&nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<int>dp(n+1,0); // n+1 as j=n-1 then for j+1 to handle runtime error\\n        \\n        // base case \\n        dp[n]=0;\\n        \\n        //loops for iteration\\n        for(int i=n-1;i>=0;i--){ // changing variable\\n            int maxi=-1e9;\\n            // loop for partition\\n            // start from i+k-1 as it would be less than i+k\\n            // take minimum from n-1 and i+k-1 for array size\\n            for(int j=min(i+k-1,n-1);j>=i;j--){\\n                \\n                // finding maximum in partition \\n                int a=search(i,j,nums);\\n                //value added= length of partition j-i+1 x a\\n                // for partition of range i to j --> the length is j-i+1\\n                int val=(j-i+1)*a;\\n                \\n                // using pre computed state from next point i.e.j+1 because range from i to j is computed so precompute for state j+1;\\n                maxi=max(maxi,val+dp[j+1]);\\n            }\\n            \\n            //storing each state for each number we travel in the array\\n            dp[i]=maxi;\\n        }\\n        \\n        // maximum will be retrieved when whole array is computed i.e at index 0\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // Tabulation Code\\n    \\n    \\n    // function to find maximum in the partition\\n    \\n    int search(int i,int j,vector<int>&nums){\\n        int maxi=-1e9;\\n        while(i<=j){\\n            maxi=max(maxi,nums[i++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2210679,
                "title": "simple-solution-for-recursion-memoization-and-topdown",
                "content": "# recursion\\n\\n\\tclass Solution {\\n    int n,k;\\n    \\n    int rec(int i,vector<int>& arr,vector<int>&dp)\\n    {\\n        if(i==n)\\n            return 0;\\n        \\n        int len =0;\\n        int mx=INT_MIN,ans=INT_MIN;\\n        \\n        for(int j=i;j<min(i+k,n);++j)\\n        {\\n            ++len;\\n            mx=max(mx,arr[j]);\\n            int sum=mx*len+rec(j+1,arr,dp);\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n\\tpublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int K) \\n    {\\n        n=arr.size();\\n        k=K;\\n        vector<int>dp(n+1,0);\\n        return rec(0,arr,dp);\\n        // return 1;\\n    }\\n\\t};\\n\\t\\n# \\tmemoization\\n\\n\\tclass Solution {\\n    int n,k;\\n    int rec(int i,vector<int>&a,vector<int>&dp)\\n    {\\n        if(i==n)\\n            return 0;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int len=0,mx=0;\\n        \\n        for(int j=i;j<min(i+k,n);++j)\\n        {\\n            ++len;\\n            mx=max(a[j],mx);\\n            int sum=mx*len+rec(j+1,a,dp);\\n            dp[i]=max(dp[i],sum);\\n        }\\n        return dp[i];\\n    }\\n\\tpublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int K) {\\n        n=arr.size(),k=K;\\n        vector<int>dp(n+1,-1);\\n        return rec(0,arr,dp);\\n    }\\n\\t};\\n\\t\\n# \\ttopdown\\n\\tclass Solution {    \\n\\tpublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        vector<int>dp(n+1,0);\\n        \\n        for(int i=1;i<=n;++i)\\n        {\\n            int mx=0,sum=0;\\n            for(int j=1;j<=k && i-j>=0;++j)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                sum=max(mx*j+dp[i-j],sum);\\n            }\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int n,k;\\n    \\n    int rec(int i,vector<int>& arr,vector<int>&dp)\\n    {\\n        if(i==n)\\n            return 0;\\n        \\n        int len =0;\\n        int mx=INT_MIN,ans=INT_MIN;\\n        \\n        for(int j=i;j<min(i+k,n);++j)\\n        {\\n            ++len;\\n            mx=max(mx,arr[j]);\\n            int sum=mx*len+rec(j+1,arr,dp);\\n            ans=max(ans,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2205626,
                "title": "c-tabulation-easy-solution-dp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182884,
                "title": "using-dynamic-programming-o-n-k",
                "content": "```\\nif(ind==n) return 0;\\n\\tif(dp[ind]!=-1) return dp[ind];\\n\\tint len=0;\\n\\tint res=INT_MIN;\\n\\tint maxi=INT_MIN;\\n\\tfor(int i=ind;i<min(ind+k,n);i++){\\n\\t\\tlen++;\\n\\t\\tmaxi=max(maxi,arr[i]);\\n\\t\\tint sum=(len*maxi)+f(i+1,n,k,arr,dp);\\n\\n\\t\\tres=max(res,sum);\\n\\t}\\n\\n\\treturn dp[ind]=res;\\n}\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int>dp(arr.size(),-1);\\n\\treturn f(0,arr.size(),k,arr,dp);\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nif(ind==n) return 0;\\n\\tif(dp[ind]!=-1) return dp[ind];\\n\\tint len=0;\\n\\tint res=INT_MIN;\\n\\tint maxi=INT_MIN;\\n\\tfor(int i=ind;i<min(ind+k,n);i++){\\n\\t\\tlen++;\\n\\t\\tmaxi=max(maxi,arr[i]);\\n\\t\\tint sum=(len*maxi)+f(i+1,n,k,arr,dp);\\n\\n\\t\\tres=max(res,sum);\\n\\t}\\n\\n\\treturn dp[ind]=res;\\n}\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int>dp(arr.size(),-1);\\n\\treturn f(0,arr.size(),k,arr,dp);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144180,
                "title": "simple-forward-partitioning-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>&arr, int k, int i,vector<int>& dp){\\n        \\n        int n =arr.size();\\n        \\n        if(i == n) \\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int max_element=INT_MIN;\\n        int ans = INT_MIN;\\n        int len=0;\\n       \\n        // simply \\n        for(int j=i; j < min(i+k,n); j++){\\n            \\n            len++;\\n            max_element = max(arr[j], max_element);\\n            int sum = len*max_element + f(arr,k,j+1,dp);\\n            \\n            ans = max(ans,sum);\\n        }\\n        \\n        return dp[i] =ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        vector<int> dp(arr.size(),-1);\\n        \\n        return f(arr,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>&arr, int k, int i,vector<int>& dp){\\n        \\n        int n =arr.size();\\n        \\n        if(i == n) \\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int max_element=INT_MIN;\\n        int ans = INT_MIN;\\n        int len=0;\\n       \\n        // simply \\n        for(int j=i; j < min(i+k,n); j++){\\n            \\n            len++;\\n            max_element = max(arr[j], max_element);\\n            int sum = len*max_element + f(arr,k,j+1,dp);\\n            \\n            ans = max(ans,sum);\\n        }\\n        \\n        return dp[i] =ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        vector<int> dp(arr.size(),-1);\\n        \\n        return f(arr,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142656,
                "title": "java-recursive-to-memorization-to-dp",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length;\\n        int dp[] = new int[n];\\n        Arrays.fill(dp,-1);\\n        return func(0,n,arr,k,dp);\\n    }\\n    \\n    public int func(int ind,int n,int arr[],int k,int [] dp){\\n        if(ind == n) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        int maxiSum =Integer.MIN_VALUE;\\n        int len =0;\\n        int maxi = Integer.MIN_VALUE;\\n        for(int j=ind;j<Math.min(ind+k,n);j++){\\n            len++;\\n            maxi = Math.max(maxi,arr[j]);\\n            int sum = (len*maxi) + func(j+1,n,arr,k,dp);\\n            maxiSum=Math.max(sum,maxiSum);\\n            \\n        }\\n        return dp[ind] = maxiSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length;\\n        int dp[] = new int[n];\\n        Arrays.fill(dp,-1);\\n        return func(0,n,arr,k,dp);\\n    }\\n    \\n    public int func(int ind,int n,int arr[],int k,int [] dp){\\n        if(ind == n) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        int maxiSum =Integer.MIN_VALUE;\\n        int len =0;\\n        int maxi = Integer.MIN_VALUE;\\n        for(int j=ind;j<Math.min(ind+k,n);j++){\\n            len++;\\n            maxi = Math.max(maxi,arr[j]);\\n            int sum = (len*maxi) + func(j+1,n,arr,k,dp);\\n            maxiSum=Math.max(sum,maxiSum);\\n            \\n        }\\n        return dp[ind] = maxiSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060178,
                "title": "c-recursion-memoization-tabulation",
                "content": "**RECURSION (GIVES TLE)**\\n```\\nint f(int ind,vector<int>&nums,int k)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        return f(0,nums,k);\\n    }\\n};\\n```\\n**MEMOIZATION**\\n```\\nint f(int ind,vector<int>&nums,int k,vector<int>&dp)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k,dp);\\n            maxans=max(maxans,sum);\\n        }\\n        return dp[ind]=maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,nums,k,dp);\\n    }\\n};\\n```\\n**TABULATION**\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint f(int ind,vector<int>&nums,int k)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        return f(0,nums,k);\\n    }\\n};\\n```\n```\\nint f(int ind,vector<int>&nums,int k,vector<int>&dp)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k,dp);\\n            maxans=max(maxans,sum);\\n        }\\n        return dp[ind]=maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,nums,k,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978484,
                "title": "classic-dp-problem-java-clean-code",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length; \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MIN_VALUE); \\n        return fun(dp, arr, 0, k); \\n    }\\n    public int findMax(int[] arr, int i, int j){\\n        int max =0; \\n        for (int k = i; k <= j; k++){\\n            max = Math.max(arr[k], max);\\n        }\\n        \\n        return max; \\n    }\\n    public int fun(int[] dp, int[] arr, int pos, int k){\\n        int n = dp.length; \\n        if (pos >= n) return 0;\\n        // if (k == 1) return findMax(arr, pos, n - 1)*(n - pos); \\n        if (dp[pos] != Integer.MIN_VALUE) return dp[pos]; \\n        \\n        int ans = 0;  \\n        for (int i = pos + 1; i < Math.min(n , pos + k + 1); i++){\\n         ans = Math.max(ans, findMax(arr, pos, i - 1)*(i - pos) + fun(dp, arr, i, k));    \\n        }\\n     if (n - pos <= k)   ans = Math.max(ans, findMax(arr, pos, n - 1)*(n - pos)); \\n        dp[pos] = ans; \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length; \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MIN_VALUE); \\n        return fun(dp, arr, 0, k); \\n    }\\n    public int findMax(int[] arr, int i, int j){\\n        int max =0; \\n        for (int k = i; k <= j; k++){\\n            max = Math.max(arr[k], max);\\n        }\\n        \\n        return max; \\n    }\\n    public int fun(int[] dp, int[] arr, int pos, int k){\\n        int n = dp.length; \\n        if (pos >= n) return 0;\\n        // if (k == 1) return findMax(arr, pos, n - 1)*(n - pos); \\n        if (dp[pos] != Integer.MIN_VALUE) return dp[pos]; \\n        \\n        int ans = 0;  \\n        for (int i = pos + 1; i < Math.min(n , pos + k + 1); i++){\\n         ans = Math.max(ans, findMax(arr, pos, i - 1)*(i - pos) + fun(dp, arr, i, k));    \\n        }\\n     if (n - pos <= k)   ans = Math.max(ans, findMax(arr, pos, n - 1)*(n - pos)); \\n        dp[pos] = ans; \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968983,
                "title": "c-dp-memorization-with-explanation",
                "content": "1.  The intitution by reading this problem was to traverse\\n the whole array and at each index making the decision\\n to pick 0 to k elements < ie. index ----  index+k >\\n \\n2.  it is essential to use the maximum of the index ---- index+k\\nelement to make as per the question and it trivialy calculated\\n\\n3.  memoization also revolves around the fact that at perticular\\nindex we will have max solution\\n\\n**Pseudo Code**\\n4.  for i in index--- index+k:\\n          ans =  max_value*i-index+1 + backtrack(i+1)\\n          max_val = max(ans,max_val)\\n\\n\\n     return memo[index] = max_val\\n\\t \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        vector<int>dp(n+1,-1);\\n        return backtrack(arr,0,k,dp);\\n    }\\n    int backtrack(vector<int>&arr,int index,int k,vector<int>&dp){\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int max_value=INT_MIN;\\n        int maxAtIndex=INT_MIN;\\n        for(int i=index;i<index+k and i<n;i++){\\n            if(max_value<arr[i]){\\n                max_value=arr[i];\\n            }\\n            int ans = max_value*(i-index+1)+backtrack(arr,i+1,k,dp);\\n            maxAtIndex = max(ans,maxAtIndex);\\n        }\\n        return dp[index]=maxAtIndex;\\n    }\\n};\\n```\\nPls Upvote if you found this helpful",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        vector<int>dp(n+1,-1);\\n        return backtrack(arr,0,k,dp);\\n    }\\n    int backtrack(vector<int>&arr,int index,int k,vector<int>&dp){\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int max_value=INT_MIN;\\n        int maxAtIndex=INT_MIN;\\n        for(int i=index;i<index+k and i<n;i++){\\n            if(max_value<arr[i]){\\n                max_value=arr[i];\\n            }\\n            int ans = max_value*(i-index+1)+backtrack(arr,i+1,k,dp);\\n            maxAtIndex = max(ans,maxAtIndex);\\n        }\\n        return dp[index]=maxAtIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951674,
                "title": "c-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int n, int k,int idx,vector<int> &dp)\\n    {\\n        if(dp[idx]!=-1) return dp[idx];\\n        int max_num=0;\\n        int res=0;\\n        \\n        \\n        for(int i=idx; i<n && i-idx<k;i++)\\n        {\\n            max_num=max(max_num,arr[i]);\\n            res=max(res,max_num*(i-idx+1)+fun(arr,n,k,i+1,dp));            \\n        }\\n        dp[idx]=res;\\n        return res;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int> dp(n+1,-1);\\n        \\n        return fun(arr,n,k,0,dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int n, int k,int idx,vector<int> &dp)\\n    {\\n        if(dp[idx]!=-1) return dp[idx];\\n        int max_num=0;\\n        int res=0;\\n        \\n        \\n        for(int i=idx; i<n && i-idx<k;i++)\\n        {\\n            max_num=max(max_num,arr[i]);\\n            res=max(res,max_num*(i-idx+1)+fun(arr,n,k,i+1,dp));            \\n        }\\n        dp[idx]=res;\\n        return res;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int> dp(n+1,-1);\\n        \\n        return fun(arr,n,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923148,
                "title": "c-mcm-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500+10][500+10];\\n    int mcm(vector<int>&arr,int k,int i,int j)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0;\\n        for(int f=i;f<=min(j,i+k-1);f++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int y=i;y<=f;y++)\\n            {\\n                if(arr[y]>maxi)\\n                maxi=arr[y];\\n            }\\n            int temp=(f-i+1)*maxi+mcm(arr,k,f+1,j);\\n            if(temp>ans)\\n                ans=temp;\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return mcm(arr,k,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500+10][500+10];\\n    int mcm(vector<int>&arr,int k,int i,int j)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0;\\n        for(int f=i;f<=min(j,i+k-1);f++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int y=i;y<=f;y++)\\n            {\\n                if(arr[y]>maxi)\\n                maxi=arr[y];\\n            }\\n            int temp=(f-i+1)*maxi+mcm(arr,k,f+1,j);\\n            if(temp>ans)\\n                ans=temp;\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return mcm(arr,k,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921648,
                "title": "c-easy-understanding",
                "content": "\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\t  int n = arr.size();\\n\\t\\t\\t  vector<int> dp(n+1, 0);\\n\\n\\t\\t\\t  for(int i=1; i<=n; i++){\\n\\t\\t\\t\\t  int curr_max = 0;\\n\\t\\t\\t\\t  int curr_ans = 0;\\n\\n\\t\\t\\t\\t  for(int j=1; j<=k && i-j>=0; j++){\\n\\t\\t\\t\\t\\t  curr_max = max(curr_max, arr[i-j]);\\n\\t\\t\\t\\t\\t  curr_ans = max(curr_ans, dp[i-j] + curr_max * j);\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  dp[i] = curr_ans;\\n\\t\\t\\t  }\\n\\t\\t\\t   return dp[n];\\n\\t\\t}\\n\\t\\t",
                "solutionTags": [],
                "code": "\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\t  int n = arr.size();\\n\\t\\t\\t  vector<int> dp(n+1, 0);\\n\\n\\t\\t\\t  for(int i=1; i<=n; i++){\\n\\t\\t\\t\\t  int curr_max = 0;\\n\\t\\t\\t\\t  int curr_ans = 0;\\n\\n\\t\\t\\t\\t  for(int j=1; j<=k && i-j>=0; j++){\\n\\t\\t\\t\\t\\t  curr_max = max(curr_max, arr[i-j]);\\n\\t\\t\\t\\t\\t  curr_ans = max(curr_ans, dp[i-j] + curr_max * j);\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  dp[i] = curr_ans;\\n\\t\\t\\t  }\\n\\t\\t\\t   return dp[n];\\n\\t\\t}\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1906420,
                "title": "easy-recurssion-memoization-bottom-down-tabulation-bottom-up",
                "content": "RECURSSION\\n\\nTime Complexity = Exponentital\\nSpace Complexity = Exponential\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        \\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k));\\n        }\\n        \\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        return maxSum(n-1,arr,k);\\n    }\\n```\\n\\nMemoization ( Bottom Down)\\n\\nTime Complexity = O(N) // because of dp vector of n size;\\nSpace Complexity = O(N)// dp vector + stack space\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k,vector<int>&dp){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k,dp));\\n        }\\n        dp[ind] = ans;\\n        return dp[ind];\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,-1);\\n        return maxSum(n-1,arr,k,dp);\\n    }\\n};\\n```\\n\\nTabulation( Bottom Up)\\n\\nTime Complexity = O(N) // because of dp vector of n size;\\nSpace Complexity = O(N)// dp vector\\n```\\nclass Solution {\\npublic:\\n   \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        for(int i = 1 ; i < n ; i++){\\n            int ma = 0, ans = 0;\\n            for(int j = i ; j > i-k && j >= 0 ; j--){\\n                ma = max(arr[j] , ma);\\n                if(j>=1)\\n                    ans = max(dp[j-1] + ma*(i-j+1),ans);\\n                else ans = max(ans,ma*(i-j+1));\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Upvote if you like the code**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        \\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k));\\n        }\\n        \\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        return maxSum(n-1,arr,k);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k,vector<int>&dp){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k,dp));\\n        }\\n        dp[ind] = ans;\\n        return dp[ind];\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,-1);\\n        return maxSum(n-1,arr,k,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        for(int i = 1 ; i < n ; i++){\\n            int ma = 0, ans = 0;\\n            for(int j = i ; j > i-k && j >= 0 ; j--){\\n                ma = max(arr[j] , ma);\\n                if(j>=1)\\n                    ans = max(dp[j-1] + ma*(i-j+1),ans);\\n                else ans = max(ans,ma*(i-j+1));\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1870126,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n          int n = arr.size();\\n          int dp[n + 1];\\n          memset(dp, 0, sizeof(dp));\\n          for(int i= 1; i<=n; i++){\\n              int K = k;\\n              int cur_max = 0;\\n              int cur_ans = 0;\\n              for(int K = 1; K <= k && i - K >= 0; K++){\\n                  cur_max = max(cur_max, arr[i-K]);\\n                  cur_ans = max(cur_ans, dp[i-K] + K * cur_max);\\n              }\\n              dp[i] = cur_ans;\\n          }\\n           return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n          int n = arr.size();\\n          int dp[n + 1];\\n          memset(dp, 0, sizeof(dp));\\n          for(int i= 1; i<=n; i++){\\n              int K = k;\\n              int cur_max = 0;\\n              int cur_ans = 0;\\n              for(int K = 1; K <= k && i - K >= 0; K++){\\n                  cur_max = max(cur_max, arr[i-K]);\\n                  cur_ans = max(cur_ans, dp[i-K] + K * cur_max);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1862527,
                "title": "python-dp-explained-in-comments",
                "content": "```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\t\"\"\"\\n\\t\\tk=3\\n\\t   idx   [0]     [1]      [2]     [3]     [4] [5] [6]\\n\\t\\tarr = 1      15       7       9       2   5   10\\n\\t\\tdp    1   dp[0]+15 or \\n\\t\\t\\t\\t  15*2\\n\\t\\t\\t\\t\\t\\t   dp[1]+7 or\\n\\t\\t\\t\\t\\t\\t   dp[0]+15*2 or\\n\\t\\t\\t\\t\\t\\t   15*3\\n\\t\\t\\t... so ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i] = max(element from j to i)*(i-j)+dp[j-1] or\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i]\\n\\t\"\"\"\\n\\tdp = [0]*(len(arr))\\n\\tfor i in range(0, len(arr)):\\n\\t\\tfor j in range(i, max(i-k, -1), -1):\\n\\t\\t\\tnew_split = max(arr[j:i+1]) * (i-j+1)\\n\\t\\t\\tprev = dp[j-1] if j>0 else 0\\n\\t\\t\\tdp[i] = max(dp[i], prev +new_split)\\n\\treturn dp[-1]\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\t\"\"\"\\n\\t\\tk=3\\n\\t   idx   [0]     [1]      [2]     [3]     [4] [5] [6]\\n\\t\\tarr = 1      15       7       9       2   5   10\\n\\t\\tdp    1   dp[0]+15 or \\n\\t\\t\\t\\t  15*2\\n\\t\\t\\t\\t\\t\\t   dp[1]+7 or\\n\\t\\t\\t\\t\\t\\t   dp[0]+15*2 or\\n\\t\\t\\t\\t\\t\\t   15*3\\n\\t\\t\\t... so ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i] = max(element from j to i)*(i-j)+dp[j-1] or\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i]\\n\\t\"\"\"\\n\\tdp = [0]*(len(arr))\\n\\tfor i in range(0, len(arr)):\\n\\t\\tfor j in range(i, max(i-k, -1), -1):\\n\\t\\t\\tnew_split = max(arr[j:i+1]) * (i-j+1)\\n\\t\\t\\tprev = dp[j-1] if j>0 else 0\\n\\t\\t\\tdp[i] = max(dp[i], prev +new_split)\\n\\treturn dp[-1]\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1854834,
                "title": "c-memoization-solution-o-nk-time-complexity",
                "content": "```\\nclass Solution {\\nprivate:\\n    // memo[i] defines the largest sum starting from the ith index\\n    vector<int>memo;\\n    int solve(vector<int>&arr,int k,int index){\\n        if(index>=arr.size()){\\n            return 0;\\n        } else if(memo[index]!=-1){\\n            return memo[index];\\n        } else {\\n            int maxElement=arr[index];\\n            int ans=-1;\\n            //since we do not know what window size to take, we will brute force through all of them and store the maximum result\\n            for(int i=index;i<index+k and i<arr.size();i++){\\n                maxElement=max(maxElement,arr[i]);\\n                ans=max(ans,maxElement*(i-index+1)+solve(arr,k,i+1));\\n            }\\n            return memo[index]=ans;\\n        }\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memo=vector<int>(arr.size(),-1);\\n        return solve(arr,k,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    // memo[i] defines the largest sum starting from the ith index\\n    vector<int>memo;\\n    int solve(vector<int>&arr,int k,int index){\\n        if(index>=arr.size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1816601,
                "title": "c-dp-bottom-up-approach-very-easy-to-understand",
                "content": "let suppose if we have one element in array than the answer will be arr[0];\\nthen we have to think if we have 2 element than what will be the answer.\\n\\nwe have to increase one by one element max maximize it.\\nfor first k element the answer will be k*max(arr[0],arr[1],,,,,arr[k[);\\n\\nthen we will start loop from k+1\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int t[n],m=arr[0];\\n        memset(t,-1,sizeof(t));\\n        for(int i=0;i<k;i++)\\n        {\\n            m= max(m,arr[i]); \\n            t[i] = m*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            m=0;\\n            for(int j = i;j>i-k;j--)\\n            {\\n                m = max(m,arr[j]);\\n                t[i] = max(t[i], m*(i-j+1)+ t[j-1]);\\n            }\\n        }\\n        return t[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int t[n],m=arr[0];\\n        memset(t,-1,sizeof(t));\\n        for(int i=0;i<k;i++)\\n        {\\n            m= max(m,arr[i]); \\n            t[i] = m*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            m=0;\\n            for(int j = i;j>i-k;j--)\\n            {\\n                m = max(m,arr[j]);\\n                t[i] = max(t[i], m*(i-j+1)+ t[j-1]);\\n            }\\n        }\\n        return t[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732431,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            int currMax = 0;\\n            // the farthest position that can be impacted by index i is:   i - k + 1\\n            // therefore, we iterate dp[] from index     1 to i - k + 1  to find\\n            // the max partition method for dp[i]\\n            // if the current length of right subarray is j = 2. And, i = 5 (0-based index)\\n            // [1,2,3,4,5,6], k = 3\\n            //            i\\n            // then the farthest position can be impacted by index i is i - j + 1 = 4\\n            // rightMax is the max value of right subarray, which now is 6\\n            // then right subarray is rightMax * length of right subarray = 6 * 2 = 12\\n            // \\n            for (int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                currMax = Math.max(currMax, arr[i - j + 1]);\\n                int rightSub = currMax * j;\\n                if (i - j < 0) {\\n                    dp[i] = Math.max(dp[i], rightSub);\\n                } else {\\n                    dp[i] = Math.max(dp[i], dp[i - j] + rightSub);\\n                }\\n            }\\n        }\\n        return dp[arr.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            int currMax = 0;\\n            // the farthest position that can be impacted by index i is:   i - k + 1\\n            // therefore, we iterate dp[] from index     1 to i - k + 1  to find\\n            // the max partition method for dp[i]\\n            // if the current length of right subarray is j = 2. And, i = 5 (0-based index)\\n            // [1,2,3,4,5,6], k = 3\\n            //            i\\n            // then the farthest position can be impacted by index i is i - j + 1 = 4\\n            // rightMax is the max value of right subarray, which now is 6\\n            // then right subarray is rightMax * length of right subarray = 6 * 2 = 12\\n            // \\n            for (int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                currMax = Math.max(currMax, arr[i - j + 1]);\\n                int rightSub = currMax * j;\\n                if (i - j < 0) {\\n                    dp[i] = Math.max(dp[i], rightSub);\\n                } else {\\n                    dp[i] = Math.max(dp[i], dp[i - j] + rightSub);\\n                }\\n            }\\n        }\\n        return dp[arr.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708248,
                "title": "c-bottom-up-o-nk",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size() + 1);\\n        int n = arr.size();\\n        for (int i = n - 1; i >= 0; i--) {\\n            int mx = 0;\\n            for (int j = i; j < min(n, i + k); j++) {\\n                mx = max(mx, arr[j]);\\n                dp[i] = max(dp[i], dp[j + 1] + mx * (j - i + 1));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size() + 1);\\n        int n = arr.size();\\n        for (int i = n - 1; i >= 0; i--) {\\n            int mx = 0;\\n            for (int j = i; j < min(n, i + k); j++) {\\n                mx = max(mx, arr[j]);\\n                dp[i] = max(dp[i], dp[j + 1] + mx * (j - i + 1));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682466,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633061,
                "title": "python-simple-dp-10-lines",
                "content": "```\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(arr)\\n        dp = [0 for _ in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1, k+1):\\n                if i-j < 0:\\n                    break\\n                dp[i] = max(dp[i], dp[i-j] + max(arr[i-j:i])*j)\\n        return dp[n]",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(arr)\\n        dp = [0 for _ in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1, k+1):\\n                if i-j < 0:\\n                    break\\n                dp[i] = max(dp[i], dp[i-j] + max(arr[i-j:i])*j)\\n        return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1533766,
                "title": "dp-python-code",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # DP dp[i] = max sum of arr[0] ~ arr[i-1]\\n        n = len(arr)\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            cur_max = arr[i-1]\\n            # pick the maximum for dp[i] when considering the last subarrry includes different numbers (1, 2, ... k)\\n            for j in range(1, k + 1):\\n                if i - j >= 0:\\n                    cur_max = max(cur_max, arr[i - j])\\n                    dp[i] = max(dp[i], dp[i-j] + j * cur_max)\\n        return dp[n]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # DP dp[i] = max sum of arr[0] ~ arr[i-1]\\n        n = len(arr)\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            cur_max = arr[i-1]\\n            # pick the maximum for dp[i] when considering the last subarrry includes different numbers (1, 2, ... k)\\n            for j in range(1, k + 1):\\n                if i - j >= 0:\\n                    cur_max = max(cur_max, arr[i - j])\\n                    dp[i] = max(dp[i], dp[i-j] + j * cur_max)\\n        return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1530479,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(arr:tuple):\\n            if not arr:\\n                return 0\\n            \\n            ret = 0\\n            for i in range(1, min(k+1, len(arr)+1)):\\n                window = arr[:i]\\n                max_window = max(arr[:i])\\n                new_arr = tuple(arr[i:])\\n                \\n                ret = max(ret, max_window*i + helper(new_arr))\\n            \\n            return ret\\n        \\n        return helper(tuple(arr)) if k > 1 else sum(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(arr:tuple):\\n            if not arr:\\n                return 0\\n            \\n            ret = 0\\n            for i in range(1, min(k+1, len(arr)+1)):\\n                window = arr[:i]\\n                max_window = max(arr[:i])\\n                new_arr = tuple(arr[i:])\\n                \\n                ret = max(ret, max_window*i + helper(new_arr))\\n            \\n            return ret\\n        \\n        return helper(tuple(arr)) if k > 1 else sum(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530159,
                "title": "java-easy-solution-bottom-up-dp-polynomial-time-complexity",
                "content": "```\\nclass Solution {\\n    \\n    \\n    \\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    \\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482276,
                "title": "c-simple-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int > dp(arr.size(), 0);\\n        dp[0] = arr[0];\\n        for (int i = 1; i < arr.size(); ++i) {\\n            int max_v = 0;\\n            for (int j = 0; j < k && i - j >= 0; ++j) {\\n                max_v = std::max(max_v, arr[i - j]);\\n                int left_value = (i - j == 0 ? 0 : dp[i - j - 1]);\\n                dp[i] = std::max(dp[i], (left_value + max_v * (j + 1)));\\n            }\\n        }\\n        return dp[arr.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int > dp(arr.size(), 0);\\n        dp[0] = arr[0];\\n        for (int i = 1; i < arr.size(); ++i) {\\n            int max_v = 0;\\n            for (int j = 0; j < k && i - j >= 0; ++j) {\\n                max_v = std::max(max_v, arr[i - j]);\\n                int left_value = (i - j == 0 ? 0 : dp[i - j - 1]);\\n                dp[i] = std::max(dp[i], (left_value + max_v * (j + 1)));\\n            }\\n        }\\n        return dp[arr.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456159,
                "title": "simple-python-o-nk-dynamic-programming-solution",
                "content": "```Python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # let dp[i] denote the maximum sum for the \\n\\t\\t# first i elements of arr\\n\\t\\t# i.e arr[0]...arr[i-1]\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            window_max = 0\\n            for window_size in range(1, k+1):\\n                if i-window_size < 0: break\\n                window_max = max(window_max, arr[i-window_size])\\n                dp[i] = max(dp[i], dp[i-window_size]+window_max*window_size)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # let dp[i] denote the maximum sum for the \\n\\t\\t# first i elements of arr\\n\\t\\t# i.e arr[0]...arr[i-1]\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            window_max = 0\\n            for window_size in range(1, k+1):\\n                if i-window_size < 0: break\\n                window_max = max(window_max, arr[i-window_size])\\n                dp[i] = max(dp[i], dp[i-window_size]+window_max*window_size)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452028,
                "title": "recursive-memo-dp-with-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/434e08db-cb69-47df-8f77-ac9583a44411_1631098683.8599129.jpeg)\\n\\n**Recursive**\\n```\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        return fun(arr,0,k);\\n    }\\n```\\n\\n**Memo**\\n```\\nvector<int>dp;\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    if(dp[i]!=-1)\\n    {\\n    return dp[i];\\n    }\\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return dp[i]=maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n         dp.resize(arr.size(),-1);\\n        return fun(arr,0,k);\\n    }\\n```\\n\\n**DP**\\n```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n    int dp[n+1];\\n        dp[n]=0;\\n    int maxoverall=0;\\n    for(int l=n;l>=0;l--)\\n    {\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=l+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=dp[tillarr+1];\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n       dp[l]=maxoverall;\\n}\\nreturn dp[0];\\n    }\\n\\n```\\n**upvote if this helps :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        return fun(arr,0,k);\\n    }\\n```\n```\\nvector<int>dp;\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    if(dp[i]!=-1)\\n    {\\n    return dp[i];\\n    }\\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return dp[i]=maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n         dp.resize(arr.size(),-1);\\n        return fun(arr,0,k);\\n    }\\n```\n```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n    int dp[n+1];\\n        dp[n]=0;\\n    int maxoverall=0;\\n    for(int l=n;l>=0;l--)\\n    {\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=l+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=dp[tillarr+1];\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n       dp[l]=maxoverall;\\n}\\nreturn dp[0];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406284,
                "title": "python3-dynamic-programming",
                "content": "**the idea here is to form k length subarrays for each element and check for maximum sum. k length subarrays should be made using k-1 previous elements for any arr[i]. Simultaneously keep track of maximum element in that subarray.**\\n```\\n#TIME COMPLEXITY - O(N*k)\\n#SPACE COMPLEXITY - O(N)\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(len(arr)+1)]\\n        dp[0]=0\\n        for i in range(len(arr)):\\n            best,curr_max=0,0\\n            for j in range(min(k,i+1)):\\n                curr_max=max(curr_max,arr[i-j])\\n                best=max(best,dp[i-j]+curr_max*(j+1))\\n            dp[i+1]=best\\n        return dp[len(arr)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(N*k)\\n#SPACE COMPLEXITY - O(N)\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(len(arr)+1)]\\n        dp[0]=0\\n        for i in range(len(arr)):\\n            best,curr_max=0,0\\n            for j in range(min(k,i+1)):\\n                curr_max=max(curr_max,arr[i-j])\\n                best=max(best,dp[i-j]+curr_max*(j+1))\\n            dp[i+1]=best\\n        return dp[len(arr)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352080,
                "title": "java-recursion-memoization-dp-3ms-beats-99-64-t-c-o-n-k-s-c-o-n",
                "content": "\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRec(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\treturn maxSumAfterPartitioningRecHelper(arr, k, 0, len);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRecHelper(int[] arr, int k, int si, int len) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningRecHelper(arr, k, si + i + 1, len);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemo(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tInteger[] memo = new Integer[len];\\n\\t\\treturn maxSumAfterPartitioningMemoHelper(arr, k, 0, len, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemoHelper(int[] arr, int k, int si, int len, Integer[] memo) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[si] != null)\\n\\t\\t\\treturn memo[si];\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningMemoHelper(arr, k, si + i + 1, len, memo);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\n\\t\\tmemo[si] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningBU(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tint[] dp = new int[len + 1];\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int j = 0; j < k && i + j < len; j++) {\\n\\t\\t\\t\\tif (arr[i + j] > max)\\n\\t\\t\\t\\t\\tmax = arr[i + j];\\n\\t\\t\\t\\tint sum = max * (j + 1) + dp[i + j + 1];\\n\\t\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\t\\tans = sum;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = ans;\\n\\t\\t}\\n\\n\\t\\treturn dp[0];\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRec(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\treturn maxSumAfterPartitioningRecHelper(arr, k, 0, len);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRecHelper(int[] arr, int k, int si, int len) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningRecHelper(arr, k, si + i + 1, len);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemo(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tInteger[] memo = new Integer[len];\\n\\t\\treturn maxSumAfterPartitioningMemoHelper(arr, k, 0, len, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemoHelper(int[] arr, int k, int si, int len, Integer[] memo) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[si] != null)\\n\\t\\t\\treturn memo[si];\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningMemoHelper(arr, k, si + i + 1, len, memo);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\n\\t\\tmemo[si] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningBU(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tint[] dp = new int[len + 1];\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int j = 0; j < k && i + j < len; j++) {\\n\\t\\t\\t\\tif (arr[i + j] > max)\\n\\t\\t\\t\\t\\tmax = arr[i + j];\\n\\t\\t\\t\\tint sum = max * (j + 1) + dp[i + j + 1];\\n\\t\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\t\\tans = sum;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = ans;\\n\\t\\t}\\n\\n\\t\\treturn dp[0];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1334993,
                "title": "simple-c-dp-memorization",
                "content": "class Solution {\\npublic:\\n    int dp[501];\\n    \\n    int helper(vector<int>&arr, int k , int start)\\n    {\\n        int n = arr.size(); \\n        int max_v = 0; \\n        if ( start >= n)\\n            return 0 ; \\n        int total=0;\\n        if ( dp[start]!=-1)\\n            return dp[start];\\n        for ( int i = start;  i<min(start+k, n); i++)\\n        {\\n    \\n                if (max_v < arr[i])\\n                {\\n                    max_v = arr[i];\\n                }\\n           int t ;\\n            t = max_v*(i-start+1) + helper(arr, k, i+1);\\n            if ( t > total)\\n                total = t; \\n        }\\n        \\n        return dp[start]=total; \\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(arr, k, 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[501];\\n    \\n    int helper(vector<int>&arr, int k , int start)\\n    {\\n        int n = arr.size(); \\n        int max_v = 0; \\n        if ( start >= n)\\n            return 0 ; \\n        int total=0;\\n        if ( dp[start]!=-1)\\n            return dp[start];\\n        for ( int i = start;  i<min(start+k, n); i++)\\n        {\\n    \\n                if (max_v < arr[i])\\n                {\\n                    max_v = arr[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1300905,
                "title": "c-o-nk-time-o-n-space-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size(),maxx,j;\\n        vector<int> dp(n+1,0);\\n        \\n        for (int i=1;i<=n;i++)\\n        {\\n            maxx=arr[i-1];\\n            j=0;\\n            while(j<k && j<=i-1)\\n            {\\n                maxx=max(arr[i-j-1],maxx);\\n                dp[i]=max(dp[i],dp[i-j-1]+maxx*(j+1));\\n                j++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size(),maxx,j;\\n        vector<int> dp(n+1,0);\\n        \\n        for (int i=1;i<=n;i++)\\n        {\\n            maxx=arr[i-1];\\n            j=0;\\n            while(j<k && j<=i-1)\\n            {\\n                maxx=max(arr[i-j-1],maxx);\\n                dp[i]=max(dp[i],dp[i-j-1]+maxx*(j+1));\\n                j++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272029,
                "title": "easy-java-solution-top-down-approach",
                "content": "```\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        return solve(0, arr.length - 1,arr,k,dp);\\n\\n    }\\n    \\n    public static int solve(int start,int end,int[] arr, int k,int[] dp){\\n        if(start > end){\\n            return 0;\\n        }\\n        \\n        if(dp[start] != -1){\\n            return dp[start];\\n        }\\n        int max = arr[start];\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = start; i < start + k && i <= end; i++){\\n            max = Math.max(arr[i],max);\\n            //division\\n            int multiple = (i - start + 1);\\n            int temp = multiple * max;\\n            int x = temp + solve(i + 1, end,arr,k,dp);\\n            ans = Math.max(ans,x);\\n        }\\n        return dp[start] = ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        return solve(0, arr.length - 1,arr,k,dp);\\n\\n    }\\n    \\n    public static int solve(int start,int end,int[] arr, int k,int[] dp){\\n        if(start > end){\\n            return 0;\\n        }\\n        \\n        if(dp[start] != -1){\\n            return dp[start];\\n        }\\n        int max = arr[start];\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = start; i < start + k && i <= end; i++){\\n            max = Math.max(arr[i],max);\\n            //division\\n            int multiple = (i - start + 1);\\n            int temp = multiple * max;\\n            int x = temp + solve(i + 1, end,arr,k,dp);\\n            ans = Math.max(ans,x);\\n        }\\n        return dp[start] = ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249233,
                "title": "c-dp-solution-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findmax(vector<int>& arr, int i, int j)\\n    {\\n        int ans = INT_MIN;\\n        for(int l=1; l<=j; l++)\\n        {\\n            ans = max(ans, arr[i-l]);\\n        }\\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i = 1, j=1; i <=k; i++,j++)\\n        {\\n            dp[i] = findmax(arr, i, j)*j;\\n        }\\n        for(int i=k+1; i<=n; i++)\\n        {\\n            dp[i] = 0;\\n            for(int j=1; j<=k; j++)\\n            {\\n                dp[i] = max(dp[i], (dp[i-j] + findmax(arr, i, j)*j));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findmax(vector<int>& arr, int i, int j)\\n    {\\n        int ans = INT_MIN;\\n        for(int l=1; l<=j; l++)\\n        {\\n            ans = max(ans, arr[i-l]);\\n        }\\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i = 1, j=1; i <=k; i++,j++)\\n        {\\n            dp[i] = findmax(arr, i, j)*j;\\n        }\\n        for(int i=k+1; i<=n; i++)\\n        {\\n            dp[i] = 0;\\n            for(int j=1; j<=k; j++)\\n            {\\n                dp[i] = max(dp[i], (dp[i-j] + findmax(arr, i, j)*j));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247937,
                "title": "clarification",
                "content": "Can someone please clarify this Example 2 which is part of the description?\\n```\\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\\nOutput: 83\\n```\\nI can create sub arrays like this which satisfies the requirement.\\n`[5,7,7,7,7,9,9,9,9,9,9]`  It returns the sum of 87. Not 83.\\n\\nI am seeing I have misunderstood the problem. I do not know where!!",
                "solutionTags": [],
                "code": "```\\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\\nOutput: 83\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243882,
                "title": "c-bottom-up",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumAfterPartitioning(const vector<int>& arr, int k)\\n    {\\n        const int N = arr.size();\\n        if (N <= k)\\n        {\\n            return *max_element(arr.begin(), arr.end())*N;\\n        }\\n        \\n        vector<int> cache(N);\\n        \\n        int curMax = 0;\\n        for (int i = 0; i < k; ++i)\\n        {\\n            curMax = max(curMax, arr[i]);\\n            cache[i] = (i+1)*curMax;\\n        }\\n        \\n        int maxSum = 0;        \\n        for (int i = k; i < N; ++i)\\n        {\\n            curMax = 0;\\n            maxSum = 0;\\n            \\n            for (int j = i; j > i-k; --j)\\n            {\\n                curMax = max(curMax, arr[j]);\\n                maxSum = max(maxSum, (i-j+1)*curMax + cache[j-1]);\\n            }\\n            cache[i] = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumAfterPartitioning(const vector<int>& arr, int k)\\n    {\\n        const int N = arr.size();\\n        if (N <= k)\\n        {\\n            return *max_element(arr.begin(), arr.end())*N;\\n        }\\n        \\n        vector<int> cache(N);\\n        \\n        int curMax = 0;\\n        for (int i = 0; i < k; ++i)\\n        {\\n            curMax = max(curMax, arr[i]);\\n            cache[i] = (i+1)*curMax;\\n        }\\n        \\n        int maxSum = 0;        \\n        for (int i = k; i < N; ++i)\\n        {\\n            curMax = 0;\\n            maxSum = 0;\\n            \\n            for (int j = i; j > i-k; --j)\\n            {\\n                curMax = max(curMax, arr[j]);\\n                maxSum = max(maxSum, (i-j+1)*curMax + cache[j-1]);\\n            }\\n            cache[i] = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237443,
                "title": "java-dp-top-down-with-memoization-and-bottom-up",
                "content": "```\\n// DP Top Down with Memoization\\n// During each recursive call, try the partition sizes from 1 to K\\n// Track the max value in the current partition\\n// Track the max result of partition sum of max values + recursive call\\n// Time: O(N*K)\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] memo = new int[n];\\n    Arrays.fill(memo, -1);\\n    return maxSumAfterPartitioning(arr, k, memo, 0);\\n  }\\n  private int maxSumAfterPartitioning(int[] arr, int k, int[] memo, int start) {\\n    int n = arr.length;\\n    if (start == n)\\n      return 0;\\n    if (memo[start] != -1)\\n      return memo[start];\\n    \\n    int maxResult = 0;\\n    int maxVal = 0;\\n    int sum = 0;\\n    for (int i = start; i < start + k && i < n; i++) {\\n      maxVal = Math.max(arr[i], maxVal);\\n      int result = maxVal * (i - start + 1) + maxSumAfterPartitioning(arr, k, memo, i + 1);\\n      maxResult = Math.max(result, maxResult);\\n    }\\n    memo[start] = maxResult;\\n    return maxResult;\\n  }\\n}\\n\\n\\n// DP - Bottom Up\\n// Time: O(N*K)\\n// 4 ms, faster than 92.98%\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] dp = new int[n+1];\\n\\n    for (int start = n - 1; start >= 0; start--) {\\n      int maxVal = 0;\\n      int maxResult = 0;\\n      for (int j = 0; j < k && start + j < n; j++) {\\n        maxVal = Math.max(arr[start+j], maxVal);\\n        int result = maxVal * (j + 1) + dp[start+j+1];\\n        maxResult = Math.max(result, maxResult);\\n      }\\n      dp[start] = maxResult;\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// DP Top Down with Memoization\\n// During each recursive call, try the partition sizes from 1 to K\\n// Track the max value in the current partition\\n// Track the max result of partition sum of max values + recursive call\\n// Time: O(N*K)\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] memo = new int[n];\\n    Arrays.fill(memo, -1);\\n    return maxSumAfterPartitioning(arr, k, memo, 0);\\n  }\\n  private int maxSumAfterPartitioning(int[] arr, int k, int[] memo, int start) {\\n    int n = arr.length;\\n    if (start == n)\\n      return 0;\\n    if (memo[start] != -1)\\n      return memo[start];\\n    \\n    int maxResult = 0;\\n    int maxVal = 0;\\n    int sum = 0;\\n    for (int i = start; i < start + k && i < n; i++) {\\n      maxVal = Math.max(arr[i], maxVal);\\n      int result = maxVal * (i - start + 1) + maxSumAfterPartitioning(arr, k, memo, i + 1);\\n      maxResult = Math.max(result, maxResult);\\n    }\\n    memo[start] = maxResult;\\n    return maxResult;\\n  }\\n}\\n\\n\\n// DP - Bottom Up\\n// Time: O(N*K)\\n// 4 ms, faster than 92.98%\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] dp = new int[n+1];\\n\\n    for (int start = n - 1; start >= 0; start--) {\\n      int maxVal = 0;\\n      int maxResult = 0;\\n      for (int j = 0; j < k && start + j < n; j++) {\\n        maxVal = Math.max(arr[start+j], maxVal);\\n        int result = maxVal * (j + 1) + dp[start+j+1];\\n        maxResult = Math.max(result, maxResult);\\n      }\\n      dp[start] = maxResult;\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226080,
                "title": "c-easy-to-understand",
                "content": "The idea is simple, check all partion cases for arr[i] and get max value\\n```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int largest(int start, int end, vector<int> arr ){\\n        int result=0;\\n        for(int i=start; i<=end; i++){\\n            result=max(result, arr[i]);\\n        }\\n        return result;\\n    }\\n \\n    int arr1[501];\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        dp[0]=arr[0];\\n        for(int i=0; i<arr.size(); i++){\\n            arr1[i]=arr[i];\\n        }\\n         \\n        for(int i=1; i<arr.size(); i++){\\n            dp[i]=arr[i]+dp[i-1];\\n        }\\n        for(int i=1; i<arr.size(); i++){\\n            for (int j=k; j>=1; j--){\\n                if(i-j>=0){\\n                    dp[i]=max(dp[i],dp[i-j]+j*(*max_element(arr1+i-j+1, arr1+i+1)));\\n                }\\n                else if(i-j==-1){\\n                    dp[i]=max(dp[i],j*(*max_element(arr1+i-j+1, arr1 + i+1)));\\n                }\\n            }\\n        }\\n        return dp[arr.size()-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[501];\\n    int largest(int start, int end, vector<int> arr ){\\n        int result=0;\\n        for(int i=start; i<=end; i++){\\n            result=max(result, arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1223864,
                "title": "cpp-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = (int)arr.size();\\n        int dp[n+1];\\n        dp[n] = 0;\\n        dp[n-1] = arr[n-1];\\n        for(int i = n-2;i >= 0;i--)\\n        {\\n            int temp = arr[i];\\n            dp[i] = INT_MIN;\\n            for(int j = 1;((i + j - 1 < n)&&(j <= k));j++)\\n            {\\n                temp = max(temp,arr[i+j-1]);\\n                dp[i] = max(dp[i],temp*j + dp[i+j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = (int)arr.size();\\n        int dp[n+1];\\n        dp[n] = 0;\\n        dp[n-1] = arr[n-1];\\n        for(int i = n-2;i >= 0;i--)\\n        {\\n            int temp = arr[i];\\n            dp[i] = INT_MIN;\\n            for(int j = 1;((i + j - 1 < n)&&(j <= k));j++)\\n            {\\n                temp = max(temp,arr[i+j-1]);\\n                dp[i] = max(dp[i],temp*j + dp[i+j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223707,
                "title": "recursion-with-memoisation-c-well-explained",
                "content": "Try to think of absolute bruteforce.\\nEx. [1,15,7,9,2,5,10], k = 3\\n\\nThe possible partitions to start with can be\\nCase 1: 1   |    15,7, 9, 2...\\nCase 2: 1,15 |   7,9,2,5,10\\nCase 3: 1 15 7 |  9 2 5 10\\n\\nans for Case 1: maxElement of left Partition * number of elements in left partition added to the solution of the array beggining at 15 (i.e. 15,7, 9, 2...)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& arr, int k, int ind, vector<int> &dp){\\n        \\n        int n = arr.size();\\n        // if you reached end of the array then the right side of the partition yeilds a 0 sum\\n        if(ind == n) return 0;\\n        \\n        //if the value is precalculated dont calculate again\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        // initialise variable to calculate ans\\n        int ans = INT_MIN;\\n        // end indicates till which index you can have the partition \\n        int end = min(n, ind+k);\\n        \\n        // maxElement is used to store the maxElement in the left partition\\n        int maxElement = -1;\\n        // iterate for all possible partitions\\n        for(int i = ind; i < end; i++){\\n            //update the max element\\n            maxElement = max(arr[i], maxElement);\\n            // calculate sum of elements to left of partition \\n            int sumLeft = (i - ind + 1)* (maxElement);\\n            // calculate the ans if you chose this partition\\n            int ansForPartition = sumLeft + solve(arr, k, i + 1, dp);\\n            ans = max(ans, ansForPartition);\\n        }\\n        \\n        return dp[ind] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int ind = 0;\\n        vector<int> dp(501, -1);\\n        return solve(arr, k, ind, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& arr, int k, int ind, vector<int> &dp){\\n        \\n        int n = arr.size();\\n        // if you reached end of the array then the right side of the partition yeilds a 0 sum\\n        if(ind == n) return 0;\\n        \\n        //if the value is precalculated dont calculate again\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        // initialise variable to calculate ans\\n        int ans = INT_MIN;\\n        // end indicates till which index you can have the partition \\n        int end = min(n, ind+k);\\n        \\n        // maxElement is used to store the maxElement in the left partition\\n        int maxElement = -1;\\n        // iterate for all possible partitions\\n        for(int i = ind; i < end; i++){\\n            //update the max element\\n            maxElement = max(arr[i], maxElement);\\n            // calculate sum of elements to left of partition \\n            int sumLeft = (i - ind + 1)* (maxElement);\\n            // calculate the ans if you chose this partition\\n            int ansForPartition = sumLeft + solve(arr, k, i + 1, dp);\\n            ans = max(ans, ansForPartition);\\n        }\\n        \\n        return dp[ind] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int ind = 0;\\n        vector<int> dp(501, -1);\\n        return solve(arr, k, ind, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171472,
                "title": "easy-to-understand-solution-using-memoization-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector <int> cache;\\npublic:\\n    int partition(vector <int> &arr, int idx, int k) {\\n        if(idx >= arr.size()) return 0;\\n        if(cache[idx] != -1) return cache[idx];\\n        \\n        int s = 0, n = arr.size(), maxVal = arr[idx];\\n        for(int i = idx; i < min((idx + k), n); i++) {\\n            int l = idx, r = i, len = r - l + 1;\\n            maxVal = max(maxVal, arr[i]);\\n            \\n            s = max(s, maxVal*len + partition(arr, i + 1, k));\\n        }\\n        \\n        return cache[idx] = s;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        cache.resize(arr.size(), -1);\\n        return partition(arr, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector <int> cache;\\npublic:\\n    int partition(vector <int> &arr, int idx, int k) {\\n        if(idx >= arr.size()) return 0;\\n        if(cache[idx] != -1) return cache[idx];\\n        \\n        int s = 0, n = arr.size(), maxVal = arr[idx];\\n        for(int i = idx; i < min((idx + k), n); i++) {\\n            int l = idx, r = i, len = r - l + 1;\\n            maxVal = max(maxVal, arr[i]);\\n            \\n            s = max(s, maxVal*len + partition(arr, i + 1, k));\\n        }\\n        \\n        return cache[idx] = s;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        cache.resize(arr.size(), -1);\\n        return partition(arr, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168564,
                "title": "java-dp-memoization",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        int dp[] = new int[arr.length];\\n        \\n        Arrays.fill(dp, -1);\\n        \\n        return helper(arr, k, 0, dp);\\n    }\\n    \\n    private int helper(int[] arr, int k, int curr,int[] dp){\\n        \\n        if(curr >= arr.length)\\n            return 0;\\n        \\n        if(dp[curr] != -1)\\n            return dp[curr];\\n        \\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=curr ; i<curr+k ; ++i){\\n            if(i >= arr.length)\\n                break;\\n            \\n            count++;\\n            max = Math.max(max, arr[i]);\\n            \\n            ans = Math.max(ans, max*count + helper(arr, k, i+1, dp));\\n        }\\n        \\n        dp[curr] = ans;\\n        return dp[curr];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        int dp[] = new int[arr.length];\\n        \\n        Arrays.fill(dp, -1);\\n        \\n        return helper(arr, k, 0, dp);\\n    }\\n    \\n    private int helper(int[] arr, int k, int curr,int[] dp){\\n        \\n        if(curr >= arr.length)\\n            return 0;\\n        \\n        if(dp[curr] != -1)\\n            return dp[curr];\\n        \\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=curr ; i<curr+k ; ++i){\\n            if(i >= arr.length)\\n                break;\\n            \\n            count++;\\n            max = Math.max(max, arr[i]);\\n            \\n            ans = Math.max(ans, max*count + helper(arr, k, i+1, dp));\\n        }\\n        \\n        dp[curr] = ans;\\n        return dp[curr];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153946,
                "title": "dp",
                "content": "**Down to top, iterative:** time `O(N*k)` space `O(N)`\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/8e9fe6a8-08bf-4b52-b998-48683a18ddcf_1618229699.9158788.png)\\n\\n<br>\\n\\n```\\nint maxSumAfterPartitioning(vector<int>& a, int k) \\n{\\n    vector v(size(a)+1, 0);       // int v[501]={0};\\n    for(int i(size(a)-1); i>=0; --i)\\n        for(auto j(i), m(-1); j<size(a) and j-i<k; ++j)\\n            v[i] = max(v[i], (j-i+1)*(m=max(m, a[j])) + v[j+1]);\\n    return v[0];\\n}\\n```\\n**Top to down, recursive (memoization, helper):** time `O(N*k)` space `O(N)`\\n```\\nclass Solution \\n{\\n    vector<int> um;\\n\\n    int f(vector<int>& a, int k, int i) \\n    {\\n        int out{-1};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um[j+1]==-1) um[j+1] = f(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\npublic:    \\n    int maxSumAfterPartitioning(vector<int>& a, int k) \\n    {\\n        um.assign(size(a)+1, -1);\\n\\t\\tum.back()=0;\\n        return f(a, k, 0);\\n    }\\n};\\n```\\n**Top to down, recursive (memoization, no helper):** time `O(N*k)` space `O(N)`\\n```\\nclass Solution \\n{\\n    unordered_map<int, int> um;\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k, int i=0) \\n    {\\n        int out{0};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um.find(j+1)==end(um)) um[j+1] = maxSumAfterPartitioning(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSumAfterPartitioning(vector<int>& a, int k) \\n{\\n    vector v(size(a)+1, 0);       // int v[501]={0};\\n    for(int i(size(a)-1); i>=0; --i)\\n        for(auto j(i), m(-1); j<size(a) and j-i<k; ++j)\\n            v[i] = max(v[i], (j-i+1)*(m=max(m, a[j])) + v[j+1]);\\n    return v[0];\\n}\\n```\n```\\nclass Solution \\n{\\n    vector<int> um;\\n\\n    int f(vector<int>& a, int k, int i) \\n    {\\n        int out{-1};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um[j+1]==-1) um[j+1] = f(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\npublic:    \\n    int maxSumAfterPartitioning(vector<int>& a, int k) \\n    {\\n        um.assign(size(a)+1, -1);\\n\\t\\tum.back()=0;\\n        return f(a, k, 0);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    unordered_map<int, int> um;\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k, int i=0) \\n    {\\n        int out{0};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um.find(j+1)==end(um)) um[j+1] = maxSumAfterPartitioning(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564665,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567542,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1565397,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567614,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566335,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566896,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575451,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1570889,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575356,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567385,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1564665,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567542,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1565397,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567614,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566335,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566896,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575451,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1570889,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575356,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567385,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1568598,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1574753,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1573612,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 2018095,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1907058,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1835377,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1813878,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1789096,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1770356,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1762133,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            }
        ]
    }
]