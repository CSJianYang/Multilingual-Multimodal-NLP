[
    {
        "title": "Minimized Maximum of Products Distributed to Any Store",
        "question_content": "You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.\nYou need to distribute all products to the retail stores following these rules:\n\n\tA store can only be given at most one product type but can be given any amount of it.\n\tAfter distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store.\n\nReturn the minimum possible x.\n&nbsp;\nExample 1:\n\nInput: n = 6, quantities = [11,6]\nOutput: 3\nExplanation: One optimal way is:\n- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\nThe maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.\n\nExample 2:\n\nInput: n = 7, quantities = [15,10,10]\nOutput: 5\nExplanation: One optimal way is:\n- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\nThe maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.\n\nExample 3:\n\nInput: n = 1, quantities = [100000]\nOutput: 100000\nExplanation: The only optimal way is:\n- The 100000 products of type 0 are distributed to the only store.\nThe maximum number of products given to any store is max(100000) = 100000.\n\n&nbsp;\nConstraints:\n\n\tm == quantities.length\n\t1 <= m <= n <= 105\n\t1 <= quantities[i] <= 105",
        "solutions": [
            {
                "id": 1563739,
                "title": "java-c-python-binary-search",
                "content": "# **Intuition**\\nThe key is to find out it should solve with the binary search.\\nVery similar to\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n<br>\\n\\n# **Explanation**\\nBinary search the products distributed to every store.\\nThe search range it between `left = 1` and `right = 100000`.\\nWe can also use `right = max(A)`, no big difference.\\n\\nFor `a` products to distributed,\\nwe needs `ceil(A[i] / mid)` store,\\nI use  `(a + mid - 1) / mid` to calculate this.\\n\\nWe sum up the stores we needs and check whether we have that enough stores.\\nIf we have enough stores, \\n`mid` is big enough.\\nthen change `right = mid`\\n\\nIf we have no enough stores, \\n`mid` is too small,\\nthen change `left = mid + 1`\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog100000) < O(14n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimizedMaximum(int n, int[] A) {\\n        int left = 1, right = 100000;\\n        while (left < right) {\\n            int mid = (left + right) / 2, sum = 0;\\n            for (int a : A)\\n                sum += (a + mid - 1) / mid;\\n            if (sum > n)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizedMaximum(int n, vector<int>& A) {\\n        int left = 1, right = 100000;\\n        while (left < right) {\\n            int mid = (left + right) / 2, sum = 0;\\n            for (int a : A)\\n                sum += (a + mid - 1) / mid;\\n            if (sum > n)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizedMaximum(self, n, A):\\n        left, right = 1, max(A)\\n        while left < right:\\n            x = (left + right) / 2\\n            if sum((a + x - 1) / x for a in A) > n:\\n                left = x + 1\\n            else:\\n                right = x\\n        return left\\n```\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search/)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search/)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int minimizedMaximum(int n, int[] A) {\\n        int left = 1, right = 100000;\\n        while (left < right) {\\n            int mid = (left + right) / 2, sum = 0;\\n            for (int a : A)\\n                sum += (a + mid - 1) / mid;\\n            if (sum > n)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int minimizedMaximum(int n, vector<int>& A) {\\n        int left = 1, right = 100000;\\n        while (left < right) {\\n            int mid = (left + right) / 2, sum = 0;\\n            for (int a : A)\\n                sum += (a + mid - 1) / mid;\\n            if (sum > n)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def minimizedMaximum(self, n, A):\\n        left, right = 1, max(A)\\n        while left < right:\\n            x = (left + right) / 2\\n            if sum((a + x - 1) / x for a in A) > n:\\n                left = x + 1\\n            else:\\n                right = x\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1563722,
                "title": "python-short-binary-search-explained",
                "content": "The idea of this problem is to use binary search, where we ask question: given `mid` restriction for each shop, how many shops we need to distribute all goods? For example if we have `Q = [6, 11]` and `mid = 6`, then we need 3 shops: `[6], [6, 5]`. If we have `mid = 3`, we need `6` shops: `[3, 3], [3, 3, 3, 2]`. What we need to find is the smallest `mid`, such that we have `<= n` shops needed.\\n\\n#### Complexity\\nIt is `O(n * log W)`, where `W = sum(Q)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimizedMaximum(self, n, Q):\\n        beg, end = 0, max(Q)\\n        \\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if sum(ceil(i/mid) for i in Q) <= n:\\n                end = mid\\n            else:\\n                beg = mid\\n        \\n        return end\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizedMaximum(self, n, Q):\\n        beg, end = 0, max(Q)\\n        \\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if sum(ceil(i/mid) for i in Q) <= n:\\n                end = mid\\n            else:\\n                beg = mid\\n        \\n        return end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566853,
                "title": "check-if-isitpossibletodistributeallproducts",
                "content": "Complexity\\nTime : `O(NlogN)`\\nSpace : `O(1)`\\n\\nOn every possible x, \\nCheck whether is it Possible to Distribute all products to n retail stores\\nwith atmost x products of one type are given to each shop\\n\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        int lo = 1;\\n        int hi = (int)1e5;\\n        \\n        int ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = (lo + hi)/2;\\n            \\n            if(isItPossible(mid, quantities, n)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isItPossible(int x, int[] quantities, int n){\\n        \\n        // isItPossible to distribute <= x products to each of the n shops\\n        for(int i=0; i<quantities.length; i++){\\n            \\n            int products = quantities[i];\\n            \\n            n -= Math.ceil(products/(x*1.0));\\n            \\n            if(n<0)     // means it requires more than n shops to distribute all products\\n                return false; \\n        }\\n        \\n        return true; // distributed all products to exactly n shops\\n    }\\n}\\n```\\n\\nFunc Without using Ceil takes less time\\n```\\nprivate boolean isItPossible(int x, int[] quantities, int n){\\n        \\n        // isItPossible to distribute with <= x\\n        \\n        for(int i=0; i<quantities.length; i++){\\n            \\n            int products = quantities[i];\\n            \\n            n -= (products/x);\\n            \\n            if(products % x != 0){\\n                n--;\\n            }\\n            \\n            if(n<0)\\n                return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n```\\n\\nPlease do upvote the solution if it helped you :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        int lo = 1;\\n        int hi = (int)1e5;\\n        \\n        int ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = (lo + hi)/2;\\n            \\n            if(isItPossible(mid, quantities, n)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isItPossible(int x, int[] quantities, int n){\\n        \\n        // isItPossible to distribute <= x products to each of the n shops\\n        for(int i=0; i<quantities.length; i++){\\n            \\n            int products = quantities[i];\\n            \\n            n -= Math.ceil(products/(x*1.0));\\n            \\n            if(n<0)     // means it requires more than n shops to distribute all products\\n                return false; \\n        }\\n        \\n        return true; // distributed all products to exactly n shops\\n    }\\n}\\n```\n```\\nprivate boolean isItPossible(int x, int[] quantities, int n){\\n        \\n        // isItPossible to distribute with <= x\\n        \\n        for(int i=0; i<quantities.length; i++){\\n            \\n            int products = quantities[i];\\n            \\n            n -= (products/x);\\n            \\n            if(products % x != 0){\\n                n--;\\n            }\\n            \\n            if(n<0)\\n                return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564842,
                "title": "c-easy-solution-similar-to-page-allocation-problem",
                "content": "Minimum amount which can be given is 1 and maximum is max(quantities), so 1-max(quantites) will be our search space.\\n\\nIf it is possible for a particular mid then we will shift our search space to left side as we want minimize the no. of products otherwise will shift to the right if not possible\\n\\nIn **isPossible function** if cnt<n then we will give 0 quantites to the remaining stores , so that barrier will be possible\\n\\nBut if at any point cnt becomes greater than n , it means that after distributing to all stores some quantites are still left , so we will return false\\n\\n\\n```\\nclass Solution {\\n    bool isPossible(vector<int>& q,int n,int barrier){\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=barrier){\\n                cnt++;\\n            }\\n            else{\\n                int temp=q[i];\\n                while(temp>0){\\n                    temp-=barrier;\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>n) return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int start=1,end=*max_element(q.begin(),q.end());\\n        \\n        int ans = INT_MAX;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(isPossible(q,n,mid)){\\n                ans = min(ans,mid);\\n                end=mid-1;\\n            }\\n            else start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TC : nlog(max(quantities))**\\n(n is quantities.size())",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(vector<int>& q,int n,int barrier){\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=barrier){\\n                cnt++;\\n            }\\n            else{\\n                int temp=q[i];\\n                while(temp>0){\\n                    temp-=barrier;\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>n) return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int start=1,end=*max_element(q.begin(),q.end());\\n        \\n        int ans = INT_MAX;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(isPossible(q,n,mid)){\\n                ans = min(ans,mid);\\n                end=mid-1;\\n            }\\n            else start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563757,
                "title": "c-simple-binary-search-approach",
                "content": "class Solution {\\npublic:\\n\\n    int check(int v , vector<int>num , int n){\\n        int c = 0;\\n        for(int i=0;i<num.size();i++){\\n            c+= num[i]/v;\\n            if(num[i]%v!=0){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& v) {\\n        int h=INT_MIN;\\n        int l =1;\\n        for(auto i : v){\\n            h = max(h , i);\\n        }\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n          \\n            int x = check(mid , v, n);\\n            if(x<=n){\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int check(int v , vector<int>num , int n){\\n        int c = 0;\\n        for(int i=0;i<num.size();i++){\\n            c+= num[i]/v;\\n            if(num[i]%v!=0){\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1563731,
                "title": "python3-binary-search",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/6b6e6b9115d2b659e68dcf3ea8e21befefaae16c) for solutions of weekly 266. \\n\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        lo, hi = 1, max(quantities)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum(ceil(qty/mid) for qty in quantities) <= n: hi = mid \\n            else: lo = mid + 1\\n        return lo\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        lo, hi = 1, max(quantities)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum(ceil(qty/mid) for qty in quantities) <= n: hi = mid \\n            else: lo = mid + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563809,
                "title": "why-heap-leads-to-tle",
                "content": "I am wondering why my solution using PriorityQueue leads to a TLE.\\n\\nInitially, I assign every quantity only one store. For the left stores, I will assign them to the stores one by one to minimize the maximum of the averages of the quantity given to the corresponding stores.\\n\\nn = number of stores\\nm = len(quantities)\\nI think the time complexity for this is O(n logm). Since m<=n<= 10^5, this should pass. Why it doesn\\'t? Any ideas?\\n\\n\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        qs = [(-q, ceil(q / 2), 1, q) for q in quantities] # (-current avg, next avg, current assigned store, original quantities)\\n        n -= len(qs)\\n        heapify(qs)\\n        for _ in range(n):\\n            cur_avg, next_avg, cur_store, q = heappop(qs)\\n            heappush(qs, (-next_avg, ceil(q/(cur_store+2)), cur_store+1, q))\\n        return -qs[0][0]\\n```\\n\\nUpdate:\\n\\nHere is my idea about this. I think it is just because the overhead of this method is quite large comapred to that of binary search. Since the the Leetcode judge the TLE using the total running time of all testcases, which makes the total time of this method (> 8000 ms) much larger than the other one (~2000 ms). As a result, if you are using method, there is still some chances that you will pass. But in most cases, TLE.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        qs = [(-q, ceil(q / 2), 1, q) for q in quantities] # (-current avg, next avg, current assigned store, original quantities)\\n        n -= len(qs)\\n        heapify(qs)\\n        for _ in range(n):\\n            cur_avg, next_avg, cur_store, q = heappop(qs)\\n            heappush(qs, (-next_avg, ceil(q/(cur_store+2)), cur_store+1, q))\\n        return -qs[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563718,
                "title": "binary-search",
                "content": "We can check in the linear time if we can distribute quantities if we give no more than `m` amount to each store.\\n\\nThen, we can binary search for the minimum `m` that we can distribute.\\n\\n**C++**\\n```cpp\\nint minimizedMaximum(int n, vector<int>& qs) {\\n    int l = 1, r = 100000;\\n    while (l < r) {\\n        int m = (l + r) / 2, nn = n;\\n        for (int i = 0; i < qs.size() && n >= 0; ++i)\\n            nn -= qs[i] / m + (qs[i] % m ? 1 : 0);\\n        if (nn >= 0)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimizedMaximum(int n, vector<int>& qs) {\\n    int l = 1, r = 100000;\\n    while (l < r) {\\n        int m = (l + r) / 2, nn = n;\\n        for (int i = 0; i < qs.size() && n >= 0; ++i)\\n            nn -= qs[i] / m + (qs[i] % m ? 1 : 0);\\n        if (nn >= 0)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563964,
                "title": "java-binary-search",
                "content": "Find the left boundary\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max = 0;\\n        for (int q : quantities) {\\n            max = Math.max(max, q);\\n        }\\n        int l = 1, r = max;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            int cnt = count(m, quantities);\\n            if (cnt > n) {\\n                l = m + 1;\\n            } else if (cnt < n) {\\n                r = m - 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return l;\\n    }\\n    private int count(int div, int[] quantities) {\\n        int res = 0;\\n        for (int q : quantities) {\\n            res += q / div + (q % div == 0 ? 0 : 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max = 0;\\n        for (int q : quantities) {\\n            max = Math.max(max, q);\\n        }\\n        int l = 1, r = max;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            int cnt = count(m, quantities);\\n            if (cnt > n) {\\n                l = m + 1;\\n            } else if (cnt < n) {\\n                r = m - 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return l;\\n    }\\n    private int count(int div, int[] quantities) {\\n        int res = 0;\\n        for (int q : quantities) {\\n            res += q / div + (q % div == 0 ? 0 : 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552711,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int is_possible(vector<int>& arr, int mid, int k)\\n    {\\n        int n = arr.size();\\n        \\n        // find the no. of stalls required, for distributing mid as maximum no of products\\n        \\n        int stalls = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            stalls += ceil((double) arr[i] / mid);\\n        }\\n        \\n        return stalls <= k;\\n    }\\n    \\n    int minimizedMaximum(int k, vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // apply binary search\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(arr.begin(), arr.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(arr, mid, k))\\n            {\\n                ans = mid;\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int is_possible(vector<int>& arr, int mid, int k)\\n    {\\n        int n = arr.size();\\n        \\n        // find the no. of stalls required, for distributing mid as maximum no of products\\n        \\n        int stalls = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            stalls += ceil((double) arr[i] / mid);\\n        }\\n        \\n        return stalls <= k;\\n    }\\n    \\n    int minimizedMaximum(int k, vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // apply binary search\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(arr.begin(), arr.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(arr, mid, k))\\n            {\\n                ans = mid;\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741346,
                "title": "java-bruteforce-optimized-explained",
                "content": "\\nAs we know there are n stores. and m products of different quantities are there.Each store can have only one type of products and we have to distribute all the products to store. So if number of stores is equals to number of products then max of quantities of product are the number we can distribute in a store beacuse we have to distribute all the products.\\ni.e n=2 and quantities are [ 200,300].then max that can be stored in that stores is 300.\\n\\nso brute force will be start from 1 to max of array( beacuse our maximum range is this) and check weather it satisfy the condition or not.(condition is all the products should be in store although it may be case that some of stores are empty but we have to give all the quantities of our products to store ). \\n\\n now optimized as we know our search space will be from 0 to max of array so , apply binary search on outer area. inner condition is going to remain same.\\n```\\nclass Solution {\\n    public int answer(int n, int[]arr){\\n         int max =0;\\n        for(int a: arr){\\n            max=Math.max(max, a);\\n        }\\n        if(n==arr.length)return max;\\n        \\n        int lo=0;\\n        int hi=max;\\n         int ans =0;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            int c =helper(arr, mid); // this tells the number of stores in which products can be stored if one store can store atmost mid products.\\n           \\n            if(c<=n){\\n                ans =mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int minimizedMaximum(int n, int[] arr) {\\n\\t// bruteForce Approach \\n\\t// Try every possibility ranging from 0 to max of array\\n        //  int max =0;\\n        // for(int a: arr){\\n        //     max=Math.max(max, a);\\n        // }\\n        // if(n==arr.length)return max;\\n        // for(int i=1;i<=max;i++){\\n        //     int c = helper(arr, i);\\n        //     if(c<=n)return i;\\n        // }\\n        // return 1;\\n       return answer(n,arr);\\n    }\\n    public int helper(int []arr, int mid){\\n        int an =0;\\n        for(int a:arr){\\n            an +=Math.ceil(a*1.0/mid);\\n\\t\\t\\t// this tells number of stores in which a product can be distributed \\n        }\\n        return an;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int answer(int n, int[]arr){\\n         int max =0;\\n        for(int a: arr){\\n            max=Math.max(max, a);\\n        }\\n        if(n==arr.length)return max;\\n        \\n        int lo=0;\\n        int hi=max;\\n         int ans =0;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            int c =helper(arr, mid); // this tells the number of stores in which products can be stored if one store can store atmost mid products.\\n           \\n            if(c<=n){\\n                ans =mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int minimizedMaximum(int n, int[] arr) {\\n\\t// bruteForce Approach \\n\\t// Try every possibility ranging from 0 to max of array\\n        //  int max =0;\\n        // for(int a: arr){\\n        //     max=Math.max(max, a);\\n        // }\\n        // if(n==arr.length)return max;\\n        // for(int i=1;i<=max;i++){\\n        //     int c = helper(arr, i);\\n        //     if(c<=n)return i;\\n        // }\\n        // return 1;\\n       return answer(n,arr);\\n    }\\n    public int helper(int []arr, int mid){\\n        int an =0;\\n        for(int a:arr){\\n            an +=Math.ceil(a*1.0/mid);\\n\\t\\t\\t// this tells number of stores in which a product can be distributed \\n        }\\n        return an;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620926,
                "title": "python-greedy-heap-1180ms-99-binary-search-2140ms-64",
                "content": "## binary search (2140ms 64%)\\ndenote maximum quantity as `res`.  `min(res) = 1, max(res) = max(quantities)`. And `res` is negatively related to min number of stores needed. This tells us to search the minimum `res` such that min number of needed stores still `<= n`.  \\n\\n```python\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def cond(m, n):\\n            return sum([(q // m) + (q % m > 0) for q in quantities]) <= n\\n        \\n        l, r = 1, max(quantities)\\n        while l < r:\\n            m = (l + r) // 2\\n            if cond(m, n):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```\\n\\n## using heap (1180ms 99%)\\nSolution-wise, this problem can be reduced to [774. Minimize Max Distance to Gas Station problem](https://leetcode.com/problems/minimize-max-distance-to-gas-station/) in linear time. If interested in its solution, take a look at [my post here](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/1620387/python-124ms-100.-heap-(NOT-binary-search)).\\n\\nThe idea is\\n1. start from considering `m=quantities.length` stores, where each store has to contain all quantity of one product type. decrement budget `n` by `m`\\n2. iteratively, add store one by one to share quantity load to lower max quantity. specifically:\\n\\t2.1. find, pop element `(Q, i)` (the product that has max quantity per store, store number)\\n\\t2.2. new quantity = `Q*i / (i+1)`, new store number = `i+1`\\n\\t2.3. update, push `(new Q, new i)` into the array. \\n\\t2.4. decrement budget `n` by 1. \\n3. when `n==0`, return max quantity from the array, which will be the minimum max quantity with `n` budget.\\n\\n#### optimization\\nabove solution run time is `O((n-m)logm)`, if budget `n` is large, this is not that good. \\n\\nconsider an extreme case when `n -> inf`, then min max quantity `q = epsilon -> 0`.  and number of stores for each product will be proportional to number of quanities. \\n\\nfor example, product A has quantity 2Q, product B has quantity Q, for `n->inf`, number of stores for A: number of stores for B -> `2Q/Q = 2`. \\n\\nfrom this, the optimization idea is preallocate stores to each product type **proportionally** to quantity. and we only allocate floor integer number of stores. so in the next step, we post-allocate remaining stores using the heap idea. \\n- Run Time:\\n\\t- worse case scenario is O(mlogm), becasue we have at most `m` stores to allocate in the post-allocation step.\\n- Note that in the iteration, quantities are stored as floating number. for example, for some product A, it may be `(Q=12.5, i=4)`, which means 4 stores, each stores 12.5 of A, totalling 50. in the end, we need to get ceil integer of 12.5 for the answer, because actual allocations will be `12, 12, 13, 13`\\n\\n```python\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def ceil(x):\\n            return int(x) + (x > int(x))\\n        \\n        # initial allocation: m stores, one per product type\\n        quantities = [-q for q in quantities]\\n        tot = sum(quantities)\\n        n -= len(quantities)\\n        \\n        # pre-allocation\\n        prealloc = [int(n * q / tot) for q in quantities]\\n        quantities = [(q / (i + 1), i + 1) for q, i in zip(quantities, prealloc)]\\n        n -= sum(prealloc)\\n        \\n        # post-allocation\\n        heapq.heapify(quantities)\\n        while n > 0:\\n            cur, cnt = heapq.heappop(quantities)\\n            heapq.heappush(quantities, (cur*cnt/(cnt+1), cnt+1))\\n            n -= 1\\n        return ceil(-quantities[0][0])\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def cond(m, n):\\n            return sum([(q // m) + (q % m > 0) for q in quantities]) <= n\\n        \\n        l, r = 1, max(quantities)\\n        while l < r:\\n            m = (l + r) // 2\\n            if cond(m, n):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```\n```python\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def ceil(x):\\n            return int(x) + (x > int(x))\\n        \\n        # initial allocation: m stores, one per product type\\n        quantities = [-q for q in quantities]\\n        tot = sum(quantities)\\n        n -= len(quantities)\\n        \\n        # pre-allocation\\n        prealloc = [int(n * q / tot) for q in quantities]\\n        quantities = [(q / (i + 1), i + 1) for q, i in zip(quantities, prealloc)]\\n        n -= sum(prealloc)\\n        \\n        # post-allocation\\n        heapq.heapify(quantities)\\n        while n > 0:\\n            cur, cnt = heapq.heappop(quantities)\\n            heapq.heappush(quantities, (cur*cnt/(cnt+1), cnt+1))\\n            n -= 1\\n        return ceil(-quantities[0][0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813428,
                "title": "beginner-friendly-explanation-binary-search-on-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, when the question asks us to find minimized maximum, maximized minimum or maximum/minimum/atmost/atleast and the constraints are of order 10^5, the optimum way to solve would be Binary Search.\\n\\nThis problem is also a standard variation of Binary Search on Answer.\\n\\n# Approach\\n\\nSo, we\\'ve confirmed the approach i.e., Binary Search. \\nNow the first step is to find \"low\" and \"high\" values.\\n\\nWhen each store receives single quantity(because none of them should be empty), then low = 1;\\nAnd when the number of stores(n) == number of types of products(quantity.size()), then each store gets either types of products. The store which gets the type of product containing maximum quantity would be the maximum possible answer, hence high = max(quantities)\\n\\nThen we are calculating the value of \"mid\". Here mid is basically tells the maximum quantity of a single product a store gets(threshold quantity).\\n\\nNow, \"ok()\" functions tells us whether the distribution of types of products among \"n\" stores is possible or not. \\nFor e.g: mid = 5, quantities[i]  = 8 can be distributed as 5+3, hence 2 different stores are covered. Similarly if quantities[i] = 22, (22/5 = 4) + 1 (the remaining 22%5 = 2 into the other store) = 5 stores.\\n\\nSo, if we get true from ok() function, this could be our answer or we may get even smaller answer too(which is asked i.e., minimized maximum), so we update the high pointer to mid-1. If we get false i.e., the threshold quantity (mid) is not large enough to distribute among n stores, to get larger quantity we are updating low as mid+1.\\n\\nEventually, we\\'ll get the minimized maximum number of products that are given to any store.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mlog(max(quantities)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool ok(int n, int mid, vector<int>& v) {\\n        int c = 0;\\n        for(int i : v) {\\n            c += i/mid;\\n            if(i%mid) c++;\\n        }\\n        return c <= n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m = quantities.size();\\n        int low = 1, high = *max_element(quantities.begin(), quantities.end()), ans = -1;\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n            if(ok(n, mid, quantities)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHope it helps :)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ok(int n, int mid, vector<int>& v) {\\n        int c = 0;\\n        for(int i : v) {\\n            c += i/mid;\\n            if(i%mid) c++;\\n        }\\n        return c <= n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m = quantities.size();\\n        int low = 1, high = *max_element(quantities.begin(), quantities.end()), ans = -1;\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n            if(ok(n, mid, quantities)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900037,
                "title": "c-easy-to-understand-tc-o-m-log-max-quantities-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size(), l=1,r=0;\\n        for(auto quantity: quantities) r=max(r,quantity);\\n        \\n        int mid=0, ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0;\\n            for(auto quantity: quantities){\\n                count+=quantity/mid;\\n                if(quantity%mid) count++;\\n            }\\n            if(count<=n) ans=mid,r=mid-1;\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n```\\n\\nThe [***875. Koko Eating Bananas***](https://leetcode.com/problems/koko-eating-bananas/) is also the same question just it is a task to figureout this is the same question. And this question can be used as sample question, this concept are used in different questions.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size(), l=1,r=0;\\n        for(auto quantity: quantities) r=max(r,quantity);\\n        \\n        int mid=0, ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0;\\n            for(auto quantity: quantities){\\n                count+=quantity/mid;\\n                if(quantity%mid) count++;\\n            }\\n            if(count<=n) ans=mid,r=mid-1;\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570757,
                "title": "c-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// is it possible to distribute all the products with maximum given to particular store=k\\n    bool possible(int n, int k, vector<int>& qty){\\n        int m=qty.size();\\n        int c=0;\\n        for(int i=0;i<m;i++){\\n            c+=(qty[i]/k)+(qty[i]%k!=0); // count of stores we required to distribute ith type of product with maximum given to particular store=k\\n        }\\n        return (c<=n);\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& qty) {\\n        int m=qty.size();\\n        \\n        int maxe=*max_element(qty.begin(),qty.end());\\n        \\n        int r=maxe;\\n        int l=1;\\n        \\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(n,m,qty)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// is it possible to distribute all the products with maximum given to particular store=k\\n    bool possible(int n, int k, vector<int>& qty){\\n        int m=qty.size();\\n        int c=0;\\n        for(int i=0;i<m;i++){\\n            c+=(qty[i]/k)+(qty[i]%k!=0); // count of stores we required to distribute ith type of product with maximum given to particular store=k\\n        }\\n        return (c<=n);\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& qty) {\\n        int m=qty.size();\\n        \\n        int maxe=*max_element(qty.begin(),qty.end());\\n        \\n        int r=maxe;\\n        int l=1;\\n        \\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(n,m,qty)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750918,
                "title": "best-c-solution-list-of-8-similar-very-imp-binary-search-questions",
                "content": "# List of similar binary search questions \\n- [Koko Eating Bananas - Leetcode](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-7-similar-very-imp-binary-search-questions/) \\n- [Find the Smallest Divisor Given a Threshold - Leetcode](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3746201/best-c-solution-pure-binary-search-approach-beats-98-84/)\\n- [Minimum Number of Days to Make m Bouquets - Leetcode](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/3751751/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Capacity To Ship Packages Within D Days - Leetcode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3751752/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Minimum Time to Repair Cars - Leetcode](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/3753730/best-c-solution-list-of-8-similar-very-imp-binary-search-questions/)\\n- [Book Allocation - Coding Ninjas](https://www.codingninjas.com/studio/problems/ayush-and-ninja-test_1097574?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n- [Aggressive cows - Coding Ninjas](https://www.codingninjas.com/studio/problems/aggressive-cows_1082559?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=1)\\n- [Painter\\'s partition - Coding Ninjas](https://www.codingninjas.com/studio/problems/painter\\'s-partition-problem_1089557?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        sort(q.begin(), q.end());\\n        int m = q.size(), start = 1, end = q[m-1], ans = -1;\\n        if(n==m)    return end;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            long long qCount = 0;\\n            for(int i=0; i<m; i++)\\n                qCount += (q[i]-1)/mid + 1;\\n            if(qCount <= n)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        sort(q.begin(), q.end());\\n        int m = q.size(), start = 1, end = q[m-1], ans = -1;\\n        if(n==m)    return end;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            long long qCount = 0;\\n            for(int i=0; i<m; i++)\\n                qCount += (q[i]-1)/mid + 1;\\n            if(qCount <= n)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694915,
                "title": "revised-version-of-allocate-minimum-number-of-pages-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> quantities, int mid, int store, int n){\\n        int s = 0;\\n        for(int i = 0; i < n; i++){\\n            int quan = quantities[i];\\n            //distributing predecting quantities mid to store s, incresing s++\\n            while(quan > 0){\\n                if(quan >= mid){\\n                    quan -= mid;\\n                    s++;\\n                }\\n                else{\\n                    s++;\\n                    quan = 0;\\n                }\\n                // when more store required than given store\\n                if(s > store) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizedMaximum(int store, vector<int>& quantities) {\\n        int n = quantities.size();\\n        int right;\\n        for(int i = 0; i < n; i++){\\n            right = max(right, quantities[i]);\\n        }\\n        int res = -1;\\n        int left = 1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(check(quantities, mid , store, n)){\\n                res = mid;\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> quantities, int mid, int store, int n){\\n        int s = 0;\\n        for(int i = 0; i < n; i++){\\n            int quan = quantities[i];\\n            //distributing predecting quantities mid to store s, incresing s++\\n            while(quan > 0){\\n                if(quan >= mid){\\n                    quan -= mid;\\n                    s++;\\n                }\\n                else{\\n                    s++;\\n                    quan = 0;\\n                }\\n                // when more store required than given store\\n                if(s > store) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizedMaximum(int store, vector<int>& quantities) {\\n        int n = quantities.size();\\n        int right;\\n        for(int i = 0; i < n; i++){\\n            right = max(right, quantities[i]);\\n        }\\n        int res = -1;\\n        int left = 1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(check(quantities, mid , store, n)){\\n                res = mid;\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567227,
                "title": "java-max-heap-greedy-idea-based-solution",
                "content": "The question\\'s description did not immediately bring me the idea about using binary search to search for store capacity. Instead, I spend nearly one hour to come up with a greedy solution using max heap. Basically\\n\\n- At the beginning, you use m stores, and each store just takes entire volume of a product type. The capacity is max(quantities).\\n- We push int arrays into priority queue: [q, n, val]\\n\\n\\t- q: total quantity of a given product. Basically original values in quantities array.\\n\\t- n: number of stores assigned.\\n\\t- val: store capacity needed. Computing this needs a helper function costing O(1).\\n- We know, we can add n - m new stores, so we just do the following for n - m rounds:\\n\\t- We pop the product costing most store capacities\\n\\t- Add 1 extra store to this product.\\n\\t- Recompute the required capacity and push this product\\'s state back to the heap.\\n- By the end of the day, heap.peek().val would give us the final result.\\n\\n\\nHand-wavy intuition of why the above works: naively, we just start with most stupid store assignments, that is just contain each product with a single store. In order to do better, one must pick the bottleneck, the store containing most items, and add another store to its aid. If we pick any other store to improve, we either arrive at the same solution in later stage or we missed the opportunity to improve the bottleneck. The same logic holds for later iterations. One could workout an induction based proof which shows `n-th iteration gives optimal store capacity for using n stores.`\\n\\n- Iteration 1 the idea is correct (we just talked about it). Iteration 2 can be proved by easy examples as well.\\n- If iteration n gives best splits for having n stores, we can prove the strategy gives best split for n+1 stores. After n-th iteration, we will have to pick the next product to assign the n+1-th store. Picking any product which does not have largest store capacity will not improve upon n-th iteration: the max store capacity is still bounded by the current maximum. \\n- We define the max store capacity after picking the top of the heap as v* and the max store capacity of picking any product as v_i, we can safely claim `v* <= v_i`.\\n- Thus, n+1-th iterations answer is v*, and we showed it gives better result than the rest picking strategy.\\n\\nComplexity:\\n\\n- Time: O( (n - m) log m). Space: O(m)\\n- Why does this idea suck so badly compared to binary search? Define max quantity of a product as V, then binary search gives time complexity of O(m log V). The test cases for this question is designed with using binary search in mind, thus m < n is always ensured by a good margin. Imagine on average m = 100 and n = 10000, then our solution here costs 1e4 and binary search costs 1e2.\\n- However, if m, n scales are much closer on average and V values are much bigger than m, the proposed idea has a narrow path way of winning.\\n\\nSummary: this is more like a fun alternative idea, I DO NOT prefer this idea over binary search. I always hate greedy solutions and stuff I cannot 100% prove in general.\\n\\nCode:\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        // int[] : q, n, val\\n        // max heap.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n        (o1, o2) -> o2[2] - o1[2]);\\n        \\n        // Init the heap.\\n        // At the beginning, we compute the res using m stores,\\n        // then we m + 1 -> n.\\n        for (int q : quantities) {\\n            pq.offer(new int[]{q, 1, computeVal(1, q)});\\n        }\\n        \\n        int m = quantities.length;\\n        while (m < n) {\\n            int[] product = pq.poll();\\n            pq.offer(\\n            new int[]{product[0], \\n                      product[1] + 1, \\n                      computeVal(product[1] + 1, product[0])});\\n            m += 1;\\n        }\\n        \\n        int[] bottleneck = pq.poll();\\n        return bottleneck[2];\\n    }\\n    \\n    public int computeVal(int n, int q) {\\n        // given quantity and number of stores.\\n        // compute max val in a store.\\n        int val = q / n;\\n        if (n == 1) return val;\\n        \\n        int remainder = q % n;\\n        return val + (remainder > 0 ? 1 : 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        // int[] : q, n, val\\n        // max heap.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n        (o1, o2) -> o2[2] - o1[2]);\\n        \\n        // Init the heap.\\n        // At the beginning, we compute the res using m stores,\\n        // then we m + 1 -> n.\\n        for (int q : quantities) {\\n            pq.offer(new int[]{q, 1, computeVal(1, q)});\\n        }\\n        \\n        int m = quantities.length;\\n        while (m < n) {\\n            int[] product = pq.poll();\\n            pq.offer(\\n            new int[]{product[0], \\n                      product[1] + 1, \\n                      computeVal(product[1] + 1, product[0])});\\n            m += 1;\\n        }\\n        \\n        int[] bottleneck = pq.poll();\\n        return bottleneck[2];\\n    }\\n    \\n    public int computeVal(int n, int q) {\\n        // given quantity and number of stores.\\n        // compute max val in a store.\\n        int val = q / n;\\n        if (n == 1) return val;\\n        \\n        int remainder = q % n;\\n        return val + (remainder > 0 ? 1 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563842,
                "title": "even-o-nlogm-giving-tle-using-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int m = q.size();\\n        vector<int> allocated(m, 1); //allocate 1 store for every item\\n        \\n\\t\\t//max heap based on maximum number of products that are given to a store\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<pair<int, int>>> pq; \\n        for(int i=0; i<m; ++i) {\\n            pq.push({q[i], i});\\n        }\\n        \\n        int rem = n-m; //remaining stores\\n        while(rem--) {\\n            int index = pq.top().second;\\n            pq.pop();\\n            allocated[index]++; //allocate one more store\\n            pq.push({ceil((float)q[index]/allocated[index]), index}); // calculate maximum number of products that are given to a store\\n        }\\n        //cout << n << \" \" << m;\\n        return pq.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int m = q.size();\\n        vector<int> allocated(m, 1); //allocate 1 store for every item\\n        \\n\\t\\t//max heap based on maximum number of products that are given to a store\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<pair<int, int>>> pq; \\n        for(int i=0; i<m; ++i) {\\n            pq.push({q[i], i});\\n        }\\n        \\n        int rem = n-m; //remaining stores\\n        while(rem--) {\\n            int index = pq.top().second;\\n            pq.pop();\\n            allocated[index]++; //allocate one more store\\n            pq.push({ceil((float)q[index]/allocated[index]), index}); // calculate maximum number of products that are given to a store\\n        }\\n        //cout << n << \" \" << m;\\n        return pq.top().first;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1563749,
                "title": "c-binary-search",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Binary Search\\n\\n**Intuition**: \\n1. Given `k` (the maximum number of products given to any store), we can compute the number of stores we are able to assign in `O(Q)` time where `Q` is the length of `quantities`.\\n2. `k` is in range `[1, MAX(quantities)]` and this answer range has perfect monotonicity: There must exist a `K` that for every `k >= K`, we can do the assignment with `k`; for every `k < K`, we can\\'t do the assignment because the number of stores are not enough.\\n\\nSo, we can use binary search to find this `K` in `O(Qlog(MAX(quantities)))` time.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\n// Author: github.com/lzl124631x\\n// Time: O(QlogM) where `Q` is the length of `quantities` and `M` is the max element in `quantities`.\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& Q) {\\n        long long L = 1, R = accumulate(begin(Q), end(Q), 0LL);\\n        auto valid = [&](int M) {\\n            int ans = 0;\\n            for (int n : Q) ans += (n + M - 1) / M; // ceil(n / M)\\n            return ans <= n;\\n        };\\n        while (L <= R) {\\n            long long M = (L + R) / 2;\\n            if (valid(M)) R = M - 1;\\n            else L = M + 1;\\n        }\\n        return L;\\n    }\\n};\\n```\\n\\nOr use `L < R` template\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\n// Author: github.com/lzl124631x\\n// Time: O(QlogM) where `Q` is the length of `quantities` and `M` is the max element in `quantities`.\\n// Space: O(1\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& Q) {\\n        long long L = 1, R = *max_element(begin(Q), end(Q));\\n        auto valid = [&](int M) {\\n            int ans = 0;\\n            for (int n : Q) {\\n                ans += (n + M - 1) / M;\\n            }\\n            return ans <= n;\\n        };\\n        while (L < R) {\\n            long long M = (L + R) / 2;\\n            if (valid(M)) R = M;\\n            else L = M + 1;\\n        }\\n        return L;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\n// Author: github.com/lzl124631x\\n// Time: O(QlogM) where `Q` is the length of `quantities` and `M` is the max element in `quantities`.\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& Q) {\\n        long long L = 1, R = accumulate(begin(Q), end(Q), 0LL);\\n        auto valid = [&](int M) {\\n            int ans = 0;\\n            for (int n : Q) ans += (n + M - 1) / M; // ceil(n / M)\\n            return ans <= n;\\n        };\\n        while (L <= R) {\\n            long long M = (L + R) / 2;\\n            if (valid(M)) R = M - 1;\\n            else L = M + 1;\\n        }\\n        return L;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\n// Author: github.com/lzl124631x\\n// Time: O(QlogM) where `Q` is the length of `quantities` and `M` is the max element in `quantities`.\\n// Space: O(1\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& Q) {\\n        long long L = 1, R = *max_element(begin(Q), end(Q));\\n        auto valid = [&](int M) {\\n            int ans = 0;\\n            for (int n : Q) {\\n                ans += (n + M - 1) / M;\\n            }\\n            return ans <= n;\\n        };\\n        while (L < R) {\\n            long long M = (L + R) / 2;\\n            if (valid(M)) R = M;\\n            else L = M + 1;\\n        }\\n        return L;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362285,
                "title": "binary-search-with-detailed-approach-c",
                "content": "# Intuition\\nHere the core idea is to divide appropriate number of retail stores to each of the products suct that we can distribute all our products and also following the minimum element condition. \\nFor searching a given value within a specified range we may give a thought for binary search.\\n\\n# Approach\\nAs soon as we strike binary search we need to decide range limits.\\n1. The lower bound ( l ) should be 1 as we can distribute 1 product of a particular category to retail store.\\n2. The upper bound ( r ) will be the product with highest quantity. Means we can give that much highest capacity in one go. \\n3. Even if we have other products with less quantities, we can still distribute them ( they we not disturb our answer as we want to minimize the maximum element, so smaller element will not affect. )\\n4. But each element distributed will cost us a retail store, since we can give them only 1 type of product not more than that.\\n5. $$mid = ( l+r )/2$$ --> as here we need to find the first truth value for example \"FFFTTT\"  we will not get desired answer for smaller values of mid, but for larger values of mid.\\n6. If we our situation was like \"TTTTFFF\" ie we have to find last truth values then **$$mid = ( l+r )/2 +1$$** to avoid infinite loop\\n7. After getting mid value we will send it to possible function to find whether all products will be distributed using this value of mid or not.\\n8. ($$ q[ind] + mid +1) / mid$$  will calculate no of retail stores required. It is doing same function as ceil do.\\n9. If possible function returns true then we try to reduce our answer by reducing r=mid.  if possible function return false then , we are in shortage of retail stores then we should increase individual giving capacity.\\n\\n\\n# Complexity\\n- Time complexity:\\nO( N LogN )\\nN is size of quantity vector.\\nAlso Log(N) --> Log( Highest value in quantity)\\nboth the quantities have same upper bound in worst case.\\n\\n- Space complexity:\\nO(1) \\n\\n\\nPlease Upvote if this was helpful for you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> &q,int n, int mid){\\n\\n        int ind=0;\\n\\n        while(ind<q.size()){\\n            int num= (q[ind]+mid-1)/mid;\\n            if(n>=num){\\n                n-=num;\\n            }\\n            else{\\n               return false;\\n            }\\n            ind++;\\n        }\\n\\n        return true;;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n\\n        int l=1, r= *max_element(quantities.begin(),quantities.end()),mid;\\n\\n        while(l<r){\\n\\n            mid= (l+r)/2 ;\\n\\n            if(possible(quantities,n,mid)){\\n                r=mid;\\n\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n\\n        return r;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> &q,int n, int mid){\\n\\n        int ind=0;\\n\\n        while(ind<q.size()){\\n            int num= (q[ind]+mid-1)/mid;\\n            if(n>=num){\\n                n-=num;\\n            }\\n            else{\\n               return false;\\n            }\\n            ind++;\\n        }\\n\\n        return true;;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n\\n        int l=1, r= *max_element(quantities.begin(),quantities.end()),mid;\\n\\n        while(l<r){\\n\\n            mid= (l+r)/2 ;\\n\\n            if(possible(quantities,n,mid)){\\n                r=mid;\\n\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n\\n        return r;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228621,
                "title": "python3-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(logk)$$ k is maximum `quantity` in `quantities`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        l, r = 1, max(quantities)\\n        while l <= r:\\n            m = (l + r) >> 1\\n            if sum(math.ceil(q / m) for q in quantities) > n:\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        l, r = 1, max(quantities)\\n        while l <= r:\\n            m = (l + r) >> 1\\n            if sum(math.ceil(q / m) for q in quantities) > n:\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219623,
                "title": "c-binary-search",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long l = 0, r = 0;\\n        for (auto q: quantities) r += q; l = r / n;\\n        auto getNum = [&](int pivot, int res = 0) {\\n            for (auto q: quantities) res += q / pivot, res += (q % pivot) ? 1: 0;\\n            return res;\\n        };\\n        while (l < r) {\\n            auto mid = l + (r - l) / 2;\\n            if (!mid) return r;\\n            auto val = getNum(mid);\\n            if (val > n) l = mid + 1; else r = mid;\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long l = 0, r = 0;\\n        for (auto q: quantities) r += q; l = r / n;\\n        auto getNum = [&](int pivot, int res = 0) {\\n            for (auto q: quantities) res += q / pivot, res += (q % pivot) ? 1: 0;\\n            return res;\\n        };\\n        while (l < r) {\\n            auto mid = l + (r - l) / 2;\\n            if (!mid) return r;\\n            auto val = getNum(mid);\\n            if (val > n) l = mid + 1; else r = mid;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181923,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int valid(int mid,vector<int> &arr,int n){\\n        int cnt=0;\\n        for(int i=0;i<arr.size();i++){\\n            // cout<<arr[i]<<\" \"<<mid<<endl;\\n            int x=arr[i]/mid;\\n            int y=arr[i]%mid;\\n            if(y==0){\\n                cnt+=x;\\n            }\\n            else{\\n            cnt+=x+1;}\\n            // cout<<x<<\" \"<<y<<endl;\\n            // cout<<x;\\n        }\\n        return cnt<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low=1;\\n        int high=11;\\n        for(int i=0;i<quantities.size();i++){\\n            high=max(high,quantities[i]);\\n        }\\n        int res=0;\\n        int ans;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(valid(mid,quantities,n)){\\n                res=mid;\\n                high=mid-1;\\n                // cout<<\"agya\";\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // cout<<low<<\" \"<<high;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int valid(int mid,vector<int> &arr,int n){\\n        int cnt=0;\\n        for(int i=0;i<arr.size();i++){\\n            // cout<<arr[i]<<\" \"<<mid<<endl;\\n            int x=arr[i]/mid;\\n            int y=arr[i]%mid;\\n            if(y==0){\\n                cnt+=x;\\n            }\\n            else{\\n            cnt+=x+1;}\\n            // cout<<x<<\" \"<<y<<endl;\\n            // cout<<x;\\n        }\\n        return cnt<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low=1;\\n        int high=11;\\n        for(int i=0;i<quantities.size();i++){\\n            high=max(high,quantities[i]);\\n        }\\n        int res=0;\\n        int ans;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(valid(mid,quantities,n)){\\n                res=mid;\\n                high=mid-1;\\n                // cout<<\"agya\";\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // cout<<low<<\" \"<<high;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3159548,
                "title": "95-faster-binary-search-c-simple-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minimizedMaximum(int n, vector<int> &v)\\n    {\\n        int mx = 100009, mn = 1;\\n        int ans = v[0], k, mid;\\n        while (mn <= mx)\\n        {\\n            mid = (mx - mn) / 2 + mn;\\n            k = 0;\\n            for (auto &i : v)\\n            {\\n                if (i % mid)\\n                {\\n                    k += i / mid + 1;\\n                }\\n                else\\n                {\\n                    k += i / mid;\\n                }\\n            }\\n            // cout<<k<<\" \"<<mid<<endl;\\n            if (k > n)\\n            {\\n                mn = mid + 1;\\n            }\\n            else\\n            {\\n                ans = mid;\\n                mx = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimizedMaximum(int n, vector<int> &v)\\n    {\\n        int mx = 100009, mn = 1;\\n        int ans = v[0], k, mid;\\n        while (mn <= mx)\\n        {\\n            mid = (mx - mn) / 2 + mn;\\n            k = 0;\\n            for (auto &i : v)\\n            {\\n                if (i % mid)\\n                {\\n                    k += i / mid + 1;\\n                }\\n                else\\n                {\\n                    k += i / mid;\\n                }\\n            }\\n            // cout<<k<<\" \"<<mid<<endl;\\n            if (k > n)\\n            {\\n                mn = mid + 1;\\n            }\\n            else\\n            {\\n                ans = mid;\\n                mx = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2958799,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &q, int k) {\\n        int cnt = 0;\\n        for(int i : q) {\\n            cnt += ceil((double) i / x);\\n            if(cnt > k) return false;\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int s = 1, e = 1e5, ans = INT_MAX;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, quantities, n)) ans = min(ans, m), e = m - 1;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &q, int k) {\\n        int cnt = 0;\\n        for(int i : q) {\\n            cnt += ceil((double) i / x);\\n            if(cnt > k) return false;\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int s = 1, e = 1e5, ans = INT_MAX;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, quantities, n)) ans = min(ans, m), e = m - 1;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897538,
                "title": "java-interval-binary-search-to-find-minimum-valid-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer (maximum number of products that a retail store can display) falls in interval `[1, max(quantities)]`. Use binary search in this interval to find the minimum valid number that satisfies the condition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIdea is similar to [278. First Bad Version](https://leetcode.com/problems/first-bad-version/) and [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n\\n# Code\\n```\\nclass Solution {\\n    public int n = 0;\\n\\n    public int[] quantities;\\n\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        this.n = n;\\n        this.quantities = quantities;\\n\\n        // search maximum number of products that are given to any store.\\n        int left = 1, right = Arrays.stream(quantities).max().getAsInt();\\n        while (left < right) {\\n            int mid = left + ((right - left) >> 1);\\n            if (!isValid(mid))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n    \\n    /** Validate if given maximum number of product a retail store can display is possible under given constrain. */\\n    private boolean isValid(int maxNumberProduct) {\\n        int count = 0;\\n        for (int quantity : quantities) {\\n            count += (maxNumberProduct + quantity - 1) / maxNumberProduct;\\n            if (count > n)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int n = 0;\\n\\n    public int[] quantities;\\n\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        this.n = n;\\n        this.quantities = quantities;\\n\\n        // search maximum number of products that are given to any store.\\n        int left = 1, right = Arrays.stream(quantities).max().getAsInt();\\n        while (left < right) {\\n            int mid = left + ((right - left) >> 1);\\n            if (!isValid(mid))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n    \\n    /** Validate if given maximum number of product a retail store can display is possible under given constrain. */\\n    private boolean isValid(int maxNumberProduct) {\\n        int count = 0;\\n        for (int quantity : quantities) {\\n            count += (maxNumberProduct + quantity - 1) / maxNumberProduct;\\n            if (count > n)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666257,
                "title": "binary-search-easy-explaination-c-constant-space",
                "content": "This Question is based on a popular question (\"Allocation of minimum pages\").\\nIf you haven\\'t heard of that question,no problem.\\nwe know that we can only use binary search in sorted or ordered sequence, so if we are able to fin the range of our answer we can apply binary search in that range. In this question the lowest possible  number of product one store can have is 0 and the maximum is total number of that specific product ,so our lower bound will be 0(low) and our upper bound will be the max elemnt in the array because it is the biggest amount a store can have (high).\\nso if we jump into the middle 0f this range and check that wether this value will satisfy our solution or not (how we will check I\\'ll explain below) , if it does we need to minimize our solution so we will move our high to **high=mid-1**.If it doesn\\'t satisfy with our requirements we will move our low to **low=mid+1**.\\n**How to check that wether the found value is one of the solution or not :-**\\nlet\\'s assume that the value(mid) I got was some value x and we have an array of elements arr[]={15,10,10} , lets say x= 7[(0+15)/2=7]. 7 will divide 15 into 7,7,1 and it will divide both 10 into 7,10 ,there fore total number of distributuin are 7 and if this 7 equals or is less than number of stores we will return true.\\n**FULL CODE :-**    \\n**Drop a like if you understood the soln**\\n```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&v,int k,int val){\\n    int p=0;\\n    if (val==0)return false;\\n    for(int i=0;i<v.size();i++){\\n        if(v[i]%val==0){\\n            p+=(v[i]/val);\\n        }\\n        else{\\n            p+=((v[i]/val)+1);\\n        }\\n    }\\n    if(p>k)return false;\\n    return true;\\n}\\nint minimizedMaximum(int k, vector<int>& a){\\n    int n=a.size(); int mx=INT_MIN,res=INT_MAX;\\n    for(int i=0;i<n;i++){\\n        mx=max(a[i],mx);\\n    }\\n    int l=0,h=mx;\\n    while(l<=h){\\n        int mid=(l+h)/2;\\n        if(ispossible(a,k,mid)){\\n            res=min(res,mid);\\n            h=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&v,int k,int val){\\n    int p=0;\\n    if (val==0)return false;\\n    for(int i=0;i<v.size();i++){\\n        if(v[i]%val==0){\\n            p+=(v[i]/val);\\n        }\\n        else{\\n            p+=((v[i]/val)+1);\\n        }\\n    }\\n    if(p>k)return false;\\n    return true;\\n}\\nint minimizedMaximum(int k, vector<int>& a){\\n    int n=a.size(); int mx=INT_MIN,res=INT_MAX;\\n    for(int i=0;i<n;i++){\\n        mx=max(a[i],mx);\\n    }\\n    int l=0,h=mx;\\n    while(l<=h){\\n        int mid=(l+h)/2;\\n        if(ispossible(a,k,mid)){\\n            res=min(res,mid);\\n            h=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606468,
                "title": "binary-search-solution",
                "content": "This is a typical Binary Search solution. Other similar questions are: Koko eating bananas, minimum ships required to transport containers, etc\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max=0; for(int i:quantities) max=Math.max(i, max);\\n        return binarySearch(quantities, 1, max, n);\\n    }\\n    \\n    private int binarySearch(int[] quantities, int left, int right, int shops) {\\n        while(left <= right) {\\n            int mid = (left+right)/2;\\n            if(shopsCovered(quantities, mid) <= shops) \\n                right = mid-1;\\n            else \\n                left = mid+1;\\n        }\\n        return left;\\n    }\\n    \\n    private int shopsCovered(int[] quantities, int max) {\\n        int sum = 0;\\n        for(int i:quantities)\\n            sum += (int)Math.ceil(1.0*i/max);\\n        return sum;\\n    }\\n}\\n```\\n\\n**TC:** O(array_len * log maxval)\\n**SC:** O(1)\\n\\nUpvote if u have liked!",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max=0; for(int i:quantities) max=Math.max(i, max);\\n        return binarySearch(quantities, 1, max, n);\\n    }\\n    \\n    private int binarySearch(int[] quantities, int left, int right, int shops) {\\n        while(left <= right) {\\n            int mid = (left+right)/2;\\n            if(shopsCovered(quantities, mid) <= shops) \\n                right = mid-1;\\n            else \\n                left = mid+1;\\n        }\\n        return left;\\n    }\\n    \\n    private int shopsCovered(int[] quantities, int max) {\\n        int sum = 0;\\n        for(int i:quantities)\\n            sum += (int)Math.ceil(1.0*i/max);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577325,
                "title": "with-explanation-comments-time-499-ms-21-06-space-84-3-mb-97-18",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    //helper function to check if the middle pointer value of the range is a valid value to be divided or not\\n    bool valid(int mid, vector<int> &quantities, int n){\\n        \\n        //initialize a counter\\n        int counter=0;\\n\\n        //loop over the whole array elements\\n        for(int qu:quantities){\\n            //check if the current element is smaller than the mid\\n            if(qu<mid)\\n                //if yes-> add the counter by one\\n                counter++;\\n            \\n            else{\\n                //if no->initialize a temp partial sum variable\\n                int parSum=qu;\\n                \\n                //loop until getting 0 \\n                while(parSum>0){\\n                    //subtract the mid value from the current sum\\n                    parSum-=mid;\\n                    //add the counter by one\\n                    counter++;\\n                }\\n            }\\n        }\\n        \\n        //check if the counted products is valid or not compared to the allowed ones\\n        return counter<=n;\\n    }\\n    \\n    \\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n        //handle invalid cases\\n        if(n<1)\\n            return 0;\\n  \\n        //initialize mainly two pointers-> one on the minimum possible value in the array & one on the maximum one\\n        int left=1, right=*max_element(quantities.begin(), quantities.end()), ans=-1;\\n        \\n        //loop while the left pointer is before the right one\\n        while(left<right){\\n            //the third pointer mid-> is exactly the middle element between the main two ones\\n            int mid=left+(right-left)/2;\\n        //call the helper function\\n            if(valid(mid, quantities, n))\\n                //case 1: if yes, valid-> move the right pointer to the mid position\\n                right=mid;\\n            \\n            else\\n                //case 2: if not-> move the left pointer to the position after the mid one\\n                left=mid+1;\\n                \\n        }\\n        \\n        //return the right position \\n        return right;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //helper function to check if the middle pointer value of the range is a valid value to be divided or not\\n    bool valid(int mid, vector<int> &quantities, int n){\\n        \\n        //initialize a counter\\n        int counter=0;\\n\\n        //loop over the whole array elements\\n        for(int qu:quantities){\\n            //check if the current element is smaller than the mid\\n            if(qu<mid)\\n                //if yes-> add the counter by one\\n                counter++;\\n            \\n            else{\\n                //if no->initialize a temp partial sum variable\\n                int parSum=qu;\\n                \\n                //loop until getting 0 \\n                while(parSum>0){\\n                    //subtract the mid value from the current sum\\n                    parSum-=mid;\\n                    //add the counter by one\\n                    counter++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2267375,
                "title": "c-soln-binary-search",
                "content": "**Intuition is the same i.e. simple binary search, assuming mid can be our acceptable answer. In this we can use low =1 which will not affect time complexity but it would be great if you tell your interviewer what is the minimum acceptable answer**\\n\\n**In the first sight it can come to mind i.e. low= sum(array)/n but we have to keep an edge case in our mind what if n > sum(array), so low=max(sum(array),1))**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int>& arr,int mid,int k){\\n        int count=0; // count represent number of element in new subarray\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>mid){\\n                count+= arr[i]%mid?arr[i]/mid+1:arr[i]/mid;\\n                if(count>k)return false;\\n            }\\n            else count++;\\n        }\\n        return count<=k; // if(count<=k) then mid can be our acceptable ans\\n    }\\n    int minimizedMaximum(int k, vector<int>& arr) {\\n        int maxi=-1;\\n        long long sum=0;\\n        for(auto a:arr){\\n            sum+=a;\\n            maxi=max(a,maxi);\\n        }\\n        int low=max<long long>(1,sum/k),high=maxi;\\n        int ans=1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;  // to avoid integer overflow\\n            if(isvalid(arr,mid,k)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**T.C---> O(N*log(max_element(array)))** // assuming sum/k-1<<<<< max_element\\n**S.C--->O(1)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int>& arr,int mid,int k){\\n        int count=0; // count represent number of element in new subarray\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>mid){\\n                count+= arr[i]%mid?arr[i]/mid+1:arr[i]/mid;\\n                if(count>k)return false;\\n            }\\n            else count++;\\n        }\\n        return count<=k; // if(count<=k) then mid can be our acceptable ans\\n    }\\n    int minimizedMaximum(int k, vector<int>& arr) {\\n        int maxi=-1;\\n        long long sum=0;\\n        for(auto a:arr){\\n            sum+=a;\\n            maxi=max(a,maxi);\\n        }\\n        int low=max<long long>(1,sum/k),high=maxi;\\n        int ans=1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;  // to avoid integer overflow\\n            if(isvalid(arr,mid,k)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660232,
                "title": "java-binary-search-o-n-quantities-log-max-quantities-time-o-1-space",
                "content": "**Runtime: 58 ms, faster than 60.23% of Java online submissions for Minimized Maximum of Products Distributed to Any Store.\\nMemory Usage: 47.3 MB, less than 91.24% of Java online submissions for Minimized Maximum of Products Distributed to Any Store.**\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int start = 1, end = Integer.MIN_VALUE, result = 1; // answer will lie between 1 and max(quantities)\\n        for(int quantity : quantities) {\\n            end = Math.max(end, quantity);\\n        }\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(check(quantities, n, mid)) {\\n                result = mid; // We have found a potential answer but need to check if we can do better\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private boolean check(int[] quantities, int n, int target) {\\n        int count = 0;\\n        for(int quantity : quantities) {\\n            count += quantity % target == 0 ? quantity / target : quantity / target + 1;\\n        }\\n        return count <= n;\\n    }\\n}\\n```\\n\\nNote: Same solution as [**Koko Eating Bananas**](https://leetcode.com/problems/koko-eating-bananas/)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int start = 1, end = Integer.MIN_VALUE, result = 1; // answer will lie between 1 and max(quantities)\\n        for(int quantity : quantities) {\\n            end = Math.max(end, quantity);\\n        }\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(check(quantities, n, mid)) {\\n                result = mid; // We have found a potential answer but need to check if we can do better\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private boolean check(int[] quantities, int n, int target) {\\n        int count = 0;\\n        for(int quantity : quantities) {\\n            count += quantity % target == 0 ? quantity / target : quantity / target + 1;\\n        }\\n        return count <= n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569744,
                "title": "simple-binary-search-soln",
                "content": "\\'\\'\\'\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        ll i,j,m=q.size();\\n        sort(q.rbegin(),q.rend());\\n        ll lo=1,hi=100001;\\n        ll res=hi;\\n        while(lo<=hi){\\n            ll mid=(lo+hi)/2;\\n            ll cnt=0;\\n            for(i=0;i<m;i++){\\n                cnt+=q[i]/mid;\\n                if(q[i]%mid!=0){\\n                    cnt++;\\n                }\\n                if(cnt>n){\\n                    break;\\n                }\\n            }\\n            if(cnt<=n){\\n                res=min(res,mid);\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        ll i,j,m=q.size();\\n        sort(q.rbegin(),q.rend());\\n        ll lo=1,hi=100001;\\n        ll res=hi;\\n        while(lo<=hi){\\n            ll mid=(lo+hi)/2;\\n            ll cnt=0;\\n            for(i=0;i<m;i++){\\n                cnt+=q[i]/mid;\\n                if(q[i]%mid!=0){\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1566404,
                "title": "c-192ms-71-binary-search",
                "content": "Runtime: 252 ms, faster than 57.14% of C++ online submissions for Minimized Maximum of Products Distributed to Any Store.\\nMemory Usage: 84.5 MB, less than 42.86% of C++ online submissions for Minimized Maximum of Products Distributed to Any Store.\\n```\\nclass Solution {\\npublic:\\n  bool func(int N, int n, vector<int>& quantities){\\n    int temp = 0;\\n    for(int id = 0; temp <= n && id != quantities.size(); id++)\\n      temp += quantities[id] / N + (quantities[id] % N ? 1 : 0);\\n    \\n    return temp <= n;\\n  }\\n  \\n  int minimizedMaximum(int n, vector<int>& quantities) {\\n    int l = 1, r = *max_element(quantities.begin(), quantities.end());\\n    \\n    for(int m = (l + r)>>1; l <= r; m = (l + r)>>1) \\n      func(m, n , quantities) ? r = m - 1 : l = m + 1; \\n    \\n    return l;\\n  }\\n};\\n```\\n\\nwith improving from **carstenh**\\nRuntime: 192 ms, faster than 70.65% of C++ online submissions for Minimized Maximum of Products Distributed to Any Store.\\nMemory Usage: 84.4 MB, less than 43.62% of C++ online submissions for Minimized Maximum of Products Distributed to Any Store.\\n```\\nclass Solution {\\npublic:\\n  bool func(int N, int n, vector<int>& quantities){\\n    int temp = 0;\\n    for(int id = 0; temp <= n && id != quantities.size(); id++)\\n      temp += (quantities[id] + N - 1) / N;\\n    \\n    return temp <= n;\\n  }\\n  \\n  int minimizedMaximum(int n, vector<int>& quantities) {\\n    int l = 1, r = *max_element(quantities.begin(), quantities.end());\\n    \\n    for(int m = (l + r)>>1; l <= r; m = (l + r)>>1) \\n      func(m, n , quantities) ? r = m - 1 : l = m + 1; \\n    \\n    return l;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool func(int N, int n, vector<int>& quantities){\\n    int temp = 0;\\n    for(int id = 0; temp <= n && id != quantities.size(); id++)\\n      temp += quantities[id] / N + (quantities[id] % N ? 1 : 0);\\n    \\n    return temp <= n;\\n  }\\n  \\n  int minimizedMaximum(int n, vector<int>& quantities) {\\n    int l = 1, r = *max_element(quantities.begin(), quantities.end());\\n    \\n    for(int m = (l + r)>>1; l <= r; m = (l + r)>>1) \\n      func(m, n , quantities) ? r = m - 1 : l = m + 1; \\n    \\n    return l;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  bool func(int N, int n, vector<int>& quantities){\\n    int temp = 0;\\n    for(int id = 0; temp <= n && id != quantities.size(); id++)\\n      temp += (quantities[id] + N - 1) / N;\\n    \\n    return temp <= n;\\n  }\\n  \\n  int minimizedMaximum(int n, vector<int>& quantities) {\\n    int l = 1, r = *max_element(quantities.begin(), quantities.end());\\n    \\n    for(int m = (l + r)>>1; l <= r; m = (l + r)>>1) \\n      func(m, n , quantities) ? r = m - 1 : l = m + 1; \\n    \\n    return l;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565596,
                "title": "python-faster-than-100-submissions-solution",
                "content": "\"\"\"\\n\\t\\tdef minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n\\t\\t\\tlo , hi , sol = 1, max(quantities), 0 \\n\\t\\t\\twhile(lo<=hi):\\n\\t\\t\\t\\tmid , num_store = ceil((lo+hi)/2) , 0\\n\\t\\t\\t\\tfor quant in quantities :\\n\\t\\t\\t\\t\\tnum_store+= ceil(quant/mid)\\n\\t\\t\\t\\t\\tif num_store > n:\\n\\t\\t\\t\\t\\t\\tlo = mid+1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif num_store <= n : sol , hi = mid , mid-1\\n\\t\\t\\treturn sol\\n\"\"\"\\n\\n***Happy Coding !!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "\"\"\"\\n\\t\\tdef minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n\\t\\t\\tlo , hi , sol = 1, max(quantities), 0 \\n\\t\\t\\twhile(lo<=hi):\\n\\t\\t\\t\\tmid , num_store = ceil((lo+hi)/2) , 0\\n\\t\\t\\t\\tfor quant in quantities :\\n\\t\\t\\t\\t\\tnum_store+= ceil(quant/mid)\\n\\t\\t\\t\\t\\tif num_store > n:\\n\\t\\t\\t\\t\\t\\tlo = mid+1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif num_store <= n : sol , hi = mid , mid-1\\n\\t\\t\\treturn sol\\n\"\"\"\\n\\n***Happy Coding !!***",
                "codeTag": "Python3"
            },
            {
                "id": 1563991,
                "title": "python-binary-search-with-explain",
                "content": "```python\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n        l, r = 1, max(quantities)\\n        while l <= r:\\n            mid = (l+r)//2\\n            # count the number of stores needed if the max distribution is mid\\n            # one store can has max one product only and we need to distribute all the quantities\\n            cnt = 0\\n            for x in quantities:\\n                # if 0<=x<=mid, cnt = 1, if mid<x<=2mid, cnt = 2\\n                cnt += (x+mid-1)//mid\\n            \\n            # if with max distribution is mid, but number of stores needed is larger than actual stores n, then will need to increase the distribution, else we can further lower down the distribution.\\n            if cnt > n:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        \\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n        l, r = 1, max(quantities)\\n        while l <= r:\\n            mid = (l+r)//2\\n            # count the number of stores needed if the max distribution is mid\\n            # one store can has max one product only and we need to distribute all the quantities\\n            cnt = 0\\n            for x in quantities:\\n                # if 0<=x<=mid, cnt = 1, if mid<x<=2mid, cnt = 2\\n                cnt += (x+mid-1)//mid\\n            \\n            # if with max distribution is mid, but number of stores needed is larger than actual stores n, then will need to increase the distribution, else we can further lower down the distribution.\\n            if cnt > n:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563827,
                "title": "c-binary-search",
                "content": "We can Binary Serch for max value of the items that can be in a store(mid denotes this )\\n\\n```\\nbool check(int mx,vector<int>&v,int n)\\n    {\\n        int sum = 0 ; \\n        if(mx==0)\\n            return false;\\n        for(int i = 0 ;i<v.size();i++)\\n        {\\n            if(n<0)\\n                return false;\\n            int q = v[i]/mx + (v[i]%mx?1:0);\\n            n -= q;\\n            \\n        }\\n        if(n<0)\\n            return false;\\n        return true ;\\n    }\\n    int minimizedMaximum(int n, vector<int>&v) {\\n        sort(v.begin(),v.end());\\n        int m = v.size();\\n        if(n==1)\\n            return v[0];\\n         int l = 1, h = v[m-1], ans=1;\\n        while(l <= h)\\n        {\\n            int m = (l+h)/2;\\n            if(check(m,v,n))\\n            {\\n                ans = m ;\\n                h = m-1 ;\\n            }\\n            else\\n                l = m+1;\\n        }\\n        return ans ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool check(int mx,vector<int>&v,int n)\\n    {\\n        int sum = 0 ; \\n        if(mx==0)\\n            return false;\\n        for(int i = 0 ;i<v.size();i++)\\n        {\\n            if(n<0)\\n                return false;\\n            int q = v[i]/mx + (v[i]%mx?1:0);\\n            n -= q;\\n            \\n        }\\n        if(n<0)\\n            return false;\\n        return true ;\\n    }\\n    int minimizedMaximum(int n, vector<int>&v) {\\n        sort(v.begin(),v.end());\\n        int m = v.size();\\n        if(n==1)\\n            return v[0];\\n         int l = 1, h = v[m-1], ans=1;\\n        while(l <= h)\\n        {\\n            int m = (l+h)/2;\\n            if(check(m,v,n))\\n            {\\n                ans = m ;\\n                h = m-1 ;\\n            }\\n            else\\n                l = m+1;\\n        }\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563800,
                "title": "heap-well-explained-visualizable",
                "content": "## IDEA :\\n* The key point of this question is to distribute the stores to the products. \\n* Each product gets at least one store in the beginning, this is always possible due to problem constraints. After this we need to ask ourselves, to which product should we assing a score.\\n* If there are total number of a given product, we can distribute it to num_part store and every store gets part number of products. \\n* Then we keep the max value of part so far. \\n* At every step, greedily reduce this ratio. This can be done via max heap.\\n\\n> **Implementation :**  (Little slow)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimizedMaximum(self, n, A):\\n        \\n        heap = []\\n        for q in A:\\n            heapq.heappush(heap,(-q,1))\\n            n-=1\\n            \\n        while n>0:\\n            quantity,num_shops = heapq.heappop(heap)\\n            total = (-1)*quantity*num_shops\\n            num_shops+=1\\n            n-=1\\n            heapq.heappush(heap,(-1*(total/num_shops),num_shops))\\n        \\n        return math.ceil(-heap[0][0])\\n\\t\\n\\t**Thanks and Upvote if You like the Idea !! \\uD83E\\uDD1E**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "## IDEA :\\n* The key point of this question is to distribute the stores to the products. \\n* Each product gets at least one store in the beginning, this is always possible due to problem constraints. After this we need to ask ourselves, to which product should we assing a score.\\n* If there are total number of a given product, we can distribute it to num_part store and every store gets part number of products. \\n* Then we keep the max value of part so far. \\n* At every step, greedily reduce this ratio. This can be done via max heap.\\n\\n> **Implementation :**  (Little slow)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimizedMaximum(self, n, A):\\n        \\n        heap = []\\n        for q in A:\\n            heapq.heappush(heap,(-q,1))\\n            n-=1\\n            \\n        while n>0:\\n            quantity,num_shops = heapq.heappop(heap)\\n            total = (-1)*quantity*num_shops\\n            num_shops+=1\\n            n-=1\\n            heapq.heappush(heap,(-1*(total/num_shops),num_shops))\\n        \\n        return math.ceil(-heap[0][0])\\n\\t\\n\\t**Thanks and Upvote if You like the Idea !! \\uD83E\\uDD1E**",
                "codeTag": "Java"
            },
            {
                "id": 3944442,
                "title": "simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int divisor,vector<int>& quantities) {\\n        int sum = 0;\\n        for(int i=0;i<quantities.size();i++) {\\n            sum += ceil((double)quantities[i]/(double)divisor);\\n        }\\n\\n        return sum;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low = 1;\\n        int high = *max_element(quantities.begin(),quantities.end());\\n        int ans;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            int val = func(mid,quantities);\\n\\n            if(val <= n) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n![upvote_CAT.webp](https://assets.leetcode.com/users/images/070e4c88-7540-45fe-b606-f0e41f2d8d57_1692692239.15073.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int divisor,vector<int>& quantities) {\\n        int sum = 0;\\n        for(int i=0;i<quantities.size();i++) {\\n            sum += ceil((double)quantities[i]/(double)divisor);\\n        }\\n\\n        return sum;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low = 1;\\n        int high = *max_element(quantities.begin(),quantities.end());\\n        int ans;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            int val = func(mid,quantities);\\n\\n            if(val <= n) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269095,
                "title": "range-bs-easy-to-understand-must-see",
                "content": "# Code\\n```\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& arr) \\n    {\\n        //we need to minimize the ans\\n        int ans = INT_MAX;\\n\\n        //the min amount of product that we can give to any retail store is 0;\\n        long long int start = 0;\\n\\n        //the max amount of product that we can give to any retail store is max element form the array\\n        long long int end = *max_element(arr.begin(),arr.end());\\n\\n        //the ans would be in the range of left and right (including)\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n            \\n            if(fun(n,arr,mid) == true)\\n            {\\n                if(mid < ans)\\n                ans = mid;\\n                \\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int fun(int n,vector<int>&arr,long long int &mid)\\n    {\\n         if(mid == 0) return false;\\n\\n         long long int count = 0;\\n         \\n         for(int i=0;i<arr.size();i++)\\n         {\\n             if((arr[i]%mid) == 0)\\n             {\\n                 long long int temp = (arr[i]/mid);\\n                 count += temp;\\n                 \\n             }\\n             else if((arr[i]%mid) != 0)\\n             {\\n                 long long int ele  = arr[i];\\n                 long long int rem  = (ele%mid);\\n                 count+=1;\\n                 ele = ele - rem;\\n\\n                 long long int temp = (ele/mid);\\n                 count+=temp;\\n             }\\n         }\\n         if(count <= n)\\n         return true;\\n\\n         return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& arr) \\n    {\\n        //we need to minimize the ans\\n        int ans = INT_MAX;\\n\\n        //the min amount of product that we can give to any retail store is 0;\\n        long long int start = 0;\\n\\n        //the max amount of product that we can give to any retail store is max element form the array\\n        long long int end = *max_element(arr.begin(),arr.end());\\n\\n        //the ans would be in the range of left and right (including)\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n            \\n            if(fun(n,arr,mid) == true)\\n            {\\n                if(mid < ans)\\n                ans = mid;\\n                \\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int fun(int n,vector<int>&arr,long long int &mid)\\n    {\\n         if(mid == 0) return false;\\n\\n         long long int count = 0;\\n         \\n         for(int i=0;i<arr.size();i++)\\n         {\\n             if((arr[i]%mid) == 0)\\n             {\\n                 long long int temp = (arr[i]/mid);\\n                 count += temp;\\n                 \\n             }\\n             else if((arr[i]%mid) != 0)\\n             {\\n                 long long int ele  = arr[i];\\n                 long long int rem  = (ele%mid);\\n                 count+=1;\\n                 ele = ele - rem;\\n\\n                 long long int temp = (ele/mid);\\n                 count+=temp;\\n             }\\n         }\\n         if(count <= n)\\n         return true;\\n\\n         return false;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2593431,
                "title": "c-binary-search-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& qty) {\\n        int m = qty.size();\\n\\t\\tauto valid = [&](int &mx) {\\n\\t\\t\\tint st = 0;\\n\\t\\t\\tfor (int &q: qty) {\\n\\t\\t\\t\\tint s = ceil((1.0 * q) / mx);\\n\\t\\t\\t\\tst += s;\\n\\t\\t\\t}\\n\\t\\t\\treturn st <= n;\\n\\t\\t};\\n\\t\\tint lo = 1, hi = 1e5;\\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (valid(mid)) hi = mid;\\n\\t\\t\\telse lo = mid + 1;\\n\\t\\t}\\n\\t\\treturn lo;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& qty) {\\n        int m = qty.size();\\n\\t\\tauto valid = [&](int &mx) {\\n\\t\\t\\tint st = 0;\\n\\t\\t\\tfor (int &q: qty) {\\n\\t\\t\\t\\tint s = ceil((1.0 * q) / mx);\\n\\t\\t\\t\\tst += s;\\n\\t\\t\\t}\\n\\t\\t\\treturn st <= n;\\n\\t\\t};\\n\\t\\tint lo = 1, hi = 1e5;\\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (valid(mid)) hi = mid;\\n\\t\\t\\telse lo = mid + 1;\\n\\t\\t}\\n\\t\\treturn lo;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496853,
                "title": "c-easy-binary-search-clean-code",
                "content": "class Solution {\\n    public:\\n    bool ispossible(vector<int>& arr,int mid,int n){\\n        int count=0;\\n        for(int i=0;i<arr.size();i++){\\n            count+=(int)ceil(arr[i]/(double)mid);\\n        }\\n        \\n        return count<=n;\\n    }\\n    \\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int start=1;\\n        int end=*max_element(quantities.begin(),quantities.end());\\n        int ans=-1;\\n        \\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            \\n            if(ispossible(quantities,mid,n)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    bool ispossible(vector<int>& arr,int mid,int n){\\n        int count=0;\\n        for(int i=0;i<arr.size();i++){\\n            count+=(int)ceil(arr[i]/(double)mid);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2496823,
                "title": "100-faster-java-solution-binary-search-easy-to-understand",
                "content": "```\\npublic boolean isPossible(int n, int[] quantities, int mid){\\n        int count = 0;\\n        for(int i=0; i<quantities.length; i++){\\n            count += Math.ceil(quantities[i]/(mid*1.0)); \\n        }\\n        return count<=n; \\n    }\\n    \\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int start = 1, end = quantities[0];\\n        int size = quantities.length;\\n        for(int i=1;i<size;i++){\\n            end = Math.max(end,quantities[i]);\\n        }\\n        \\n        int ans = -1;\\n        \\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(isPossible(n,quantities,mid)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\npublic boolean isPossible(int n, int[] quantities, int mid){\\n        int count = 0;\\n        for(int i=0; i<quantities.length; i++){\\n            count += Math.ceil(quantities[i]/(mid*1.0)); \\n        }\\n        return count<=n; \\n    }\\n    \\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int start = 1, end = quantities[0];\\n        int size = quantities.length;\\n        for(int i=1;i<size;i++){\\n            end = Math.max(end,quantities[i]);\\n        }\\n        \\n        int ans = -1;\\n        \\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(isPossible(n,quantities,mid)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489421,
                "title": "minimised-maximum-products-distributed-to-any-store-c-explained-solution",
                "content": "The question here is good and needs some important observations to solve. Now looking at the question, the first thing that can come to mind is to take sum of all quantities and dividing it by **N** cause ideally that is the minimum maximum value to be distributed but this approach is incorrect cause the number of goods of each type is not same so distribution has to be done differently. Now let\\'s try to see the question from another perspective : Let\\'s say instead of individually distributing goods to every shop, we decide that we will give **atmost K goods to each shop**. So basically if number of some **i-th** type of goods is **quantities[i]**, then number of shops that will get goods of this type is : **quantities[i]/K ( Take ceil value in case if quantities[i] is not exactly divisible by K**. Now since no shop can take more than one type of goods, thus we should keep a track of how many shops have been given goods uptil now . This can be done by summing up **quantities[i]/K for all i from 0 to m-1 where m is the size of quantities array**. Now if this **sum > N**, then it means that we are exceeding the number of shops, thus we need to increase the value of **K** in order to reduce **sum**. Similarly is **sum < = N**, then it means that its easily possible to distribute all goods in such a way that every shop gets **atmost K goods of same type**. Now for finding this optimal value of **K** we can apply binary search on **K**. The implementation of above approach is given below :\\n\\nTime Complexity :  **O(Mlog(max(quantities[i])))**, where **M** is the size of quantities array and **max(quantities[i])** is the maximum value inside quantities array as we can in the worst case give atmax the max value number of goods to each shop.\\n\\nSpace Complexity : O(1)\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        ios_base::sync_with_stdio(0);\\n        int m = quantities.size(),start = 1,end = 0,mid = 0,ans = INT_MAX;\\n        for(auto it : quantities){\\n            end = max(end,it);\\n        }\\n        while(start<=end){\\n            mid = start+(end-start)/2;   // We are going to give each person mid amount\\n            long long c = 0;\\n            for(int i = 0; i<m; i++){\\n                c+=ceil((double)quantities[i]/mid);\\n            }\\n            if(c>n){\\n                start = mid+1;\\n            }\\n            else{\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/81e64d25-26ce-4768-9d41-89e4eb719e3c_1661590463.2660778.png)\\n\\n**Do Upvote If Found Helpful !**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        ios_base::sync_with_stdio(0);\\n        int m = quantities.size(),start = 1,end = 0,mid = 0,ans = INT_MAX;\\n        for(auto it : quantities){\\n            end = max(end,it);\\n        }\\n        while(start<=end){\\n            mid = start+(end-start)/2;   // We are going to give each person mid amount\\n            long long c = 0;\\n            for(int i = 0; i<m; i++){\\n                c+=ceil((double)quantities[i]/mid);\\n            }\\n            if(c>n){\\n                start = mid+1;\\n            }\\n            else{\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415690,
                "title": "easy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //given a limit and arr , this function tells us is it possible to divide arr such that max is limit\\n    //eg [6,7,8] limit=5 n=10\\n    // divide 6 as 5+1 greedily 7 as 5+2 and 8=5+3\\n    //so we need 6 slots 6<=10 so it is possible.. why 6 works because we can have 0 product as well\\n    // so distribution will be {5,1,5,2,5,3,0,0,0,0} = 10 elements\\n    int isPossible(vector<int> &arr, int limit, int n){\\n        int temp=0;\\n        for(int i=0;i<arr.size();i++)\\n            temp+=ceil(1.0*arr[i]/limit);\\n        return temp<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n        //simple binary search to find the minimum limit\\n        //high will be the maximum quantity of product\\n        int low=1, high=0;\\n        for(int i=0;i<quantities.size();i++)\\n            if(quantities[i]>high)\\n                high=quantities[i];\\n        \\n        //why i used low<high\\n        //because high=mid and low=mid+1.. so if  i has 0 as low and 1 as high..then\\n        //either 0 will become 1 or 1 will become 0..so at end high=low \\n        //so return any of them\\n        while(low<high){\\n            int mid=(low+high)/2;\\n            if(isPossible(quantities, mid , n))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //given a limit and arr , this function tells us is it possible to divide arr such that max is limit\\n    //eg [6,7,8] limit=5 n=10\\n    // divide 6 as 5+1 greedily 7 as 5+2 and 8=5+3\\n    //so we need 6 slots 6<=10 so it is possible.. why 6 works because we can have 0 product as well\\n    // so distribution will be {5,1,5,2,5,3,0,0,0,0} = 10 elements\\n    int isPossible(vector<int> &arr, int limit, int n){\\n        int temp=0;\\n        for(int i=0;i<arr.size();i++)\\n            temp+=ceil(1.0*arr[i]/limit);\\n        return temp<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n        //simple binary search to find the minimum limit\\n        //high will be the maximum quantity of product\\n        int low=1, high=0;\\n        for(int i=0;i<quantities.size();i++)\\n            if(quantities[i]>high)\\n                high=quantities[i];\\n        \\n        //why i used low<high\\n        //because high=mid and low=mid+1.. so if  i has 0 as low and 1 as high..then\\n        //either 0 will become 1 or 1 will become 0..so at end high=low \\n        //so return any of them\\n        while(low<high){\\n            int mid=(low+high)/2;\\n            if(isPossible(quantities, mid , n))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271767,
                "title": "binary-search-c-solution",
                "content": "```\\n bool isvalid(vector<int>& q,int mid,int n){\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            cnt+=q[i]/mid;\\n            if(q[i]%mid!=0){\\n                cnt++;\\n            }\\n        }\\n       if(cnt>n){\\n           return false;\\n       }\\n        return true;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int m=q.size();\\n        int lo=1;\\n        int hi=*max_element(q.begin(),q.end());\\n     \\n        int ans;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n           \\n            if(isvalid(q,mid,n)==true){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "```\\n bool isvalid(vector<int>& q,int mid,int n){\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            cnt+=q[i]/mid;\\n            if(q[i]%mid!=0){\\n                cnt++;\\n            }\\n        }\\n       if(cnt>n){\\n           return false;\\n       }\\n        return true;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int m=q.size();\\n        int lo=1;\\n        int hi=*max_element(q.begin(),q.end());\\n     \\n        int ans;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n           \\n            if(isvalid(q,mid,n)==true){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2251529,
                "title": "easy-c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ok(int mid,vector<int> &arr,int n){\\n        int ttl=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]%mid!=0){\\n                ttl++;\\n            }\\n            ttl+=arr[i]/mid;\\n        }\\n        return ttl<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int hi=1e9+7,lo=1,ans=0;\\n        while(hi>=lo){\\n            int mid=lo+(hi-lo)/2;\\n            if(ok(mid,quantities,n)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ok(int mid,vector<int> &arr,int n){\\n        int ttl=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]%mid!=0){\\n                ttl++;\\n            }\\n            ttl+=arr[i]/mid;\\n        }\\n        return ttl<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int hi=1e9+7,lo=1,ans=0;\\n        while(hi>=lo){\\n            int mid=lo+(hi-lo)/2;\\n            if(ok(mid,quantities,n)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245487,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int start = 1;\\n        int end = 0;\\n        for(int num : quantities){\\n            if(num>end){\\n                end = num; // maximum element is our endpoint\\n            }\\n        }\\n        while(start<end){\\n            int mid = start +(end-start)/2; //calculation of mid\\n            \\n            // checking if mid is our answer\\n            // a is the no of store required if \"mid\" products are distributed\\n            int a =0;\\n            for(int num : quantities){\\n                a += num/mid;\\n                if(num%mid>0){\\n                    a++;\\n                }\\n            }\\n            \\n            // we got more stores than required.\\n            if(a>n){\\n                start = mid+1;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n        \\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int start = 1;\\n        int end = 0;\\n        for(int num : quantities){\\n            if(num>end){\\n                end = num; // maximum element is our endpoint\\n            }\\n        }\\n        while(start<end){\\n            int mid = start +(end-start)/2; //calculation of mid\\n            \\n            // checking if mid is our answer\\n            // a is the no of store required if \"mid\" products are distributed\\n            int a =0;\\n            for(int num : quantities){\\n                a += num/mid;\\n                if(num%mid>0){\\n                    a++;\\n                }\\n            }\\n            \\n            // we got more stores than required.\\n            if(a>n){\\n                start = mid+1;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n        \\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151105,
                "title": "easy-binary-search-in-java",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max = 0;\\n        for(int i=0; i<quantities.length; i++){\\n            max = Math.max(max, quantities[i]);\\n        }\\n        int start = 1;\\n        int end = max;\\n        int ans = 0;\\n        while(start<=end){\\n            int mid = start +(end-start)/2 ;\\n            if(isPossible(n, quantities, mid)){\\n                ans = mid;\\n                end = mid-1;\\n                }\\n            else{\\n                start = mid+1;\\n            }            \\n        }\\n        return ans;\\n    }\\npublic boolean isPossible(int n, int[] quantities, int max_allowed_distri){\\n    int shops=0;\\n    for(int i=0; i<quantities.length; i++){\\n        shops += quantities[i]/max_allowed_distri; //if the max_allowed_distri is 4 and first shop has 8 items of a type then we can fill 8/4 = 2 shops with it\\n        if(quantities[i]%max_allowed_distri!=0){\\n            shops++;\\n        }\\n    }\\n    return shops<=n; \\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max = 0;\\n        for(int i=0; i<quantities.length; i++){\\n            max = Math.max(max, quantities[i]);\\n        }\\n        int start = 1;\\n        int end = max;\\n        int ans = 0;\\n        while(start<=end){\\n            int mid = start +(end-start)/2 ;\\n            if(isPossible(n, quantities, mid)){\\n                ans = mid;\\n                end = mid-1;\\n                }\\n            else{\\n                start = mid+1;\\n            }            \\n        }\\n        return ans;\\n    }\\npublic boolean isPossible(int n, int[] quantities, int max_allowed_distri){\\n    int shops=0;\\n    for(int i=0; i<quantities.length; i++){\\n        shops += quantities[i]/max_allowed_distri; //if the max_allowed_distri is 4 and first shop has 8 items of a type then we can fill 8/4 = 2 shops with it\\n        if(quantities[i]%max_allowed_distri!=0){\\n            shops++;\\n        }\\n    }\\n    return shops<=n; \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120954,
                "title": "runtime-238-ms-faster-than-75-18-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n,vector<int>& v, float mid){\\n        for(int i =0;i<v.size();i++){\\n            n = n-ceil(v[i]/mid);\\n            if(n<0)return false;\\n        }\\n        return true;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int s =1;\\n        int e = 1e6;\\n        int res = -1;\\n        while(s<=e){\\n            float mid = (s+e)/2;\\n            if(isValid(n,quantities,mid)){\\n                res = mid;\\n                e = mid-1;\\n            }\\n            else    s = mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n,vector<int>& v, float mid){\\n        for(int i =0;i<v.size();i++){\\n            n = n-ceil(v[i]/mid);\\n            if(n<0)return false;\\n        }\\n        return true;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int s =1;\\n        int e = 1e6;\\n        int res = -1;\\n        while(s<=e){\\n            float mid = (s+e)/2;\\n            if(isValid(n,quantities,mid)){\\n                res = mid;\\n                e = mid-1;\\n            }\\n            else    s = mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076001,
                "title": "simple-binary-search-approach-with-explanation",
                "content": "**do binary search** from **start=1 to end=max(all quantities)**.\\n### mid=(start+end)/2;\\n**check** when max amount of product to be given is mid -> can we distribute in n number of shop\\n##### case i) number of shop required is more than n -> increasae mid by increasing start.\\n\\t\\t\\tso that if we distribute more item from products we will need less shop\\n\\t\\t\\t[start=mid+1]\\n#### case ii) number of shop required is less than n -> decrease mid\\n\\t\\t\\tso,\\n\\t\\t\\t[end=mid]\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int start=1,end=0;\\n        for(auto &k: quantities) end=max(end,k);    //if prod with max quan. is taken then always possible\\n        \\n        while(start<end){\\n            int mid=(start+end)>>1;\\n            \\n            int cnt=0;  //number of shop required to distribute all products.\\n            for(auto &k: quantities) cnt+=(k+mid-1)/mid;    // if mid=5, 12 item can be given in ceil(12,5)=3; {5,5,2}\\n            //since one shop can take products of only one type.\\n            \\n            if(cnt>n){  //more shop required . thus increase mid.\\n                start=mid+1;\\n            }\\n            else end=mid;\\n        }\\n        \\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int start=1,end=0;\\n        for(auto &k: quantities) end=max(end,k);    //if prod with max quan. is taken then always possible\\n        \\n        while(start<end){\\n            int mid=(start+end)>>1;\\n            \\n            int cnt=0;  //number of shop required to distribute all products.\\n            for(auto &k: quantities) cnt+=(k+mid-1)/mid;    // if mid=5, 12 item can be given in ceil(12,5)=3; {5,5,2}\\n            //since one shop can take products of only one type.\\n            \\n            if(cnt>n){  //more shop required . thus increase mid.\\n                start=mid+1;\\n            }\\n            else end=mid;\\n        }\\n        \\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977012,
                "title": "python-easy-to-understand-binary-search-approach",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach:\\n    The problem can be tackled using binary search\\n    \\n    min_product = 1\\n    max_product = max(quantities)\\n    we can apply binary search to get the optimal value of products\\n    \\n    if for current product value, after distribuiton, we are still left with products,\\n    then, we\\'ll have to increase the product that each store is getting\\n    \\n    if for current product value, after distribution, we are not left with any product\\n    for some store to receive, we will have to decrease the product that each store is\\n    getting\\n    \"\"\"\\n    def check_fulfilment(self, quantities, n, product_per_store):\\n        stores = 0\\n        for quantity in quantities:\\n            stores+=math.ceil(quantity/product_per_store)\\n        if stores>n:\\n            return True\\n        return False\\n        \\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        min_product = 1\\n        max_product = max(quantities)\\n        while min_product <= max_product:\\n            mid = (min_product + max_product) // 2\\n            status = self.check_fulfilment(quantities, n, mid)\\n            if status:\\n                # we can distribute mid products to each store, try reducing the min_product\\n                min_product = mid + 1\\n            else:\\n                max_product = mid - 1\\n        return min_product\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach:\\n    The problem can be tackled using binary search\\n    \\n    min_product = 1\\n    max_product = max(quantities)\\n    we can apply binary search to get the optimal value of products\\n    \\n    if for current product value, after distribuiton, we are still left with products,\\n    then, we\\'ll have to increase the product that each store is getting\\n    \\n    if for current product value, after distribution, we are not left with any product\\n    for some store to receive, we will have to decrease the product that each store is\\n    getting\\n    \"\"\"\\n    def check_fulfilment(self, quantities, n, product_per_store):\\n        stores = 0\\n        for quantity in quantities:\\n            stores+=math.ceil(quantity/product_per_store)\\n        if stores>n:\\n            return True\\n        return False\\n        \\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        min_product = 1\\n        max_product = max(quantities)\\n        while min_product <= max_product:\\n            mid = (min_product + max_product) // 2\\n            status = self.check_fulfilment(quantities, n, mid)\\n            if status:\\n                # we can distribute mid products to each store, try reducing the min_product\\n                min_product = mid + 1\\n            else:\\n                max_product = mid - 1\\n        return min_product\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976302,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        int lo = 1;\\n        int hi = (int)1e5;\\n        \\n        int ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = (lo + hi)/2;\\n            \\n            if(isItPossible(mid, quantities, n)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isItPossible(int x, int[] quantities, int n){\\n        \\n        // isItPossible to distribute <= x products to each of the n shops\\n        for(int i=0; i<quantities.length; i++){\\n            \\n            int products = quantities[i];\\n            \\n            n -= Math.ceil(products/(x*1.0));\\n            \\n            if(n<0)     // means it requires more than n shops to distribute all products\\n                return false; \\n        }\\n        \\n        return true; // distributed all products to exactly n shops\\n    }\\n}\\n```\\n\\n***Consider upvote if usefull!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        int lo = 1;\\n        int hi = (int)1e5;\\n        \\n        int ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = (lo + hi)/2;\\n            \\n            if(isItPossible(mid, quantities, n)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isItPossible(int x, int[] quantities, int n){\\n        \\n        // isItPossible to distribute <= x products to each of the n shops\\n        for(int i=0; i<quantities.length; i++){\\n            \\n            int products = quantities[i];\\n            \\n            n -= Math.ceil(products/(x*1.0));\\n            \\n            if(n<0)     // means it requires more than n shops to distribute all products\\n                return false; \\n        }\\n        \\n        return true; // distributed all products to exactly n shops\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949681,
                "title": "c-binary-search-faster-than-90-27-of-c-online-submissions",
                "content": "\\tpublic:\\n\\n\\t\\tbool isValid(long long mid, vector<int>&quantities, int n){\\n        \\n        long long shop = 0;\\n        long long remian = 0;\\n        \\n        for(auto it:quantities){\\n            shop += it/mid;\\n            if(it%mid!=0)\\n                shop++;\\n        }        \\n\\n        if(shop <= n)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long low = 1;\\n        long long high = 0;\\n        long long ans = INT_MAX;\\n        \\n        for(auto it:quantities){\\n            if(high<it)\\n                high = it;\\n        }\\n        \\n        while(low<=high){\\n            \\n            long long mid = low + (high - low)/2;\\n            if(isValid(mid, quantities, n)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n            \\n        }\\n    \\n        return ans;    \\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "\\tpublic:\\n\\n\\t\\tbool isValid(long long mid, vector<int>&quantities, int n){\\n        \\n        long long shop = 0;\\n        long long remian = 0;\\n        \\n        for(auto it:quantities){\\n            shop += it/mid;\\n            if(it%mid!=0)\\n                shop++;\\n        }        \\n\\n        if(shop <= n)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long low = 1;\\n        long long high = 0;\\n        long long ans = INT_MAX;\\n        \\n        for(auto it:quantities){\\n            if(high<it)\\n                high = it;\\n        }\\n        \\n        while(low<=high){\\n            \\n            long long mid = low + (high - low)/2;\\n            if(isValid(mid, quantities, n)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n            \\n        }\\n    \\n        return ans;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1804552,
                "title": "binary-search-explained",
                "content": "It is a nice little problem on the modified binary search, \\nHere we are trying to find the minimum - maximum no of products that can be delivered to each shop. \\n\\n```\\nint minimizedMaximum(int n, vector<int>& q) {\\n        int lo = 1, hi = 100000;\\n        while(hi >= lo) {\\n            int m = lo + (hi-lo)/2;\\n            int cur = 0;\\n            for(auto x : q) \\n                cur += ceil(1.0*x/m);  //cur = number of shops needed to purchase all the products\\n            if(cur > n) \\n                lo = m+1;  // selected value is too small to complete all the products in the given number of shops. \\n            else \\n                hi = m-1;   //to minimize the value\\n        }\\n        return lo;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nint minimizedMaximum(int n, vector<int>& q) {\\n        int lo = 1, hi = 100000;\\n        while(hi >= lo) {\\n            int m = lo + (hi-lo)/2;\\n            int cur = 0;\\n            for(auto x : q) \\n                cur += ceil(1.0*x/m);  //cur = number of shops needed to purchase all the products\\n            if(cur > n) \\n                lo = m+1;  // selected value is too small to complete all the products in the given number of shops. \\n            else \\n                hi = m-1;   //to minimize the value\\n        }\\n        return lo;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736193,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int l = 1, r = *max_element(quantities.begin(),quantities.end());\\n        while( l <= r )\\n        {\\n            int mid = l+(r-l)/2;\\n            if ( valid(quantities,mid,n) )\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return l;\\n    }\\nprivate:\\n    bool valid(vector<int> const& quantities, int max_val, int n)\\n    {\\n        int cnt = 0;\\n        for ( auto q : quantities )\\n            cnt += (q+max_val-1) / max_val;\\n        return cnt <= n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int l = 1, r = *max_element(quantities.begin(),quantities.end());\\n        while( l <= r )\\n        {\\n            int mid = l+(r-l)/2;\\n            if ( valid(quantities,mid,n) )\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return l;\\n    }\\nprivate:\\n    bool valid(vector<int> const& quantities, int max_val, int n)\\n    {\\n        int cnt = 0;\\n        for ( auto q : quantities )\\n            cnt += (q+max_val-1) / max_val;\\n        return cnt <= n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705639,
                "title": "binary-search-solution-python",
                "content": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        # step-1 define boolean function\\n        def distribute(x):\\n            \"\"\"\\n            if the maximal number of products is x,\\n            can we distribute all the quantities?\\n            \"\"\"\\n            needed = 0\\n            for qt in quantities:\\n                q, r = divmod(qt, x)\\n                needed += q\\n                if r != 0:\\n                    needed += 1\\n                if needed > n:\\n                    return False\\n            return True\\n        \\n        # step-2 binary search\\n        # find min x s.t distribue(x) is true\\n        low, high = 1, max(quantities)\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if distribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        # step-1 define boolean function\\n        def distribute(x):\\n            \"\"\"\\n            if the maximal number of products is x,\\n            can we distribute all the quantities?\\n            \"\"\"\\n            needed = 0\\n            for qt in quantities:\\n                q, r = divmod(qt, x)\\n                needed += q\\n                if r != 0:\\n                    needed += 1\\n                if needed > n:\\n                    return False\\n            return True\\n        \\n        # step-2 binary search\\n        # find min x s.t distribue(x) is true\\n        low, high = 1, max(quantities)\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if distribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704009,
                "title": "c-binary-search-beginner-friendly",
                "content": "Upvote if you like the solution approach Happy Coding :)\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quant) {\\n        int m=quant.size();\\n\\t\\t\\n\\t\\t// Sort the given array to access maximum element.\\n        sort(quant.begin(),quant.end());\\n        int max=quant[m-1];\\n        \\n\\t\\t// Apply binary search from 1 to max element so, we can find the given even distribution for the retail stores.\\n\\t\\tint start=1;\\n        int end=max;\\n        while(start<end){\\n            int mid=(start+end)/2;\\n            int cntr=0;\\n            for(int i=0;i<m;i++)\\n                cntr+=quant[i]/mid+(quant[i]%mid!=0); // Calculate the distributions made by each and every binary search value\\n            if(cntr<=n){\\n                end=mid;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```\\n\\nSolve this question also forn easy understanding :: \\nKoko Eating Banana ->> https://leetcode.com/problems/koko-eating-bananas/",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quant) {\\n        int m=quant.size();\\n\\t\\t\\n\\t\\t// Sort the given array to access maximum element.\\n        sort(quant.begin(),quant.end());\\n        int max=quant[m-1];\\n        \\n\\t\\t// Apply binary search from 1 to max element so, we can find the given even distribution for the retail stores.\\n\\t\\tint start=1;\\n        int end=max;\\n        while(start<end){\\n            int mid=(start+end)/2;\\n            int cntr=0;\\n            for(int i=0;i<m;i++)\\n                cntr+=quant[i]/mid+(quant[i]%mid!=0); // Calculate the distributions made by each and every binary search value\\n            if(cntr<=n){\\n                end=mid;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682702,
                "title": "2064-minimized-maximum-of-products-distributed-to-any-store-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int l = 1, r = 100000, ans = -1;\\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n            int stores = 0;\\n            for(auto& i : q) stores += ceil(1.0 * i / mid);\\n            if(stores <= n){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int l = 1, r = 100000, ans = -1;\\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n            int stores = 0;\\n            for(auto& i : q) stores += ceil(1.0 * i / mid);\\n            if(stores <= n){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626596,
                "title": "binary-search-check-is-it-possible-to-distribute-all-the-element",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findans(int mid,int n,vector<int>&quantities,int m){\\n        int no=0;\\n        for(int i=0;i<m;i++){\\n            if(quantities[i]%mid==0){\\n\\t\\t\\t//if a no is divisble then it can be divided into exact n person\\n                no=no+(quantities[i]/mid);\\n            }else{\\n\\t\\t\\t// if it is not divisible then last person get less no product but it get more then 0\\n                 no=no+(quantities[i]/mid)+1;\\n            }\\n            if(no>n){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long ans=0,m=quantities.size();\\n        int l=1,r=0;\\n        for(int i=0;i<m;i++){\\n            r=max(r,quantities[i]);\\n        }\\n        while(l<=r){\\n            long mid=(r+l)/2;\\n\\t\\t\\t//this function check if we  give max product=mid then all the product is distrunuted or not\\n            if(findans(mid,n,quantities,m)){\\n                ans=mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findans(int mid,int n,vector<int>&quantities,int m){\\n        int no=0;\\n        for(int i=0;i<m;i++){\\n            if(quantities[i]%mid==0){\\n\\t\\t\\t//if a no is divisble then it can be divided into exact n person\\n                no=no+(quantities[i]/mid);\\n            }else{\\n\\t\\t\\t// if it is not divisible then last person get less no product but it get more then 0\\n                 no=no+(quantities[i]/mid)+1;\\n            }\\n            if(no>n){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long ans=0,m=quantities.size();\\n        int l=1,r=0;\\n        for(int i=0;i<m;i++){\\n            r=max(r,quantities[i]);\\n        }\\n        while(l<=r){\\n            long mid=(r+l)/2;\\n\\t\\t\\t//this function check if we  give max product=mid then all the product is distrunuted or not\\n            if(findans(mid,n,quantities,m)){\\n                ans=mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590140,
                "title": "simple-binary-search-based-solution-c-clean-code",
                "content": "# Code: \\n```\\nclass Solution {\\n    int distribute(vector<int>& quantities, int val) {\\n        int count = 0;\\n        \\n        for(auto& quantity : quantities) {\\n            count += (quantity / val) + (quantity % val > 0);\\n        }\\n\\n        return count;\\n    }\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n        int lo = 1, hi = *max_element(quantities.begin(), quantities.end());\\n        \\n        int ans = hi;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + ((hi-lo) >> 1);\\n\\n            if(distribute(quantities, mid) <= n) {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity :** \\n\\n* Time : `O(N log M)`\\n\\t* *N* : size of `quantities` array, and we traverse over it in `distribute()`\\n\\t* *M* : max `quantity` in array , which is also search space i.e `[1 .. max(quantities)]`\\n\\n* Space : `O(1)`",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int distribute(vector<int>& quantities, int val) {\\n        int count = 0;\\n        \\n        for(auto& quantity : quantities) {\\n            count += (quantity / val) + (quantity % val > 0);\\n        }\\n\\n        return count;\\n    }\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n        int lo = 1, hi = *max_element(quantities.begin(), quantities.end());\\n        \\n        int ans = hi;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + ((hi-lo) >> 1);\\n\\n            if(distribute(quantities, mid) <= n) {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573953,
                "title": "c-binarysearch-simlar-to-allocate-minimum-number-pages",
                "content": "class Solution {\\npublic:\\n    \\n    bool minimumPossibleProduct(int n, vector<int>& q, int mid)\\n    {\\n        int stores = 1;\\n        \\n        int sum =0;\\n        for(int i=0; i<q.size();i++)\\n        {\\n            sum += (q[i] - 1)/mid + 1;\\n              \\n            if(sum>n)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& q) {\\n        \\n        int l = 1;\\n        \\n        int hi = INT_MIN;\\n        \\n        for(int i=0; i<q.size(); i++)\\n        {\\n            hi = max(hi, q[i]);\\n        }\\n        \\n        int result = 0;\\n        \\n        while(l<=hi)\\n        {\\n            int mid = l + (hi -l)/2;           \\n            \\n            if(minimumPossibleProduct(n, q, mid))\\n            {\\n                result = mid;\\n                hi = mid -1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }    \\n        }\\n        \\n        return result;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool minimumPossibleProduct(int n, vector<int>& q, int mid)\\n    {\\n        int stores = 1;\\n        \\n        int sum =0;\\n        for(int i=0; i<q.size();i++)\\n        {\\n            sum += (q[i] - 1)/mid + 1;\\n              \\n            if(sum>n)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1565368,
                "title": "c-2064-minimized-maximum-of-products-distributed-to-any-store",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int lo = 1, hi = *max_element(quantities.begin(), quantities.end()); \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2, cnt = 0; \\n            for (auto& qty : quantities) cnt += ceil((double) qty / mid); \\n            if (cnt <= n) hi = mid; \\n            else lo = mid + 1; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int lo = 1, hi = *max_element(quantities.begin(), quantities.end()); \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2, cnt = 0; \\n            for (auto& qty : quantities) cnt += ceil((double) qty / mid); \\n            if (cnt <= n) hi = mid; \\n            else lo = mid + 1; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563882,
                "title": "python-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = max(quantities)\\n\\t\\t\\twhile l < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif sum((quantity + m - 1) // m for quantity in quantities) > n:\\n\\t\\t\\t\\t\\tl = m + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = m\\n\\t\\t\\treturn l",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = max(quantities)\\n\\t\\t\\twhile l < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif sum((quantity + m - 1) // m for quantity in quantities) > n:\\n\\t\\t\\t\\t\\tl = m + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = m\\n\\t\\t\\treturn l",
                "codeTag": "Java"
            },
            {
                "id": 1563869,
                "title": "java-o-mlogn-m-quantities",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int sum = 0;\\n        int max = 0;\\n        for(int q : quantities){\\n            sum += q;\\n            max = Math.max(max, q);\\n        }\\n        int min = sum/n;\\n        int match = max;\\n        if(min == 0){\\n            return 1;\\n        }\\n        while(min < max){\\n            int mid = (min + max) / 2;\\n            if(match(mid, quantities, n) >= 0){\\n                match = mid;\\n                max = mid;\\n            }else {\\n                min = mid+1;\\n            }\\n        }\\n        \\n        return match;\\n    }\\n    \\n    private int match(int mid, int[] quantities, int n){\\n        for(int q : quantities){\\n            n -= q/mid;\\n            if(q%mid > 0)\\n                n--;\\n        }\\n        return n;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int sum = 0;\\n        int max = 0;\\n        for(int q : quantities){\\n            sum += q;\\n            max = Math.max(max, q);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1563847,
                "title": "binary-search-explained",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n    /*\\n    Approach: The answer will be in the range from 1 to maxProductQuqntity.\\n    If an answer \\'i\\' is not possible then i-1, i-2, i-3.....1 are also not possible\\n    If an answer \\'i\\' is possible then i+1, i+2, i+3.....maxProductQuqntity are also possible\\n    So we can use binary search for the range 1 to maxProductQuqntity;\\n    */\\n    let maxQuantity=0;\\n    if(quantities.length===1){//If there is only 1 type of product then just simply distribute this to all shops\\n        return Math.ceil(quantities[0]/n);\\n    }\\n    quantities.sort(function(a,b){return b-a});\\n\\n    maxQuantity = quantities[0];\\n    let left=1,right=maxQuantity,mid,ans;\\n    while(left<=right){\\n        mid = left + Math.floor((right-left)/2);\\n        if(isPossible(mid)){\\n            ans = mid;\\n            right = mid-1;\\n        }else{\\n            left = mid+1;\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    function isPossible(ans){\\n        let  remainingShops = n-quantities.length; \\n        for(let i=0;i<quantities.length;i++){\\n            if(quantities[i]<=ans){\\n                 return true;\\n            }else{\\n                let newShopsCountForThisProduct = Math.ceil(quantities[i]/ans);\\n                remainingShops -=(newShopsCountForThisProduct-1);\\n                if(remainingShops<0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n    /*\\n    Approach: The answer will be in the range from 1 to maxProductQuqntity.\\n    If an answer \\'i\\' is not possible then i-1, i-2, i-3.....1 are also not possible\\n    If an answer \\'i\\' is possible then i+1, i+2, i+3.....maxProductQuqntity are also possible\\n    So we can use binary search for the range 1 to maxProductQuqntity;\\n    */\\n    let maxQuantity=0;\\n    if(quantities.length===1){//If there is only 1 type of product then just simply distribute this to all shops\\n        return Math.ceil(quantities[0]/n);\\n    }\\n    quantities.sort(function(a,b){return b-a});\\n\\n    maxQuantity = quantities[0];\\n    let left=1,right=maxQuantity,mid,ans;\\n    while(left<=right){\\n        mid = left + Math.floor((right-left)/2);\\n        if(isPossible(mid)){\\n            ans = mid;\\n            right = mid-1;\\n        }else{\\n            left = mid+1;\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    function isPossible(ans){\\n        let  remainingShops = n-quantities.length; \\n        for(let i=0;i<quantities.length;i++){\\n            if(quantities[i]<=ans){\\n                 return true;\\n            }else{\\n                let newShopsCountForThisProduct = Math.ceil(quantities[i]/ans);\\n                remainingShops -=(newShopsCountForThisProduct-1);\\n                if(remainingShops<0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563819,
                "title": "c-binary-search-and-very-similar-problems-1482-1760-1552-1954-1011-410",
                "content": "\\nCode in this contest:\\n```\\nint minimizedMaximum(int n, vector<int>& quant) {\\n        int lo = 1, hi = *max_element(quant.begin(), quant.end()), ans = 0;    \\n        while (lo < hi) {\\n            int m = lo + (hi - lo) / 2;\\n            int cnt = 0;\\n            for (auto &q : quant) {\\n                cnt += (q + m - 1) / m;\\n            }\\n            if (cnt > n) {\\n                lo = m + 1;\\n            } else {\\n                hi = m;\\n            }\\n        }\\n        return lo;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimizedMaximum(int n, vector<int>& quant) {\\n        int lo = 1, hi = *max_element(quant.begin(), quant.end()), ans = 0;    \\n        while (lo < hi) {\\n            int m = lo + (hi - lo) / 2;\\n            int cnt = 0;\\n            for (auto &q : quant) {\\n                cnt += (q + m - 1) / m;\\n            }\\n            if (cnt > n) {\\n                lo = m + 1;\\n            } else {\\n                hi = m;\\n            }\\n        }\\n        return lo;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563801,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int lo=0,hi = *max_element(q.begin(),q.end());\\n        sort(q.begin(),q.end());\\n        while(lo<hi)\\n        {\\n            int md = lo+(hi-lo)/2;\\n            if(isPossible(n,q,md))\\n                hi = md;\\n            else\\n                lo=md+1;\\n        }\\n        \\n        return hi;\\n    }\\n    \\n    bool isPossible(int n,vector<int>& q,int md)\\n    {\\n        if(md==0)return false;\\n        for(int i=0;i<q.size();i++){\\n            int am = q[i];\\n            int d = am/md;\\n            n -= (d+ (am%md != 0));\\n            if(n<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int lo=0,hi = *max_element(q.begin(),q.end());\\n        sort(q.begin(),q.end());\\n        while(lo<hi)\\n        {\\n            int md = lo+(hi-lo)/2;\\n            if(isPossible(n,q,md))\\n                hi = md;\\n            else\\n                lo=md+1;\\n        }\\n        \\n        return hi;\\n    }\\n    \\n    bool isPossible(int n,vector<int>& q,int md)\\n    {\\n        if(md==0)return false;\\n        for(int i=0;i<q.size();i++){\\n            int am = q[i];\\n            int d = am/md;\\n            n -= (d+ (am%md != 0));\\n            if(n<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563747,
                "title": "5-line-binary-search-solution",
                "content": "```\\ndef minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n        l, r  = 1, sum(quantities)\\n        \\n        while r > l:\\n            mid = (l+r)//2\\n            if sum([ceil(quantities[i]/val) for i in range(len(quantities))]) <= n:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l",
                "solutionTags": [],
                "code": "```\\ndef minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n        l, r  = 1, sum(quantities)\\n        \\n        while r > l:\\n            mid = (l+r)//2\\n            if sum([ceil(quantities[i]/val) for i in range(len(quantities))]) <= n:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l",
                "codeTag": "Python3"
            },
            {
                "id": 1563726,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        def shop_needed(num):\\n            return sum(math.ceil(i/num) for i in quantities)\\n        \\n        low = math.ceil(sum(quantities) / n)\\n        high = max(quantities)\\n        \\n        while low <= high:\\n            mid = (low + high) // 2\\n            \\n            if shop_needed(mid) > n: \\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n            \\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        def shop_needed(num):\\n            return sum(math.ceil(i/num) for i in quantities)\\n        \\n        low = math.ceil(sum(quantities) / n)\\n        high = max(quantities)\\n        \\n        while low <= high:\\n            mid = (low + high) // 2\\n            \\n            if shop_needed(mid) > n: \\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n            \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063627,
                "title": "binary-search-solution-java",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) \\n    {\\n        int left=1;\\n        int right=Arrays.stream(quantities).max().getAsInt();\\n        \\n        while(left<right)\\n        {\\n            int mid=left+(right-left)/2;\\n            \\n            if(possible(n,mid,quantities)==false)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean possible(int n, int mid, int[] quantities)\\n    {\\n        int count=0;\\n        \\n        for(int i:quantities)\\n        {\\n            count+=(i+mid-1)/mid;\\n            \\n            if(count>n)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) \\n    {\\n        int left=1;\\n        int right=Arrays.stream(quantities).max().getAsInt();\\n        \\n        while(left<right)\\n        {\\n            int mid=left+(right-left)/2;\\n            \\n            if(possible(n,mid,quantities)==false)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean possible(int n, int mid, int[] quantities)\\n    {\\n        int count=0;\\n        \\n        for(int i:quantities)\\n        {\\n            count+=(i+mid-1)/mid;\\n            \\n            if(count>n)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063625,
                "title": "binary-search-solution-java",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) \\n    {\\n        int left=1;\\n        int right=Arrays.stream(quantities).max().getAsInt();\\n        \\n        while(left<right)\\n        {\\n            int mid=left+(right-left)/2;\\n            \\n            if(possible(n,mid,quantities)==false)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean possible(int n, int mid, int[] quantities)\\n    {\\n        int count=0;\\n        \\n        for(int i:quantities)\\n        {\\n            count+=(i+mid-1)/mid;\\n            \\n            if(count>n)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) \\n    {\\n        int left=1;\\n        int right=Arrays.stream(quantities).max().getAsInt();\\n        \\n        while(left<right)\\n        {\\n            int mid=left+(right-left)/2;\\n            \\n            if(possible(n,mid,quantities)==false)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean possible(int n, int mid, int[] quantities)\\n    {\\n        int count=0;\\n        \\n        for(int i:quantities)\\n        {\\n            count+=(i+mid-1)/mid;\\n            \\n            if(count>n)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032764,
                "title": "c-binarysearch-approach",
                "content": "# Intuition\\nTo solve the problem we need to understand how many shops is required to distribute all the quantities available. For this we are going to choose quantities per shop we are planning to ditribute. In other words we selct any amount of goods we are going to distribute and see how many shops we need so all the provided quantities will be ditributed. If the number of shops will exceed the given number shops it means that number of goods per shops is too small and we need to choose bigger value, otherwise we need to choose smaller.\\n\\n# Approach\\nBinary search approach where `left` iterator is the smallest possible amount of goods to distribute and `right` iterator is the biggest possible amount of goods to distribute. As smallest we could choose `0` and as biggest (i.e. `right`) we could choose the biggest value in `quantities` vector. \\n\\n# Complexity\\n- Time complexity:\\nO(N log 10^5), where N == len(quantities)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countShopsWithProduct(const vector<int>& quantities, int productsPerShop) {\\n        int cnt = 0;\\n        std::for_each(std::begin(quantities), std::end(quantities), [&cnt, productsPerShop](int quantity){\\n            cnt += std::ceil(static_cast<double>(quantity) / productsPerShop);\\n        });\\n\\n        return cnt;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int left = 0;\\n        int right = *std::max_element(std::begin(quantities), std::end(quantities));\\n        while (right - left > 1) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (countShopsWithProduct(quantities, mid) > n) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countShopsWithProduct(const vector<int>& quantities, int productsPerShop) {\\n        int cnt = 0;\\n        std::for_each(std::begin(quantities), std::end(quantities), [&cnt, productsPerShop](int quantity){\\n            cnt += std::ceil(static_cast<double>(quantity) / productsPerShop);\\n        });\\n\\n        return cnt;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int left = 0;\\n        int right = *std::max_element(std::begin(quantities), std::end(quantities));\\n        while (right - left > 1) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (countShopsWithProduct(quantities, mid) > n) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021546,
                "title": "binary-search-same-as-1283",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, nums: List[int]) -> int:\\n        def possible(mid):\\n            return sum(ceil(x/mid) for x in nums) > n\\n\\n        l, r = 1, max(nums)\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if possible(mid):\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, nums: List[int]) -> int:\\n        def possible(mid):\\n            return sum(ceil(x/mid) for x in nums) > n\\n\\n        l, r = 1, max(nums)\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if possible(mid):\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014423,
                "title": "c-simple-binary-search-approach",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(int limit,int n,vector<int> quantities){\\n        int maxi=limit;\\n        int m=quantities.size();\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(quantities[j]>limit){\\n                quantities[j]-=limit;\\n                i++;\\n            }else{\\n                i++;\\n                j++;\\n                \\n            }\\n            \\n        }\\n        if(i<=n && j==m){\\n            \\n\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low,high;\\n        int maxi=0,ans=-1;\\n        for(int i=0;i<quantities.size();i++){\\n            maxi=max(maxi,quantities[i]);\\n        }\\n        low=1,high=maxi;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(possible(mid,n,quantities)){\\n                \\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(int limit,int n,vector<int> quantities){\\n        int maxi=limit;\\n        int m=quantities.size();\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(quantities[j]>limit){\\n                quantities[j]-=limit;\\n                i++;\\n            }else{\\n                i++;\\n                j++;\\n                \\n            }\\n            \\n        }\\n        if(i<=n && j==m){\\n            \\n\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low,high;\\n        int maxi=0,ans=-1;\\n        for(int i=0;i<quantities.size();i++){\\n            maxi=max(maxi,quantities[i]);\\n        }\\n        low=1,high=maxi;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(possible(mid,n,quantities)){\\n                \\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999154,
                "title": "beats-99-17-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int n, vector<int>&v, int mid) {\\n        int store=0, k=0;\\n        for(int i: v) {\\n            int a = i/mid;\\n            int b = i%mid;\\n            if(b==0) {\\n                store +=a;\\n            }\\n            else {\\n                store +=a+1;\\n            }\\n        }\\n        if(store<=n)\\n            return true;\\n        \\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int s=1, e=*max_element(quantities.begin(),quantities.end());\\n        int ans=0, mid = s+(e-s)/2;\\n\\n        while(s<=e) {\\n            if(isValid(n, quantities, mid)) {\\n                e = mid-1;\\n                ans = mid;\\n            }\\n            else {\\n                s = mid+1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n, vector<int>&v, int mid) {\\n        int store=0, k=0;\\n        for(int i: v) {\\n            int a = i/mid;\\n            int b = i%mid;\\n            if(b==0) {\\n                store +=a;\\n            }\\n            else {\\n                store +=a+1;\\n            }\\n        }\\n        if(store<=n)\\n            return true;\\n        \\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int s=1, e=*max_element(quantities.begin(),quantities.end());\\n        int ans=0, mid = s+(e-s)/2;\\n\\n        while(s<=e) {\\n            if(isValid(n, quantities, mid)) {\\n                e = mid-1;\\n                ans = mid;\\n            }\\n            else {\\n                s = mid+1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991907,
                "title": "binary-search-intuitive-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // max <= m\\n    int f(int m,int n, vector<int>&a){\\n        int cnt=0;\\n        for(auto i:a){\\n            cnt+=ceil(double(i)/double(m));\\n        }\\n        return cnt<=n;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int l=1,r=1e5,ans=0;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(f(m,n,a)){\\n                r=m-1;\\n                ans=m;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // max <= m\\n    int f(int m,int n, vector<int>&a){\\n        int cnt=0;\\n        for(auto i:a){\\n            cnt+=ceil(double(i)/double(m));\\n        }\\n        return cnt<=n;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int l=1,r=1e5,ans=0;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(f(m,n,a)){\\n                r=m-1;\\n                ans=m;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986297,
                "title": "binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N), it is doable in O(1) as well.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        quantities = Counter(quantities)\\n        def feasible(thresh):\\n            return sum([ceil(q/thresh) * c for q, c in quantities.items()]) <= n\\n        \\n        l, r = 1, max(quantities)\\n        while l < r:\\n            m = l + (r-l) // 2\\n            if feasible(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        quantities = Counter(quantities)\\n        def feasible(thresh):\\n            return sum([ceil(q/thresh) * c for q, c in quantities.items()]) <= n\\n        \\n        l, r = 1, max(quantities)\\n        while l < r:\\n            m = l + (r-l) // 2\\n            if feasible(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970067,
                "title": "easy-beginner-based-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet assume any number m be the products given to the different stores.Here using Binary Search we find best possible m for the n stores such that you can minimize the maximum number of products that are given to any store.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) \\n    {\\n        int p=quantities.size();\\n        int s=1,e=1e9,ans=INT_MAX;\\n        while(s<=e)\\n        {\\n            int m=(s+e)/2;\\n            int x=0;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(quantities[i]%m==0)\\n                    x+=(quantities[i]/m);\\n                else\\n                    x+=(quantities[i]/m)+1;\\n            }\\n            if(x<=n)\\n            {\\n                ans=min(ans,m);\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) \\n    {\\n        int p=quantities.size();\\n        int s=1,e=1e9,ans=INT_MAX;\\n        while(s<=e)\\n        {\\n            int m=(s+e)/2;\\n            int x=0;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(quantities[i]%m==0)\\n                    x+=(quantities[i]/m);\\n                else\\n                    x+=(quantities[i]/m)+1;\\n            }\\n            if(x<=n)\\n            {\\n                ans=min(ans,m);\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958262,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n       let max = -1;\\n    \\n    // Find the maximum value in the quantities array\\n    max = Math.max(...quantities);\\n    \\n    let left = 1;\\n    let right = max;\\n    let result = 0;\\n    \\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        \\n        let totalStores = 0;\\n        for (let i = 0; i < quantities.length; i++) {\\n            totalStores += Math.ceil(quantities[i] / mid);\\n        }\\n        \\n        if (totalStores <= n) {\\n            result = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n       let max = -1;\\n    \\n    // Find the maximum value in the quantities array\\n    max = Math.max(...quantities);\\n    \\n    let left = 1;\\n    let right = max;\\n    let result = 0;\\n    \\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        \\n        let totalStores = 0;\\n        for (let i = 0; i < quantities.length; i++) {\\n            totalStores += Math.ceil(quantities[i] / mid);\\n        }\\n        \\n        if (totalStores <= n) {\\n            result = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948066,
                "title": "python-binary-search-solution-beats-92-43",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        l=1\\n        r=max(quantities) \\n        while l<r:\\n            md=(l+r)//2\\n            val=sum(ceil(q/md) for q in quantities)\\n            if val<=n:\\n                r=md\\n            else:\\n                l=md+1\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        l=1\\n        r=max(quantities) \\n        while l<r:\\n            md=(l+r)//2\\n            val=sum(ceil(q/md) for q in quantities)\\n            if val<=n:\\n                r=md\\n            else:\\n                l=md+1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929053,
                "title": "swift-optimized-edges-in-binary-search",
                "content": "B# Complexity\\n- Time complexity:\\nO(logk * m), where m - size of quantities, k - max quantity value.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizedMaximum(_ n: Int, _ quantities: [Int]) -> Int {\\n        let totalQuantities = quantities.reduce(0,+)\\n        var high = quantities.max()!\\n        var low = (totalQuantities + n - 1) / n\\n        var mid: Int\\n        while low < high {\\n            mid = (low + high) / 2\\n            let numberOfStores = quantities.reduce(0, { $0 + ($1 + mid - 1) / mid })\\n            if numberOfStores > n {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        \\n        return high\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedMaximum(_ n: Int, _ quantities: [Int]) -> Int {\\n        let totalQuantities = quantities.reduce(0,+)\\n        var high = quantities.max()!\\n        var low = (totalQuantities + n - 1) / n\\n        var mid: Int\\n        while low < high {\\n            mid = (low + high) / 2\\n            let numberOfStores = quantities.reduce(0, { $0 + ($1 + mid - 1) / mid })\\n            if numberOfStores > n {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        \\n        return high\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923951,
                "title": "easy-understanding-c-binary-search-solution",
                "content": "```\\nclass Solution {\\n    bool check(int k,int n,vector<int> &nums)\\n    {\\n       int count = 0;\\n       for(auto it : nums)\\n       {\\n           count += ceil((double)it/k);\\n       }\\n         \\n       return count<=n;\\n    }\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n       \\n        int mx = 0;\\n        for(auto it : quantities) mx = max(mx,it);\\n        \\n        int l = 1;\\n        int h = mx;\\n        \\n        int ans = INT_MAX;\\n        while(l<=h)\\n        {\\n            int mid = l+(h-l)/2;\\n            if(check(mid,n,quantities))\\n            {\\n                ans = min(ans,mid);\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool check(int k,int n,vector<int> &nums)\\n    {\\n       int count = 0;\\n       for(auto it : nums)\\n       {\\n           count += ceil((double)it/k);\\n       }\\n         \\n       return count<=n;\\n    }\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n       \\n        int mx = 0;\\n        for(auto it : quantities) mx = max(mx,it);\\n        \\n        int l = 1;\\n        int h = mx;\\n        \\n        int ans = INT_MAX;\\n        while(l<=h)\\n        {\\n            int mid = l+(h-l)/2;\\n            if(check(mid,n,quantities))\\n            {\\n                ans = min(ans,mid);\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909024,
                "title": "python-solution-using-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        mini,maxi=1,max(quantities)\\n        while mini<maxi:\\n            mid=mini+(maxi-mini)//2\\n            stores=sum([ceil(q/mid) for q in quantities])\\n            if stores<=n:\\n                maxi=mid\\n            else:\\n                mini=mid+1\\n        return maxi\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        mini,maxi=1,max(quantities)\\n        while mini<maxi:\\n            mid=mini+(maxi-mini)//2\\n            stores=sum([ceil(q/mid) for q in quantities])\\n            if stores<=n:\\n                maxi=mid\\n            else:\\n                mini=mid+1\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900985,
                "title": "c-binary-search-solution-on-point-explanation-w-comments",
                "content": "# Complexity\\n- Time complexity:\\nO(q*log m)\\nwhere q = difference between max and min possible products/store =( h-l )\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(int n, vector<int>& q, int prod){\\n        \\n        int cnt=0; //cnt = at how many stores have udelived at max \"prod\" products\\n        for(int i=0; i<q.size(); i++){\\n            cnt += (q[i]/prod);\\n            if(q[i]%prod) cnt++;\\n        }\\n\\n        if(cnt<=n) return true; \\n        // if cnt exceeds total no. of stores, return false!\\n        return false; \\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        \\n        // given there are n stores\\n\\n        int m = q.size(); //qunatities[i] represents the number of products of the ith product type.\\n\\n        //minimum product per store = 1 atleast (see constraint) hence l = 1;\\n        // maximum products per store = max_element as a store can only one type of element!\\n        int l=1; int h = *max_element(q.begin(), q.end());\\n        \\n        while(l<=h){ //binary search for optimal maximum products per store\\n\\n            int mid = l + (h-l)/2;\\n\\n            if(check(n,q,mid)==true){\\n                h = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(int n, vector<int>& q, int prod){\\n        \\n        int cnt=0; //cnt = at how many stores have udelived at max \"prod\" products\\n        for(int i=0; i<q.size(); i++){\\n            cnt += (q[i]/prod);\\n            if(q[i]%prod) cnt++;\\n        }\\n\\n        if(cnt<=n) return true; \\n        // if cnt exceeds total no. of stores, return false!\\n        return false; \\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        \\n        // given there are n stores\\n\\n        int m = q.size(); //qunatities[i] represents the number of products of the ith product type.\\n\\n        //minimum product per store = 1 atleast (see constraint) hence l = 1;\\n        // maximum products per store = max_element as a store can only one type of element!\\n        int l=1; int h = *max_element(q.begin(), q.end());\\n        \\n        while(l<=h){ //binary search for optimal maximum products per store\\n\\n            int mid = l + (h-l)/2;\\n\\n            if(check(n,q,mid)==true){\\n                h = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889738,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(int mid, int n, vector<int> &quantities){\\n    int count = 0;\\n    for(int i=0;i<quantities.size();i++){\\n        if(quantities[i]%mid==0){\\n            count+=quantities[i]/mid;\\n        }\\n        else{\\n            count= count+(quantities[i]/mid)+1;\\n        }\\n    }\\n    if(count<=n) return true;\\n    return false;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low = 1;\\n        int high = *max_element(quantities.begin(), quantities.end());\\n        int res = -1;\\n\\n        while(low<=high){\\n            int mid = low-(low-high)/2;\\n            if(check(mid, n, quantities)){\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(int mid, int n, vector<int> &quantities){\\n    int count = 0;\\n    for(int i=0;i<quantities.size();i++){\\n        if(quantities[i]%mid==0){\\n            count+=quantities[i]/mid;\\n        }\\n        else{\\n            count= count+(quantities[i]/mid)+1;\\n        }\\n    }\\n    if(count<=n) return true;\\n    return false;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low = 1;\\n        int high = *max_element(quantities.begin(), quantities.end());\\n        int res = -1;\\n\\n        while(low<=high){\\n            int mid = low-(low-high)/2;\\n            if(check(mid, n, quantities)){\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873890,
                "title": "binary-search-explained",
                "content": "# Approach\\nMain idea is to split each product type to the amount so we can distribute them across as much of stores as possible\\n```\\n// Example 1:\\n//  stores: 10\\n//  product types:      16      8     4       20\\n//  try split by 6:    6+6+4   4+4    4     6+6+6+2  \\n//  ans: we can distribute by 10 stores, MAX(6,6,4,4,4,4,6,6,6,2)=6\\n\\n//  Example 2:\\n//  stores:7\\n//  product types:  15      10    10\\n//  split by 6:    6+6+3    6+4   6+4     \\n//  split by 5:    5+5+5    5+5   5+5     \\n//  ans: we pick smaller distribution, which is 5, MAX(5,5,5,5,5,5,5)=5\\n```\\n\\nIn order to achieve this we use binary search,\\npick mid between 1 and MAX(quantities), and try to split it by all stores \\'split(mid)\\'\\nwhere split(mid) returns the number of needed stores to perform a split\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogM)$$ N-length of \\'quantities\\', M-maximum value in \\'quantities\\' array\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minimizedMaximum = function(n, quantities) {\\n    \\n    const split=(count)=>quantities.reduce((acc,cur)=>acc+Math.ceil(cur/count),0);\\n\\n    let l=1, r=quantities.reduce((curr,acc)=>Math.max(curr,acc)), lastOptimal=0;\\n    while(l<=r){\\n      const mid=Math.trunc((l+r)/2);\\n      const storesNeeded=split(mid);\\n      if(storesNeeded===n){\\n        lastOptimal=mid;\\n        r=mid-1; // even we have a match, we try to reduce the mid, so we can get even smaller split number\\n        continue;\\n      }\\n      if(storesNeeded>n)l=mid+1;\\n      else {\\n        lastOptimal=mid; // at this point we can distribute product but not for ALL stores, anyway it is better then not distributing product at all \\n        r=mid-1; \\n      }  \\n    }\\n    return lastOptimal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Example 1:\\n//  stores: 10\\n//  product types:      16      8     4       20\\n//  try split by 6:    6+6+4   4+4    4     6+6+6+2  \\n//  ans: we can distribute by 10 stores, MAX(6,6,4,4,4,4,6,6,6,2)=6\\n\\n//  Example 2:\\n//  stores:7\\n//  product types:  15      10    10\\n//  split by 6:    6+6+3    6+4   6+4     \\n//  split by 5:    5+5+5    5+5   5+5     \\n//  ans: we pick smaller distribution, which is 5, MAX(5,5,5,5,5,5,5)=5\\n```\n```\\nvar minimizedMaximum = function(n, quantities) {\\n    \\n    const split=(count)=>quantities.reduce((acc,cur)=>acc+Math.ceil(cur/count),0);\\n\\n    let l=1, r=quantities.reduce((curr,acc)=>Math.max(curr,acc)), lastOptimal=0;\\n    while(l<=r){\\n      const mid=Math.trunc((l+r)/2);\\n      const storesNeeded=split(mid);\\n      if(storesNeeded===n){\\n        lastOptimal=mid;\\n        r=mid-1; // even we have a match, we try to reduce the mid, so we can get even smaller split number\\n        continue;\\n      }\\n      if(storesNeeded>n)l=mid+1;\\n      else {\\n        lastOptimal=mid; // at this point we can distribute product but not for ALL stores, anyway it is better then not distributing product at all \\n        r=mid-1; \\n      }  \\n    }\\n    return lastOptimal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3870224,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int check(int quantaties[],int mid,int n){\\n        int sum=0;\\n        for(int i=0;i<quantaties.length;i++){\\n             sum=sum+quantaties[i]/mid;\\n            int rem=quantaties[i]%mid;\\n            if(rem!=0){\\n                sum=sum+1;\\n            }\\n        }\\n        return sum;\\n    }\\n    int f(int n, int quantities[]){\\n        int low=1;\\n        int high=quantities[quantities.length-1];\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(check(quantities,mid,n)<=n){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        Arrays.sort(quantities);\\n\\n        return f(n,quantities);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    int check(int quantaties[],int mid,int n){\\n        int sum=0;\\n        for(int i=0;i<quantaties.length;i++){\\n             sum=sum+quantaties[i]/mid;\\n            int rem=quantaties[i]%mid;\\n            if(rem!=0){\\n                sum=sum+1;\\n            }\\n        }\\n        return sum;\\n    }\\n    int f(int n, int quantities[]){\\n        int low=1;\\n        int high=quantities[quantities.length-1];\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(check(quantities,mid,n)<=n){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        Arrays.sort(quantities);\\n\\n        return f(n,quantities);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832680,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private boolean isValid(int[] quantities, int x, int n) {\\n        int storeCount = 0;\\n        for (int i = 0; i < quantities.length; i++) {\\n            storeCount += (quantities[i] + x - 1) / x;\\n            if (storeCount > n) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int low = 1;\\n      //  int high = Arrays.stream(quantities).sum();\\n        int high = (int)1e5;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isValid(quantities, mid, n)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private boolean isValid(int[] quantities, int x, int n) {\\n        int storeCount = 0;\\n        for (int i = 0; i < quantities.length; i++) {\\n            storeCount += (quantities[i] + x - 1) / x;\\n            if (storeCount > n) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int low = 1;\\n      //  int high = Arrays.stream(quantities).sum();\\n        int high = (int)1e5;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isValid(quantities, mid, n)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832093,
                "title": "faster-than-100-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(len(quantities)*log(right-left))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def helper(val ):\\n            crr = 0 \\n            for ele in quantities : \\n                crr += ceil(ele/val) \\n            if crr <= n : \\n                return False \\n            return True \\n        \\n        left = ceil(sum(quantities)/n) // min value will be average \\n        right = max(quantities) // right will be max as we give that completely\\n        \\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left  \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def helper(val ):\\n            crr = 0 \\n            for ele in quantities : \\n                crr += ceil(ele/val) \\n            if crr <= n : \\n                return False \\n            return True \\n        \\n        left = ceil(sum(quantities)/n) // min value will be average \\n        right = max(quantities) // right will be max as we give that completely\\n        \\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818252,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nint minimizedMaximum(int n, int* quantities, int quantitiesSize){\\n    if(n==1) return quantities[0];\\n    int left=1,right=0,ans;\\n    for(int i=0;i<quantitiesSize;i++){\\n        right=fmax(right,quantities[i]);\\n    }\\n    while(left<right){\\n        int mid=(left+right)/2;\\n        printf(\"left: %d | right :%d\\\\n\",left,right);\\n        int k=0;\\n        for(int i=0;i<quantitiesSize;i++){\\n            k+=quantities[i]/mid;\\n            k+=quantities[i]%mid!=0?1:0;\\n        }\\n        if(k>n){\\n            left=mid+1;\\n        }else{\\n            right=mid;\\n        }\\n    }\\n    return right;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedMaximum(int n, int* quantities, int quantitiesSize){\\n    if(n==1) return quantities[0];\\n    int left=1,right=0,ans;\\n    for(int i=0;i<quantitiesSize;i++){\\n        right=fmax(right,quantities[i]);\\n    }\\n    while(left<right){\\n        int mid=(left+right)/2;\\n        printf(\"left: %d | right :%d\\\\n\",left,right);\\n        int k=0;\\n        for(int i=0;i<quantitiesSize;i++){\\n            k+=quantities[i]/mid;\\n            k+=quantities[i]%mid!=0?1:0;\\n        }\\n        if(k>n){\\n            left=mid+1;\\n        }else{\\n            right=mid;\\n        }\\n    }\\n    return right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817771,
                "title": "binary-search-low-high-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> arr,int mid,int n)\\n    {\\n        long long c=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            c=c+ceil((double)arr[i]/(double)mid);\\n        }\\n        return c<=n;\\n    }\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int high=0;\\n        for(int i=0;i<quantities.size();i++)\\n        {\\n            high=max(high,quantities[i]);\\n        }\\n        int low=1;\\n\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n\\n            if(possible(quantities, mid, n))\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> arr,int mid,int n)\\n    {\\n        long long c=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            c=c+ceil((double)arr[i]/(double)mid);\\n        }\\n        return c<=n;\\n    }\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int high=0;\\n        for(int i=0;i<quantities.size();i++)\\n        {\\n            high=max(high,quantities[i]);\\n        }\\n        int low=1;\\n\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n\\n            if(possible(quantities, mid, n))\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795235,
                "title": "java-binary-search-solution-with-explaination",
                "content": "# Intuition\\nThe best solution will have even distribution of products \\n    i.e. if product[i] is to be distributed among 3 stores then each store should get ~ products[i]/3\\n     Let x be maxProductPerStore then no. of stores needed for ith product = ceil[products[i]/maxProductPerStore]\\n     possible values of x for ith product = 1, 2, 3, ... products[i]\\n     note that even if x > products[i] then no. of stores needed will remain at 1\\n     Using above note we can simplify the problem to only search for x in 1, 2, 3,... max(products)\\n     apply binary search on above search space to find a valid minimum possible maxProductPerStore\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    - Let M = max product quantity, P = no. of products\\n    - O(P log M) : log M iterations and each iteration needs O(P) time to validate. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        return findMaxProduct(quantities, n);\\n    }\\n\\n    // The best solution will have even distribution of products \\n    // i.e. if product[i] is to be distributed among 3 stores then each store should get ~ products[i]/3\\n    // Let x be maxProductPerStore then no. of stores needed for ith product = ceil[products[i]/minProductPerStore]\\n    // possible values of x for ith product = 1, 2, 3, ... products[i]\\n    // note that even if x > products[i] then no. of stores needed will remain at 1\\n    // Using above note we can simplify the problem to only search for x in 1, 2, 3,... max(products)\\n    // apply binary search on above search space to find a valid minimum possible maxProductPerStore\\n    private int findMaxProduct(int[] products, int n) {\\n        int min = 1; int max = 1;\\n        for (int q : products) max = Math.max(max, q);\\n        int ans = -1;\\n        // Note that reducing maxProductsPerStore increases no. of stores needed to distribute all products\\n        // And we have a limit on number of stores. \\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            int storesNeeded = findStoresNeeded(products, mid);\\n            if (storesNeeded <= n) {\\n                // this is a possible solution \\n                ans = mid;\\n                // However we may still be able to reduce maxProductsPerStore so lets check on the left of mid \\n                // i.e. with less products per store => will need more stores \\n                // but if new no. of stores is still <= n then that is a better solution\\n                max = mid - 1;\\n            } else {\\n                // we need to increase max products per store to reduce no. of stores needed to distribute all products\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n    // Assuming we are distributing maxProductsPerStore then count no. of stores needed to distribute all quantitites. \\n    private int findStoresNeeded(int[] products, int maxProductsPerStore) {\\n        int count = 0;\\n        for (int quantity : products) {\\n            count += (quantity + maxProductsPerStore - 1) / maxProductsPerStore;\\n            //count += Math.ceil((1.0 * quantity)/ maxProductsPerStore);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        return findMaxProduct(quantities, n);\\n    }\\n\\n    // The best solution will have even distribution of products \\n    // i.e. if product[i] is to be distributed among 3 stores then each store should get ~ products[i]/3\\n    // Let x be maxProductPerStore then no. of stores needed for ith product = ceil[products[i]/minProductPerStore]\\n    // possible values of x for ith product = 1, 2, 3, ... products[i]\\n    // note that even if x > products[i] then no. of stores needed will remain at 1\\n    // Using above note we can simplify the problem to only search for x in 1, 2, 3,... max(products)\\n    // apply binary search on above search space to find a valid minimum possible maxProductPerStore\\n    private int findMaxProduct(int[] products, int n) {\\n        int min = 1; int max = 1;\\n        for (int q : products) max = Math.max(max, q);\\n        int ans = -1;\\n        // Note that reducing maxProductsPerStore increases no. of stores needed to distribute all products\\n        // And we have a limit on number of stores. \\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            int storesNeeded = findStoresNeeded(products, mid);\\n            if (storesNeeded <= n) {\\n                // this is a possible solution \\n                ans = mid;\\n                // However we may still be able to reduce maxProductsPerStore so lets check on the left of mid \\n                // i.e. with less products per store => will need more stores \\n                // but if new no. of stores is still <= n then that is a better solution\\n                max = mid - 1;\\n            } else {\\n                // we need to increase max products per store to reduce no. of stores needed to distribute all products\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n    // Assuming we are distributing maxProductsPerStore then count no. of stores needed to distribute all quantitites. \\n    private int findStoresNeeded(int[] products, int maxProductsPerStore) {\\n        int count = 0;\\n        for (int quantity : products) {\\n            count += (quantity + maxProductsPerStore - 1) / maxProductsPerStore;\\n            //count += Math.ceil((1.0 * quantity)/ maxProductsPerStore);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764421,
                "title": "begineer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n * log(max_quantity))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint check_mid(int mid , vector<int>&q, int n)\\n{\\n     //counting that how many store can be coverd with this mid value\\n int count =0;\\n\\n    for(int i =0;i<q.size();i++)\\n    {\\n        int house_cover = q[i]/mid; // number of house can be covered by this mid value\\n        int left_value = q[i]%mid; // number of product can be left after providing the mid(product) value to  stores\\n\\n        if(left_value==0)  // if the value is equal to zero that means No house is left for that mid value\\n        {\\n            count+=house_cover;\\n        }\\n        else{\\n            count += house_cover+1;   // left_value can be given to next house that\\'s why +1\\n        }\\n    }\\n\\n    if(count<=n) // if count value is less than \\'n\\' it mean its a valid case\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n         int ed =*max_element(quantities.begin(), quantities.end());\\n\\n         int st=1;\\nint ans =0;\\n         while(st<=ed)\\n         {\\n             int mid = st + (ed-st)/2;\\n            if(check_mid(mid,quantities,n))\\n            {\\n                ans= mid;\\n                ed = mid-1;\\n            }\\n            else{\\n                st = mid+1;\\n            }\\n             \\n\\n         }\\n\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint check_mid(int mid , vector<int>&q, int n)\\n{\\n     //counting that how many store can be coverd with this mid value\\n int count =0;\\n\\n    for(int i =0;i<q.size();i++)\\n    {\\n        int house_cover = q[i]/mid; // number of house can be covered by this mid value\\n        int left_value = q[i]%mid; // number of product can be left after providing the mid(product) value to  stores\\n\\n        if(left_value==0)  // if the value is equal to zero that means No house is left for that mid value\\n        {\\n            count+=house_cover;\\n        }\\n        else{\\n            count += house_cover+1;   // left_value can be given to next house that\\'s why +1\\n        }\\n    }\\n\\n    if(count<=n) // if count value is less than \\'n\\' it mean its a valid case\\n    {\\n        return 1;\\n    }\\n    return 0;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n         int ed =*max_element(quantities.begin(), quantities.end());\\n\\n         int st=1;\\nint ans =0;\\n         while(st<=ed)\\n         {\\n             int mid = st + (ed-st)/2;\\n            if(check_mid(mid,quantities,n))\\n            {\\n                ans= mid;\\n                ed = mid-1;\\n            }\\n            else{\\n                st = mid+1;\\n            }\\n             \\n\\n         }\\n\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753031,
                "title": "easy-c-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nour search space will be at low we need to choose 1 product and at max we can give the maximum quatity of a product type available.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long l=1,r=0,ans=INT_MAX;\\n        for(auto it:quantities)r=max(r,(long long)it);\\n        while(l<=r){\\n            long long m=(l+r)/2;\\n            long long stores=0;\\n            for(auto it:quantities){\\n                stores+=ceil((double)it/m); //find number of stores a product is distributed to\\n            }\\n            if(stores>n){//if stores number exceed given number then increase the quantity or number of products given to a store\\n                l=m+1;\\n            }else{\\n                ans=m,r=m-1;//if can be allocated then look for minimum answer\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long l=1,r=0,ans=INT_MAX;\\n        for(auto it:quantities)r=max(r,(long long)it);\\n        while(l<=r){\\n            long long m=(l+r)/2;\\n            long long stores=0;\\n            for(auto it:quantities){\\n                stores+=ceil((double)it/m); //find number of stores a product is distributed to\\n            }\\n            if(stores>n){//if stores number exceed given number then increase the quantity or number of products given to a store\\n                l=m+1;\\n            }else{\\n                ans=m,r=m-1;//if can be allocated then look for minimum answer\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738279,
                "title": "binary-search-o-n-logn-solution-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int n, vector<int> &q, int val){\\n        int rem = n;\\n        long long sum = 0;\\n        int d = 0;\\n        for(int i = 0; i<q.size(); i++){\\n            int a = q[i]/val;\\n            if(rem>=a){\\n                rem-=a;\\n                sum+=q[i]%val;\\n                if(q[i]%val!=0){\\n                    d++;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(rem==0){\\n            if(sum==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(rem>0){\\n            if(rem>=d){\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int l = 1;\\n        int r = *max_element(quantities.begin(), quantities.end());\\n        int ans=-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(isvalid(n, quantities, mid)){\\n                ans =mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int n, vector<int> &q, int val){\\n        int rem = n;\\n        long long sum = 0;\\n        int d = 0;\\n        for(int i = 0; i<q.size(); i++){\\n            int a = q[i]/val;\\n            if(rem>=a){\\n                rem-=a;\\n                sum+=q[i]%val;\\n                if(q[i]%val!=0){\\n                    d++;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(rem==0){\\n            if(sum==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(rem>0){\\n            if(rem>=d){\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int l = 1;\\n        int r = *max_element(quantities.begin(), quantities.end());\\n        int ans=-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(isvalid(n, quantities, mid)){\\n                ans =mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725398,
                "title": "easy-solution",
                "content": "# Intuition\\n- As per question we have to distribute min quantity of product to max number of shop. so our task is to find min quantity.\\n- We can distribute products in range 1 to max quantity of a product.\\n- Using binary search to get that min quantity value.\\n\\n# Approach\\n- First find the max quantity of a product we can distribute.\\n- Take two variable left = 1 and right = max value of a product.\\n- Apply binary search between left and right and try to find the min number of product.\\n- Create on method which is responsible for to check isProduct distribution possible or not for that mid(product quantity).\\n- At last in mid have a ans.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n    \\n    let left = 1;\\n    let right = Math.max(...quantities);\\n    let result =-1;\\n\\n    while(left<=right){\\n        let mid = left + Math.floor((right-left)/2);\\n\\n        if(isDistributionPossible(quantities,mid,n)){\\n            result = mid;\\n            right=mid-1;\\n        }\\n        else{\\n            left=mid+1;\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n\\nconst isDistributionPossible = (quantities, maxProduct, stores)=>{\\n    let storeCount = 0;\\n\\n    for(let i=0;i<quantities.length;i++){\\n        \\n        storeCount += Math.floor(quantities[i]/maxProduct);\\n\\n        if(quantities[i]%maxProduct != 0){\\n            storeCount += 1;\\n        }\\n\\n        if(storeCount > stores){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n    \\n    let left = 1;\\n    let right = Math.max(...quantities);\\n    let result =-1;\\n\\n    while(left<=right){\\n        let mid = left + Math.floor((right-left)/2);\\n\\n        if(isDistributionPossible(quantities,mid,n)){\\n            result = mid;\\n            right=mid-1;\\n        }\\n        else{\\n            left=mid+1;\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n\\nconst isDistributionPossible = (quantities, maxProduct, stores)=>{\\n    let storeCount = 0;\\n\\n    for(let i=0;i<quantities.length;i++){\\n        \\n        storeCount += Math.floor(quantities[i]/maxProduct);\\n\\n        if(quantities[i]%maxProduct != 0){\\n            storeCount += 1;\\n        }\\n\\n        if(storeCount > stores){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3723011,
                "title": "easy-solution",
                "content": "# Intuition\\n- We can distribute either zero product to a shop or min one and max as per max quantity of a product.\\n- Our goal is to minimized the product quantities distribution to shop.\\n- Here we can use apply binary search where left = 1 and right=max quantity of a product in quantities array.\\n\\n# Approach\\n- Define left, right and result variable.\\n- Right initialized with max product quantity.\\n- Result keeping the valid result if possible otherwise it keep -1.\\n- Define a method isDistributionPossible for checking maxProduct distribution are possible for shop or not.\\n- We will check it for all possible minProduct value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n    \\n    let left = 1;\\n    let right = Math.max(...quantities);\\n    let result =-1;\\n\\n    while(left<=right){\\n        let mid = left + Math.floor((right-left)/2);\\n\\n        if(isDistributionPossible(quantities,mid,n)){\\n            result = mid;\\n            right=mid-1;\\n        }\\n        else{\\n            left=mid+1;\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n\\nconst isDistributionPossible = (quantities, maxProduct, stores)=>{\\n    let storeCount = 0;\\n\\n    for(let i=0;i<quantities.length;i++){\\n        \\n        storeCount += Math.floor(quantities[i]/maxProduct);\\n\\n        if(quantities[i]%maxProduct != 0){\\n            storeCount += 1;\\n        }\\n\\n        if(storeCount > stores){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\nvar minimizedMaximum = function(n, quantities) {\\n    \\n    let left = 1;\\n    let right = Math.max(...quantities);\\n    let result =-1;\\n\\n    while(left<=right){\\n        let mid = left + Math.floor((right-left)/2);\\n\\n        if(isDistributionPossible(quantities,mid,n)){\\n            result = mid;\\n            right=mid-1;\\n        }\\n        else{\\n            left=mid+1;\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n\\nconst isDistributionPossible = (quantities, maxProduct, stores)=>{\\n    let storeCount = 0;\\n\\n    for(let i=0;i<quantities.length;i++){\\n        \\n        storeCount += Math.floor(quantities[i]/maxProduct);\\n\\n        if(quantities[i]%maxProduct != 0){\\n            storeCount += 1;\\n        }\\n\\n        if(storeCount > stores){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722655,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[] quantities,int n,int mid,int len){\\n        int sum = 0;\\n        int count = 0;\\n        int remaining = 0;\\n        for(int i = 0;i < len;i++){\\n            if(quantities[i] <= mid)\\n                count++;\\n            else if(quantities[i] % mid == 0)\\n                count += quantities[i]/mid;\\n            else\\n                count += quantities[i]/mid + 1;\\n        }\\n        return count <= n;\\n    }\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int low = 1;\\n        int high = 100000;\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(quantities,n,mid,quantities.length)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] quantities,int n,int mid,int len){\\n        int sum = 0;\\n        int count = 0;\\n        int remaining = 0;\\n        for(int i = 0;i < len;i++){\\n            if(quantities[i] <= mid)\\n                count++;\\n            else if(quantities[i] % mid == 0)\\n                count += quantities[i]/mid;\\n            else\\n                count += quantities[i]/mid + 1;\\n        }\\n        return count <= n;\\n    }\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int low = 1;\\n        int high = 100000;\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(quantities,n,mid,quantities.length)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722060,
                "title": "easy-and-most-understable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolved this by using binary search \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach steps are explained in code snippet\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedMaximum(int n, int[] quantities) {\\n        // in this problem main constant is each shop must have atleaset one product and all product should be distributed\\n        // so will take the max value from the array and will check the answer from 1 to max value \\n        // when we are searching in a range (means that is sorted) , the most optimized solution is binary search\\n        // now will take the mid and will check if the mid is full filling the requirement \\n        // if not then we short the range => from 1 to mid - 1\\n        // we are doing this because if mid is not satisfying the condition then mid + 1 will definitely not satisfy the constants \\n        // we always start from 1 as the shop should have atleast 1 product \\n\\n        // like shop = 6 and products = [11,6]\\n        // max = 11 and min = 1+11 / 2 = 6\\n        // now will start distributing 6 product to each shop \\n        // 6, 11-6, 6, 0, 0, 0 so we are not able to give product to each store , so 6 will not be the answer\\n        // new range 1 to mid-1 => 6-1 = 5\\n        // mid = 1+5 /2 = 3\\n        // now if we start shareing 3 product then\\n        // 3,3,3,2,3,3 // so 3 is fullfilling the condition\\n        // mid = 1 + (oldmid(3) -1) => 1 + 2 /2 = 1\\n        // if we use 1 then we will not be able to distribute all the product\\n        // similerly if the 1 to mid range did not work will make new range and do the same\\n        // new range mid + 1 to high\\n\\n        int low = 1, high = quantities.Max(), ans = -1;\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n           // will check if this mid will be the answer\\n           if(IsPossible(quantities, n, mid))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private bool IsPossible(int[] arr, int totalShop, int maxRange)\\n    {\\n        // initially set the store 0\\n        int shop = 0;\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            int quantity = arr[i];\\n            while (quantity > 0)\\n            {\\n                if (quantity > maxRange)\\n                {\\n                    quantity -= maxRange;\\n                    shop++;\\n                }\\n                else\\n                {\\n                    shop++;\\n                    quantity = 0;\\n                }\\n                if(shop > totalShop)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedMaximum(int n, int[] quantities) {\\n        // in this problem main constant is each shop must have atleaset one product and all product should be distributed\\n        // so will take the max value from the array and will check the answer from 1 to max value \\n        // when we are searching in a range (means that is sorted) , the most optimized solution is binary search\\n        // now will take the mid and will check if the mid is full filling the requirement \\n        // if not then we short the range => from 1 to mid - 1\\n        // we are doing this because if mid is not satisfying the condition then mid + 1 will definitely not satisfy the constants \\n        // we always start from 1 as the shop should have atleast 1 product \\n\\n        // like shop = 6 and products = [11,6]\\n        // max = 11 and min = 1+11 / 2 = 6\\n        // now will start distributing 6 product to each shop \\n        // 6, 11-6, 6, 0, 0, 0 so we are not able to give product to each store , so 6 will not be the answer\\n        // new range 1 to mid-1 => 6-1 = 5\\n        // mid = 1+5 /2 = 3\\n        // now if we start shareing 3 product then\\n        // 3,3,3,2,3,3 // so 3 is fullfilling the condition\\n        // mid = 1 + (oldmid(3) -1) => 1 + 2 /2 = 1\\n        // if we use 1 then we will not be able to distribute all the product\\n        // similerly if the 1 to mid range did not work will make new range and do the same\\n        // new range mid + 1 to high\\n\\n        int low = 1, high = quantities.Max(), ans = -1;\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n           // will check if this mid will be the answer\\n           if(IsPossible(quantities, n, mid))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private bool IsPossible(int[] arr, int totalShop, int maxRange)\\n    {\\n        // initially set the store 0\\n        int shop = 0;\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            int quantity = arr[i];\\n            while (quantity > 0)\\n            {\\n                if (quantity > maxRange)\\n                {\\n                    quantity -= maxRange;\\n                    shop++;\\n                }\\n                else\\n                {\\n                    shop++;\\n                    quantity = 0;\\n                }\\n                if(shop > totalShop)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716826,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[] quantities,int n,int mid,int len){\\n        int count = 0;\\n        int remaining = 0;\\n        for(int i = 0;i < len;){\\n            if(remaining == 0){\\n                if(quantities[i] <= mid){\\n                    i++;\\n                }\\n                else{\\n                    remaining = quantities[i] - mid;\\n                }\\n            }\\n            else{\\n                remaining -= mid;\\n                if(remaining <= 0){\\n                    i++;\\n                    remaining = 0;\\n                }\\n            }\\n            count++;\\n            if(count > n)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int low = 0;\\n        int high = 100000;\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(quantities,n,mid,quantities.length)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] quantities,int n,int mid,int len){\\n        int count = 0;\\n        int remaining = 0;\\n        for(int i = 0;i < len;){\\n            if(remaining == 0){\\n                if(quantities[i] <= mid){\\n                    i++;\\n                }\\n                else{\\n                    remaining = quantities[i] - mid;\\n                }\\n            }\\n            else{\\n                remaining -= mid;\\n                if(remaining <= 0){\\n                    i++;\\n                    remaining = 0;\\n                }\\n            }\\n            count++;\\n            if(count > n)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int low = 0;\\n        int high = 100000;\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(quantities,n,mid,quantities.length)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716704,
                "title": "binary-search-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution is explained as a comment at the end of the code\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O[n*log(maxR)]$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O[1]$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(int x,int n,vector<int>& quantities){\\n        int i=0;\\n        while(i<quantities.size()){\\n            int num=quantities[i];\\n            int k=num%x;\\n            int l=num/x;\\n            if(k>0){\\n                n-=l;\\n                n--;\\n            }\\n            else{\\n                n-=l;\\n            }\\n            i++;\\n            //cout<<n<<\" \";\\n        }\\n        //cout<<\"\\\\n\";\\n        if(n>=0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int minR=1;\\n        int maxR=1;\\n        for(int i=0;i<quantities.size();i++){\\n            maxR=max(maxR,quantities[i]);\\n        }\\n        int ans=0;\\n        while(minR<=maxR){\\n            int mid=(minR+maxR)/2;\\n            if(canDistribute(mid,n,quantities)){\\n                ans=mid;\\n                maxR=mid-1;\\n            }\\n            else{\\n                minR=mid+1;\\n            }\\n        }\\n        return ans;\\n        // a very good question of binary search over minR and maxR\\n        // let minR=1 and maxR=max of quantities\\n        // if i am able to distribute all products i will  take it as an answer and reduce high to mid-1\\n        // if no answer found low will be incremented to mid+1\\n    }\\n};\\n\\n/*\\n1 2 3 4 5 6 7 8 9 10 11\\nminR=1, maxR=11\\nmid=6\\ncheck if i am able to distribute all products at max 6 products to each retailer (yes) (found an answer) ans=6\\nreduce the high to mid-1\\nminR=1, maxR=5\\nmid=3\\ncheck if i am able to distribute all products at max 3 given to each retailer(yes) (found an answer) ans=3\\nminR=1, maxR=2\\nmid=1;\\nunable to distribute\\nminR=2, maxR=2\\nmid=2\\nunable to distriute\\nminR=3, maxR=2  (no furher cases possible)\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(int x,int n,vector<int>& quantities){\\n        int i=0;\\n        while(i<quantities.size()){\\n            int num=quantities[i];\\n            int k=num%x;\\n            int l=num/x;\\n            if(k>0){\\n                n-=l;\\n                n--;\\n            }\\n            else{\\n                n-=l;\\n            }\\n            i++;\\n            //cout<<n<<\" \";\\n        }\\n        //cout<<\"\\\\n\";\\n        if(n>=0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int minR=1;\\n        int maxR=1;\\n        for(int i=0;i<quantities.size();i++){\\n            maxR=max(maxR,quantities[i]);\\n        }\\n        int ans=0;\\n        while(minR<=maxR){\\n            int mid=(minR+maxR)/2;\\n            if(canDistribute(mid,n,quantities)){\\n                ans=mid;\\n                maxR=mid-1;\\n            }\\n            else{\\n                minR=mid+1;\\n            }\\n        }\\n        return ans;\\n        // a very good question of binary search over minR and maxR\\n        // let minR=1 and maxR=max of quantities\\n        // if i am able to distribute all products i will  take it as an answer and reduce high to mid-1\\n        // if no answer found low will be incremented to mid+1\\n    }\\n};\\n\\n/*\\n1 2 3 4 5 6 7 8 9 10 11\\nminR=1, maxR=11\\nmid=6\\ncheck if i am able to distribute all products at max 6 products to each retailer (yes) (found an answer) ans=6\\nreduce the high to mid-1\\nminR=1, maxR=5\\nmid=3\\ncheck if i am able to distribute all products at max 3 given to each retailer(yes) (found an answer) ans=3\\nminR=1, maxR=2\\nmid=1;\\nunable to distribute\\nminR=2, maxR=2\\nmid=2\\nunable to distriute\\nminR=3, maxR=2  (no furher cases possible)\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3703422,
                "title": "c-binary-search-on-answer-minimize-the-maximum-pattern",
                "content": "# Approach : Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quant) {\\n        auto func=[&](int mid){\\n            int cnt=0;\\n            for(int i=0;i<quant.size();i++){\\n                cnt+=(quant[i]/mid)+((quant[i]%mid)?1:0);\\n            }\\n            return cnt<=n;\\n        };\\n        int low=1,high=*max_element(quant.begin(),quant.end());\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            if(func(mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quant) {\\n        auto func=[&](int mid){\\n            int cnt=0;\\n            for(int i=0;i<quant.size();i++){\\n                cnt+=(quant[i]/mid)+((quant[i]%mid)?1:0);\\n            }\\n            return cnt<=n;\\n        };\\n        int low=1,high=*max_element(quant.begin(),quant.end());\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            if(func(mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688595,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>& quantities, int n, int mid){\\n        int count = 0;\\n        for(auto i : quantities){\\n            count += (i + mid - 1)/mid;\\n        }\\n        return count;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int right = INT_MIN;\\n        for(auto i : quantities){\\n            right = max(right, i);\\n        }\\n        int left =1;\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n            if(check(quantities, n, mid) > n)left = mid+1;\\n            else right = mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& quantities, int n, int mid){\\n        int count = 0;\\n        for(auto i : quantities){\\n            count += (i + mid - 1)/mid;\\n        }\\n        return count;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int right = INT_MIN;\\n        for(auto i : quantities){\\n            right = max(right, i);\\n        }\\n        int left =1;\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n            if(check(quantities, n, mid) > n)left = mid+1;\\n            else right = mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639876,
                "title": "java-binary-search-implementation",
                "content": "ara\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max = Integer.MIN_VALUE;\\n        for(int p : quantities){\\n            max = Math.max(p, max);\\n        }\\n\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            int result = 0;\\n            for(int i = 0;i<quantities.length;i++){\\n                result += (int)Math.ceil(quantities[i]*1.0/mid);\\n            }\\n\\n            if(result <= n){\\n                ans = mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max = Integer.MIN_VALUE;\\n        for(int p : quantities){\\n            max = Math.max(p, max);\\n        }\\n\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            int result = 0;\\n            for(int i = 0;i<quantities.length;i++){\\n                result += (int)Math.ceil(quantities[i]*1.0/mid);\\n            }\\n\\n            if(result <= n){\\n                ans = mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638814,
                "title": "100-fast-detailed-explanation-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s my summarized approach for this problem\\n\\n1. Initially, we may think of distributing goods equally by dividing the sum of all quantities by the total number of shops (N). However, this approach is incorrect as the number of goods of each type is different.\\n\\n2. Instead, let\\'s consider distributing goods with a maximum limit of K goods per shop. We need to determine the minimum value of K such that all goods can be distributed appropriately.\\n\\n3. To determine the number of shops that will receive goods of each type, we calculate quantities[i]/K for each type i. If quantities[i] is not exactly divisible by K, we take the ceiling value to ensure at most K goods are allocated.\\n\\n4. We keep track of the cumulative sum of quantities[i]/K for all types i (from 0 to m-1, where m is the size of the quantities array). This sum represents the number of shops that have been allocated goods so far.\\n\\n5. If the cumulative sum is greater than the total number of shops (sum > N), it means we are exceeding the available number of shops. In this case, we need to increase the value of K to reduce the sum.\\n\\n6. Conversely, if the cumulative sum is less than or equal to the total number of shops (sum <= N), it indicates that it\\'s possible to distribute all goods in a way that each shop receives at most K goods of the same type.\\n\\n7. To find the optimal value of K, we can apply binary search on K. Start with a lower bound and an upper bound and repeatedly update the mid value to check if the sum falls within the desired range. Adjust the lower or upper bound accordingly until we find the minimum K that satisfies the distribution condition.\\n\\nBy applying the above approach, we can determine the minimum maximum value (K) required to distribute goods in a way that satisfies the given conditions.\\n# Complexity\\n- Time complexity: **O(M.Log(Max(Quantities[i])))**,where M is the size of quantities array and max(quantities[i]) is the maximum value inside quantities array as we can in the worst case give atmax the max value number of goods to each shop.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumOfStores(int k,vector<int>&quant)\\n    {\\n        int stores = 0;\\n        for(auto product : quant)\\n        {\\n            stores += ceil(product/double(k));\\n        }\\n        return stores;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quant) {\\n        ios_base::sync_with_stdio(0);\\n        int m = quant.size();\\n        int k = *max_element(quant.begin(),quant.end());\\n\\n        int low = 1,high = k;\\n        //Binary Search\\n\\n        while(low<=high)\\n        {\\n            int mid = low + (high-low)/2;//k\\n            int stores = findNumOfStores(mid,quant);//O(M)\\n            if(stores>n)\\n                low = mid + 1;\\n            else\\n                high = mid -1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def findNumOfStores(self, k, quant):\\n        stores = 0\\n        for product in quant:\\n            stores += math.ceil(product / float(k))\\n        return stores\\n    \\n    def minimizedMaximum(self, n: int, quant: List[int]) -> int:\\n        m = len(quant)\\n        k = max(quant)\\n        \\n        low, high = 1, k\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            stores = self.findNumOfStores(mid, quant)\\n            \\n            if stores > n:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return low\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findNumOfStores(int k,vector<int>&quant)\\n    {\\n        int stores = 0;\\n        for(auto product : quant)\\n        {\\n            stores += ceil(product/double(k));\\n        }\\n        return stores;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quant) {\\n        ios_base::sync_with_stdio(0);\\n        int m = quant.size();\\n        int k = *max_element(quant.begin(),quant.end());\\n\\n        int low = 1,high = k;\\n        //Binary Search\\n\\n        while(low<=high)\\n        {\\n            int mid = low + (high-low)/2;//k\\n            int stores = findNumOfStores(mid,quant);//O(M)\\n            if(stores>n)\\n                low = mid + 1;\\n            else\\n                high = mid -1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findNumOfStores(self, k, quant):\\n        stores = 0\\n        for product in quant:\\n            stores += math.ceil(product / float(k))\\n        return stores\\n    \\n    def minimizedMaximum(self, n: int, quant: List[int]) -> int:\\n        m = len(quant)\\n        k = max(quant)\\n        \\n        low, high = 1, k\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            stores = self.findNumOfStores(mid, quant)\\n            \\n            if stores > n:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636334,
                "title": "easy-cpp-soln-koko-eating-banana-version-2-o",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool pred(vector<int>&quantities, int n,int mid){\\n    long long hr=0;\\n    for(int i=0;i<quantities.size();i++){\\n        if(quantities[i]%mid!=0){\\n            hr+=(quantities[i]/mid+1);\\n        }\\n        else{\\n            hr+=quantities[i]/mid;\\n        }\\n\\n    }\\n    return hr<=n;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n         int l=1,r=0,ans=-1;\\n        for(int i=0;i<quantities.size();i++){\\n            r=max(r,quantities[i]);\\n        }\\n        while(r-l>1){\\n            int mid=(l+r)/2;\\n            !pred(quantities,n,mid)?l=mid:r=mid;\\n        }\\n        if (pred(quantities, n, l)) return l;\\n    return r;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool pred(vector<int>&quantities, int n,int mid){\\n    long long hr=0;\\n    for(int i=0;i<quantities.size();i++){\\n        if(quantities[i]%mid!=0){\\n            hr+=(quantities[i]/mid+1);\\n        }\\n        else{\\n            hr+=quantities[i]/mid;\\n        }\\n\\n    }\\n    return hr<=n;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n         int l=1,r=0,ans=-1;\\n        for(int i=0;i<quantities.size();i++){\\n            r=max(r,quantities[i]);\\n        }\\n        while(r-l>1){\\n            int mid=(l+r)/2;\\n            !pred(quantities,n,mid)?l=mid:r=mid;\\n        }\\n        if (pred(quantities, n, l)) return l;\\n    return r;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593339,
                "title": "binary-search-time-complexity-o-m-log-max-element-from-quantities",
                "content": "```\\nint atleastReqStores(int mid,vector<int>& quantities,int m)\\n    {\\n        int atleast=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(quantities[i]%mid!=0)\\n                atleast++;\\n            atleast+=quantities[i]/mid;                \\n        }\\n        return atleast;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size();\\n        int low=1,high=*max_element(quantities.begin(),quantities.end()),ans;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int atleast=atleastReqStores(mid,quantities,m);\\n            \\n            if(atleast>n)\\n                low=mid+1;\\n            else\\n            {\\n               ans=mid;\\n                high=mid-1;\\n            }            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint atleastReqStores(int mid,vector<int>& quantities,int m)\\n    {\\n        int atleast=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(quantities[i]%mid!=0)\\n                atleast++;\\n            atleast+=quantities[i]/mid;                \\n        }\\n        return atleast;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size();\\n        int low=1,high=*max_element(quantities.begin(),quantities.end()),ans;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int atleast=atleastReqStores(mid,quantities,m);\\n            \\n            if(atleast>n)\\n                low=mid+1;\\n            else\\n            {\\n               ans=mid;\\n                high=mid-1;\\n            }            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487507,
                "title": "best-solution-ever-possible-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& A) {\\n        int s=1;\\n        int e=100000;\\n        \\n        while(s<e)\\n        {int mid=s+(e-s)/2;int sum=0;\\n            for (int p:A)\\n            {\\n                sum+=(p + mid - 1)/mid;\\n            }\\n            if (sum>n)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid;\\n            }\\n        }return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& A) {\\n        int s=1;\\n        int e=100000;\\n        \\n        while(s<e)\\n        {int mid=s+(e-s)/2;int sum=0;\\n            for (int p:A)\\n            {\\n                sum+=(p + mid - 1)/mid;\\n            }\\n            if (sum>n)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid;\\n            }\\n        }return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485374,
                "title": "python3-clean-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        \\n        \\n        def isValid(x):\\n            \\n            count=0\\n            \\n            for val in quantities:\\n                count+=ceil(val/x)\\n\\n            return count<=n\\n        \\n        \\n        low=1\\n        high=10**9\\n        ans=-1\\n\\n        while low<=high:\\n            \\n            mid=(low+high)//2\\n            if isValid(mid):\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        \\n        \\n        def isValid(x):\\n            \\n            count=0\\n            \\n            for val in quantities:\\n                count+=ceil(val/x)\\n\\n            return count<=n\\n        \\n        \\n        low=1\\n        high=10**9\\n        ans=-1\\n\\n        while low<=high:\\n            \\n            mid=(low+high)//2\\n            if isValid(mid):\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464848,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n1. We will search minimum max quantity given to any store using binary search.\\n2. By selecting a quantity we will check how many stores can be catered.\\n3. If lesser stores than n are being catered  at a quantity level, we need to reduce max quantity. Here we dont have enough to distribute to all stores at selected quantity level.\\n4. If more stores can be catered than n at a quantity level, we need to increase max quantity as we need to consume all quantity.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        ans,low,high = -1,1,10**5\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            stores_temp = 0\\n            for i in range(len(quantities)):\\n                stores_temp+=math.ceil(quantities[i]/mid)\\n\\n            if stores_temp <= n:\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        ans,low,high = -1,1,10**5\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            stores_temp = 0\\n            for i in range(len(quantities)):\\n                stores_temp+=math.ceil(quantities[i]/mid)\\n\\n            if stores_temp <= n:\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440932,
                "title": "c-revised-allocate-minimum-number-of-pages-solution-binary-search",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedMaximum(int n, int[] quantities) {\\n        int max = Int32.MinValue;\\n\\n        foreach(int q in quantities){\\n            max = Math.Max(max, q);\\n        }\\n\\n        int lo = 1 ;\\n        int hi = max;\\n        int res = -1;\\n\\n        while(lo<=hi){\\n            int mid = lo+((hi-lo)/2);\\n            if(IsValid(quantities, n , mid)){\\n                res = mid;\\n                hi = mid-1;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return res;\\n    }   \\n    bool IsValid(int[] nums, int k, int mx){\\n        int store = 0;\\n        for(int i = 0 ; i < nums.Length ; i++){\\n            int quantity = nums[i];\\n            while(quantity>0){\\n                if(quantity>mx){\\n                    quantity -= mx;\\n                    store++;\\n                }\\n                else{\\n                    store++;\\n                    quantity= 0;\\n                }\\n                if(store>k)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedMaximum(int n, int[] quantities) {\\n        int max = Int32.MinValue;\\n\\n        foreach(int q in quantities){\\n            max = Math.Max(max, q);\\n        }\\n\\n        int lo = 1 ;\\n        int hi = max;\\n        int res = -1;\\n\\n        while(lo<=hi){\\n            int mid = lo+((hi-lo)/2);\\n            if(IsValid(quantities, n , mid)){\\n                res = mid;\\n                hi = mid-1;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return res;\\n    }   \\n    bool IsValid(int[] nums, int k, int mx){\\n        int store = 0;\\n        for(int i = 0 ; i < nums.Length ; i++){\\n            int quantity = nums[i];\\n            while(quantity>0){\\n                if(quantity>mx){\\n                    quantity -= mx;\\n                    store++;\\n                }\\n                else{\\n                    store++;\\n                    quantity= 0;\\n                }\\n                if(store>k)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423085,
                "title": "simple-js-ts-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isValid(q: number[], n: number, key: number): boolean {\\n    let stores_reqd = 0;\\n\\n    for (let i = 0; i < q.length; i++) {\\n        if (q[i] <= key) stores_reqd++;\\n        else {\\n            let temp = q[i];\\n            while (temp > 0) {\\n                temp -= key;\\n                stores_reqd++;\\n            }\\n        }\\n        if (stores_reqd > n) return false;\\n    }\\n\\n    return true;\\n}\\n\\nfunction minimizedMaximum(n: number, quantities: number[]): number {\\n    let res = Number.MAX_SAFE_INTEGER;\\n    let low = 1, high = Math.max(...quantities);\\n    while (low <= high) {\\n        let mid = Math.ceil(low + ((high - low) / 2));\\n        if (isValid(quantities, n, mid)) {\\n            high = mid-1;\\n            res = Math.min(mid, res);\\n        } else {\\n            low = mid+1;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isValid(q: number[], n: number, key: number): boolean {\\n    let stores_reqd = 0;\\n\\n    for (let i = 0; i < q.length; i++) {\\n        if (q[i] <= key) stores_reqd++;\\n        else {\\n            let temp = q[i];\\n            while (temp > 0) {\\n                temp -= key;\\n                stores_reqd++;\\n            }\\n        }\\n        if (stores_reqd > n) return false;\\n    }\\n\\n    return true;\\n}\\n\\nfunction minimizedMaximum(n: number, quantities: number[]): number {\\n    let res = Number.MAX_SAFE_INTEGER;\\n    let low = 1, high = Math.max(...quantities);\\n    while (low <= high) {\\n        let mid = Math.ceil(low + ((high - low) / 2));\\n        if (isValid(quantities, n, mid)) {\\n            high = mid-1;\\n            res = Math.min(mid, res);\\n        } else {\\n            low = mid+1;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3387680,
                "title": "c-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&arr,int num,int k){\\n        \\n        long long sum=0;\\n        long long shops=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>num){\\n                if(arr[i]%num==0){\\n                    shops=shops+(arr[i]/num);\\n                }       \\n                else{\\n                    shops=shops+(arr[i]/num)+1;\\n                }\\n            }\\n            else{\\n                shops++;\\n            }\\n            if(shops>k){\\n                return false;\\n            }\\n        }\\n        if(shops>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        \\n        long long sum=0;\\n        for(int i=0;i<quantities.size();i++){\\n            sum=sum+quantities[i];\\n        }\\n        long long end=sum;\\n        long long start=1;\\n        long long ans=-1;\\n        while(start<=end){\\n            \\n            long long mid=(start+end)/2;\\n            if(ispossible(quantities,mid,n)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>&arr,int num,int k){\\n        \\n        long long sum=0;\\n        long long shops=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>num){\\n                if(arr[i]%num==0){\\n                    shops=shops+(arr[i]/num);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3386928,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quant) \\n    {\\n        if(n==1)\\n        return quant[0];\\n        //search between the no of candies distributed \\n        int l = 1 ,  h = 100000 , mid , res =-1 ; \\n        while(l<=h)\\n        {\\n            mid = (l+h)/2;\\n            cout<<mid<<\" \"; \\n            long long int sum = 0; \\n            for(auto x:quant)\\n             sum += ceil(double(x)/double(mid));\\n             //cout<<sum<<\" \";\\n             if(sum<=n)\\n             {\\n                 res = mid; \\n                 h = mid -1; \\n             }\\n             else  l = mid +1 ;\\n        }\\n       return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quant) \\n    {\\n        if(n==1)\\n        return quant[0];\\n        //search between the no of candies distributed \\n        int l = 1 ,  h = 100000 , mid , res =-1 ; \\n        while(l<=h)\\n        {\\n            mid = (l+h)/2;\\n            cout<<mid<<\" \"; \\n            long long int sum = 0; \\n            for(auto x:quant)\\n             sum += ceil(double(x)/double(mid));\\n             //cout<<sum<<\" \";\\n             if(sum<=n)\\n             {\\n                 res = mid; \\n                 h = mid -1; \\n             }\\n             else  l = mid +1 ;\\n        }\\n       return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3384656,
                "title": "readable-c-solution-with-time-and-space-complexity",
                "content": "```\\n//RUNTIME: 173 - 188 MS\\n//TIME COMPLEXITY: O(n log(100 000) aka O(n), where n\\n// is the length of the parameter quantities\\n//SPACE COMPLEXITY: O(1)\\n\\nclass Solution {\\npublic:\\n    bool canDistributeProducts(const std::vector<int>& quantities,\\n const int& numStores, const double& quantityPerStore)\\n    {\\n        int sum = 0;\\n\\n        for(const int& productCount : quantities)\\n        {\\n            sum += std::ceil(productCount / quantityPerStore);\\n        }\\n\\n        if(sum <= numStores)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        //We would never want to distribute 0 products to all stores,\\n        // so set our lower bound value to 1\\n        int leftPtr = 1;\\n        int rightPtr = 100\\'000;\\n        int answer = 100\\'000;\\n\\n        while(leftPtr <= rightPtr)\\n        {\\n            int mid = leftPtr + (rightPtr - leftPtr) / 2;\\n\\n            if(canDistributeProducts(quantities, n, mid))\\n            {\\n                rightPtr = mid - 1;\\n                answer = mid;\\n            }\\n            else\\n            {\\n                leftPtr = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//RUNTIME: 173 - 188 MS\\n//TIME COMPLEXITY: O(n log(100 000) aka O(n), where n\\n// is the length of the parameter quantities\\n//SPACE COMPLEXITY: O(1)\\n\\nclass Solution {\\npublic:\\n    bool canDistributeProducts(const std::vector<int>& quantities,\\n const int& numStores, const double& quantityPerStore)\\n    {\\n        int sum = 0;\\n\\n        for(const int& productCount : quantities)\\n        {\\n            sum += std::ceil(productCount / quantityPerStore);\\n        }\\n\\n        if(sum <= numStores)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        //We would never want to distribute 0 products to all stores,\\n        // so set our lower bound value to 1\\n        int leftPtr = 1;\\n        int rightPtr = 100\\'000;\\n        int answer = 100\\'000;\\n\\n        while(leftPtr <= rightPtr)\\n        {\\n            int mid = leftPtr + (rightPtr - leftPtr) / 2;\\n\\n            if(canDistributeProducts(quantities, n, mid))\\n            {\\n                rightPtr = mid - 1;\\n                answer = mid;\\n            }\\n            else\\n            {\\n                leftPtr = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371047,
                "title": "c-code",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int binarySearch(vector<int>&quantities,int mid){\\n        int n=quantities.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(quantities[i]%mid!=0){\\n                ans+=quantities[i]/mid+1;\\n            }\\n            else{\\n                ans+=quantities[i]/mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int l=1,h=*max_element(quantities.begin(),quantities.end()),mid=0,temp=1e8;\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n            int ans=binarySearch(quantities,mid);\\n            if(ans>n){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n                temp=min(temp,mid);\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int binarySearch(vector<int>&quantities,int mid){\\n        int n=quantities.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(quantities[i]%mid!=0){\\n                ans+=quantities[i]/mid+1;\\n            }\\n            else{\\n                ans+=quantities[i]/mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int l=1,h=*max_element(quantities.begin(),quantities.end()),mid=0,temp=1e8;\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n            int ans=binarySearch(quantities,mid);\\n            if(ans>n){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n                temp=min(temp,mid);\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364468,
                "title": "easy-to-understand-solution-by-binary-search-on-ans",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&q,int maxamt,int n){\\n        long long ans=0;\\n        for(int i=0;i<q.size();i++){\\n            ans+=q[i]/maxamt;\\n            if(q[i]%maxamt)ans++;\\n        }\\n        return ans<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int s=1;\\n        int e=100005;\\n        long long ans=0;\\n        sort(q.begin(),q.end());\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(f(q,mid,n)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&q,int maxamt,int n){\\n        long long ans=0;\\n        for(int i=0;i<q.size();i++){\\n            ans+=q[i]/maxamt;\\n            if(q[i]%maxamt)ans++;\\n        }\\n        return ans<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int s=1;\\n        int e=100005;\\n        long long ans=0;\\n        sort(q.begin(),q.end());\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(f(q,mid,n)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337716,
                "title": "java-binary-search-easy-to-understand",
                "content": "# Java\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max=Integer.MIN_VALUE;\\n        for(int quantity: quantities){\\n            max=Math.max(quantity,max);\\n        }\\n        int l=1,r=max;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(canDistribute(n,quantities,mid)){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    //checking if we can distribute all products to n retail stores with x(is the maximum number of products)\\n    public boolean canDistribute(int n, int[] quantities,int x){\\n        //res is the number of retail stores\\n        int res=0;\\n        for(int quantity: quantities){\\n            res+=(quantity-1)/x+1;\\n            \\n        }\\n        //res<n means the rest of retail stores will have been given 0 product\\n        //if res>n, we can not distribute all the products with max is x\\n        return res<=n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int max=Integer.MIN_VALUE;\\n        for(int quantity: quantities){\\n            max=Math.max(quantity,max);\\n        }\\n        int l=1,r=max;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(canDistribute(n,quantities,mid)){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    //checking if we can distribute all products to n retail stores with x(is the maximum number of products)\\n    public boolean canDistribute(int n, int[] quantities,int x){\\n        //res is the number of retail stores\\n        int res=0;\\n        for(int quantity: quantities){\\n            res+=(quantity-1)/x+1;\\n            \\n        }\\n        //res<n means the rest of retail stores will have been given 0 product\\n        //if res>n, we can not distribute all the products with max is x\\n        return res<=n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299955,
                "title": "simple-c-solution-beats-90-in-time-and-99-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>&v, int k){\\n    if(k==0) return INT_MAX;\\n    int sum = 0;\\n    for(auto i: v){\\n        if(i%k!=0){\\n            sum++;\\n        }\\n        sum += i/k;\\n    }\\n    return sum;\\n}\\n    int minimizedMaximum(int n, vector<int>& v) {\\n        if(n==1) return *min_element(v.begin(),v.end());\\n        int l = 0;\\n        int r = *max_element(v.begin(),v.end());\\n        int res = 0;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            int ans = solve(v,mid);\\n            if(ans > n){\\n                l = mid+1;\\n            }\\n            else{\\n                res = mid;\\n                r = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>&v, int k){\\n    if(k==0) return INT_MAX;\\n    int sum = 0;\\n    for(auto i: v){\\n        if(i%k!=0){\\n            sum++;\\n        }\\n        sum += i/k;\\n    }\\n    return sum;\\n}\\n    int minimizedMaximum(int n, vector<int>& v) {\\n        if(n==1) return *min_element(v.begin(),v.end());\\n        int l = 0;\\n        int r = *max_element(v.begin(),v.end());\\n        int res = 0;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            int ans = solve(v,mid);\\n            if(ans > n){\\n                l = mid+1;\\n            }\\n            else{\\n                res = mid;\\n                r = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297218,
                "title": "96-faster-easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int n, vector<int>& q,int mid){\\n        int total=0;\\n        for(auto it:q){\\n            total+=(it+mid-1)/mid;\\n        }\\n        return total<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int m=q.size();\\n        int sum=0;\\n        int lo=1,hi=0,mid;\\n        hi=1e5;\\n        int ans=0;\\n        \\n        while(lo<=hi){\\n            mid=(hi+lo)/2;\\n            if(f(n,q,mid)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                \\n                lo=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int n, vector<int>& q,int mid){\\n        int total=0;\\n        for(auto it:q){\\n            total+=(it+mid-1)/mid;\\n        }\\n        return total<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int m=q.size();\\n        int sum=0;\\n        int lo=1,hi=0,mid;\\n        hi=1e5;\\n        int ans=0;\\n        \\n        while(lo<=hi){\\n            mid=(hi+lo)/2;\\n            if(f(n,q,mid)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                \\n                lo=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292764,
                "title": "minimized-maximum-of-products-distributed-to-any-store",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findq(vector<int>& quantities,int q,int n){\\n        int count = 0;\\n        for(int i = 0;i<quantities.size();i++){\\n            if(quantities[i]%q!=0)count++;\\n            count = count + quantities[i]/q;\\n        }\\n        return count;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low = 1;\\n        int high = 1e9;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n            int q  = findq(quantities,mid,n);\\n            if(q>n)low = mid + 1;\\n            else{\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findq(vector<int>& quantities,int q,int n){\\n        int count = 0;\\n        for(int i = 0;i<quantities.size();i++){\\n            if(quantities[i]%q!=0)count++;\\n            count = count + quantities[i]/q;\\n        }\\n        return count;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low = 1;\\n        int high = 1e9;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n            int q  = findq(quantities,mid,n);\\n            if(q>n)low = mid + 1;\\n            else{\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289008,
                "title": "efficient-binary-search-solution-range-binary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] q) {\\n        int big = Arrays.stream(q).max().getAsInt();\\n        if(q.length == 1) return q[0];\\n        if(n == q.length) return big;\\n        int start = 1, end = big, ans = 0;\\n        while(start < end) {\\n            int mid = (start + end) >> 1;\\n            if(isPossible(q, n, mid)) {\\n                ans = mid;\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean isPossible(int[] q, int n, int check) {\\n        int total = 0;\\n        for(int val: q) {\\n            total += ((val - 1) + check) / check;\\n            if(total > n) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] q) {\\n        int big = Arrays.stream(q).max().getAsInt();\\n        if(q.length == 1) return q[0];\\n        if(n == q.length) return big;\\n        int start = 1, end = big, ans = 0;\\n        while(start < end) {\\n            int mid = (start + end) >> 1;\\n            if(isPossible(q, n, mid)) {\\n                ans = mid;\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean isPossible(int[] q, int n, int check) {\\n        int total = 0;\\n        for(int val: q) {\\n            total += ((val - 1) + check) / check;\\n            if(total > n) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287638,
                "title": "easy-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& nums) {\\n        int start=0;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(mid==0){\\n                ans=end;\\n                break;\\n            }\\n            int count=0;\\n            for(auto it:nums){\\n                count+=ceil(double(it)/double(mid));\\n            }\\n            if(count<=n){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& nums) {\\n        int start=0;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(mid==0){\\n                ans=end;\\n                break;\\n            }\\n            int count=0;\\n            for(auto it:nums){\\n                count+=ceil(double(it)/double(mid));\\n            }\\n            if(count<=n){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283175,
                "title": "best-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool feasible(int x,int n,vector<int>& quantities){\\n        int m=quantities.size(),count=0;\\n        for(int i=0;i<m;i++)\\n            count += ceil((double)quantities[i]/x);\\n        return count<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int ll=1,ul=1e5,mid=0,ans=0;\\n        while(ll<=ul){\\n            mid=(ll+ul)>>1;\\n            if(feasible(mid,n,quantities)){\\n                ul=mid-1;\\n                ans=mid;\\n            }\\n            else\\n                ll=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool feasible(int x,int n,vector<int>& quantities){\\n        int m=quantities.size(),count=0;\\n        for(int i=0;i<m;i++)\\n            count += ceil((double)quantities[i]/x);\\n        return count<=n;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int ll=1,ul=1e5,mid=0,ans=0;\\n        while(ll<=ul){\\n            mid=(ll+ul)>>1;\\n            if(feasible(mid,n,quantities)){\\n                ul=mid-1;\\n                ans=mid;\\n            }\\n            else\\n                ll=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283163,
                "title": "python-easy-to-understand-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        l, r = 1, max(quantities)\\n        ans = r\\n\\n        while l <= r:\\n            m = l + (r - l) // 2\\n            stores = 0\\n            for q in quantities:\\n                stores += ceil(q / m)\\n            if stores <= n:\\n                ans = min(ans, m)\\n                r = m - 1\\n            else:\\n                l = m + 1\\n    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        l, r = 1, max(quantities)\\n        ans = r\\n\\n        while l <= r:\\n            m = l + (r - l) // 2\\n            stores = 0\\n            for q in quantities:\\n                stores += ceil(q / m)\\n            if stores <= n:\\n                ans = min(ans, m)\\n                r = m - 1\\n            else:\\n                l = m + 1\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279563,
                "title": "binary-search-solution",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        sort(quantities.begin(),quantities.end());\\n        int ans=INT_MAX;\\n        int i=1, j=1e5;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            long long cnt=0;\\n            for(int it: quantities){\\n                if(it%mid==0){\\n                    cnt+=it/mid;\\n                }\\n                else cnt+=it/mid+1;\\n            }\\n            if(cnt<=n){\\n                ans=min(ans,mid);\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        sort(quantities.begin(),quantities.end());\\n        int ans=INT_MAX;\\n        int i=1, j=1e5;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            long long cnt=0;\\n            for(int it: quantities){\\n                if(it%mid==0){\\n                    cnt+=it/mid;\\n                }\\n                else cnt+=it/mid+1;\\n            }\\n            if(cnt<=n){\\n                ans=min(ans,mid);\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275477,
                "title": "java-easy-check-function-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int l=1,r=100000;\\n       \\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(check(quantities,mid,n))\\n            r=mid-1;\\n            else \\n            l=mid+1;\\n        }\\n        return l;\\n    }\\n    private boolean check(int arr[],int mid,int n){\\n        int c=0;\\n        for (int q : arr) {\\n            c += q / mid;\\n            if (q % mid != 0) c++;\\n        }\\n        return c<=n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        int l=1,r=100000;\\n       \\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(check(quantities,mid,n))\\n            r=mid-1;\\n            else \\n            l=mid+1;\\n        }\\n        return l;\\n    }\\n    private boolean check(int arr[],int mid,int n){\\n        int c=0;\\n        for (int q : arr) {\\n            c += q / mid;\\n            if (q % mid != 0) c++;\\n        }\\n        return c<=n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273761,
                "title": "c-easy-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int left=1, right=*max_element(quantities.begin(), quantities.end());\\n\\n        while(left<right){\\n            int cnt=0;\\n            int mid= left+(right-left)/2;\\n            for(auto i:quantities){\\n                cnt+= (i+mid-1)/mid;\\n            }\\n            if(cnt>n){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int left=1, right=*max_element(quantities.begin(), quantities.end());\\n\\n        while(left<right){\\n            int cnt=0;\\n            int mid= left+(right-left)/2;\\n            for(auto i:quantities){\\n                cnt+= (i+mid-1)/mid;\\n            }\\n            if(cnt>n){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273343,
                "title": "java-easy-solution-beats-99",
                "content": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n      int low = 1;\\n        int high = quantities[0];\\n        for(int quantity : quantities){\\n            if(high<quantity){\\n                high = quantity;\\n            }\\n        }\\n        while(low<high){\\n            int mid = low +(high - low)/2;\\n            if(func(quantities,mid,n)){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    private boolean func(int []quantities,int speed,int n){\\n        int c = 0;\\n        for(int quantity : quantities){\\n            c += (quantity -1)/speed + 1;\\n            if(c > n){\\n                return false;\\n            }\\n        }\\n        return true;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n      int low = 1;\\n        int high = quantities[0];\\n        for(int quantity : quantities){\\n            if(high<quantity){\\n                high = quantity;\\n            }\\n        }\\n        while(low<high){\\n            int mid = low +(high - low)/2;\\n            if(func(quantities,mid,n)){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    private boolean func(int []quantities,int speed,int n){\\n        int c = 0;\\n        for(int quantity : quantities){\\n            c += (quantity -1)/speed + 1;\\n            if(c > n){\\n                return false;\\n            }\\n        }\\n        return true;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271500,
                "title": "binary-search-easy-approach-for-begginers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(int maxi,vector<int>& q,int n){\\n        int count=0;\\n        for(auto x:q){\\n            count+=((x+maxi-1)/maxi);   //ceil(x/maxi)\\n        }\\n        if(count>n)    return false;    \\n        return true;        //MAXI CAN BE MINIMIZED\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size();\\n        auto mnmx=minmax_element(quantities.begin(),quantities.end());\\n        int l=1,h=*mnmx.second,ans=0;\\n        while(l<=h){\\n            int mid=(l+h)>>1;\\n            \\n            if(possible(mid,quantities,n)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(int maxi,vector<int>& q,int n){\\n        int count=0;\\n        for(auto x:q){\\n            count+=((x+maxi-1)/maxi);   //ceil(x/maxi)\\n        }\\n        if(count>n)    return false;    \\n        return true;        //MAXI CAN BE MINIMIZED\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size();\\n        auto mnmx=minmax_element(quantities.begin(),quantities.end());\\n        int l=1,h=*mnmx.second,ans=0;\\n        while(l<=h){\\n            int mid=(l+h)>>1;\\n            \\n            if(possible(mid,quantities,n)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271482,
                "title": "c-binary-search-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& quantities,int n,int mid) {\\n        int m=quantities.size();\\n        int sumQuantity=0;\\n        for (int i=0;i<m;i++) {\\n            sumQuantity+=ceil((double)quantities[i]/(double)mid);\\n            if (sumQuantity>n) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size();\\n        int l=1,r=*max_element(quantities.begin(),quantities.end());\\n        while (l<r) {\\n            int mid=(l+r)/2;\\n            if (isPossible(quantities,n,mid)) {\\n                r=mid;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& quantities,int n,int mid) {\\n        int m=quantities.size();\\n        int sumQuantity=0;\\n        for (int i=0;i<m;i++) {\\n            sumQuantity+=ceil((double)quantities[i]/(double)mid);\\n            if (sumQuantity>n) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int m=quantities.size();\\n        int l=1,r=*max_element(quantities.begin(),quantities.end());\\n        while (l<r) {\\n            int mid=(l+r)/2;\\n            if (isPossible(quantities,n,mid)) {\\n                r=mid;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271070,
                "title": "simple-binary-search-o-1-space-complexity-o-nlogn-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Need to find a minimum number which can give count equals n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMax value of ans can be the sum of all quantities and minimum value can be 1.\\nSo do binary search in min value and max value.\\nCheck if it can give a count of n.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(max(quantities)))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long right=0;\\n        for(auto i:quantities)\\n            right+=i;\\n        long long left=1;\\n        long long ans=right;\\n        while(left<=right)\\n        {\\n            long long mid=(left+right)/2;\\n            long long cnt=0;\\n            for(auto i:quantities)\\n                cnt+= (i/mid) +(i%mid!=0);\\n            if(cnt<=n)\\n            {\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else \\n                left=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        long long right=0;\\n        for(auto i:quantities)\\n            right+=i;\\n        long long left=1;\\n        long long ans=right;\\n        while(left<=right)\\n        {\\n            long long mid=(left+right)/2;\\n            long long cnt=0;\\n            for(auto i:quantities)\\n                cnt+= (i/mid) +(i%mid!=0);\\n            if(cnt<=n)\\n            {\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else \\n                left=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269847,
                "title": "binary-search-standard-problems-c",
                "content": "```\\n    bool f(vector<int>&vec,int n,int mid){\\n        int curr = 0;\\n        for(int i = 0;i<vec.size();i++){\\n            curr+=(ceil((float)vec[i]/mid));\\n        }\\n        return curr<=n;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& vec) {\\n        \\n        int low = 1;\\n        int high = *max_element(vec.begin(),vec.end());\\n        int ans;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(f(vec,n,mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    bool f(vector<int>&vec,int n,int mid){\\n        int curr = 0;\\n        for(int i = 0;i<vec.size();i++){\\n            curr+=(ceil((float)vec[i]/mid));\\n        }\\n        return curr<=n;\\n    }\\n    \\n    int minimizedMaximum(int n, vector<int>& vec) {\\n        \\n        int low = 1;\\n        int high = *max_element(vec.begin(),vec.end());\\n        int ans;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(f(vec,n,mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269165,
                "title": "easy-solution-binary-search-c",
                "content": "# Intuition\\nif we try to distribute the products one by one to the stores.then we can observe that either we can give all the products to an store or withhold some products so that we can give them to another shop.\\nwe will try to give as few as we can to a store at a certain amount.if we succesfully distribute all the given product(possibly 0) to all the stores.then we will try to reduce the quantity of products.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nlog(n) for the main fun every time we are calling stub function that will take O(n) so .\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int isPossible(vector<int> &arr,int mx){\\n        int stores = 0;\\n        for(auto i : arr)\\n        stores +=  (i + mx - 1) / mx;\\n       \\n        return stores;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& arr) {\\n       \\n       int low = 1;\\n       int high = 1e5;\\n       while(low <= high){\\n\\n           int mid = (low + high)/2;\\n           if(isPossible(arr,mid) <= n)\\n           high = mid-1;\\n           else \\n           low = mid+1;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int isPossible(vector<int> &arr,int mx){\\n        int stores = 0;\\n        for(auto i : arr)\\n        stores +=  (i + mx - 1) / mx;\\n       \\n        return stores;\\n    }\\n\\n    int minimizedMaximum(int n, vector<int>& arr) {\\n       \\n       int low = 1;\\n       int high = 1e5;\\n       while(low <= high){\\n\\n           int mid = (low + high)/2;\\n           if(isPossible(arr,mid) <= n)\\n           high = mid-1;\\n           else \\n           low = mid+1;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268882,
                "title": "c-easy-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& q,int n,int maxV)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            cnt+=ceil((double)q[i]/maxV);\\n        }\\n        if(cnt<=n)\\n        return true;\\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        sort(q.begin(),q.end());\\n        int l = 1;\\n        int r = q[q.size()-1];\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(solve(q,n,mid))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& q,int n,int maxV)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            cnt+=ceil((double)q[i]/maxV);\\n        }\\n        if(cnt<=n)\\n        return true;\\n        return false;\\n    }\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        sort(q.begin(),q.end());\\n        int l = 1;\\n        int r = q[q.size()-1];\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(solve(q,n,mid))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268679,
                "title": "easy-c-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& arr) {\\n        // minimum product that can be given to any store=1\\n        // maximum product that can be given to any store=max(arr)\\n        int start=1;\\n        int end=*max_element(arr.begin(),arr.end());\\n        int ans=INT_MAX;\\n        int mid;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(arr,n,mid)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,int &n,int &mid)\\n    {\\n        int c=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mid>0)\\n            {\\n                if(arr[i]%mid==0)\\n                {\\n                    c=c+(arr[i]/mid);\\n                }\\n                else\\n                {\\n                    c=c+((arr[i]/mid)+1);\\n                }\\n            }\\n        }\\n        if(c<=n)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& arr) {\\n        // minimum product that can be given to any store=1\\n        // maximum product that can be given to any store=max(arr)\\n        int start=1;\\n        int end=*max_element(arr.begin(),arr.end());\\n        int ans=INT_MAX;\\n        int mid;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(arr,n,mid)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,int &n,int &mid)\\n    {\\n        int c=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mid>0)\\n            {\\n                if(arr[i]%mid==0)\\n                {\\n                    c=c+(arr[i]/mid);\\n                }\\n                else\\n                {\\n                    c=c+((arr[i]/mid)+1);\\n                }\\n            }\\n        }\\n        if(c<=n)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268417,
                "title": "binary-search-on-answer-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& quantities,int mid,int n)\\n{\\n    int s=0;\\n    for(int i=0;i<quantities.size();i++)\\n    {\\n        s+=ceil(quantities[i]/(float)mid);\\n    }\\n    return s<=n;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low=1,high=1e5;\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check(quantities,mid,n))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& quantities,int mid,int n)\\n{\\n    int s=0;\\n    for(int i=0;i<quantities.size();i++)\\n    {\\n        s+=ceil(quantities[i]/(float)mid);\\n    }\\n    return s<=n;\\n}\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int low=1,high=1e5;\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check(quantities,mid,n))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267608,
                "title": "check-the-code-once-using-binary-search-shortest-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint is_possible(int mid,vector<int> &v,int k){\\n    int stalls=0;\\n    for(int i=0;i<v.size();i++){\\n       int x=v[i]/mid;\\n       int y=v[i]%mid;\\n       if(y==0){\\n        stalls+=x;\\n       }\\n       else{\\n        stalls+=x+1;\\n       }\\n    }\\n    return stalls<=k;\\n}\\n    int minimizedMaximum(int k, vector<int>& v) {\\n        long long end=0;\\n        int low=1;\\n int high=*max_element(v.begin(),v.end());\\n int ans=0;\\n while(low<=high){\\n    int mid=low+(high-low)/2;\\n    if(is_possible(mid,v,k)){\\n        ans=mid;\\n        high=mid-1;\\n    }\\n    else{\\n        low=mid+1;\\n    }\\n }\\n return ans; \\n    }\\n};\\n```\\n# \\uD83E\\uDD79Please upvote it really motivates\\uD83E\\uDD79\\n![image.png](https://assets.leetcode.com/users/images/fc9ede58-ba9b-4a14-88c1-42a82bc7078a_1678173388.6523368.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint is_possible(int mid,vector<int> &v,int k){\\n    int stalls=0;\\n    for(int i=0;i<v.size();i++){\\n       int x=v[i]/mid;\\n       int y=v[i]%mid;\\n       if(y==0){\\n        stalls+=x;\\n       }\\n       else{\\n        stalls+=x+1;\\n       }\\n    }\\n    return stalls<=k;\\n}\\n    int minimizedMaximum(int k, vector<int>& v) {\\n        long long end=0;\\n        int low=1;\\n int high=*max_element(v.begin(),v.end());\\n int ans=0;\\n while(low<=high){\\n    int mid=low+(high-low)/2;\\n    if(is_possible(mid,v,k)){\\n        ans=mid;\\n        high=mid-1;\\n    }\\n    else{\\n        low=mid+1;\\n    }\\n }\\n return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266985,
                "title": "binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int mx=*max_element(q.begin(),q.end());\\n        int l=1,h=mx,ans=0;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            int cur_max=0;\\n            for(int i=0;i<q.size();i++){\\n                cur_max+=(q[i]+mid-1)/mid;\\n            }\\n\\n            if(cur_max<=n){\\n                ans=mid;h=mid-1;\\n            }\\n            else{l=mid+1;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& q) {\\n        int mx=*max_element(q.begin(),q.end());\\n        int l=1,h=mx,ans=0;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            int cur_max=0;\\n            for(int i=0;i<q.size();i++){\\n                cur_max+=(q[i]+mid-1)/mid;\\n            }\\n\\n            if(cur_max<=n){\\n                ans=mid;h=mid-1;\\n            }\\n            else{l=mid+1;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243276,
                "title": "rust-easy-to-understand-clean-code-binary-search-o-nlogn",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimized_maximum(n: i32, quantities: Vec<i32>) -> i32 {\\n        let mut low: i32 = 1; // minimmum max value that any shop can take \\n        let mut high = *quantities.iter().max().unwrap(); // maximmmum max value that any shop can take\\n\\n        while low < high {\\n            let mut mid = (low + high) / 2;\\n            // sum of ceil divisions of q[i] / mid to get number of shops required to distribute all products\\n            // while keeping max quantity give to any store <= mid  \\n            if n >= quantities.clone().into_iter().map(| q | (q + mid - 1) / mid).sum::<i32>() {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        low\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimized_maximum(n: i32, quantities: Vec<i32>) -> i32 {\\n        let mut low: i32 = 1; // minimmum max value that any shop can take \\n        let mut high = *quantities.iter().max().unwrap(); // maximmmum max value that any shop can take\\n\\n        while low < high {\\n            let mut mid = (low + high) / 2;\\n            // sum of ceil divisions of q[i] / mid to get number of shops required to distribute all products\\n            // while keeping max quantity give to any store <= mid  \\n            if n >= quantities.clone().into_iter().map(| q | (q + mid - 1) / mid).sum::<i32>() {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        low\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243213,
                "title": "python-easy-to-understand-clean-code-binary-search-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        min_x = 1 # this could be the min value of max quantity any shop gets \\n        max_x = max(quantities) # or this could be it\\n        # our answer lies in the above range \\n\\n        # calculate the number of shops to distribute all products with each shop having <= max_quantity\\n        def can_distribute(max_q):\\n            # calculate number of shops to distribute each product and sum it\\n            return n >= sum([math.ceil(quantity / max_q) for quantity in quantities])\\n\\n        low, high = min_x, max_x\\n        while low < high:\\n            mid = (low + high) // 2\\n\\n            if can_distribute(mid):\\n            # maybe distributing minimizing maximmum even further gets us an answer too\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        min_x = 1 # this could be the min value of max quantity any shop gets \\n        max_x = max(quantities) # or this could be it\\n        # our answer lies in the above range \\n\\n        # calculate the number of shops to distribute all products with each shop having <= max_quantity\\n        def can_distribute(max_q):\\n            # calculate number of shops to distribute each product and sum it\\n            return n >= sum([math.ceil(quantity / max_q) for quantity in quantities])\\n\\n        low, high = min_x, max_x\\n        while low < high:\\n            mid = (low + high) // 2\\n\\n            if can_distribute(mid):\\n            # maybe distributing minimizing maximmum even further gets us an answer too\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232572,
                "title": "binary-search-c-solution",
                "content": "# Complexity\\n- Time complexity: O(size(quantities)*log(max_element(quantities)))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isPossible(vector<int>& quantities, int products, int remainingStores)\\n    {\\n        int stores=0;\\n        for(auto it: quantities)\\n        {\\n            int n=it/products;\\n            if(it%products==0) n--;\\n            stores+=n;\\n        }\\n        return stores<=remainingStores;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) \\n    {\\n        int remainingStores=n-quantities.size();\\n        int st=1, en=*max_element(quantities.begin(), quantities.end());\\n        while(st<=en)\\n        {\\n            int products=(st+en)/2;\\n            if(isPossible(quantities,products,remainingStores)) en=products-1;\\n            else st=products+1;\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isPossible(vector<int>& quantities, int products, int remainingStores)\\n    {\\n        int stores=0;\\n        for(auto it: quantities)\\n        {\\n            int n=it/products;\\n            if(it%products==0) n--;\\n            stores+=n;\\n        }\\n        return stores<=remainingStores;\\n    }\\n    int minimizedMaximum(int n, vector<int>& quantities) \\n    {\\n        int remainingStores=n-quantities.size();\\n        int st=1, en=*max_element(quantities.begin(), quantities.end());\\n        while(st<=en)\\n        {\\n            int products=(st+en)/2;\\n            if(isPossible(quantities,products,remainingStores)) en=products-1;\\n            else st=products+1;\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222519,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool Possible(vector<int> &quantities, int n, int cap){\\n        int cnt = 0;\\n        for(int it:quantities){\\n            if(it <= cap){\\n                cnt++;\\n            }\\n            else{\\n                cnt += ceil((float)it/cap);\\n            }\\n        }\\n        return cnt <= n;\\n    }\\n    int minimizedMaximum(int n, vector<int> &quantities) {\\n        int low = 1, high = 0;\\n        for(int it:quantities){\\n            high = max(high, it);\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(Possible(quantities, n, mid)){\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool Possible(vector<int> &quantities, int n, int cap){\\n        int cnt = 0;\\n        for(int it:quantities){\\n            if(it <= cap){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3222269,
                "title": "rust-binary-search-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimized_maximum(n: i32, quantities: Vec<i32>) -> i32 {\\n        // Implement a function canDistribute(k), which returns true\\n        // if you can distribute all products such that any store will not be given more than k products,\\n        // and returns false if you cannot. Use this function to binary search for the smallest possible k.\\n        fn can_distribute(k: i32, quantities: &[i32], n: i32) -> bool {\\n            let mut distributed_stores = 0;\\n            for &quantity in quantities {\\n                if quantity < k {\\n                    distributed_stores += 1;\\n                } else {\\n                    distributed_stores += quantity / k + if quantity % k == 0 { 0 } else { 1 };\\n                }\\n            }\\n            distributed_stores <= n\\n        }\\n        let mut ans = 0;\\n        let mut lo = 1;\\n        let mut hi = 1000000000;\\n        while lo <= hi {\\n            let mid = lo + (hi - lo) / 2;\\n            if can_distribute(mid, &quantities, n) {\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimized_maximum(n: i32, quantities: Vec<i32>) -> i32 {\\n        // Implement a function canDistribute(k), which returns true\\n        // if you can distribute all products such that any store will not be given more than k products,\\n        // and returns false if you cannot. Use this function to binary search for the smallest possible k.\\n        fn can_distribute(k: i32, quantities: &[i32], n: i32) -> bool {\\n            let mut distributed_stores = 0;\\n            for &quantity in quantities {\\n                if quantity < k {\\n                    distributed_stores += 1;\\n                } else {\\n                    distributed_stores += quantity / k + if quantity % k == 0 { 0 } else { 1 };\\n                }\\n            }\\n            distributed_stores <= n\\n        }\\n        let mut ans = 0;\\n        let mut lo = 1;\\n        let mut hi = 1000000000;\\n        while lo <= hi {\\n            let mid = lo + (hi - lo) / 2;\\n            if can_distribute(mid, &quantities, n) {\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221501,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\n\\nvar tryMaximum = function(max, n, quantities) {\\n    for (let i=0; i<quantities.length; i++) {\\n       n=n-Math.ceil(quantities[i]/max);\\n    }\\n    return n;\\n}\\n\\nvar minimizedMaximum = function(n, quantities) {\\n    var max = Math.max(...quantities);\\n    var min = 1;\\n    var sol = Math.ceil((max + min)/2);\\n    var foundSolution = tryMaximum(sol, n,quantities);\\n    while(min<max && foundSolution!==0) {   \\n        if(foundSolution<0) {\\n            min=sol+1;\\n        } else if(foundSolution>0)  {\\n           max=sol-1;\\n        }\\n        sol = Math.ceil((max + min) /2);  \\n        foundSolution = tryMaximum(sol, n,quantities);\\n    }\\n \\n    while(foundSolution==0) {\\n        sol--;\\n        foundSolution = tryMaximum(sol, n,quantities);\\n    }\\n    if (foundSolution<0) sol++;\\n    return sol;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} quantities\\n * @return {number}\\n */\\n\\nvar tryMaximum = function(max, n, quantities) {\\n    for (let i=0; i<quantities.length; i++) {\\n       n=n-Math.ceil(quantities[i]/max);\\n    }\\n    return n;\\n}\\n\\nvar minimizedMaximum = function(n, quantities) {\\n    var max = Math.max(...quantities);\\n    var min = 1;\\n    var sol = Math.ceil((max + min)/2);\\n    var foundSolution = tryMaximum(sol, n,quantities);\\n    while(min<max && foundSolution!==0) {   \\n        if(foundSolution<0) {\\n            min=sol+1;\\n        } else if(foundSolution>0)  {\\n           max=sol-1;\\n        }\\n        sol = Math.ceil((max + min) /2);  \\n        foundSolution = tryMaximum(sol, n,quantities);\\n    }\\n \\n    while(foundSolution==0) {\\n        sol--;\\n        foundSolution = tryMaximum(sol, n,quantities);\\n    }\\n    if (foundSolution<0) sol++;\\n    return sol;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219455,
                "title": "binary-search-answer-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// this questions is also be solved by binary search on answers , becuase we have to find least \\n// maximum of quanities which is given in quantity array , so we will use binary search on answer \\n// topic ; \\n\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        // now for binary search \\n\\n        // we need low and high . in this question low will be (sum / n) and high will be maximum value of quantities ; \\n\\n\\n         int sum = 0 ;\\n\\n         int high = Integer.MIN_VALUE ;\\n\\n          \\n\\n        for( int i = 0 ; i < quantities.length ; i++)\\n        {\\n              sum += quantities[i] ; \\n\\n              if(quantities[i] > high)\\n              high = quantities[i] ; \\n\\n        }\\n\\n      // high will be equal to maximum value of element in quantity because maximum this value can be given\\n      //to any shop kyonki 1 shop mein ek hi product type hona chahiye toh maximum quantity kisi bhi 1 product \\n      // type ki maximum value ke barabar hogi ;\\n\\n      // and low value will be equal to \\n\\n      int remainder = sum % n ; \\n       \\n       int low = sum/n ; \\n\\n       if( remainder != 0 )\\n       low++ ; \\n\\n\\n     int answer = -1 ;\\n\\n       while( low <= high)\\n       {\\n           int mid = (low + high)/2 ;\\n\\n           if( findAnswer(n , quantities , mid ) == true)\\n           {\\n               answer = mid ; \\n               high = mid-1 ; \\n           }\\n           else\\n           low = mid +1 ; \\n\\n       } \\n\\n\\n       return answer ; \\n\\n\\n\\n    }\\n    public boolean findAnswer( int n , int quantities[] , int capacity)\\n    {\\n         for( int i = 0 ; i < quantities.length ; i++)\\n         {\\n             if( n == 0 )\\n             return false ; \\n\\n             int temp = quantities[i] ; \\n\\n             int tempremainder = quantities[i] % capacity ;\\n\\n             int ans = quantities[i] / capacity ; \\n\\n             n = n - ans ; \\n\\n             if( n < 0)\\n             return false ; \\n\\n             if ( tempremainder != 0 )\\n             n-- ; \\n\\n             if( n < 0)\\n             return false ; \\n         }\\n\\n\\n          return true ; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// this questions is also be solved by binary search on answers , becuase we have to find least \\n// maximum of quanities which is given in quantity array , so we will use binary search on answer \\n// topic ; \\n\\nclass Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        // now for binary search \\n\\n        // we need low and high . in this question low will be (sum / n) and high will be maximum value of quantities ; \\n\\n\\n         int sum = 0 ;\\n\\n         int high = Integer.MIN_VALUE ;\\n\\n          \\n\\n        for( int i = 0 ; i < quantities.length ; i++)\\n        {\\n              sum += quantities[i] ; \\n\\n              if(quantities[i] > high)\\n              high = quantities[i] ; \\n\\n        }\\n\\n      // high will be equal to maximum value of element in quantity because maximum this value can be given\\n      //to any shop kyonki 1 shop mein ek hi product type hona chahiye toh maximum quantity kisi bhi 1 product \\n      // type ki maximum value ke barabar hogi ;\\n\\n      // and low value will be equal to \\n\\n      int remainder = sum % n ; \\n       \\n       int low = sum/n ; \\n\\n       if( remainder != 0 )\\n       low++ ; \\n\\n\\n     int answer = -1 ;\\n\\n       while( low <= high)\\n       {\\n           int mid = (low + high)/2 ;\\n\\n           if( findAnswer(n , quantities , mid ) == true)\\n           {\\n               answer = mid ; \\n               high = mid-1 ; \\n           }\\n           else\\n           low = mid +1 ; \\n\\n       } \\n\\n\\n       return answer ; \\n\\n\\n\\n    }\\n    public boolean findAnswer( int n , int quantities[] , int capacity)\\n    {\\n         for( int i = 0 ; i < quantities.length ; i++)\\n         {\\n             if( n == 0 )\\n             return false ; \\n\\n             int temp = quantities[i] ; \\n\\n             int tempremainder = quantities[i] % capacity ;\\n\\n             int ans = quantities[i] / capacity ; \\n\\n             n = n - ans ; \\n\\n             if( n < 0)\\n             return false ; \\n\\n             if ( tempremainder != 0 )\\n             n-- ; \\n\\n             if( n < 0)\\n             return false ; \\n         }\\n\\n\\n          return true ; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218122,
                "title": "very-simple-binary-search-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nWe need to try for numbers to find our answer . \\nAnd for that number we see if we can distribute all product \\nor not to all store .\\n```\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        // n store , m quan\\n        // minimize the maximum no of products\\n        // we are going to try numbers as our solution we can see here \\n        // n = 7 , qua[15,10,10]\\n        // for x quantity we have stores : 0 - inf , 1 - 35,\\n        // 2 - 18 , 3 - 13 , 4 - 10 , 5 - 7, 6- 7, 7- 7, 8- 6\\n        // so we can see here from 0 to some number the number of store we can give x products is decreasing and at some point we got n numbers of store so at that point we have to find minimum .\\n        // because we need to distribute all product\\n        int left = 1;\\n        int right = -1;\\n        if(n == 1) return quantities[0];\\n        for(int i: quantities) right = max(i,right);\\n        int ans = 1e9;\\n        while(left <= right){\\n            int mid = left + (right- left)/2;\\n            long long int st = 0;\\n            for(int i: quantities){\\n                st += i/mid + 1;\\n                if(i%mid == 0) st--;\\n            }\\n            if(st > n){\\n                // right\\n                left = mid+1;\\n            }else{\\n                ans = mid;\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nWe need to try for numbers to find our answer . \\nAnd for that number we see if we can distribute all product \\nor not to all store .\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        // n store , m quan\\n        // minimize the maximum no of products\\n        // we are going to try numbers as our solution we can see here \\n        // n = 7 , qua[15,10,10]\\n        // for x quantity we have stores : 0 - inf , 1 - 35,\\n        // 2 - 18 , 3 - 13 , 4 - 10 , 5 - 7, 6- 7, 7- 7, 8- 6\\n        // so we can see here from 0 to some number the number of store we can give x products is decreasing and at some point we got n numbers of store so at that point we have to find minimum .\\n        // because we need to distribute all product\\n        int left = 1;\\n        int right = -1;\\n        if(n == 1) return quantities[0];\\n        for(int i: quantities) right = max(i,right);\\n        int ans = 1e9;\\n        while(left <= right){\\n            int mid = left + (right- left)/2;\\n            long long int st = 0;\\n            for(int i: quantities){\\n                st += i/mid + 1;\\n                if(i%mid == 0) st--;\\n            }\\n            if(st > n){\\n                // right\\n                left = mid+1;\\n            }else{\\n                ans = mid;\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218006,
                "title": "simplest-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(int store,vector<int> quantities, int mid){\\n        int s =0;\\n        for(int temp:quantities)s+=(temp/mid) + ((temp%mid)!=0);\\n        return s<=store;\\n    }\\n\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int lo = 1,hi=0;\\n\\n        for(int i:quantities)hi= max(hi,i);\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n\\n            if(isPossible(n,quantities,mid))hi=mid-1;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(int store,vector<int> quantities, int mid){\\n        int s =0;\\n        for(int temp:quantities)s+=(temp/mid) + ((temp%mid)!=0);\\n        return s<=store;\\n    }\\n\\npublic:\\n    int minimizedMaximum(int n, vector<int>& quantities) {\\n        int lo = 1,hi=0;\\n\\n        for(int i:quantities)hi= max(hi,i);\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n\\n            if(isPossible(n,quantities,mid))hi=mid-1;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212016,
                "title": "binary-search-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n        def stores(value):\\n            store = 0\\n            for i in quantities:\\n                store += math.ceil(i / value)\\n                if store > n:\\n                    return False\\n            return True\\n        left, right = 1, max(quantities)\\n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n\\n            if stores(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n\\n        def stores(value):\\n            store = 0\\n            for i in quantities:\\n                store += math.ceil(i / value)\\n                if store > n:\\n                    return False\\n            return True\\n        left, right = 1, max(quantities)\\n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n\\n            if stores(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1825967,
                "content": [
                    {
                        "username": "daddysboiii",
                        "content": "Same as:  \"875. Koko Eating Bananas\""
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search!"
                    },
                    {
                        "username": "Atcoder_ADI",
                        "content": "Very easy ,just count no. of shops required to distribute quantities[i] by using binary search on space(1,max[quantities])."
                    },
                    {
                        "username": "rnikh",
                        "content": "Standard Problem!"
                    }
                ]
            },
            {
                "id": 1815725,
                "content": [
                    {
                        "username": "daddysboiii",
                        "content": "Same as:  \"875. Koko Eating Bananas\""
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search!"
                    },
                    {
                        "username": "Atcoder_ADI",
                        "content": "Very easy ,just count no. of shops required to distribute quantities[i] by using binary search on space(1,max[quantities])."
                    },
                    {
                        "username": "rnikh",
                        "content": "Standard Problem!"
                    }
                ]
            },
            {
                "id": 1968591,
                "content": [
                    {
                        "username": "daddysboiii",
                        "content": "Same as:  \"875. Koko Eating Bananas\""
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search!"
                    },
                    {
                        "username": "Atcoder_ADI",
                        "content": "Very easy ,just count no. of shops required to distribute quantities[i] by using binary search on space(1,max[quantities])."
                    },
                    {
                        "username": "rnikh",
                        "content": "Standard Problem!"
                    }
                ]
            },
            {
                "id": 1926212,
                "content": [
                    {
                        "username": "daddysboiii",
                        "content": "Same as:  \"875. Koko Eating Bananas\""
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search!"
                    },
                    {
                        "username": "Atcoder_ADI",
                        "content": "Very easy ,just count no. of shops required to distribute quantities[i] by using binary search on space(1,max[quantities])."
                    },
                    {
                        "username": "rnikh",
                        "content": "Standard Problem!"
                    }
                ]
            }
        ]
    }
]