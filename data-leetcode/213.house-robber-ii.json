[
    {
        "title": "House Robber II",
        "question_content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\nExample 2:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 1000",
        "solutions": [
            {
                "id": 59934,
                "title": "simple-ac-solution-in-java-in-o-n-with-explanation",
                "content": "Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.\\n    \\n    private int rob(int[] num, int lo, int hi) {\\n        int include = 0, exclude = 0;\\n        for (int j = lo; j <= hi; j++) {\\n            int i = include, e = exclude;\\n            include = e + num[j];\\n            exclude = Math.max(e, i);\\n        }\\n        return Math.max(include, exclude);\\n    }\\n\\nNow the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob *num[lo]* is entirely our choice. But, it is now constrained by whether *num[hi]* is robbed. \\n\\nHowever, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.\\n\\nFor example, 1 -> 2 -> 3 -> 1 becomes 2 -> 3 if 1 is not robbed.\\n\\nSince every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.\\n\\n    public int rob(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.\\n    \\n    private int rob(int[] num, int lo, int hi) {\\n        int include = 0, exclude = 0;\\n        for (int j = lo; j <= hi; j++) {\\n            int i = include, e = exclude;\\n            include = e + num[j];\\n            exclude = Math.max(e, i);\\n        }\\n        return Math.max(include, exclude);\\n    }\\n\\nNow the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob *num[lo]* is entirely our choice. But, it is now constrained by whether *num[hi]* is robbed. \\n\\nHowever, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.\\n\\nFor example, 1 -> 2 -> 3 -> 1 becomes 2 -> 3 if 1 is not robbed.\\n\\nSince every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.\\n\\n    public int rob(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59921,
                "title": "9-lines-0ms-o-1-space-c-solution",
                "content": "This problem is a little tricky at first glance. However, if you have finished the **House Robber** problem, this problem can simply  be **decomposed into two House Robber problems**. \\n    Suppose there are `n` houses, since house `0` and `n - 1` are now neighbors, we cannot rob them together and thus the solution is now the maximum of\\n\\n 1. Rob houses `0` to `n - 2`;\\n 2. Rob houses `1` to `n - 1`.\\n\\nThe code is as follows. Some edge cases (`n < 2`) are handled explicitly.\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int n = nums.size(); \\n            if (n < 2) return n ? nums[0] : 0;\\n            return max(robber(nums, 0, n - 2), robber(nums, 1, n - 1));\\n        }\\n    private:\\n        int robber(vector<int>& nums, int l, int r) {\\n            int pre = 0, cur = 0;\\n            for (int i = l; i <= r; i++) {\\n                int temp = max(pre + nums[i], cur);\\n                pre = cur;\\n                cur = temp;\\n            }\\n            return cur;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int n = nums.size(); \\n            if (n < 2) return n ? nums[0] : 0;\\n            return max(robber(nums, 0, n - 2), robber(nums, 1, n - 1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 59986,
                "title": "c-super-simple-0ms-solution-with-explanation",
                "content": "Since you cannot rob both the first and last house, just create two separate vectors, one excluding the first house, and another excluding the last house. The best solution generated from these two vectors using the original House Robber DP algorithm is the optimal one. \\n\\n    class Solution {\\n    public:\\n    \\n        int robOriginal(vector<int>& nums) {\\n            int a = 0, b = 0, res = 0;\\n            \\n            for(int i = 0; i < nums.size(); ++i){\\n                res = max(b + nums[i], a);\\n                b = a;\\n                a = res;\\n            }\\n            \\n            return res;\\n        }\\n    \\n        int rob(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            if(nums.size() == 1) return nums[0];\\n            \\n            vector<int> numsA(nums.begin() + 1, nums.end());\\n            vector<int> numsB(nums.begin(), nums.end()-1);\\n            \\n            return max(robOriginal(numsA), robOriginal(numsB));\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        int robOriginal(vector<int>& nums) {\\n            int a = 0, b = 0, res = 0;\\n            \\n            for(int i = 0; i < nums.size(); ++i){\\n                res = max(b + nums[i], a);\\n                b = a;\\n                a = res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 299071,
                "title": "python-o-n-time-o-1-space",
                "content": "Notice that the first house and the last house can not be both robbed, so we have rob(nums) = max(rob(nums[1:], nums[:-1]). Since there are no circles in both nums[1:] and nums[:-1], we can simply apply the answers from **House Rob**. https://leetcode.com/problems/house-robber/discuss/299056/Python-O(n)-time-O(1)-space-4-lines\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```\\n\\nSlicing a list is actually O(n) space in Python (thanks post2web for pointing out). In our case, nums[1:], nums[:-1] create copies, to avoid this, we can pass indices into the simple_rob function instead of sliced lists. Below is the less elegant, but true O(1) space solution:\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def simple_rob(nums, i, j):\\n            rob, not_rob = 0, 0\\n            for idx in range(i, j):\\n                num = nums[idx]\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            n = len(nums)\\n            return max(simple_rob(nums, 1, n), simple_rob(nums, 0, n-1))",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893957,
                "title": "python-just-use-house-robber-twice",
                "content": "This problem can be seen as follow-up question for problem **198. House Robber**. Imagine, that we can already solve this problem: for more detailes please see my post:\\nhttps://leetcode.com/problems/house-robber/discuss/846004/Python-4-lines-easy-dp-solution-explained\\n\\nNow, what we have here is circular pattern. Imagine, that we have `10` houses: `a0, a1, a2, a3, ... a9`: Then we have two possible options:\\n1. Rob house `a0`, then we can not rob `a0` or `a9` and we have `a2, a3, ..., a8` range to rob\\n2. Do not rob house `a0`, then we have `a1, a2, ... a9` range to rob.\\n\\nThen we just choose maximum of these two options and we are done!\\n\\n**Complexity**: time complexity is `O(n)`, because we use `dp` problem with complexity `O(n)` twice. Space complexity is `O(1)`, because in python lists passed by reference and space complexity of House Robber problem is `O(1)`.\\n\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        def rob_helper(nums):\\n            dp1, dp2 = 0, 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n            return dp2\\n    \\n        return max(nums[0] + rob_helper(nums[2:-1]), rob_helper(nums[1:]))\\n ```\\n \\n If you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        def rob_helper(nums):\\n            dp1, dp2 = 0, 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n            return dp2\\n    \\n        return max(nums[0] + rob_helper(nums[2:-1]), rob_helper(nums[1:]))\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 893946,
                "title": "c-super-simple-and-short-dp-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int houseRobber(vector<int>& nums) {\\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // either use first house and can\\'t use last or last and not first:\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(houseRobber(v1), houseRobber(v2));\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int houseRobber(vector<int>& nums) {\\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // either use first house and can\\'t use last or last and not first:\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(houseRobber(v1), houseRobber(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60044,
                "title": "good-performance-dp-solution-using-java",
                "content": "    public class Solution {\\n        public int rob(int[] nums) {\\n            if (nums.length == 0)\\n                return 0;\\n            if (nums.length < 2)\\n                return nums[0];\\n            \\n            int[] startFromFirstHouse = new int[nums.length + 1];\\n            int[] startFromSecondHouse = new int[nums.length + 1];\\n            \\n            startFromFirstHouse[0]  = 0;\\n            startFromFirstHouse[1]  = nums[0];\\n            startFromSecondHouse[0] = 0;\\n            startFromSecondHouse[1] = 0;\\n            \\n            for (int i = 2; i <= nums.length; i++) {\\n                startFromFirstHouse[i] = Math.max(startFromFirstHouse[i - 1], startFromFirstHouse[i - 2] + nums[i-1]);\\n                startFromSecondHouse[i] = Math.max(startFromSecondHouse[i - 1], startFromSecondHouse[i - 2] + nums[i-1]);\\n            }\\n            \\n            return Math.max(startFromFirstHouse[nums.length - 1], startFromSecondHouse[nums.length]);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int rob(int[] nums) {\\n            if (nums.length == 0)\\n                return 0;\\n            if (nums.length < 2)\\n                return nums[0];\\n            \\n            int[] startFromFirstHouse = new int[nums.length + 1];\\n            int[] startFromSecondHouse = new int[nums.length + 1];\\n            \\n            startFromFirstHouse[0]  = 0;\\n            startFromFirstHouse[1]  = nums[0];\\n            startFromSecondHouse[0] = 0;\\n            startFromSecondHouse[1] = 0;\\n            \\n            for (int i = 2; i <= nums.length; i++) {\\n                startFromFirstHouse[i] = Math.max(startFromFirstHouse[i - 1], startFromFirstHouse[i - 2] + nums[i-1]);\\n                startFromSecondHouse[i] = Math.max(startFromSecondHouse[i - 1], startFromSecondHouse[i - 2] + nums[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 894594,
                "title": "java-bottom-up-dp-explained-o-n-extra-space",
                "content": "The main point is that you **can\\'t rob both the first and last** houses.\\n\\nTherefore, the core idea is to **apply DP twice**: when you rob the first house, and when you don\\'t (you rob the last one).\\n\\n**The DP algorithm:**\\n\\n1. Iterate over houses\\n2. At *ith* house you have 2 options:\\n \\t- Keep the money from the *(i-1)th* (previous) house, skipping the *ith* house\\n \\t- Rob the *ith* house after the *(i-2)th* house, skipping the *(i-1)th*\\n 3. Choose the most profitable option (obviously)\\n 4. Return the sum you\\'ve got after the last house\\n \\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)    return nums[0];\\n        if(nums.length == 2)    return Math.max(nums[0], nums[1]);\\n        \\n        // 1st option: including the 1st and excluding the last house\\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        // 2nd option: excluding the 1st and including the last house\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        // Return the maximum of the two results\\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end){        \\n        if(start == end)    return nums[start];\\n        \\n        // Array to store the maximum sum at the current iteration\\n        // while traversing all houses\\n        int money[] = new int[nums.length];\\n        \\n        /* Base case */\\n        money[start] = nums[start];\\n        \\n        // At the 2nd house, we decide to rob\\n        // either the 1st house or the 2nd\\n        // This is the core idea of the transition function\\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n            /* At ith house we have two options:\\n             1. not rob it, keeping the money from the (i-1)th house\\n             2. rob it after the (i-2)th house, skipping the (i-1)th house\\n              We choose the one that gives the max amount */\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        // Return the sum that we have at the last house\\n        return money[end];\\n    }\\n}\\n```\\n\\nThis solution runs in O(n) because we make two passes over an array that is one item smaller than the input array.\\n\\nO(n) extra space is required to store the amount of money after each house",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)    return nums[0];\\n        if(nums.length == 2)    return Math.max(nums[0], nums[1]);\\n        \\n        // 1st option: including the 1st and excluding the last house\\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        // 2nd option: excluding the 1st and including the last house\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        // Return the maximum of the two results\\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end){        \\n        if(start == end)    return nums[start];\\n        \\n        // Array to store the maximum sum at the current iteration\\n        // while traversing all houses\\n        int money[] = new int[nums.length];\\n        \\n        /* Base case */\\n        money[start] = nums[start];\\n        \\n        // At the 2nd house, we decide to rob\\n        // either the 1st house or the 2nd\\n        // This is the core idea of the transition function\\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n            /* At ith house we have two options:\\n             1. not rob it, keeping the money from the (i-1)th house\\n             2. rob it after the (i-2)th house, skipping the (i-1)th house\\n              We choose the one that gives the max amount */\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        // Return the sum that we have at the last house\\n        return money[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227366,
                "title": "thinking-process-from-easy-question-to-harder-question-within-the-same-question-set",
                "content": "I notice there are already some easy to adapt solutions from House Robber I, just in case for someone who want to build a problem solving strategy about how to build the thinking process from easy question to harder question within the same question set.\\n\\n**First, find the difference:**\\nFrom HRI, we already have the solution to a non circular houses, meaning we don\\'t need to worry about the first and the last.\\nFor this problem, the only major thing that is different is that we have to worry about the first and the last. *You want the first, leave the last. You want the last, leave the first.*\\n\\n**Second, brainstorm possible solutions**\\n*If else?* That seems really intuitive, but it is hard to do so involving so many possibilities. \\n*Divide the array into left and right*, then we can check left and right at the same time, but this basically the same as the original, since we still need to worry about the new first and the new last.\\n.\\n.\\n.\\n**Third, refocus on the difference and think about why the previous algorithm fails**\\nIf we use the old algorithm, we just simply overcount, since the new situation will always face more limitations due to the circular structure. If we overcount, how about just substracting the overcounted value.\\n*The intuitive solution is just to subtract the first*, so that we will not overcount them when using the old algorithm.\\n\\n**Fourth, real solution emerges**\\nIf we just subtract the first, we will meet the situation that we will oversubtract values, since we will subtract the first even though we don\\'t want to rob the first. \\n*Pay attention to the difference again* : You want the first, leave the last. You want the last, leave the first.\\nNow, we know we need to distinguish **Rob the first or do not rob the first**\\nIf we rob the first: then we cannot rob the last, so nums[:-1]\\nif we do not rob the first, then we can rob the last, so nums[1:]\\nAnd the final answer is just max of them using the old algorithm.\\n\\nSo basically, first gather all the information you have, then distinguish the difference and why old algorithm fails, find the essense of the difference, in this case *You want the first, leave the last. You want the last, leave the first.*. Then, brainstorming possible solutions, through constant testing and refocus on the difference, the final answer will eventually emerge.\\n\\nNote 0 is including current value, 1 is excluding the current value\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:return nums[0]\\n        def recursion(nums):\\n            if not nums: return [0 for _ in range(2)]\\n            previous = recursion(nums[1:])\\n            res = [0 for _ in range(2)]\\n            res[0] = nums[0] + previous[1]\\n            res[1] = max(previous)\\n            return res\\n        return max(max(recursion(nums[:-1])), max(recursion(nums[1:])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:return nums[0]\\n        def recursion(nums):\\n            if not nums: return [0 for _ in range(2)]\\n            previous = recursion(nums[1:])\\n            res = [0 for _ in range(2)]\\n            res[0] = nums[0] + previous[1]\\n            res[1] = max(previous)\\n            return res\\n        return max(max(recursion(nums[:-1])), max(recursion(nums[1:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893953,
                "title": "python-very-simple-and-clean-dp-solution-faster-than-97",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def houseRobber(nums):\\n            # dynamic programming - decide each problem by its sub-problems:\\n            dp = [0]*len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2, len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n\\n            return dp[-1]\\n        \\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # either use first house and can\\'t use last or last and not first:\\n        return max(houseRobber(nums[:-1]), houseRobber(nums[1:]))\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def houseRobber(nums):\\n            # dynamic programming - decide each problem by its sub-problems:\\n            dp = [0]*len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2, len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n\\n            return dp[-1]\\n        \\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # either use first house and can\\'t use last or last and not first:\\n        return max(houseRobber(nums[:-1]), houseRobber(nums[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59944,
                "title": "twice-pass-solution-c",
                "content": "Twice pass:\\n\\n1. not rob nums[n-1]\\n2. not rob nums[0]\\n\\nand the other is same as [House Robber](https://leetcode.com/problems/house-robber/ ).\\n\\n    int rob(vector<int>& nums)\\n    {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        \\n        int pre1 = 0, cur1 = 0;\\n        for(int i = 0; i < nums.size() - 1; ++ i)\\n        {\\n            int temp = pre1;\\n            pre1 = cur1;\\n            cur1 = max(temp + nums[i], pre1);\\n        }\\n        \\n        int pre2 = 0, cur2 = 0;\\n        for(int i = 1; i < nums.size(); ++ i)\\n        {\\n            int temp = pre2;\\n            pre2 = cur2;\\n            cur2 = max(temp + nums[i], pre2);\\n        }\\n        \\n        return max(cur1, cur2);\\n    }",
                "solutionTags": [],
                "code": "Twice pass:\\n\\n1. not rob nums[n-1]\\n2. not rob nums[0]\\n\\nand the other is same as [House Robber](https://leetcode.com/problems/house-robber/ ).\\n\\n    int rob(vector<int>& nums)\\n    {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        \\n        int pre1 = 0, cur1 = 0;\\n        for(int i = 0; i < nums.size() - 1; ++ i)\\n        {\\n            int temp = pre1;\\n            pre1 = cur1;\\n            cur1 = max(temp + nums[i], pre1);\\n        }\\n        \\n        int pre2 = 0, cur2 = 0;\\n        for(int i = 1; i < nums.size(); ++ i)\\n        {\\n            int temp = pre2;\\n            pre2 = cur2;\\n            cur2 = max(temp + nums[i], pre2);\\n        }\\n        \\n        return max(cur1, cur2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1442044,
                "title": "python-bottom-up-dp-o-1-space-clean-concise",
                "content": "**Idea**\\n- Since the houses form a circle, so we need to avoid robbing on `house[0]` and `house[n-1]` together.\\n- So we divide 2 cases:\\n\\t- Case 1: Rob the maximum of amount money in `houses[0..n-2]`.\\n\\t- Case 2: Rob the maximum of amount money in `houses[1..n-1]`.\\n- To solve case 1, case 2, please check this solution [198. House Robber](https://leetcode.com/problems/house-robber/discuss/263528).\\n- Pick the maximum of amount money we can rob in case 1 and case 2.\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(left, right):\\n            dp, dp1, dp2 = 0, 0, 0\\n            for i in range(left, right+1):\\n                dp = max(dp1, dp2 + nums[i])\\n                dp2 = dp1\\n                dp1 = dp\\n            return dp1\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        return max(solve(0, n-2), solve(1, n-1))\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(left, right):\\n            dp, dp1, dp2 = 0, 0, 0\\n            for i in range(left, right+1):\\n                dp = max(dp1, dp2 + nums[i])\\n                dp2 = dp1\\n                dp1 = dp\\n            return dp1\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        return max(solve(0, n-2), solve(1, n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59929,
                "title": "java-clean-short-solution-dp",
                "content": "    public class Solution {\\n\\tpublic int rob(int[] nums) {\\n\\t\\treturn Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n\\t}\\n\\t\\n    public int rob(int[] nums, int lo, int hi) {\\n        int preRob = 0, preNotRob = 0, rob = 0, notRob = 0;\\n        for (int i = lo; i <= hi; i++) {\\n          \\trob = preNotRob + nums[i];\\n        \\tnotRob = Math.max(preRob, preNotRob);\\n        \\t\\n        \\tpreNotRob = notRob;\\n        \\tpreRob = rob;\\n        }\\n        return Math.max(rob, notRob);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic int rob(int[] nums) {\\n\\t\\treturn Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 59978,
                "title": "6-lines-function-body",
                "content": "Standard solution, I guess, except I take a shortcut for the one-house case.\\n\\n    class Solution:\\n        def rob(self, nums):\\n            def rob(nums):\\n                now = prev = 0\\n                for n in nums:\\n                    now, prev = max(now, prev + n), now\\n                return now\\n            return max(rob(nums[len(nums) != 1:]), rob(nums[:-1]))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Standard solution, I guess, except I take a shortcut for the one-house case.\\n\\n    class Solution:\\n        def rob(self, nums):\\n            def rob(nums):\\n                now = prev = 0\\n                for n in nums:\\n                    now, prev = max(now, prev + n), now\\n                return now\\n            return max(rob(nums[len(nums) != 1:]), rob(nums[:-1]))",
                "codeTag": "Java"
            },
            {
                "id": 182957,
                "title": "omg-super-simple-java-dp-solution-with-explanation",
                "content": "The only difference from [House Robber I](https://leetcode.com/problems/house-robber/description/) is that all the houses are in the circle here, which simply means **if you select the first one then you WON\\'T be able to select the last one since they are neignbors. Only when you NOT select the first one, you then COULD select the last one.** Hey, why don\\'t we break the circle => e.g. houses are [2,7,9,3,1],  if I select the first one (which has money 2), I don\\'t even care about the last one, question will become to rob [2,7,9,3] instead. Same, if we did not select first one, question becomes to rob [7,9,3,1], and the final result would be the larger result between them. OMG House Robber II really is want us to do [House Robber I](https://leetcode.com/problems/house-robber/description/)  twice! Take a look at my beating-100% [solution](https://leetcode.com/problems/house-robber/discuss/182943/Super-intuitive-Java-solution) for house robber, finish this up and move on to house robber III  !\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length==0) return 0;\\n        if (nums.length==1) return nums[0];\\n        int[] circutBreaker1 = Arrays.copyOfRange(nums, 0, nums.length-1);\\n        int[] circutBreaker2 = Arrays.copyOfRange(nums, 1, nums.length);\\n        return Math.max(robSub(circutBreaker1), robSub(circutBreaker2));\\n    }\\n    \\n    private int robSub(int[] nums) {\\n        int[] dp = new int[nums.length+2];\\n        dp[0]=0;\\n        dp[1]=0;\\n        for (int i=2; i<dp.length; i++) {\\n            dp[i]=Math.max(dp[i-2]+nums[i-2], dp[i-1]);\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length==0) return 0;\\n        if (nums.length==1) return nums[0];\\n        int[] circutBreaker1 = Arrays.copyOfRange(nums, 0, nums.length-1);\\n        int[] circutBreaker2 = Arrays.copyOfRange(nums, 1, nums.length);\\n        return Math.max(robSub(circutBreaker1), robSub(circutBreaker2));\\n    }\\n    \\n    private int robSub(int[] nums) {\\n        int[] dp = new int[nums.length+2];\\n        dp[0]=0;\\n        dp[1]=0;\\n        for (int i=2; i<dp.length; i++) {\\n            dp[i]=Math.max(dp[i-2]+nums[i-2], dp[i-1]);\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219244,
                "title": "c-dp-beats-100-space-optimization",
                "content": "# Intuition\\nWe know that the houses are arranged in a circle so the only difference between this question and \"HOUSE ROBBER I\" is that here you can\\'t take the first house if you have taken the last one, or vice-versa.\\n\\n# Approach\\nCreate 2 different vector, say v1 and v2.\\nvector v1 contains the 1st house but exclude the last house.\\nvector v2 contains the last house but excludes the first house.\\nreturn the max solution by v1 and v2.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums)\\n    {\\n        int n=nums.size();\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n\\n        for(int i=2;i<n;i++)\\n        {\\n           int curr=max(prev1,prev2+nums[i]);\\n           prev2=prev1;\\n           prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n         return nums[0];\\n        if(n==2)\\n         return max(nums[0],nums[1]);\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=0)\\n             v1.push_back(nums[i]);\\n            if(i!=nums.size()-1)\\n             v2.push_back(nums[i]);\\n        }\\n        int ans=max(solve(v1),solve(v2));\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/6e9307ea-d9cb-4d65-a377-ff7a5f24ec08_1677089524.1039042.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums)\\n    {\\n        int n=nums.size();\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n\\n        for(int i=2;i<n;i++)\\n        {\\n           int curr=max(prev1,prev2+nums[i]);\\n           prev2=prev1;\\n           prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n         return nums[0];\\n        if(n==2)\\n         return max(nums[0],nums[1]);\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=0)\\n             v1.push_back(nums[i]);\\n            if(i!=nums.size()-1)\\n             v2.push_back(nums[i]);\\n        }\\n        int ans=max(solve(v1),solve(v2));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682761,
                "title": "c-4-approaches-dp-memo-o-1-space-and-o-n-time",
                "content": "**RECURSIVE APPROACH -**         *(TIME - O(2^N) & AUXILIARY SPACE - O(N))*\\n```\\nclass Solution {\\nprivate:\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\\n\\n**MEMOIZATION -**  *(TIME - O(N) & SPACE - O(2N))*\\n```\\nclass Solution {\\nprivate:\\n    int dp[101][2];\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        if(dp[i][robFirst]!=-1) return dp[i][robFirst];\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return dp[i][robFirst] = max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof dp);\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\\n**TABULATION APPRAOCH -**  *(TIME - O(N) & SPACE - O(2N))*\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n+1], dp1[n+1];\\n        dp[0] = 0 ; \\n        dp[1] = nums[0];\\n        dp1[0] = 0;\\n        dp1[1] = 0;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i == n) dp[i] = dp[i-1];\\n            else dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n            dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i-1]);\\n        }  \\n        return max(dp[n], dp1[n]);\\n    }\\n};\\n```\\n**2 VARIABLE DP APPROACH -**  *(TIME - O(N) & SPACE - O(1))*\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int a1 = 0, b1 = nums[0], a2 = 0, b2 = 0, temp1, temp2;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i != n) {\\n                temp1 = b1;\\n                b1 = max(a1 + nums[i-1], b1);\\n                a1 = temp1;\\n            }\\n            temp2 = b2;\\n            b2 = max(a2 + nums[i-1], b2);\\n            a2 = temp2;\\n        }  \\n        return max(b1, b2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int dp[101][2];\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        if(dp[i][robFirst]!=-1) return dp[i][robFirst];\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return dp[i][robFirst] = max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof dp);\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n+1], dp1[n+1];\\n        dp[0] = 0 ; \\n        dp[1] = nums[0];\\n        dp1[0] = 0;\\n        dp1[1] = 0;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i == n) dp[i] = dp[i-1];\\n            else dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n            dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i-1]);\\n        }  \\n        return max(dp[n], dp1[n]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int a1 = 0, b1 = nums[0], a2 = 0, b2 = 0, temp1, temp2;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i != n) {\\n                temp1 = b1;\\n                b1 = max(a1 + nums[i-1], b1);\\n                a1 = temp1;\\n            }\\n            temp2 = b2;\\n            b2 = max(a2 + nums[i-1], b2);\\n            a2 = temp2;\\n        }  \\n        return max(b1, b2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523568,
                "title": "one-pass-simple-solution-c-python",
                "content": "If you have already solved the problem [House Robber I](/https://leetcode.com/problems/house-robber//), then it\\'s just an extension to it.\\n\\nAs houses are circular and we cannot rob house 1 and n together, so we have 2 choices:\\n\\n**1> Rob houses from 1 to n-1\\n2> Rob houses from 2 to n**\\n\\nHere we can use two dp arrays to store the maximum profit for these two cases like this:\\n\\n<br>\\n\\n# C++ code:\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n\\t\\t// dp1 -> 1 to n-1\\n\\t\\t// dp2 -> 2 to n\\n\\t\\t\\n        int dp1[n], dp2[n];\\n\\t\\t\\n\\t\\t// if we have robbed the first house, then we can\\'t rob the second house\\n        dp1[0] = nums[0];\\n        dp1[1] = nums[0];\\n\\t\\t\\n\\t\\t// if we didn\\'t rob the first house, we will definetely rob the second\\n        dp2[0] = 0;\\n        dp2[1] = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n\\t\\t\\n\\t\\t\\t// make optimal choice at each house\\n            dp1[i] = max(nums[i] + dp1[i-2], dp1[i-1]);\\n            dp2[i] = max(nums[i] + dp2[i-2], dp2[i-1]);\\n        }\\n        \\n\\t\\t// dp1 is for nums[1 - (n-1)] so we won\\'t consider the last house in this case and dp1[n-2] will be max profit\\n\\t\\t// and dp2 is for nums[2 - n] so we can take the last house\\n        return max(dp1[n-2], dp2[n-1]);\\n    }\\n};\\n```\\n<br>\\n\\n# Python code:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        if n == 2: return max(nums[0], nums[1])\\n        \\n        dp1, dp2 = [0] * n, [0] * n\\n        \\n        dp1[0] = nums[0]\\n        dp1[1] = nums[0]\\n        dp2[0] = 0\\n        dp2[1] = nums[1]\\n        \\n        for i in range(2, n):\\n            dp1[i] = max(nums[i] + dp1[i - 2], dp1[i - 1])\\n            dp2[i] = max(nums[i] + dp2[i - 2], dp2[i - 1])\\n        \\n        return max(dp1[n - 2], dp2[n - 1])\\n```\\n\\n<br>**Felt happy for the first time after helping a robber (Though that doesn\\'t mean I\\'ve helped any other robber before  )**<br>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n\\t\\t// dp1 -> 1 to n-1\\n\\t\\t// dp2 -> 2 to n\\n\\t\\t\\n        int dp1[n], dp2[n];\\n\\t\\t\\n\\t\\t// if we have robbed the first house, then we can\\'t rob the second house\\n        dp1[0] = nums[0];\\n        dp1[1] = nums[0];\\n\\t\\t\\n\\t\\t// if we didn\\'t rob the first house, we will definetely rob the second\\n        dp2[0] = 0;\\n        dp2[1] = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n\\t\\t\\n\\t\\t\\t// make optimal choice at each house\\n            dp1[i] = max(nums[i] + dp1[i-2], dp1[i-1]);\\n            dp2[i] = max(nums[i] + dp2[i-2], dp2[i-1]);\\n        }\\n        \\n\\t\\t// dp1 is for nums[1 - (n-1)] so we won\\'t consider the last house in this case and dp1[n-2] will be max profit\\n\\t\\t// and dp2 is for nums[2 - n] so we can take the last house\\n        return max(dp1[n-2], dp2[n-1]);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        if n == 2: return max(nums[0], nums[1])\\n        \\n        dp1, dp2 = [0] * n, [0] * n\\n        \\n        dp1[0] = nums[0]\\n        dp1[1] = nums[0]\\n        dp2[0] = 0\\n        dp2[1] = nums[1]\\n        \\n        for i in range(2, n):\\n            dp1[i] = max(nums[i] + dp1[i - 2], dp1[i - 1])\\n            dp2[i] = max(nums[i] + dp2[i - 2], dp2[i - 1])\\n        \\n        return max(dp1[n - 2], dp2[n - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230657,
                "title": "python-solution",
                "content": "Since `nums[0]` and `nums[-1]` cannot be robbed simultaneously, The robber has to rob houses in `nums[:-1]` or in `nums[1:]`, whichever is larger. Therefore, the problem reduces to two LC 198. House Robber I problems, which have already been solved. \\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        rec = curr_max\\n        \\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1, 0, -1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        return max(rec, curr_max)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        rec = curr_max\\n        \\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1, 0, -1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        return max(rec, curr_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767457,
                "title": "java-dp-step-by-step-house-robber-i-ii-noobs-whiteboarding",
                "content": "Lets start this problem by solving it with a naive approach and incrementally optimize it and make it as an efficient one. Writing this post to share my understanding on dynamic programming.\\n\\n\\n**House Robber**\\n\\nThe problem requests you to find the maximum sum that you can obtain with elements that will be selected where they are not next to each other. \\nLets take the below array of three elements to solve the problem\\nnums => [5,3,4]\\nWe are given options to choose either the ith + i-2th element or i-1th element. \\nIf we say i=2 (nums.length-1)\\nThen max(nums[i-2]+nums[i],nums[i-1]) => max value of the array.\\n\\nLets start the problem with the above intuition with a larger array [5,3,4,15,6] . \\n\\n\\n```\\npublic int rob(int[] nums) {\\n\\treturn naive(nums,nums.length-1);\\n\\t}\\n    \\npublic int naive(int[] nums,int i){\\n\\tif(i<0)\\n\\t\\treturn 0;\\n\\tint select=naive(nums,i-2)+nums[i];\\n\\tint p_select=naive(nums,i-1);\\n\\treturn Math.max(select,p_select);\\n\\t}\\n\\t\\n```\\n\\nThe above program recursion steps will be as below. The repesentation of numbers 0,1,2,3,4 represents the index i.\\n\\n![image](https://assets.leetcode.com/users/images/e44f65f7-635f-45b9-a8e3-2d0764da992f_1596311359.3493848.png)\\n\\n\\nNow if we observe the recursion tree there were repeated calls made for indexes 0,1,2. We can avoid them by storing the solution that we obtain in their appropriate index in a cache array.\\n\\n![image](https://assets.leetcode.com/users/images/6ef29d33-4e1b-49a2-9008-9b5db480b0ad_1596311660.058376.png)\\n\\nTime Complexity : O(2^n) \\nSpace Complexity : O(1) If we consider stack space it will be O(n)\\nI have avoided the recursion calls in the above images that yields value of i <1 but those calls will be made which yields time complexity to 2^n\\n\\nIntroducing Cache Layer in the recursive approach saves the additional iterations made\\n\\n```\\npublic int rob(int[] nums) {        \\n        int[] cache=new int[nums.length];\\n        return dp(nums,nums.length-1,cache);\\n    }\\n    \\npublic int naive(int[] nums,int i,int[] cache){\\n        if(i<0)\\n            return 0;\\n        if(cache[i]!=0)\\n            return cache[i];\\n        int select=dp(nums,i-2,cache)+nums[i];\\n        int p_select=dp(nums,i-1,cache);\\n        return Math.max(select,p_select);\\n    }\\n```\\n\\nNow we can transform the above approach to top down hence rewriting the above code in top down approach is given below.\\n\\n```\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        int[] cache=new int[nums.length];\\n        cache[0]=nums[0];\\n        cache[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            cache[i]=cache[i-2]+nums[i];\\n            cache[i]=Math.max(cache[i],cache[i-1]);\\n        }\\n        return cache[nums.length-1];\\n    }\\n```\\nTime Complexity : O(n) \\nSpace Complexity : O(n) \\n\\n\\nIf we observe the approach above all we are looking for is to just track two values of cache eithe it will be cache[i-1] or cache[i-2] + nums[i]. Hence we dont need this additonal memory to find out the max amount/sum the robber can steal.\\n\\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];        \\n        int first=nums[0];\\n        int second=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```\\n\\nTime Complexity : O(n) \\nSpace Complexity : O(1) \\n\\nIn the above approach we declare two variables first and second to capture the first value and max of first and second value in the array respectively. This yields to track always the max of nums[i-2]+nums[i] in second variable and nums[i-1] in first variable.\\n\\nIf you have taken time to reach here with this post i assume you got an understanding of the problem approach on implementing dp and the next problem on House Robber II can be solved very easily. \\n\\n**House Robber II**\\nThe approch to solve this problem is same as House Robber but the only restriction is to consider either the first or the last house to account for the max value the robber can steal from houses. Considering this condition and applying it to the problem must be straight forward by selecting the first index and skipping the last one or skipping the first index and selecting the last one.\\n\\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        return Math.max(dp(nums,0,nums.length-2),dp(nums,1,nums.length-1));\\n    }\\n    \\n    public int dp(int[] nums,int start,int end){\\n        int first=nums[start];\\n        int second=Math.max(nums[start],nums[start+1]);\\n        for(int i=start+2;i<=end;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```\\n\\nTime Complexity : O(n) \\nSpace Complexity : O(1) \\n\\nYou can write much concise code from the above suggested solutions but I have explained it in detail so that people who are starting to understand the basics of DP might understand better.\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int rob(int[] nums) {\\n\\treturn naive(nums,nums.length-1);\\n\\t}\\n    \\npublic int naive(int[] nums,int i){\\n\\tif(i<0)\\n\\t\\treturn 0;\\n\\tint select=naive(nums,i-2)+nums[i];\\n\\tint p_select=naive(nums,i-1);\\n\\treturn Math.max(select,p_select);\\n\\t}\\n\\t\\n```\n```\\npublic int rob(int[] nums) {        \\n        int[] cache=new int[nums.length];\\n        return dp(nums,nums.length-1,cache);\\n    }\\n    \\npublic int naive(int[] nums,int i,int[] cache){\\n        if(i<0)\\n            return 0;\\n        if(cache[i]!=0)\\n            return cache[i];\\n        int select=dp(nums,i-2,cache)+nums[i];\\n        int p_select=dp(nums,i-1,cache);\\n        return Math.max(select,p_select);\\n    }\\n```\n```\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        int[] cache=new int[nums.length];\\n        cache[0]=nums[0];\\n        cache[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            cache[i]=cache[i-2]+nums[i];\\n            cache[i]=Math.max(cache[i],cache[i-1]);\\n        }\\n        return cache[nums.length-1];\\n    }\\n```\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];        \\n        int first=nums[0];\\n        int second=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        return Math.max(dp(nums,0,nums.length-2),dp(nums,1,nums.length-1));\\n    }\\n    \\n    public int dp(int[] nums,int start,int end){\\n        int first=nums[start];\\n        int second=Math.max(nums[start],nums[start+1]);\\n        for(int i=start+2;i<=end;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482985,
                "title": "javascript-easy-solution",
                "content": "```javascript\\nvar rob = function(nums) {\\n    if (nums.length < 2) {\\n        return nums[0] || 0;\\n    }\\n    \\n    const memo1 = [nums[0]];\\n    const memo2 = [0, nums[1]];\\n    \\n    for (let i=1; i<nums.length - 1; i++) {\\n        memo1[i] = Math.max(nums[i] + (memo1[i - 2] || 0), memo1[i - 1]);\\n    }\\n    \\n    for (let i=2; i<nums.length; i++) {\\n        memo2[i] = Math.max(nums[i] + memo2[i - 2], memo2[i - 1]);\\n    }\\n    \\n    return Math.max(memo1.pop(), memo2.pop());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar rob = function(nums) {\\n    if (nums.length < 2) {\\n        return nums[0] || 0;\\n    }\\n    \\n    const memo1 = [nums[0]];\\n    const memo2 = [0, nums[1]];\\n    \\n    for (let i=1; i<nums.length - 1; i++) {\\n        memo1[i] = Math.max(nums[i] + (memo1[i - 2] || 0), memo1[i - 1]);\\n    }\\n    \\n    for (let i=2; i<nums.length; i++) {\\n        memo2[i] = Math.max(nums[i] + memo2[i - 2], memo2[i - 1]);\\n    }\\n    \\n    return Math.max(memo1.pop(), memo2.pop());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60020,
                "title": "jave-o-1-space-o-n-time-optimal-solution",
                "content": "Helper method returns DP solution from 0 - n-2  and 1 - n-1. Final answer is the max between two. \\n\\n \\n\\n      public class Solution {\\n            public int rob(int[] nums) {\\n                if (nums == null || nums.length == 0)\\n                    return 0;\\n                int n = nums.length;\\n                if (n == 1) {\\n                    return nums[0];\\n                }\\n                return Math.max(robHelper(nums, 0, n - 2), robHelper(nums, 1, n - 1));\\n            }\\n            \\n            private int robHelper(int[] nums, int start, int end) {\\n                int curr, prev, prev2;\\n                curr = prev = prev2 = 0;\\n                for (int i = start; i <= end; i++) {\\n                    curr = Math.max(prev2 + nums[i], prev);\\n                    prev2 = prev;\\n                    prev = curr;\\n                }\\n                return curr;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public int rob(int[] nums) {\\n                if (nums == null || nums.length == 0)\\n                    return 0;\\n                int n = nums.length;\\n                if (n == 1) {\\n                    return nums[0];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 667454,
                "title": "python-explanation-with-very-simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. Only 2 scenarios possible \\n        ##     a) Rob 1st and donot rob last \\n        ##     b) Rob last and donot rob first. \\n        ## We take maximum of both cases.\\n        \\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def house_robber(nums):\\n            dp = [0] * len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2,len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n            return max(dp[-1], dp[-2])\\n        \\n        if len(nums) <=2 : return max([0] + nums)\\n        return max( house_robber(nums[1:]), house_robber(nums[:-1]) )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. Only 2 scenarios possible \\n        ##     a) Rob 1st and donot rob last \\n        ##     b) Rob last and donot rob first. \\n        ## We take maximum of both cases.\\n        \\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def house_robber(nums):\\n            dp = [0] * len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2,len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n            return max(dp[-1], dp[-2])\\n        \\n        if len(nums) <=2 : return max([0] + nums)\\n        return max( house_robber(nums[1:]), house_robber(nums[:-1]) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057642,
                "title": "beats-100-in-time-memoized-solution-explained",
                "content": "**Recursive Solution**\\n\\nThe selection can be done in two ways-\\n1. If nums[0] is selected, we can\\'t select nums[1]. Hence the call is made to nums[2]. \\n\\t*Also, there is an additional restriction that the list is circular. So the last element can also not be selected if the first element is selected. Hence, in the solve function, a first flag is maintained to denote if the first element is selected or not.*\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums, int n, int i, bool first)\\n    {\\n\\t\\n        if(i>=n)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t// If we have to decide for the last element, check if first element is selected or not.\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        \\n\\t\\t// At current position ,we have the same two options again\\n        int a = nums[i]+solve(nums, n, i+2, first);\\n        int b = solve(nums, n, i+1, first);\\n\\t\\t// Return maximum of both combinations\\n        return max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n\\t\\t\\t\\n\\t\\t// Return max of values starting selection from first or second element\\n        return max(nums[0]+solve(nums, n, 2, true), solve(nums, n, 1, false));\\n    }\\n};\\n```\\n\\n**Memoized Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int n, int i, bool first, vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(dp[i][first]!=-1)\\n            return dp[i][first];\\n        int a = nums[i]+solve(nums, n, i+2, first, dp);\\n        int b = solve(nums, n, i+1, first, dp);\\n        return dp[i][first]=max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        if(n==1)\\n            return nums[0];\\n        return max(nums[0]+solve(nums, n, 2, true, dp), solve(nums, n, 1, false, dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums, int n, int i, bool first)\\n    {\\n\\t\\n        if(i>=n)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t// If we have to decide for the last element, check if first element is selected or not.\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        \\n\\t\\t// At current position ,we have the same two options again\\n        int a = nums[i]+solve(nums, n, i+2, first);\\n        int b = solve(nums, n, i+1, first);\\n\\t\\t// Return maximum of both combinations\\n        return max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n\\t\\t\\t\\n\\t\\t// Return max of values starting selection from first or second element\\n        return max(nums[0]+solve(nums, n, 2, true), solve(nums, n, 1, false));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int n, int i, bool first, vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(dp[i][first]!=-1)\\n            return dp[i][first];\\n        int a = nums[i]+solve(nums, n, i+2, first, dp);\\n        int b = solve(nums, n, i+1, first, dp);\\n        return dp[i][first]=max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        if(n==1)\\n            return nums[0];\\n        return max(nums[0]+solve(nums, n, 2, true, dp), solve(nums, n, 1, false, dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354170,
                "title": "c-recursion-memoization-tabulation-space-optimization",
                "content": "***This question is the slight modification of the [House Robber-198](https://leetcode.com/problems/house-robber/) .***\\n\\n# Method-1[Recursion - Bruteforce]\\n![image](https://assets.leetcode.com/users/images/8a38320b-73ca-4e58-b17b-4be4812cf9ca_1659165415.5374784.png)\\n\\n***This gives TLE!***\\n**n==number of nodes in the Recursion Tree\\nT->O(2^n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxsum(int i,vector<int>& nums){\\n\\t\\t\\tif(i<0)return 0;\\n\\t\\t\\tint pick=nums[i]+maxsum(i-2,nums);\\n\\t\\t\\tint notpick=maxsum(i-1,nums);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(maxsum(n-2,nums1),maxsum(n-2,nums2)); \\n\\t\\t}\\n\\t};\\n\\t\\n# Method-2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/da4beb7a-7b1d-4a8d-b21c-2fae3d4769a7_1659165893.5073082.png)\\n\\n**n==nums,size()\\nT->O(n) && S->O(n) [Recursion Stack space]+O(n) [Space for dp array]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxsum(int i,vector<int>& nums,vector<int>& dp){\\n\\t\\t\\tif(i<0)return 0;\\n\\t\\t\\tif(dp[i]!=-1)return dp[i];\\n\\t\\t\\tint pick=nums[i]+maxsum(i-2,nums,dp);\\n\\t\\t\\tint notpick=maxsum(i-1,nums,dp);\\n\\t\\t\\treturn dp[i]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2,dp1(n-1,-1),dp2(n-1,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(maxsum(n-2,nums1,dp1),maxsum(n-2,nums2,dp2)); \\n\\t\\t}\\n\\t};\\n\\t\\n# Method-3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/251b3c0f-a82a-4cf2-ab31-c3bc9adfd963_1659167767.8728886.png)\\n\\n**Tabulation is bottom-up**\\n**n==nums.size()\\nT->O(n) && S->O(n) [Space for dp array]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2,dp1(n-1),dp2(n-1);\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tdp1[0]=nums1[0];\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tint pick=nums1[i];\\n\\t\\t\\t\\tif(i!=1)pick+=dp1[i-2];\\n\\t\\t\\t\\tint notpick=dp1[i-1];\\n\\t\\t\\t\\tdp1[i]=max(pick,notpick);\\n\\t\\t\\t}\\n\\t\\t\\tdp2[0]=nums2[0];\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tint pick=nums2[i];\\n\\t\\t\\t\\tif(i!=1)pick+=dp2[i-2];\\n\\t\\t\\t\\tint notpick=dp2[i-1];\\n\\t\\t\\t\\tdp2[i]=max(pick,notpick);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(dp1[n-2],dp2[n-2]); \\n\\t\\t}\\n\\t};\\n\\t\\n# Method-4 [Space Optimization]\\n\\n![image](https://assets.leetcode.com/users/images/a7f89487-0be5-450c-8adb-16874f1aac73_1659169357.2019129.png)\\n\\n**n==nums.size()\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum(int i,vector<int>& nums){\\n\\t\\t\\tint p1=nums[0],p2;\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tint pick=nums[i];\\n\\t\\t\\t\\tif(i!=1)pick+=p2;\\n\\t\\t\\t\\tint notpick=p1;\\n\\t\\t\\t\\tint curri=max(pick,notpick);\\n\\t\\t\\t\\tp2=p1;\\n\\t\\t\\t\\tp1=curri;\\n\\t\\t\\t}\\n\\t\\t\\treturn p1;\\n\\t\\t}\\n\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2,dp1(n-1),dp2(n-1);\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(sum(n-2,nums1),sum(n-2,nums2)); \\n\\t\\t}\\n\\t};\\n\\n\\t\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxsum(int i,vector<int>& nums){\\n\\t\\t\\tif(i<0)return 0;\\n\\t\\t\\tint pick=nums[i]+maxsum(i-2,nums);\\n\\t\\t\\tint notpick=maxsum(i-1,nums);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 893903,
                "title": "house-robber-ii-java-c-kotlin-o-n-time-o-1-space",
                "content": "For a circle case, in order to make sure don\\'t rob both the first and the last houses, we can seperate it to 2 linear cases and find the max.  Let\\'s say there are n houses and there will two cases:\\n\\n1. Rob the first house.  So can\\'t rob the last one.  That is rob from 0 to n-2 houses\\n1. Don\\'t rob the first house and can rob the last one.  That is rob from 1 to n-1 houses. \\n1. The result must be one of them.  Let\\'s get the max of 1 and 2\\n\\nNext, how to rob a linear houses with size n. This is **House Robber** (leetcode 191).  Assume that we have an array profits of size n.  **profit[i]** is the the maximum amount of money you can rob from house 0 to house i.   For the i+1th house, we have \\n\\n**profit[i+1] = max( profit[i-1] + nums[i+1], profits[i])** \\n\\nSo we can have a stardard dp solution. \\n\\nThis solution is for the linear case and **NOT** for this question.  Have to add this since there are complains about it doesn\\'t work.  I add this soluton so we can find and understand the optimized solution.  \\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return nums[0];\\n        int[] profit = new int[n];\\n        profit[0] = nums[0];\\n        profit[1] = Math.max(nums[0], nums[1]);\\n        for (int i = 2; i < n; i++)\\n        {\\n            profit[i] = Math.max(profit[i-2] + nums[i], profit[i-1]);\\n        }\\n        return profit[n-1];\\n    }\\n}\\n```\\n\\nThe space complexity for this is O(N).  Notice that each profit only depends on **the previous two values(dark green)**.  So we only need two variable for that.  Now we can have a space **O(1)** solution.  The follow solutions are Time **O(N)** Space **O(1)** solutions. \\n\\n![image](https://assets.leetcode.com/users/images/ce31152b-5a4f-450e-ab75-00219b581fa1_1602662738.7130792.png)\\n\\n\\nIf you like it, please upvote it. Thanks.\\n\\n**java**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length ==1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n    }\\n    private int rob(int[]nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() ==1) return nums[0];\\n        return max(rob(nums, 0, nums.size()-2), rob(nums, 1, nums.size()-1));\\n    }\\nprivate:\\n    int rob(vector<int>&nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n};\\n```\\n\\n**kotlin**\\n```\\nclass Solution {\\n    fun rob(nums: IntArray): Int {\\n        if (nums.size == 1) return nums[0]\\n        return Math.max(rob(nums, 0, nums.size-2), rob(nums, 1, nums.size-1))\\n    }\\n    private fun rob(nums: IntArray, start: Int, end: Int): Int\\n    {\\n        var a = 0\\n        var b = 0\\n        for (i in start..end)\\n        {\\n            var temp: Int = b\\n            if (a + nums[i] > b)\\n            {\\n                b = a + nums[i]\\n            }\\n            a = temp\\n        }\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return nums[0];\\n        int[] profit = new int[n];\\n        profit[0] = nums[0];\\n        profit[1] = Math.max(nums[0], nums[1]);\\n        for (int i = 2; i < n; i++)\\n        {\\n            profit[i] = Math.max(profit[i-2] + nums[i], profit[i-1]);\\n        }\\n        return profit[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length ==1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n    }\\n    private int rob(int[]nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() ==1) return nums[0];\\n        return max(rob(nums, 0, nums.size()-2), rob(nums, 1, nums.size()-1));\\n    }\\nprivate:\\n    int rob(vector<int>&nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun rob(nums: IntArray): Int {\\n        if (nums.size == 1) return nums[0]\\n        return Math.max(rob(nums, 0, nums.size-2), rob(nums, 1, nums.size-1))\\n    }\\n    private fun rob(nums: IntArray, start: Int, end: Int): Int\\n    {\\n        var a = 0\\n        var b = 0\\n        for (i in start..end)\\n        {\\n            var temp: Int = b\\n            if (a + nums[i] > b)\\n            {\\n                b = a + nums[i]\\n            }\\n            a = temp\\n        }\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477572,
                "title": "java-few-solutions-recursion-memoization-dp",
                "content": "**Recursion : TLE**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int one = helper(nums,0,nums.length-2);\\n        int two = helper(nums,1,nums.length-1);\\n        return Math.max(one,two);\\n    }\\n    public int helper(int nums[],int start,int n){\\n        if(n < start)return 0;\\n        if(n == start)return nums[start];\\n        return Math.max(helper(nums,start,n-1),helper(nums,start,n-2) + nums[n]);\\n    }\\n}\\n```\\n**Memoization :\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\nMemory Usage: 36.2 MB, less than 89.84% of Java online submissions for House Robber II.**\\n```\\nclass Solution {\\n    int dp[][];\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        dp = new int[nums.length+1][2];\\n        for(int i[] : dp)Arrays.fill(i,-1);\\n        \\n        int one = helper(nums,0,nums.length-2,0);\\n        int two = helper(nums,1,nums.length-1,1);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int helper(int nums[],int start,int n,int idx){\\n        if(n < start)return 0;\\n        if(n == start)return dp[n][idx] = nums[start];\\n        if(dp[n][idx] != -1)return dp[n][idx];\\n        return dp[n][idx] = Math.max(helper(nums,start,n-1,idx),helper(nums,start,n-2,idx) + nums[n]);\\n    }\\n}\\n```\\n**DP :O(N) Space\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\nMemory Usage: 36.7 MB, less than 46.15% of Java online submissions for House Robber II.**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int dp[][] = new int[nums.length + 1][2];\\n        int one = HouseRobberOne(nums,1,nums.length-1,dp,0);\\n        int two = HouseRobberOne(nums,2,nums.length,dp,1);\\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end,int[][] dp,int idx){\\n        dp[start][idx] = nums[start - 1];\\n        for(int i = start;i<end;i++){\\n            dp[i+1][idx] = Math.max(dp[i][idx],dp[i-1][idx] + nums[i]); \\n        }\\n        return dp[end][idx];\\n    }\\n}\\n```\\n**DP : O(1) Space\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\nMemory Usage: 36.7 MB, less than 46.15% of Java online submissions for House Robber II.**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        int one = HouseRobberOne(nums,0,nums.length-1);\\n        int two = HouseRobberOne(nums,1,nums.length);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end){\\n        int rob = nums[start],no_rob = 0;\\n        \\n        for(int i = start + 1;i<end;i++){\\n            int new_rob = no_rob + nums[i];\\n            int new_no_rob = Math.max(no_rob,rob);\\n            rob = new_rob;\\n            no_rob = new_no_rob;\\n        }\\n        \\n        return Math.max(rob,no_rob);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int one = helper(nums,0,nums.length-2);\\n        int two = helper(nums,1,nums.length-1);\\n        return Math.max(one,two);\\n    }\\n    public int helper(int nums[],int start,int n){\\n        if(n < start)return 0;\\n        if(n == start)return nums[start];\\n        return Math.max(helper(nums,start,n-1),helper(nums,start,n-2) + nums[n]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int dp[][];\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        dp = new int[nums.length+1][2];\\n        for(int i[] : dp)Arrays.fill(i,-1);\\n        \\n        int one = helper(nums,0,nums.length-2,0);\\n        int two = helper(nums,1,nums.length-1,1);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int helper(int nums[],int start,int n,int idx){\\n        if(n < start)return 0;\\n        if(n == start)return dp[n][idx] = nums[start];\\n        if(dp[n][idx] != -1)return dp[n][idx];\\n        return dp[n][idx] = Math.max(helper(nums,start,n-1,idx),helper(nums,start,n-2,idx) + nums[n]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int dp[][] = new int[nums.length + 1][2];\\n        int one = HouseRobberOne(nums,1,nums.length-1,dp,0);\\n        int two = HouseRobberOne(nums,2,nums.length,dp,1);\\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end,int[][] dp,int idx){\\n        dp[start][idx] = nums[start - 1];\\n        for(int i = start;i<end;i++){\\n            dp[i+1][idx] = Math.max(dp[i][idx],dp[i-1][idx] + nums[i]); \\n        }\\n        return dp[end][idx];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        int one = HouseRobberOne(nums,0,nums.length-1);\\n        int two = HouseRobberOne(nums,1,nums.length);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end){\\n        int rob = nums[start],no_rob = 0;\\n        \\n        for(int i = start + 1;i<end;i++){\\n            int new_rob = no_rob + nums[i];\\n            int new_no_rob = Math.max(no_rob,rob);\\n            rob = new_rob;\\n            no_rob = new_no_rob;\\n        }\\n        \\n        return Math.max(rob,no_rob);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60034,
                "title": "simple-and-easy-c-solution-modified-from-the-best-solution-of-house-robber-easy",
                "content": "    int rob_line(vector<int>& nums, int start, int end) {\\n        int odd_sum=0;\\n        int even_sum=0;\\n        \\n        for(int i=start; i<end; i++) {\\n            if(i%2)\\n                odd_sum = max(even_sum, odd_sum+nums[i]);\\n            else\\n                even_sum = max(odd_sum, even_sum+nums[i]);\\n        }\\n        \\n        return max(odd_sum, even_sum);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        else if(nums.size()==1) return nums[0];\\n        else return max(rob_line(nums,0,nums.size()-1), rob_line(nums,1,nums.size()));\\n    }",
                "solutionTags": [],
                "code": "    int rob_line(vector<int>& nums, int start, int end) {\\n        int odd_sum=0;\\n        int even_sum=0;\\n        \\n        for(int i=start; i<end; i++) {\\n            if(i%2)\\n                odd_sum = max(even_sum, odd_sum+nums[i]);\\n            else\\n                even_sum = max(odd_sum, even_sum+nums[i]);\\n        }\\n        \\n        return max(odd_sum, even_sum);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        else if(nums.size()==1) return nums[0];\\n        else return max(rob_line(nums,0,nums.size()-1), rob_line(nums,1,nums.size()));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 442219,
                "title": "simple-code-beating-100-java-solution-by-dp-with-explanation",
                "content": "The intuition is to set u two dp arrays to store largest gain.\\nThe first one is just like a normal dp (house robber 1), where the last element cannot be used.\\nThe second one initialise the first dp element as 0 to simulte when the first element is not used\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        //set two dp arrays\\n        //dp--> the first element is used\\n        //dp2 --> the first element is not used\\n        int[] dp = new int[n];\\n        int[] dp2 = new int[n];\\n        \\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        //pretend first element is not used by initilize it as 0\\n        dp2[0]=0;\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i],dp2[i-1]);\\n        }\\n        // for dp[] if we use the first element, the last element cnanot be used, \\n        //so the largest profit is max(dp[n-2],dp2[n-1])\\n        \\n        return Math.max(dp[n-2],dp2[n-1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        //set two dp arrays\\n        //dp--> the first element is used\\n        //dp2 --> the first element is not used\\n        int[] dp = new int[n];\\n        int[] dp2 = new int[n];\\n        \\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        //pretend first element is not used by initilize it as 0\\n        dp2[0]=0;\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i],dp2[i-1]);\\n        }\\n        // for dp[] if we use the first element, the last element cnanot be used, \\n        //so the largest profit is max(dp[n-2],dp2[n-1])\\n        \\n        return Math.max(dp[n-2],dp2[n-1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894847,
                "title": "house-robber-ii-dp-editorial-c-java",
                "content": "***Dynamic programming Approach:***\\n\\n**Though Process :**\\n1. dp[i] = k , here i will be the *house position* and k is the  *maximum amount of money you can rob*.\\n2. Here, if we suppose, at any house index i, do we need to keep track , that how we reached here? Well, if we think too deeply, we can think some points below:\\n  i.) if we reach l-1 (last) house, and robs it, we can only do so , if house 0th house is not robbed else we cant rob it if 0th house is also robbed.\\n  May be we should keep track wheter or not house 0 is robbed or not.\\n \\n  \\n**Editorial :**\\nBut we may not go that way, because that will get bit complicated.\\nOther thing that comes to mind is :,\\n- Either 0 will be robbed and l-1 will not be robbed , \\n OR\\n - 0 will not be robbed , and l-1 will be robbed.\\n \\n**So we find two valuses : find maximum amount robbed in going from houses 0 tp l-2  and maximum amount robbed in going from house 1 to l-1.\\n And get the maximum value of the two.**\\n \\nNow the problem is broken into two sub problems of l-2 size. Each subproblem can be solved by following method:\\n \\n` dp[i] = max (dp[i-1] , dp[i-2]+nums[i-1]);`\\n where `dp[0] = nums[0]` and `dp[1] = nums[1];`\\n \\n What above equation means is :\\n**Either we**\\n` dont rob house i ; in that case  dp[i] =  (dp[i-1])`\\n**OR**\\n `rob house i and donot rob house i-1 ; in this case dp[i] = (dp[i-2] + nums[i])`\\n \\n My solution in c++:\\n ```\\nint rob(vector<int>& nums) {\\n    int l = nums.size();\\n    if (l == 0) return 0;\\n    if (l == 1) return nums[0];\\n    if (l == 2) return max(nums[0], nums[1]);\\n\\t\\n\\t//Subproblem 1\\n    vector<int> arr(l);\\n    arr[0] = nums[0]; //start from index 0\\n    arr[1] = max(nums[1], arr[0]);\\n    for (int i = 2; i < l-1; i++) { //end at index l-2\\n        arr[i] = max(nums[i] + arr[i - 2], arr[i - 1]);        \\n    }\\n\\n    //Subproblem 2\\n    vector<int> arr2(l);\\n    arr2[0] = 0;\\n    arr2[1] = nums[1];//start from index 1\\n    arr2[2] = max(nums[2], arr2[1]);\\n    for (int i = 3; i < l; i++) { //end at index l-1\\n        arr2[i] = max(nums[i] + arr2[i - 2], arr2[i - 1]);\\n    }\\n\\t\\n\\t/*debug\\n    for (int i = 0; i < l; i++) {\\n        cout << arr[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n    for (int i = 0; i < l; i++) {\\n        cout << arr2[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n\\t*/\\n    \\n    return max(arr[l-2] , arr2[l-1]) ;\\n}\\n ```\\n \\n Happy Coding Forever!\\n \\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint rob(vector<int>& nums) {\\n    int l = nums.size();\\n    if (l == 0) return 0;\\n    if (l == 1) return nums[0];\\n    if (l == 2) return max(nums[0], nums[1]);\\n\\t\\n\\t//Subproblem 1\\n    vector<int> arr(l);\\n    arr[0] = nums[0]; //start from index 0\\n    arr[1] = max(nums[1], arr[0]);\\n    for (int i = 2; i < l-1; i++) { //end at index l-2\\n        arr[i] = max(nums[i] + arr[i - 2], arr[i - 1]);        \\n    }\\n\\n    //Subproblem 2\\n    vector<int> arr2(l);\\n    arr2[0] = 0;\\n    arr2[1] = nums[1];//start from index 1\\n    arr2[2] = max(nums[2], arr2[1]);\\n    for (int i = 3; i < l; i++) { //end at index l-1\\n        arr2[i] = max(nums[i] + arr2[i - 2], arr2[i - 1]);\\n    }\\n\\t\\n\\t/*debug\\n    for (int i = 0; i < l; i++) {\\n        cout << arr[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n    for (int i = 0; i < l; i++) {\\n        cout << arr2[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n\\t*/\\n    \\n    return max(arr[l-2] , arr2[l-1]) ;\\n}\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 60015,
                "title": "0ms-o-n-time-o-1-space-c-solution",
                "content": "This solution is based on house robber 1. The idea is that either the first house or the last house is not robbed. The final solution is max of (house robber without last element) and (house robber without the first element). Note *endIndex* is not inclusive in the second rob function.\\n\\n    class Solution {\\n    public:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, nums.size()-1), rob(nums, 1, 0));\\n    }\\n\\n    int rob(vector<int>& nums, int startIndex, int endIndex) {\\n        int p = 0, q = 0;\\n        for (int i = startIndex; i != endIndex; /* do nothing */) {\\n            int tmp = p;\\n            p = max(p, q + nums[i]);\\n            q = tmp;\\n            i = (i + 1) % nums.size();\\n        }\\n        return p;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, nums.size()-1), rob(nums, 1, 0));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3145559,
                "title": "c-beats-100-dp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Like House Robber I do the same but call for two times first from `0 to n-1` and second from `1 to n` because ` 0 and n` are neighbours so we should not include both of them (either 0 or n).\\nSo just do like original House Robber and call for these two ranges.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint gen_rob(vector<int>& arr,int st,int end) {\\n        int p1=0,p2=0;\\n        int p3=0;\\n        for(int i=st;i<end;i++){\\n            p3=max(arr[i]+p2,p1);\\n            p2=p1;\\n            p1=p3;\\n        }\\n        return p3;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return nums[0];\\n        return max(gen_rob(nums,0,n-1),gen_rob(nums,1,n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint gen_rob(vector<int>& arr,int st,int end) {\\n        int p1=0,p2=0;\\n        int p3=0;\\n        for(int i=st;i<end;i++){\\n            p3=max(arr[i]+p2,p1);\\n            p2=p1;\\n            p1=p3;\\n        }\\n        return p3;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return nums[0];\\n        return max(gen_rob(nums,0,n-1),gen_rob(nums,1,n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577360,
                "title": "c-recursive-memoization-commented-0-1-knapsack-variation-t-c-o-2-n",
                "content": "* This problem is a variation of problem **[House Robber](https://leetcode.com/problems/house-robber/)**.\\n* The given solution is **90% simmiler** to my solution of **[House Robber](https://leetcode.com/problems/house-robber/discuss/1577300/c%2B%2B-oror-recursive-%2B-memoization-oror-0-1-knapsack-variation-oror-T.C.-O(2*n))**\\n* This solution will be a *cake-walk* if you go through the solution of  **[House Robber](https://leetcode.com/problems/house-robber/discuss/1577300/c%2B%2B-oror-recursive-%2B-memoization-oror-0-1-knapsack-variation-oror-T.C.-O(2*n))**\\n\\n\\n**Observations:**\\n1. Since House[1] and House[n] are adjacent, they cannot be robbed together. \\n2. Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], depending on which choice offers more money. \\n3. Now the problem has degenerated to the [House Robber](https://leetcode.com/problems/house-robber/), which is already been solved.\\n```\\nclass Solution {\\npublic:\\n    int dp[101][2];\\n\\n    int solve(vector<int>& nums, int n, int pos, bool isValid){\\n        if(pos>=n) return 0;\\n        if(dp[pos][isValid] != -1) return dp[pos][isValid];\\n        \\n        int rob = 0, notrob = 0;\\n        if(isValid) rob = nums[pos] + solve(nums,n,pos+1,false); //can rob, only when the previous house is not robbed\\n        notrob = solve(nums,n,pos+1,true); //cannot rob\\n        \\n        return dp[pos][isValid] = max(rob,notrob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0]; //exception condition, which we have to handle separately\\n\\t\\t//when n==1, case1 and case2 return 0 but we have to select the house as there are no adjecent house.\\n        \\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 1: rob from 0...n-1, because all houses are in circular so nth is adjecent to 0th house\\n        int case1 = solve(nums,n-1,0,true);\\n\\t\\t\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 2: rob from 1...n,\\n        int case2 = solve(nums,n,1,true);\\n\\t\\t\\n\\t\\t//return maximum between case1 & case2\\n        return max(case1,case2);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][2];\\n\\n    int solve(vector<int>& nums, int n, int pos, bool isValid){\\n        if(pos>=n) return 0;\\n        if(dp[pos][isValid] != -1) return dp[pos][isValid];\\n        \\n        int rob = 0, notrob = 0;\\n        if(isValid) rob = nums[pos] + solve(nums,n,pos+1,false); //can rob, only when the previous house is not robbed\\n        notrob = solve(nums,n,pos+1,true); //cannot rob\\n        \\n        return dp[pos][isValid] = max(rob,notrob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0]; //exception condition, which we have to handle separately\\n\\t\\t//when n==1, case1 and case2 return 0 but we have to select the house as there are no adjecent house.\\n        \\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 1: rob from 0...n-1, because all houses are in circular so nth is adjecent to 0th house\\n        int case1 = solve(nums,n-1,0,true);\\n\\t\\t\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 2: rob from 1...n,\\n        int case2 = solve(nums,n,1,true);\\n\\t\\t\\n\\t\\t//return maximum between case1 & case2\\n        return max(case1,case2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893882,
                "title": "java-dp-solution-with-detailed-simple-explanation-memoization-0-ms-best-approach",
                "content": "**EXPLANATION**\\n\\nWe will do the same thing which we used to do in the normal House Robber Problem but with only the following 2 modifications:\\n\\n1. When we select the first house, then we cannot select the last house, so we make the (N-2)th house the last house and do the same thing as the generic house robber problem. **That is, run the program for indices *[0 to N-2]*.**\\n\\n2. When we do not select the first house, then we can select the last house.  In this case, we do the same thing as house robber problem from house number 2 (**index 1**) to the last house. **That is, run the program for indices *[1 to N-1]*.**\\n\\nReturn the **maximum** of the 2 options.\\n\\n-------------------------**How to solve the generic House Robber Problem?**--------------------------\\n\\nSimple, we can either select a house or not select a house, i.e. we have 2 choices.  So, we create a recursive function and return the **maximum** value when we either select a house or not select a house.  Whenever, we select a house, we call the recursive function with the next index as **(current index + 2)** because we cannot select the neighbouring house.  If we do not select the house, then we call the recursive function with the next index as **(current index + 1)** because now we can select the neighbouring house.\\n\\nThis is a simple recursive approach.  Now, to make this approach optimal, we can memoize the recursive code using a 1D DP array.  This is because for every house when we calculate the maximum possible value, we can simply use that in our future recursive calls.  We do not need to calculate the values again.\\n\\n*------Please **upvote** if you liked the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n```\\nclass Solution {\\n    \\n    public int dp [];\\n    \\n    public int rob (int[] nums) {\\n        if (nums.length == 2)\\n            return Math.max (nums [0], nums [1]);\\n        if (nums.length == 1)\\n            return nums [0];\\n        int N = nums.length;\\n        dp = new int [N];\\n        Arrays.fill (dp, -1);\\n        int max1 = Solve (nums, 0, N-2);\\n        Arrays.fill (dp, -1);\\n        int max2 = Solve (nums, 1, N-1);\\n        return Math.max (max1, max2);\\n    }\\n    \\n    public int Solve (int arr [], int index, int N) {\\n        if (index > N)\\n            return 0;\\n        if (dp [index] != -1)\\n            return dp [index];\\n        int max1 = arr [index] + Solve (arr, index + 2, N);\\n        int max2 = Solve (arr, index + 1, N);\\n        return dp [index] = Math.max (max1, max2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int dp [];\\n    \\n    public int rob (int[] nums) {\\n        if (nums.length == 2)\\n            return Math.max (nums [0], nums [1]);\\n        if (nums.length == 1)\\n            return nums [0];\\n        int N = nums.length;\\n        dp = new int [N];\\n        Arrays.fill (dp, -1);\\n        int max1 = Solve (nums, 0, N-2);\\n        Arrays.fill (dp, -1);\\n        int max2 = Solve (nums, 1, N-1);\\n        return Math.max (max1, max2);\\n    }\\n    \\n    public int Solve (int arr [], int index, int N) {\\n        if (index > N)\\n            return 0;\\n        if (dp [index] != -1)\\n            return dp [index];\\n        int max1 = arr [index] + Solve (arr, index + 2, N);\\n        int max2 = Solve (arr, index + 1, N);\\n        return dp [index] = Math.max (max1, max2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894185,
                "title": "c-dp-solution-explained-100-time-100-memory",
                "content": "Ah, the joy of knowing you did not have to trade off memory for time or the other way around!\\n\\nAnyway, my solution will first of all store the length of the input in `len`, then weed out a couple of simple (yet potentially annoying) edge cases and finally return the maximum value our burglar might get by either looting all the houses but the last or all the houses but the first.\\n\\nIn order to compute it, we will use our helper function `loot` that takes 3 parameters:\\n* `houses`, directly from the main function and without any changes - be sure to pass it as a reference!;\\n* `start` and `finish`, the starting and ending points of our search, respectively.\\n\\nThen the magic happens: no need to store all the `finish - start + 1` values, as we just need the last 3 values to keep our DP computation rolling; now, a lot of people would just keep reassining variables, shifting then like:\\n\\n```cpp\\na = b;\\nb = c;\\nc = newStuff;\\n```\\n\\nBut that is kinda cumbersome, so I tried to to just use an array of 3 values and instead of shifting them, I work on them using the modulo operator.\\n\\nI initialise the value in position `start % 3` to be `houses[start]`, the one in position `(start + 1) % 3` to be `max(houses[start], houses[start + 1])` and I just go on with a loop for all the other remaining values, making so that each one is the maximum of either the previous or the value of 2 positions ago plue the matching value in `houses`, with the expression: `max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3])`.\\n\\nOnce I am done, I can just return the value of the last element parsed: `dp[(finish - 1)  % 3]`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[(start + 1) % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = start + 2; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n    int rob(vector<int> &houses) {\\n        int len = houses.size();\\n        // begone, edge cases!\\n        if (len < 3) return len == 1 ? houses[0] : max(houses[0], houses[1]);\\n        return max(loot(houses, 0, len - 1), loot(houses, 1, len));\\n    }\\n};\\n```\\n\\nTiny stylistic variant in `loot`, using the prefix operator on `start`:\\n\\n```cpp\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[++start % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = ++start; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\na = b;\\nb = c;\\nc = newStuff;\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[(start + 1) % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = start + 2; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n    int rob(vector<int> &houses) {\\n        int len = houses.size();\\n        // begone, edge cases!\\n        if (len < 3) return len == 1 ? houses[0] : max(houses[0], houses[1]);\\n        return max(loot(houses, 0, len - 1), loot(houses, 1, len));\\n    }\\n};\\n```\n```cpp\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[++start % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = ++start; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761965,
                "title": "c-fastest-solution-o-n-dp",
                "content": "``` \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        // there are 2 ways to rob \\n        int dp[nums.size()];\\n        \\n        // 1. rob the first house => u can\\'t rob the last one\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i=2 ; i<nums.size()-1 ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        int amt1 = dp[nums.size()-2];\\n        \\n        // 2. rob the second house till the last one\\n        dp[0] = 0;\\n        dp[1] = nums[1];\\n        for(int i=2 ; i<nums.size() ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        \\n        return max(amt1, dp[nums.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        // there are 2 ways to rob \\n        int dp[nums.size()];\\n        \\n        // 1. rob the first house => u can\\'t rob the last one\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i=2 ; i<nums.size()-1 ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        int amt1 = dp[nums.size()-2];\\n        \\n        // 2. rob the second house till the last one\\n        dp[0] = 0;\\n        dp[1] = nums[1];\\n        for(int i=2 ; i<nums.size() ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        \\n        return max(amt1, dp[nums.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420934,
                "title": "easy-java-recursion-memoization-extending-from-house-robber-i",
                "content": "Let me take you step by step:\\nYou know thet For House Rober 1 the solution is easy. it\\'s Inclusion and Exclusion Recurssion.\\n\\n House Rober 1 : LC : 198 (link = https://leetcode.com/problems/house-robber/ )\\n````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int[] cache = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        return rob(nums,0,nums.length-1,cache);\\n        \\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n````\\n\\nNow for House Robber 2\\n\\n````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        if(nums==null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n       \\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache1,-1);\\n        \\n        int excludeFirstHouse = rob(nums,1,nums.length-1,cache1); // Now you can consider the last \\n        int includeFirstHouse = rob(nums,0,nums.length-2,cache2);  // Now u cannot consider the last \\n     \\n        return Math.max(excludeFirstHouse,includeFirstHouse);\\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n````\\n\\nThe rob(int[] nums) is same both solutions, But you call it twice from the driver for House Rober 2\\n\\nIf you liked the solution giev thumbsup.",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int[] cache = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        return rob(nums,0,nums.length-1,cache);\\n        \\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n```\n````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        if(nums==null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n       \\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache1,-1);\\n        \\n        int excludeFirstHouse = rob(nums,1,nums.length-1,cache1); // Now you can consider the last \\n        int includeFirstHouse = rob(nums,0,nums.length-2,cache2);  // Now u cannot consider the last \\n     \\n        return Math.max(excludeFirstHouse,includeFirstHouse);\\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621942,
                "title": "python-easy-solution-with-explanation-faster-than-95",
                "content": "# Dynamic programming with memoization\\nRuntime: 32 ms, faster than **94.51%**\\nMemory Usage: 13.8 MB, less than **70.92%**\\n\\nThen problem breaks down to the another leetcode problem, which I recommend doing first: [House robber](https://leetcode.com/problems/house-robber/). Here the problem is quite the same except houses are located in the circle, so we cannot take first and last house at the same time. We have two possible cases here:\\n1. We take first house and consider all houses except the last one\\n2. We take the last one and consider all houses except the first one\\n```\\nreturn max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\\n\\nBut we also have to take into consideration the situation when we have only one house, then we would take 0 houses in both cases, so we need if statement:\\n```\\nif len(nums) == 1:\\n            return nums[0]\\n```\\n\\nThe robInLine function is the solution for House robber problem, I explained it [here](https://leetcode.com/problems/house-robber/discuss/2621841/Python-EASY-dynamic-programming-with-explanation)\\n\\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        mem = [0] * (len(nums) + 2)\\n        for idx in range(len(nums)-1,-1,-1):\\n            mem[idx] = max(nums[idx] + mem[idx+2], mem[idx+1])\\n        return mem[0]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\\n\\n# Without memoization\\nRuntime: 49 ms, faster than **60.69%**\\nMemory Usage: 14 MB, less than **23.81%**\\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        r_neigh, r_r_neigh = 0, 0\\n        for idx in range(len(nums)-1,-1,-1):\\n            r_neigh, r_r_neigh = max(r_neigh, r_r_neigh + nums[idx]), r_neigh\\n        return r_neigh\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\\n\\nIf you liked the solution please upvote! c:",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nreturn max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\n```\\nif len(nums) == 1:\\n            return nums[0]\\n```\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        mem = [0] * (len(nums) + 2)\\n        for idx in range(len(nums)-1,-1,-1):\\n            mem[idx] = max(nums[idx] + mem[idx+2], mem[idx+1])\\n        return mem[0]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        r_neigh, r_r_neigh = 0, 0\\n        for idx in range(len(nums)-1,-1,-1):\\n            r_neigh, r_r_neigh = max(r_neigh, r_r_neigh + nums[idx]), r_neigh\\n        return r_neigh\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239869,
                "title": "c-dp-solution-recursive-memoization-tabulation",
                "content": "Recursion is the heart of dynamic programming. Without solving recursively and directly jumping to tabulation, I don\\'t think is the right approach. We understand the main concept by doing it recursively first, memoizing it and then converting it into tabulation form. In this solution I will follow all the steps mentioned.\\nThis question is a variation of knapsack.\\nWe have two options for each house:-\\n\\nEither take the money in it.\\nOr Leave it.\\n\\nIf we take the money, then we cannot take the money from the neighbouring house, but if we don\\'t take the money, money can be taken from the neighbouring house.\\n\\nIf we take the money from the first house, then we cannot take the money from the last house as the houses are arranged in circle. So we call functions for two cases, in which we consider houses from first to second last and other from second to last. \\n\\nWe have to find a way in which the maximum amount of money can be taken.\\n\\n**Recursion (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums){\\n        if(idx >= n) return 0;\\n        return max(nums[idx] + solve(idx+2,n,nums), solve(idx+1,n,nums));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        return max(solve(0,n-1,nums), solve(1,n,nums));\\n    }\\n};\\n```\\n\\n**Memoization (0ms, beats 100%)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums, vector<int>&dp){\\n        if(idx >= n) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(nums[idx] + solve(idx+2,n,nums,dp), solve(idx+1,n,nums,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int>dp1(n+1,-1);\\n        vector<int>dp2(n+1,-1);\\n        return max(solve(0,n-1,nums,dp1), solve(1,n,nums,dp2));\\n    }\\n};\\n```\\n\\n**Tabulation (0ms, beats 100%)**\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>dp(n+1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<n+1; i++){\\n            dp[i] = max(dp[i-1], nums[i-1] + dp[i-2]);\\n        }\\n        return dp[n];\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(solve(v1), solve(v2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums){\\n        if(idx >= n) return 0;\\n        return max(nums[idx] + solve(idx+2,n,nums), solve(idx+1,n,nums));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        return max(solve(0,n-1,nums), solve(1,n,nums));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums, vector<int>&dp){\\n        if(idx >= n) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(nums[idx] + solve(idx+2,n,nums,dp), solve(idx+1,n,nums,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int>dp1(n+1,-1);\\n        vector<int>dp2(n+1,-1);\\n        return max(solve(0,n-1,nums,dp1), solve(1,n,nums,dp2));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>dp(n+1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<n+1; i++){\\n            dp[i] = max(dp[i-1], nums[i-1] + dp[i-2]);\\n        }\\n        return dp[n];\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(solve(v1), solve(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427939,
                "title": "very-simple-dp-explanation-using-python",
                "content": "This post is meant to help those who is having hard time understanding. The code isn\\'t simplified by any mean, as the code is meant to be easy to read and understand.\\n\\nFrom House Robber I problem [https://leetcode.com/problems/house-robber/](http://), we can simply run House Robber problem twice, once without the first element, and second without the last element. Then, we take the max between the two answers. Below is the Python3 code.\\n\\nrobDP method is the code for House Robber I problem. The rob method simply runs it twice, then return the max of the two.\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:       \\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        numsExcludeLast = nums[:len(nums) - 1]\\n        numsExcludeFirst = nums[1:]\\n        \\n        excludeLastAns = self.robDP(numsExcludeLast)\\n        excludeFirstAns = self.robDP(numsExcludeFirst)\\n        \\n        return max(excludeLastAns, excludeFirstAns)\\n    \\n    def robDP(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(dp[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n            \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:       \\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        numsExcludeLast = nums[:len(nums) - 1]\\n        numsExcludeFirst = nums[1:]\\n        \\n        excludeLastAns = self.robDP(numsExcludeLast)\\n        excludeFirstAns = self.robDP(numsExcludeFirst)\\n        \\n        return max(excludeLastAns, excludeFirstAns)\\n    \\n    def robDP(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(dp[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n            \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59979,
                "title": "my-python-solution",
                "content": "    class Solution(object):\\n        def rob(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            if n == 0: return 0\\n            if n < 4: return max(nums)\\n    \\n            first, second = 0, 0\\n            for i in nums[:-1]: first, second = second, max(first + i, second)\\n            result = second\\n    \\n            first, second = 0, 0\\n            for i in nums[1:]: first, second = second, max(first + i, second)\\n            return max(result, second)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def rob(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            if n == 0: return 0\\n            if n < 4: return max(nums)\\n    \\n            first, second = 0, 0\\n            for i in nums[:-1]: first, second = second, max(first + i, second)\\n            result = second\\n    \\n            first, second = 0, 0\\n            for i in nums[1:]: first, second = second, max(first + i, second)\\n            return max(result, second)",
                "codeTag": "Java"
            },
            {
                "id": 3385990,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n       int n=v.size();\\n       if(n==1)return v[0];\\n       int dp1[n],dp2[n];\\n       dp1[0]=v[0];\\n       dp1[1]=max(v[0],v[1]);\\n       for(int i=2;i<n-1;i++)dp1[i]=max(dp1[i-1],v[i]+dp1[i-2]);\\n       dp2[0]=0;\\n       dp2[1]=v[1];\\n       for(int i=2;i<n;i++)dp2[i]=max(dp2[i-1],dp2[i-2]+v[i]);\\n       return max(dp1[n-2],dp2[n-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n       int n=v.size();\\n       if(n==1)return v[0];\\n       int dp1[n],dp2[n];\\n       dp1[0]=v[0];\\n       dp1[1]=max(v[0],v[1]);\\n       for(int i=2;i<n-1;i++)dp1[i]=max(dp1[i-1],v[i]+dp1[i-2]);\\n       dp2[0]=0;\\n       dp2[1]=v[1];\\n       for(int i=2;i<n;i++)dp2[i]=max(dp2[i-1],dp2[i-2]+v[i]);\\n       return max(dp1[n-2],dp2[n-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206593,
                "title": "easy-dp-js-solution",
                "content": "```\\nvar rob = function(nums) {\\n    if (nums.length <= 3) {\\n        return Math.max(...nums);\\n    }\\n    let money1 = robHelper(0, nums.length - 2, nums);\\n    let money2 = robHelper(1, nums.length - 1, nums);\\n    return Math.max(money1, money2);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/*\\ndp[i] is the max amount of money that can be robbed without alerting the police at house i\\n\\ndp[i] = max(dp[i-1], dp[i-2] + nums[i]) \\nbecause if we rob the previous house, we can\\'t rob the current house, but, else,\\nwe can rob the current house and still take the money robbed until the previous, previous house\\n*/\\nconst robHelper = (start, end, nums) => {\\n    let dp = new Array(start + (end - start + 1));\\n    for (let i = start; i <= end; i++) {\\n        dp[i] = Math.max((dp[i-1] ? dp[i-1] : 0), (dp[i-2] ? dp[i-2] : 0) + nums[i]);\\n    }\\n    return dp[end];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    if (nums.length <= 3) {\\n        return Math.max(...nums);\\n    }\\n    let money1 = robHelper(0, nums.length - 2, nums);\\n    let money2 = robHelper(1, nums.length - 1, nums);\\n    return Math.max(money1, money2);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/*\\ndp[i] is the max amount of money that can be robbed without alerting the police at house i\\n\\ndp[i] = max(dp[i-1], dp[i-2] + nums[i]) \\nbecause if we rob the previous house, we can\\'t rob the current house, but, else,\\nwe can rob the current house and still take the money robbed until the previous, previous house\\n*/\\nconst robHelper = (start, end, nums) => {\\n    let dp = new Array(start + (end - start + 1));\\n    for (let i = start; i <= end; i++) {\\n        dp[i] = Math.max((dp[i-1] ? dp[i-1] : 0), (dp[i-2] ? dp[i-2] : 0) + nums[i]);\\n    }\\n    return dp[end];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 894504,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The **ART** of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n\\n---\\n\\n**A**ll possibilities for each `i`<sup>th</sup> house:\\n\\n1. The optimal solution is to `\\u2705`  **take** the `i`<sup>th</sup> house\\n2. The optimal solution is to `\\uD83D\\uDEAB`  **skip** the `i`<sup>th</sup> house\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var take = go(i + 2, n) + A[i]\\n            var skip = go(i + 1, n)\\n            return Math.max(take, skip)\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var k = \"$i,$n\"\\n            if (!m.contains(k)) {\\n                var take = go(i + 2, n) + A[i]\\n                var skip = go(i + 1, n)\\n                m[k] = Math.max(take, skip)\\n            }\\n            return m[k]!!\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var dp = IntArray(N + 2) { 0 }\\n            for (i in end - 1 downTo start) {\\n                var take = dp[i + 2] + A[i]\\n                var skip = dp[i + 1]\\n                dp[i] = Math.max(take, skip)\\n            }\\n            return dp[start]\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var (a, b, c) = Triple(0, 0, 0)\\n            for (i in end - 1 downTo start) {\\n                var take = c + A[i]\\n                var skip = b\\n                a = Math.max(take, skip)\\n                c = b; b = a\\n            }\\n            return a\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let take = go(i + 2, n) + A[i],\\n            skip = go(i + 1, n);\\n        return Math.max(take, skip);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let k = `${i},${n}`;\\n        if (!m.has(k)) {\\n            let take = go(i + 2, n) + A[i],\\n                skip = go(i + 1, n);\\n            m.set(k, Math.max(take, skip));\\n        }\\n        return m.get(k);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let dp = Array(N + 2).fill(0);\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = dp[i + 2] + A[i],\\n                skip = dp[i + 1];\\n            dp[i] = Math.max(take, skip);\\n        }\\n        return dp[start];\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let [a, b, c] = [0, 0, 0];\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = c + A[i],\\n                skip = b;\\n            a = Math.max(take, skip);\\n            c = b, b = a;\\n        }\\n        return a;\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        @cache\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            dp = [0] * (N + 2)\\n            for i in range(end - 1, start - 1, -1):\\n                take = dp[i + 2] + A[i]\\n                skip = dp[i + 1]\\n                dp[i] = max(take, skip)\\n            return dp[start]\\n        return max(best(0, N - 1), best(1, N))\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            a, b, c = 0, 0, 0\\n            for i in range(end - 1, start - 1, -1):\\n                take = c + A[i]\\n                skip = b\\n                a = max(take, skip)\\n                c = b; b = a\\n            return a\\n        return max(best(0, N - 1), best(1, N))\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n\\t\\tif (N == 1)\\n\\t\\t    return A[0];\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto take = go(i + 2, n) + A[i],\\n                 skip = go(i + 1, n);\\n            return max(take, skip);\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto key = [](auto i, auto n) {\\n            stringstream ss; ss << i << \",\" << n;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto k = key(i, n);\\n            if (m.find(k) == m.end()) {\\n                auto take = go(i + 2, n) + A[i],\\n                     skip = go(i + 1, n);\\n                m[k] = max(take, skip);\\n            }\\n            return m[k];\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            VI dp(N + 2);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = dp[i + 2] + A[i],\\n                     skip = dp[i + 1];\\n                dp[i] = max(take, skip);\\n            }\\n            return dp[start];\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            auto [a, b, c] = make_tuple(0, 0, 0);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = c + A[i],\\n                     skip = b;\\n                a = max(take, skip);\\n                c = b, b = a;\\n            }\\n            return a;\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var take = go(i + 2, n) + A[i]\\n            var skip = go(i + 1, n)\\n            return Math.max(take, skip)\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var k = \"$i,$n\"\\n            if (!m.contains(k)) {\\n                var take = go(i + 2, n) + A[i]\\n                var skip = go(i + 1, n)\\n                m[k] = Math.max(take, skip)\\n            }\\n            return m[k]!!\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var dp = IntArray(N + 2) { 0 }\\n            for (i in end - 1 downTo start) {\\n                var take = dp[i + 2] + A[i]\\n                var skip = dp[i + 1]\\n                dp[i] = Math.max(take, skip)\\n            }\\n            return dp[start]\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var (a, b, c) = Triple(0, 0, 0)\\n            for (i in end - 1 downTo start) {\\n                var take = c + A[i]\\n                var skip = b\\n                a = Math.max(take, skip)\\n                c = b; b = a\\n            }\\n            return a\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let take = go(i + 2, n) + A[i],\\n            skip = go(i + 1, n);\\n        return Math.max(take, skip);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let k = `${i},${n}`;\\n        if (!m.has(k)) {\\n            let take = go(i + 2, n) + A[i],\\n                skip = go(i + 1, n);\\n            m.set(k, Math.max(take, skip));\\n        }\\n        return m.get(k);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let dp = Array(N + 2).fill(0);\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = dp[i + 2] + A[i],\\n                skip = dp[i + 1];\\n            dp[i] = Math.max(take, skip);\\n        }\\n        return dp[start];\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let [a, b, c] = [0, 0, 0];\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = c + A[i],\\n                skip = b;\\n            a = Math.max(take, skip);\\n            c = b, b = a;\\n        }\\n        return a;\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        @cache\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            dp = [0] * (N + 2)\\n            for i in range(end - 1, start - 1, -1):\\n                take = dp[i + 2] + A[i]\\n                skip = dp[i + 1]\\n                dp[i] = max(take, skip)\\n            return dp[start]\\n        return max(best(0, N - 1), best(1, N))\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            a, b, c = 0, 0, 0\\n            for i in range(end - 1, start - 1, -1):\\n                take = c + A[i]\\n                skip = b\\n                a = max(take, skip)\\n                c = b; b = a\\n            return a\\n        return max(best(0, N - 1), best(1, N))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n\\t\\tif (N == 1)\\n\\t\\t    return A[0];\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto take = go(i + 2, n) + A[i],\\n                 skip = go(i + 1, n);\\n            return max(take, skip);\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto key = [](auto i, auto n) {\\n            stringstream ss; ss << i << \",\" << n;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto k = key(i, n);\\n            if (m.find(k) == m.end()) {\\n                auto take = go(i + 2, n) + A[i],\\n                     skip = go(i + 1, n);\\n                m[k] = max(take, skip);\\n            }\\n            return m[k];\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            VI dp(N + 2);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = dp[i + 2] + A[i],\\n                     skip = dp[i + 1];\\n                dp[i] = max(take, skip);\\n            }\\n            return dp[start];\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            auto [a, b, c] = make_tuple(0, 0, 0);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = c + A[i],\\n                     skip = b;\\n                a = max(take, skip);\\n                c = b, b = a;\\n            }\\n            return a;\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134907,
                "title": "logical-thinking-with-clear-code",
                "content": "**Logical Thinking**\\n**state definition**\\n`circularState(i, j)` as maximum amount of money I can rob from house i to house j if arranged in a circle.\\n`oneWayState(i, j)` as maximum amount of money I can rob from house i to house j if not arranged in a circle.\\n**goal state**\\t\\n`circularState(0, nums.length - 1)`\\n**state resolution**\\t\\nCurrently I rob from house i to house j, I can decide whether to rob house i or not. \\nIf I rob house i, `circularState(i, j) = oneWayState(i, j - 1)`.\\nIf I abort house i, `circularState(i, j) = oneWayState(i + 1, j)`\\n**goal state**\\t\\n`circularState(0, nums.length - 1) = max(oneWayState(0, nums.lenght - 2), oneWayState(1, nums.length - 1))`\\n\\nIn 198. House Robber, we have solved `oneWayState()`. [https://leetcode.com/problems/house-robber/discuss/156910/Code-Beats-100-with-Explanation-and-Optimization]\\n\\nPlease note that **nums[1..nums.length - 2]** will be calculated twice in `Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1))`, so we apply **Memorization** technique.\\n\\n**Clear Code**\\n```\\n    int[][] memo;\\n    \\n    public int rob(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return 0;\\n        }\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        \\n        memo = new int[nums.length][nums.length];\\n        for (int[] tmp : memo)\\n            Arrays.fill(tmp, -1);\\n        \\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }\\n    \\n    \\n    \\n    public int rob(int[] nums, int start, int end) {\\n\\n        if (memo[start][end] != -1) {\\n            return memo[start][end];\\n        }\\n        \\n        if (nums == null || end < start) {\\n            return 0;\\n        }\\n\\n        int n = nums.length;\\n        int rob = nums[start];\\n        int abort = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int preAbort = abort;\\n            abort = Math.max(abort, rob);\\n            rob = preAbort + nums[i];\\n        }\\n\\n        memo[start][end] = Math.max(abort, rob);\\n        return memo[start][end];\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    int[][] memo;\\n    \\n    public int rob(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return 0;\\n        }\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        \\n        memo = new int[nums.length][nums.length];\\n        for (int[] tmp : memo)\\n            Arrays.fill(tmp, -1);\\n        \\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }\\n    \\n    \\n    \\n    public int rob(int[] nums, int start, int end) {\\n\\n        if (memo[start][end] != -1) {\\n            return memo[start][end];\\n        }\\n        \\n        if (nums == null || end < start) {\\n            return 0;\\n        }\\n\\n        int n = nums.length;\\n        int rob = nums[start];\\n        int abort = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int preAbort = abort;\\n            abort = Math.max(abort, rob);\\n            rob = preAbort + nums[i];\\n        }\\n\\n        memo[start][end] = Math.max(abort, rob);\\n        return memo[start][end];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60061,
                "title": "an-easy-understanding-solution-in-c",
                "content": "This problem is an advanced version of Problem \"House Robber\", the only difference is that the houses are arranged in a circle, which means the first house is adjacent to the last house.\\n\\nFrom a global view, any rob solution has two possible cases: rob the first house, or not.\\n\\nIf we rob the first house, we can't rob the last house, so the problem transfer to \"how to rob in house[1, n-1]\". If we do not rob the first house, the problem transfer to \"how to rob in house[2, n]\".\\n\\nAssuming that we have understand the solution for problem \"House Robber\", now we can simply design the new strategy as below:\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int> &nums) {\\n            if (nums.size() == 0) {\\n                return 0;\\n            }\\n            if (nums.size() == 1) {\\n                return nums.at(0);\\n            }\\n            vector<int> case1(nums);\\n            vector<int> case2(nums);\\n        \\n            vector<int>::iterator v1 = case1.begin();\\n            case1.erase(v1);\\n            case2.pop_back();\\n        \\n            int maxRobValue1 = simpleRob(case1);\\n            int maxRobValue2 = simpleRob(case2);\\n            int maxRobValue = max(maxRobValue1, maxRobValue2);\\n            return maxRobValue;\\n        }\\n        int simpleRob(vector<int> &num){\\n            int *f = new int[num.size() + 1];\\n            f[0] = 0;\\n            for (int i = 1; i <= num.size(); i++) {\\n                if (i == 1) {\\n                    f[i] = num.at(i-1);\\n                }\\n                else {\\n                    f[i] = max(f[i-2] + num.at(i-1), f[i-1]);\\n                }\\n            }\\n            int robMaxValue = f[num.size()];\\n            return robMaxValue;\\n        }    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int> &nums) {\\n            if (nums.size() == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609143,
                "title": "c-0ms-100-faster-o-n-explaination-memoized-recursion",
                "content": "\\n\\n```\\n\\n\\nclass Solution {\\n    int l;\\n    int dp[103];\\n    \\n    int recurse(int index,vector<int>& a)\\n    {\\n        if(index>=l )\\n            return 0;\\n      \\n        if(dp[index]>-1)\\n            return dp[index];\\n        \\n\\t\\t// donothing means robber is not choosing to rob this house for whatever reason( even if he can)\\n\\t\\t// and chooses to move forward \\n        int donothing= recurse(index+1,a);\\n\\t\\t\\n\\t\\t// dosomething means he will rob this house and move to the 2nd next house from this one\\n        int dosomething= a[index]+recurse(index+2, a);\\n        return dp[index]=max(donothing, dosomething);\\n    }\\n    \\n    \\npublic:\\n    int rob(vector<int>& a) {\\n       if(a.size()==1)\\n           return a[0];\\n        // since circular, \\n        //trying from index 0 to l-2;\\n        memset(dp,-1,sizeof(dp));\\n        l= a.size()-1;\\n        int maxvalue=0;\\n        maxvalue= max(maxvalue, recurse(0,a));\\n        \\n\\t\\t// we have the max answer if we choose to rob from house 0 to l-2\\n\\t\\t// now will check the max answer from house 1 to l-1\\n\\t\\t\\n        // trying from index 0 to l-1\\n        memset(dp,-1, sizeof(dp));\\n        l=a.size();\\n        maxvalue= max(maxvalue, recurse(1,a));\\n        return maxvalue;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n\\nUpvote if you like the solution, and if you have any doubt, post it in the comments.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    int l;\\n    int dp[103];\\n    \\n    int recurse(int index,vector<int>& a)\\n    {\\n        if(index>=l )\\n            return 0;\\n      \\n        if(dp[index]>-1)\\n            return dp[index];\\n        \\n\\t\\t// donothing means robber is not choosing to rob this house for whatever reason( even if he can)\\n\\t\\t// and chooses to move forward \\n        int donothing= recurse(index+1,a);\\n\\t\\t\\n\\t\\t// dosomething means he will rob this house and move to the 2nd next house from this one\\n        int dosomething= a[index]+recurse(index+2, a);\\n        return dp[index]=max(donothing, dosomething);\\n    }\\n    \\n    \\npublic:\\n    int rob(vector<int>& a) {\\n       if(a.size()==1)\\n           return a[0];\\n        // since circular, \\n        //trying from index 0 to l-2;\\n        memset(dp,-1,sizeof(dp));\\n        l= a.size()-1;\\n        int maxvalue=0;\\n        maxvalue= max(maxvalue, recurse(0,a));\\n        \\n\\t\\t// we have the max answer if we choose to rob from house 0 to l-2\\n\\t\\t// now will check the max answer from house 1 to l-1\\n\\t\\t\\n        // trying from index 0 to l-1\\n        memset(dp,-1, sizeof(dp));\\n        l=a.size();\\n        maxvalue= max(maxvalue, recurse(1,a));\\n        return maxvalue;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n\\nUpvote if you like the solution, and if you have any doubt, post it in the comments.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372853,
                "title": "easy-clear-python-3-solution-recursive-memo-top-down",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        a=dp(len(nums)-2)\\n        memo=[-1 for _ in range(len(nums))]\\n        nums.pop(0)\\n        b=dp(len(nums)-1)\\n        return max(a,b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        a=dp(len(nums)-2)\\n        memo=[-1 for _ in range(len(nums))]\\n        nums.pop(0)\\n        b=dp(len(nums)-1)\\n        return max(a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300086,
                "title": "o-n-approach-time-complexity",
                "content": "\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n    #time complexity---->O(N)\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n    #time complexity---->O(N)\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224581,
                "title": "213-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the class Solution, which contains the rob() method that takes a list of integers as input and returns an integer.\\n2. Check the edge case where the input list is empty. If this is true, return 0 because there is nothing to rob.\\n3. Check the edge case where the input list has only one element. If this is true, return that element because it is the only one that can be robbed without alerting the police.\\n4. Define a nested function rob(l: int, r: int) -> int that takes two integers l and r as input and returns an integer.\\n5. Initialize two variables dp1 and dp2 to 0. These will hold the dynamic programming values for the current and previous houses, respectively.\\n6. Loop through the range of indices from l to r inclusive.\\n7. Store the current value of dp1 in a temporary variable temp.\\n8. Update dp1 to be the maximum of dp1 and dp2 plus the value of the current house.\\n9. Update dp2 to be the previous value of dp1 (i.e., temp).\\n10. Return dp1, which holds the maximum amount of money that can be robbed without alerting the police.\\n11. In the main rob() function, call rob(0, len(nums) - 2) to calculate the maximum amount that can be robbed without robbing the last house (because it is adjacent to the first house in a circular arrangement).\\n12. Also call rob(1, len(nums) - 1) to calculate the maximum amount that can be robbed without robbing the first house.\\n13. Return the maximum of these two values, which represents the maximum amount that can be robbed without alerting the police in the circular arrangement of houses.\\n# Complexity\\n- Time complexity:\\nBeats\\n65.76%\\n\\n- Space complexity:\\nBeats\\n97.69%\\n\\n# Code\\n```\\nclass Solution:\\n  def rob(self, nums: List[int]) -> int:\\n    if not nums:\\n      return 0\\n    if len(nums) < 2:\\n      return nums[0]\\n\\n    def rob(l: int, r: int) -> int:\\n      dp1 = 0\\n      dp2 = 0\\n\\n      for i in range(l, r + 1):\\n        temp = dp1\\n        dp1 = max(dp1, dp2 + nums[i])\\n        dp2 = temp\\n\\n      return dp1\\n\\n    return max(rob(0, len(nums) - 2),\\n               rob(1, len(nums) - 1))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def rob(self, nums: List[int]) -> int:\\n    if not nums:\\n      return 0\\n    if len(nums) < 2:\\n      return nums[0]\\n\\n    def rob(l: int, r: int) -> int:\\n      dp1 = 0\\n      dp2 = 0\\n\\n      for i in range(l, r + 1):\\n        temp = dp1\\n        dp1 = max(dp1, dp2 + nums[i])\\n        dp2 = temp\\n\\n      return dp1\\n\\n    return max(rob(0, len(nums) - 2),\\n               rob(1, len(nums) - 1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057696,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int robber(vector<int> nums)\\n    {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0]=max(nums[0],0);\\n        dp[1]=max({0,nums[0], nums[1]});\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            dp[i]=max(dp[i-1], nums[i]+dp[i-2]);\\n        }\\n        return max(dp[nums.size()-1],0);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n        return 0;\\n        else if(n==1)\\n        return max(nums[0],0);\\n        else if(n==2)\\n        return max({0,nums[0], nums[1]});\\n        \\n        vector<int> v1(nums.begin()+1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end()-1);\\n        return max(robber(v1), robber(v2));\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int robber(vector<int> nums)\\n    {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0]=max(nums[0],0);\\n        dp[1]=max({0,nums[0], nums[1]});\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            dp[i]=max(dp[i-1], nums[i]+dp[i-2]);\\n        }\\n        return max(dp[nums.size()-1],0);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n        return 0;\\n        else if(n==1)\\n        return max(nums[0],0);\\n        else if(n==2)\\n        return max({0,nums[0], nums[1]});\\n        \\n        vector<int> v1(nums.begin()+1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end()-1);\\n        return max(robber(v1), robber(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023016,
                "title": "c-dp-easy-new-and-100-fast-approach",
                "content": "\\n# Approach\\nCalling recursion function (using dp) to compute the maximum money possible. This function is called 2 times. \\n- First when considering 1st house to be looted then last house can\\'t to looted due to circular arrangement. \\n- Second when considering last house to be looted then leaving the 1st house.\\n\\nOur answer will be maximum of both the returning value.\\n\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    int dfs(int i, int n, vector<int>& nums, vector<int> &dp){\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int money = nums[i] + dfs(i+2, n, nums, dp);\\n        money = max(money, dfs(i+1, n, nums, dp));\\n\\n        dp[i] = money;\\n        return money;\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<int> dp(n, -1);\\n        int cost1 = nums[0] + dfs(2, n-1, nums, dp);\\n\\n        dp = vector<int>(n, -1);\\n        int cost2 = dfs(1, n, nums, dp);\\n\\n        return max(cost1, cost2);\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    int dfs(int i, int n, vector<int>& nums, vector<int> &dp){\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int money = nums[i] + dfs(i+2, n, nums, dp);\\n        money = max(money, dfs(i+1, n, nums, dp));\\n\\n        dp[i] = money;\\n        return money;\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<int> dp(n, -1);\\n        int cost1 = nums[0] + dfs(2, n-1, nums, dp);\\n\\n        dp = vector<int>(n, -1);\\n        int cost2 = dfs(1, n, nums, dp);\\n\\n        return max(cost1, cost2);\\n    }\\n};\\n```\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912310,
                "title": "java-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        int s1 = robRange(nums, 0, n - 2);\\n        int s2 = robRange(nums, 1, n - 1);\\n        return Math.max(s1, s2);\\n    }\\n\\n    private int robRange(int[] nums, int l, int r) {\\n        int a = 0, b = nums[l];\\n        for (int i = l + 1; i <= r; ++i) {\\n            int c = Math.max(nums[i] + a, b);\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        int s1 = robRange(nums, 0, n - 2);\\n        int s2 = robRange(nums, 1, n - 1);\\n        return Math.max(s1, s2);\\n    }\\n\\n    private int robRange(int[] nums, int l, int r) {\\n        int a = 0, b = nums[l];\\n        for (int i = l + 1; i <= r; ++i) {\\n            int c = Math.max(nums[i] + a, b);\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807371,
                "title": "house-robber-2-solution-follow-up-house-robber-1-recursion",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n==1)return nums[0];\\n        int arr1[] = new int[n-1];\\n        int arr2[] = new int[n-1];\\n        for(int i=0; i<n-1; i++){\\n            arr1[i] = nums[i];    //include first element and not include last element\\n            arr2[i] = nums[i+1];  //not include first element and include last element\\n        }\\n        int x = arr1.length-1;\\n        //1.Recursion\\n        // return Math.max(help(arr1,x), help(arr2,x));\\n        \\n        //2.Memoization - Top-Down DP\\n        // int dp[] = new int[x+1];\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans1 = Memo(x,arr1,dp);\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans2 = Memo(x,arr2,dp);\\n        // return Math.max(ans1,ans2);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return Math.max(DP(arr1), DP(arr2));\\n    }\\n    public int help(int[] nums,int index){\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        \\n        int include = nums[index] + help(nums,index-2);\\n        int notInclude = help(nums,index-1);\\n        \\n        return Math.max(include,notInclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums){\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n==1)return nums[0];\\n        int arr1[] = new int[n-1];\\n        int arr2[] = new int[n-1];\\n        for(int i=0; i<n-1; i++){\\n            arr1[i] = nums[i];    //include first element and not include last element\\n            arr2[i] = nums[i+1];  //not include first element and include last element\\n        }\\n        int x = arr1.length-1;\\n        //1.Recursion\\n        // return Math.max(help(arr1,x), help(arr2,x));\\n        \\n        //2.Memoization - Top-Down DP\\n        // int dp[] = new int[x+1];\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans1 = Memo(x,arr1,dp);\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans2 = Memo(x,arr2,dp);\\n        // return Math.max(ans1,ans2);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return Math.max(DP(arr1), DP(arr2));\\n    }\\n    public int help(int[] nums,int index){\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        \\n        int include = nums[index] + help(nums,index-2);\\n        int notInclude = help(nums,index-1);\\n        \\n        return Math.max(include,notInclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums){\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177085,
                "title": "python-dp-beats-99-very-clearly-explained",
                "content": "***Problem***\\nThis problem is a follow up question for the [House Robber](https://leetcode.com/problems/house-robber/) which I already written a clearly explained 95% solution on [here.](https://leetcode.com/problems/house-robber/discuss/2172617/python-dp-and-dfs-95-solution-very-clearly-explained) I highly recommend you checking that solution first before checking this one so that you can understand this solution better, but it\\'s not required.\\n\\nFirst, we should first identify the difference(s) between the House Robber and House Robber II. The main difference is that in the House Robber question the array is in a straight line while in this question the houses will be circular. \\n>Hint: Think about what impact houses ordered circularly will make on the original question where houses are ordered on a straight line.\\n\\nBefore we proceed, I have renamed the input `nums` to `houses` for clarity sake as I will be using the variable `nums` as input of a function in the code.\\n\\n**Intuition**\\nWe notices 3 main differences between a linear and a circular arrangement:\\n* `houses[-1]` is directly adjacent to `houses[0]` as it is arranged in a circle unlike the original House Robber question.\\n* We can travel starting from `houses[0]` both left and right in a circle. What this means is that you can go right like the original linear House Robber question, meaning you go from `houses[0]` to `houses[1]` to `houses[2]` all the way to `houses[-2]`, or you can go from `houses[0]` to `houses[-1]` to `houses[-2]` until we reach `houses[2]`. Notice how we stopped on `houses[-2]` and `houses[2]` respectively, the reason is because of the first condition that `houses[-1]` is adjacent to `houses[0]`, thus we need to remove `houses[1]` if we are going left and `houses[-1]` if we decide to go right. Ultimately, the maximum output we get from left and right will be our final output, or `max(left, right)`.\\n* There is one more edge case we need to cover. Due to the first difference that `houses[0]` is adjacent to `houses[-1]`, an array with length of 3, or `len(houses) == 3`, can only rob one house. Thus, if that is the case we must rob the 1 house with the most money, or `max(houses)`.\\n\\nThus, our code can be almost the exact same as the code I wrote for the original [House Robber](https://leetcode.com/problems/house-robber/discuss/2172617/python-dp-and-dfs-95-solution-very-clearly-explainedhttp://) problem, but addressing the 3 main differences above.\\n\\n**Algorithm**\\nOur algorithm will be very similar for the original House Robber problem. We first need to address the new edge case of `len(houses) == 3`, which we can do by simply returning the max of houses, or `return max(houses)`. Then, we need to address the other 2 differences, notice that going left and right while removing `houses[1]` and `houses[-1]` respective are simply `max(left, right)`, or `max(houses[1:], houses[:-1])`.\\n\\nBut we need to find out what `left` and `right` will actually be before we find the max of the two. So, we need to start a function which I will name `find()`, and the parameter will be `nums`, which will be a linear array instead of a circle one. Does the code inside the function look familiar? Yes - that is the exact code for the original House Robber question that I copied into this function, you can check my solution for the original question for explanation of that.\\n\\nThus, `return max(find(houses[1:]), find(houses[:-1]))` will be our correct output.\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def rob(self, houses: List[int]) -> int:\\n        if len(houses) == 1:\\n            return houses[0]\\n        if len(houses) == 2 or len(houses) == 3:\\n            return max(houses)\\n        \\n        def find(nums):\\n            n = len(nums)\\n        \\n            dp = [0] * n\\n            dp[0], dp[1], dp[2] = nums[0], nums[1], nums[2] + nums[0]\\n        \\n            for i in range(3, n):\\n                dp[i] = max(dp[i-2], dp[i-3]) + nums[i]\\n        \\n       \\n            return max(dp[-1], dp[-2])\\n    \\n        return max(find(houses[1:]), find(houses[:-1]))\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n**Please consider upvoting if this solution helped you. Good luck!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, houses: List[int]) -> int:\\n        if len(houses) == 1:\\n            return houses[0]\\n        if len(houses) == 2 or len(houses) == 3:\\n            return max(houses)\\n        \\n        def find(nums):\\n            n = len(nums)\\n        \\n            dp = [0] * n\\n            dp[0], dp[1], dp[2] = nums[0], nums[1], nums[2] + nums[0]\\n        \\n            for i in range(3, n):\\n                dp[i] = max(dp[i-2], dp[i-3]) + nums[i]\\n        \\n       \\n            return max(dp[-1], dp[-2])\\n    \\n        return max(find(houses[1:]), find(houses[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855234,
                "title": "java-dynamic-programming-memoization-recursion",
                "content": "1. I have here used start variable for validating it is starting with 0-index or 1-index\\n2. we should use 2 recursion\\'s with dp because we can have edge in this problem\\n```\\nclass Solution {\\n    public int rec(int i,int start,int arr[],int dp[]){\\n        if(i>=arr.length)\\n            return 0;\\n        if(i==arr.length-1&&start==0)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=Math.max(rec(i+1,start,arr,dp),arr[i]+rec(i+2,start,arr,dp));\\n    }\\n    public int rob(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        int result=rec(0,0,nums,dp);\\n        Arrays.fill(dp,-1);\\n        result=Math.max(result,rec(1,1,nums,dp));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rec(int i,int start,int arr[],int dp[]){\\n        if(i>=arr.length)\\n            return 0;\\n        if(i==arr.length-1&&start==0)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=Math.max(rec(i+1,start,arr,dp),arr[i]+rec(i+2,start,arr,dp));\\n    }\\n    public int rob(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        int result=rec(0,0,nums,dp);\\n        Arrays.fill(dp,-1);\\n        result=Math.max(result,rec(1,1,nums,dp));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700049,
                "title": "java-faster-than-100-00",
                "content": "### **JAVA**\\n\\n```\\nclass Solution {\\n\\tpublic static int rob(int[] nums, int s, int e) {\\n\\t\\tint n1 = 0;\\n\\t\\tint n2 = 0;\\n\\t\\tif (e > s)\\n\\t\\t\\tn1 = nums[e - 1];\\n\\t\\tif (e > s + 1)\\n\\t\\t\\tn2 = Math.max(nums[e - 2], n1);\\n\\n\\t\\tfor (int i = e - 3; i >= s; i--) { \\n\\t\\t\\tint ans = Math.max(n2, nums[i] + n1); \\n\\t\\t\\tn1 = n2;\\n\\t\\t\\tn2 = ans;\\n\\t\\t}\\n\\t\\treturn n2;\\n\\t}\\n\\n\\tpublic static int rob(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn nums[0];\\n\\t\\tif (n == 2)\\n\\t\\t\\treturn Math.max(nums[1], nums[0]);\\n\\t\\treturn Math.max(rob(nums, 0, n - 1), rob(nums, 1, n));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int rob(int[] nums, int s, int e) {\\n\\t\\tint n1 = 0;\\n\\t\\tint n2 = 0;\\n\\t\\tif (e > s)\\n\\t\\t\\tn1 = nums[e - 1];\\n\\t\\tif (e > s + 1)\\n\\t\\t\\tn2 = Math.max(nums[e - 2], n1);\\n\\n\\t\\tfor (int i = e - 3; i >= s; i--) { \\n\\t\\t\\tint ans = Math.max(n2, nums[i] + n1); \\n\\t\\t\\tn1 = n2;\\n\\t\\t\\tn2 = ans;\\n\\t\\t}\\n\\t\\treturn n2;\\n\\t}\\n\\n\\tpublic static int rob(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn nums[0];\\n\\t\\tif (n == 2)\\n\\t\\t\\treturn Math.max(nums[1], nums[0]);\\n\\t\\treturn Math.max(rob(nums, 0, n - 1), rob(nums, 1, n));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530791,
                "title": "c-faster-than-100-approach-explained",
                "content": "```\\n  /*\\n    This problem is exactly the House Robber problem with a variation that here there can be two possibilites-\\n    1) Rob first house and skip last house\\n\\t2) Rob last house and skip the first house  \\n\\tOur required answer will be the max of these two possibilites. So we use dp two times-  from 0 to n-2(considering first element\\n\\tand leaving out the last) and from 1 to n-1(considering last element and leaving out the first)\\n    For any house n, Recursive relation- maxmoney[n]=max(maxmoney[n-1],maxmoney[n-2]+money[n-1])\\n */\\nclass Solution {\\n\\npublic:\\n    vector<int> dpstart; //house 0 to n-2 \\n    vector<int> dpend; //house 1 to n-1\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        dpstart.resize(n+1,0);\\n        dpend.resize(n+1,0); \\n        dpstart[0]=0;\\n        dpstart[1]=nums[0];\\n        dpend[1]=0;\\n        dpend[2]=nums[1]; \\n        for(int i=2;i<n;i++){\\n            dpstart[i]=max(dpstart[i-1],dpstart[i-2]+nums[i-1]);\\n        }\\n        for(int i=3;i<=n;i++){\\n            dpend[i]=max(dpend[i-1],dpend[i-2]+nums[i-1]);\\n        }\\n        return max(dpstart[n-1],dpend[n]);\\n    }\\n};\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  /*\\n    This problem is exactly the House Robber problem with a variation that here there can be two possibilites-\\n    1) Rob first house and skip last house\\n\\t2) Rob last house and skip the first house  \\n\\tOur required answer will be the max of these two possibilites. So we use dp two times-  from 0 to n-2(considering first element\\n\\tand leaving out the last) and from 1 to n-1(considering last element and leaving out the first)\\n    For any house n, Recursive relation- maxmoney[n]=max(maxmoney[n-1],maxmoney[n-2]+money[n-1])\\n */\\nclass Solution {\\n\\npublic:\\n    vector<int> dpstart; //house 0 to n-2 \\n    vector<int> dpend; //house 1 to n-1\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        dpstart.resize(n+1,0);\\n        dpend.resize(n+1,0); \\n        dpstart[0]=0;\\n        dpstart[1]=nums[0];\\n        dpend[1]=0;\\n        dpend[2]=nums[1]; \\n        for(int i=2;i<n;i++){\\n            dpstart[i]=max(dpstart[i-1],dpstart[i-2]+nums[i-1]);\\n        }\\n        for(int i=3;i<=n;i++){\\n            dpend[i]=max(dpend[i-1],dpend[i-2]+nums[i-1]);\\n        }\\n        return max(dpstart[n-1],dpend[n]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234674,
                "title": "javascript-dp-time-o-n-space-o-1",
                "content": "```\\nvar rob = function(nums) {\\n    if(nums.length === 1) return nums[0];\\n    if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n    //case 1, don\\'t consider the last house;\\n    var secondLast = nums[0];\\n    var last = Math.max(nums[0], nums[1]);\\n    var result1 = last;\\n    for(var i = 2; i < nums.length - 1; i++) {\\n        result1 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result1;\\n    }\\n    //case 2, don\\'t consider the first house;\\n    secondLast = nums[1];\\n    last = Math.max(nums[1], nums[2]);\\n    var result2 = last;\\n    for(var i = 3; i < nums.length; i++) {\\n        result2 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result2;\\n    }\\n    return Math.max(result1, result2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    if(nums.length === 1) return nums[0];\\n    if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n    //case 1, don\\'t consider the last house;\\n    var secondLast = nums[0];\\n    var last = Math.max(nums[0], nums[1]);\\n    var result1 = last;\\n    for(var i = 2; i < nums.length - 1; i++) {\\n        result1 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result1;\\n    }\\n    //case 2, don\\'t consider the first house;\\n    secondLast = nums[1];\\n    last = Math.max(nums[1], nums[2]);\\n    var result2 = last;\\n    for(var i = 3; i < nums.length; i++) {\\n        result2 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result2;\\n    }\\n    return Math.max(result1, result2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209265,
                "title": "clean-dp-java-solution-with-explanation-3ms-beat-98-71",
                "content": "- **dp1**: largest sum when *remove* the **last** house (nums[0] to nums[nums.length-2])\\n- **dp2**: largest sum when *remove* the **first** house (nums[1] to nums[nums.length-1])\\n- **return** the **larger** sum (Math.max(dp1[dp1.length-1]. dp2[dp2.length-1]))\\n- **edge cases**\\n\\t- *empty*  -> 0\\n\\t- only has *one* house -> nums[0]\\n\\t- only has *two* houses -> Math.max(nums[0], nums[1])\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        int[] dp1 = new int[nums.length-1];\\n        int[] dp2 = new int[nums.length-1];\\n        \\n        dp1[0] = nums[0];\\n        dp2[0] = nums[1];\\n        dp1[1] = Math.max(nums[1], dp1[0]);\\n        dp2[1] = Math.max(nums[2], dp2[0]);\\n        \\n        for(int i = 2; i < nums.length-1; i++) {\\n            dp1[i] = Math.max(dp1[i-2]+nums[i], dp1[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i+1], dp2[i-1]);\\n        }\\n        return Math.max(dp1[dp1.length-1], dp2[dp2.length-1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        int[] dp1 = new int[nums.length-1];\\n        int[] dp2 = new int[nums.length-1];\\n        \\n        dp1[0] = nums[0];\\n        dp2[0] = nums[1];\\n        dp1[1] = Math.max(nums[1], dp1[0]);\\n        dp2[1] = Math.max(nums[2], dp2[0]);\\n        \\n        for(int i = 2; i < nums.length-1; i++) {\\n            dp1[i] = Math.max(dp1[i-2]+nums[i], dp1[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i+1], dp2[i-1]);\\n        }\\n        return Math.max(dp1[dp1.length-1], dp2[dp2.length-1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60048,
                "title": "my-15-line-c-code-0ms-runtime-for-test-data",
                "content": "       /************************************\\n       **  author : s2003zy\\n       **  blog :  s2003zy.com\\n       ** weibo:  weibo.com/songzy982\\n       ****************************************/ \\n       class Solution {\\n        public:\\n            int res(vector<int>& nums, int left, int right) {\\n                int last = 0, lastlast = 0;\\n                for (int i = left; i < right; i++) {\\n                    lastlast = max(last, lastlast + nums[i]);\\n                    swap(last, lastlast);\\n                }\\n                return last;\\n            }\\n            int rob(vector<int>& nums) {\\n                if (nums.size() == 1) return nums[0];\\n                return max(res(nums, 0, nums.size() - 1) ,res(nums, 1, nums.size()));\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int res(vector<int>& nums, int left, int right) {\\n                int last = 0, lastlast = 0;\\n                for (int i = left; i < right; i++) {\\n                    lastlast = max(last, lastlast + nums[i]);\\n                    swap(last, lastlast);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3678450,
                "title": "c-house-robber-1-to-n-or-0-to-n-1",
                "content": "This problem is very similar to problem [House Robber](https://leetcode.com/problems/house-robber/solutions/3678350/c-most-optimal-code-with-explanation-and-comments/). \\nI suggest you to go through my solution on that problem first and then this problem is a cake walk.\\n\\n---\\n\\n\\n# Intuition\\n- The problem revolves around finding the maximum amount of money that can be robbed from houses arranged in a circular street, where adjacent houses have a security system connected.\\n- The objective is to devise a strategy that allows the robber to accumulate the highest possible sum of money without alerting the police.\\n- To achieve this, we need to consider two scenarios: one where the first house is robbed and one where it is not.\\n- By considering these two scenarios separately, we cover all possible combinations of robbing and skipping houses.\\n- The goal is to identify the optimal scenario that results in the maximum amount of money being robbed.\\n \\n\\n---\\n\\n\\n# Approach\\n- Divide the problem into two parts: one where the first house is robbed and one where it is not.\\n- Create a function robHelper which utilizes the dynamic programming technique, maintaining two variables (currMax and prevMax) to track the maximum amount of money that can be robbed.\\n- Call the robHelper function twice: once considering robbing the first house to the second-to-last house, and once considering skipping the first house and robbing the rest.\\n- Finally, return the maximum amount between the two scenarios as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- **Time complexity**:\\nThe time complexity of the solution is **O(N)**, where N is the size of the input array (the number of houses). The robHelper function which is used to iterate through the houses is called twice, thus the time complexity is O(N).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**:\\nThe space complexity is **O(1)** because the solution uses a constant amount of additional space to store the currMax and prevMax variables in the robHelper function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return nums[0];\\n        }\\n        \\n        int robFirstHouse = robHelper(nums, 0, nums.size() - 2); // Rob the first house to the second-to-last house\\n        int skipFirstHouse = robHelper(nums, 1, nums.size() - 1); // Skip the first house and rob the rest\\n        \\n        return max(robFirstHouse, skipFirstHouse);\\n    }\\n    \\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int currMax = 0;\\n        int prevMax = 0;\\n        \\n        for (int i = start; i <= end; i++) {\\n            int temp = max(prevMax + nums[i], currMax);\\n            prevMax = currMax;\\n            currMax = temp;\\n        }\\n        \\n        return currMax;\\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return nums[0];\\n        }\\n        \\n        int robFirstHouse = robHelper(nums, 0, nums.size() - 2); // Rob the first house to the second-to-last house\\n        int skipFirstHouse = robHelper(nums, 1, nums.size() - 1); // Skip the first house and rob the rest\\n        \\n        return max(robFirstHouse, skipFirstHouse);\\n    }\\n    \\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int currMax = 0;\\n        int prevMax = 0;\\n        \\n        for (int i = start; i <= end; i++) {\\n            int temp = max(prevMax + nums[i], currMax);\\n            prevMax = currMax;\\n            currMax = temp;\\n        }\\n        \\n        return currMax;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657452,
                "title": "c-solution-dp-100-beat-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint houseRobber(vector<int> &arr) {\\n        int n = arr.size();\\n        int prev2 = 0;\\n        int prev = arr[0];\\n        int curr;\\n        for (int i=1; i<n; i++) {\\n            int pick = arr[i];\\n            if (i > 1) pick += prev2;\\n            int notPick = 0 + prev;\\n            curr = max(pick, notPick);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        vector<int> temp1(begin(nums), end(nums)-1);\\n        vector<int> temp2(begin(nums)+1, end(nums));\\n        return max(houseRobber(temp1) , houseRobber(temp2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint houseRobber(vector<int> &arr) {\\n        int n = arr.size();\\n        int prev2 = 0;\\n        int prev = arr[0];\\n        int curr;\\n        for (int i=1; i<n; i++) {\\n            int pick = arr[i];\\n            if (i > 1) pick += prev2;\\n            int notPick = 0 + prev;\\n            curr = max(pick, notPick);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        vector<int> temp1(begin(nums), end(nums)-1);\\n        vector<int> temp2(begin(nums)+1, end(nums));\\n        return max(houseRobber(temp1) , houseRobber(temp2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447785,
                "title": "house-robber-ii-dp-c-solution-space-optimisation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**DP TABULATION APPROACH (TOP - DOWN) WITH SPACE OPTIMISATION**\\n\\nThe function **solve** iterates through the list of houses and for each house, two possible values can be calculated :\\n\\n- **take**, which represents the maximum amount of money that can be robbed if the current house is robbed, and\\n- **notTake**, which represents the maximum amount of money that can be robbed if the current house is not robbed.\\n\\nThe **curr** variable then stores the **maximum** value between take and notTake. Then the prev2 and prev1 variables accordingly changed.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &arr){\\n        //using tabulation(top-down) approach with space optimisation\\n\\n        int n = arr.size();\\n        int prev1 = arr[0];\\n        int prev2 = 0;\\n\\n        for(int i = 1; i < n; i++){\\n            int take = arr[i];\\n            \\n            if(i > 1)\\n                take += prev2;\\n\\n            int notTake = 0 + prev1;\\n            int curr = max(take,notTake);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        long long int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n\\n        //contain all the houses except the first one\\n        vector<int> temp1;\\n\\n        //contain all the houses except the last one\\n        vector<int> temp2;\\n\\n        for(int i = 0; i < n; i++){\\n            if(i != 0)\\n                temp1.push_back(nums[i]);\\n\\n            if(i != n-1)\\n                temp2.push_back(nums[i]);\\n        }\\n        return max( solve(temp1) , solve(temp2) );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &arr){\\n        //using tabulation(top-down) approach with space optimisation\\n\\n        int n = arr.size();\\n        int prev1 = arr[0];\\n        int prev2 = 0;\\n\\n        for(int i = 1; i < n; i++){\\n            int take = arr[i];\\n            \\n            if(i > 1)\\n                take += prev2;\\n\\n            int notTake = 0 + prev1;\\n            int curr = max(take,notTake);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        long long int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n\\n        //contain all the houses except the first one\\n        vector<int> temp1;\\n\\n        //contain all the houses except the last one\\n        vector<int> temp2;\\n\\n        for(int i = 0; i < n; i++){\\n            if(i != 0)\\n                temp1.push_back(nums[i]);\\n\\n            if(i != n-1)\\n                temp2.push_back(nums[i]);\\n        }\\n        return max( solve(temp1) , solve(temp2) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300063,
                "title": "dynamic-programming-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n    #please upvote me it would encourage me alot\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n    #please upvote me it would encourage me alot\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200178,
                "title": "python-dynamic-programming-approach-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        def solve(nums):\\n            dp1 = dp2 = 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)\\n            return dp2\\n        return max(solve(nums[1:]), solve(nums[:len(nums)-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        def solve(nums):\\n            dp1 = dp2 = 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)\\n            return dp2\\n        return max(solve(nums[1:]), solve(nums[:len(nums)-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541299,
                "title": "my-java-solution-by-1-recursion-tle-2-memoization-3-tabulation-4-space-optimisation",
                "content": "```\\n1. Recursion\\n\\n\\n/*\\n\\nSince last element is the adjacent of the first element, we can have 3 observations.\\n\\n1. In our answer, there will not be both first and last element together.\\n2. If we leave the first element, then its solving house robber 1 from index 1 to n.\\n3. If we leave the last element, then its solving house robber 1 from index 0 to n - 1.\\n\\nSo our final answer will be max(step2, step3).\\n\\nBut this recursive solution will gives TLE as there are so many overlapping subproblems\\n\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1);\\n        return Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\\n\\n\\n```\\n2. Memoization\\n\\n/*\\n\\nUse 2 dp tables. One to track the results while we are not cosnidering the first element and the first one while we are considering the first element.\\n\\nThen just apply the dp tables and save the result at the very end where we are doing the return statement.\\n\\nTC : O(N)\\nSC : O(N) + O(N) + O(Stack Space)\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        // dp1 will be for the case where we do not consider the first element\\n        dp1[0] = nums[1];\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        // dp2 will be for the case where we consider the first element\\n        dp2[0] = nums[0];\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1, dp1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2, dp2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end, int [] dp) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        if (dp[end] != -1) {\\n            return dp[end];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2, dp);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1, dp);\\n        return dp[end] = Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\\n\\n\\n```\\n3. Tabulation\\n\\n/*\\n\\nNow we can go for the tabulation method and get rid of the extra stack space we are using\\n\\nTC : O(N)\\nSC : O(N) + O(N) [Didn;t considered the temp arraylist created] \\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        ArrayList<Integer> arr1=new ArrayList<>();\\n        ArrayList<Integer> arr2=new ArrayList<>();\\n\\n        // storing the elements to two separate list\\n        for(int i=0; i<length; i++){\\n\\n            if(i != 0) arr1.add(nums[i]);\\n            if(i != length - 1) arr2.add(nums[i]);\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(arr1, dp1), \\n                      maxResultLeavingNotLeavingFirstLast(arr2, dp2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(ArrayList<Integer> nums, int [] dp) {\\n        dp[0] = nums.get(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            int pickElement = nums.get(i);\\n            if (i > 1) {\\n                pickElement += dp[i - 2];\\n            }\\n            int notPickElement = dp[i - 1];\\n            dp[i] = Math.max(pickElement, notPickElement);\\n        }\\n        return dp[nums.size() - 1];\\n    }\\n}\\n```\\n\\n\\n```\\n4. Space Optimized\\n\\n/*\\n\\nWe can make 1 more observation that, we only care about the previous house and the previous previous house. So instead of the dp arrays, we can just make use of two variable and apply the same logic which will reduce our space further\\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(nums, 1, length - 1), \\n                      maxResultLeavingNotLeavingFirstLast(nums, 0, length - 2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(int [] nums, int start, int end) {\\n        int previous = nums[start];\\n        int previousPrevious = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int pick = nums[i] + previousPrevious;\\n            int notPick = previous;\\n            int result = Math.max(pick, notPick);\\n            previousPrevious = previous;\\n            previous = result;\\n        }\\n        return previous;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n1. Recursion\\n\\n\\n/*\\n\\nSince last element is the adjacent of the first element, we can have 3 observations.\\n\\n1. In our answer, there will not be both first and last element together.\\n2. If we leave the first element, then its solving house robber 1 from index 1 to n.\\n3. If we leave the last element, then its solving house robber 1 from index 0 to n - 1.\\n\\nSo our final answer will be max(step2, step3).\\n\\nBut this recursive solution will gives TLE as there are so many overlapping subproblems\\n\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1);\\n        return Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\n```\\n2. Memoization\\n\\n/*\\n\\nUse 2 dp tables. One to track the results while we are not cosnidering the first element and the first one while we are considering the first element.\\n\\nThen just apply the dp tables and save the result at the very end where we are doing the return statement.\\n\\nTC : O(N)\\nSC : O(N) + O(N) + O(Stack Space)\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        // dp1 will be for the case where we do not consider the first element\\n        dp1[0] = nums[1];\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        // dp2 will be for the case where we consider the first element\\n        dp2[0] = nums[0];\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1, dp1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2, dp2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end, int [] dp) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        if (dp[end] != -1) {\\n            return dp[end];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2, dp);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1, dp);\\n        return dp[end] = Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\n```\\n3. Tabulation\\n\\n/*\\n\\nNow we can go for the tabulation method and get rid of the extra stack space we are using\\n\\nTC : O(N)\\nSC : O(N) + O(N) [Didn;t considered the temp arraylist created] \\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        ArrayList<Integer> arr1=new ArrayList<>();\\n        ArrayList<Integer> arr2=new ArrayList<>();\\n\\n        // storing the elements to two separate list\\n        for(int i=0; i<length; i++){\\n\\n            if(i != 0) arr1.add(nums[i]);\\n            if(i != length - 1) arr2.add(nums[i]);\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(arr1, dp1), \\n                      maxResultLeavingNotLeavingFirstLast(arr2, dp2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(ArrayList<Integer> nums, int [] dp) {\\n        dp[0] = nums.get(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            int pickElement = nums.get(i);\\n            if (i > 1) {\\n                pickElement += dp[i - 2];\\n            }\\n            int notPickElement = dp[i - 1];\\n            dp[i] = Math.max(pickElement, notPickElement);\\n        }\\n        return dp[nums.size() - 1];\\n    }\\n}\\n```\n```\\n4. Space Optimized\\n\\n/*\\n\\nWe can make 1 more observation that, we only care about the previous house and the previous previous house. So instead of the dp arrays, we can just make use of two variable and apply the same logic which will reduce our space further\\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(nums, 1, length - 1), \\n                      maxResultLeavingNotLeavingFirstLast(nums, 0, length - 2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(int [] nums, int start, int end) {\\n        int previous = nums[start];\\n        int previousPrevious = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int pick = nums[i] + previousPrevious;\\n            int notPick = previous;\\n            int result = Math.max(pick, notPick);\\n            previousPrevious = previous;\\n            previous = result;\\n        }\\n        return previous;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280879,
                "title": "c-solution-with-comments-representation-house-robber-i-modification",
                "content": "***Please Upvote if it helps......***\\n***\\n***Solution :***\\n***\\n***\\nThis question can be solved using the approach discussed in the Maximum Sum of non-adjacent elements. Readers are highly advised to go through that solution first and then read this. The rest of the solution will refer to the previous solution as ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)***  and will relate to that approach. \\n\\nNow, we have a single test case. Three houses have money as shown.\\n![image](https://assets.leetcode.com/users/images/0e54a364-8578-4442-87c5-17d687584179_1657790986.524139.png)\\n***\\nAccording to ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** , the answer will be 4(2+2) as we are taking the maximum sum of non-adjacent elements.\\nIn this question, the first and last element are also adjacent(circular street), therefore the answer will be 3.\\n***\\n***\\n***Modification to Article DP5\\u2019s Approach***\\n***\\nWe were finding the maximum sum of non-adjacent elements in the previous questions. For a circular street, the first and last house are adjacent, therefore one thing we know for sure is that the answer will not consider the first and last element simultaneously (as they are adjacent).\\n\\nNow building on the ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** , we can say that maybe the last element is not considered in the answer. In that case, we can consider the first element. Let\\u2019s call this answer ans1. Hence we have reduced our array(arr- last element), say arr1, and found ans1 on it by using the ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** approach.\\n![image](https://assets.leetcode.com/users/images/21eb13d2-6fdc-4b2f-be89-0930ac24e63c_1657791058.8511071.png)\\n\\n\\n\\nNow, it can also happen that the final answer does consider the last element. If we consider the last element, we can\\u2019t consider the first element( again adjacent elements). We again use the same approach on our reduced array( arr \\u2013 first element), say arr2. Let\\u2019s call the answer we get as ans2.\\n![image](https://assets.leetcode.com/users/images/e881aee1-e3d5-4be6-b76f-8c3581589fe2_1657791108.8978257.png)\\nNow, the final answer can be either ans1 or ans2. As we have to return the maximum money robbed by the robber, we will return max(ans1, ans2) as our final answer.\\n***\\n***\\n***Approach:***\\n***\\nThe approach to solving this problem can be summarized as:\\n\\n* Make two reduced arrays \\u2013 arr1(arr-last element) and arr2(arr-first element).\\n* Find the maximum of non-adjacent elements as mentioned in ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** on arr1 and arr2 separately. Let\\u2019s call the answers we got as ans1 and ans2 respectively.\\n* Return max(ans1, ans2) as our final answer.\\n***\\n***\\n***C++ Code:***\\n\\n```\\nlong long int solve(vector<int>& arr){\\n    int n = arr.size();\\n    long long int prev = arr[0];\\n    long long int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        long long int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int long long nonPick = 0 + prev;\\n        \\n        long long int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n\\nlong long int robStreet(int n, vector<int> &arr){\\n    vector<int> arr1;\\n    vector<int> arr2;\\n    \\n    for(int i=0; i<n; i++){\\n        \\n        if(i!=0) arr1.push_back(arr[i]);\\n        if(i!=n-1) arr2.push_back(arr[i]);\\n    }\\n    \\n    long long int ans1 = solve(arr1);\\n    long long int ans2 = solve(arr2);\\n    \\n    return max(ans1,ans2);\\n}\\n```\\n***\\n***Output: 11***\\n***\\n***Time Complexity: O(N )***\\n\\n***Reason:*** We are running a simple iterative loop, two times. Therefore total time complexity will be O(N) + O(N) \\u2248 O(N)\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using extra space.\\n***\\n***\\n***Please Upvote if it helps......***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nlong long int solve(vector<int>& arr){\\n    int n = arr.size();\\n    long long int prev = arr[0];\\n    long long int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        long long int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int long long nonPick = 0 + prev;\\n        \\n        long long int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n\\nlong long int robStreet(int n, vector<int> &arr){\\n    vector<int> arr1;\\n    vector<int> arr2;\\n    \\n    for(int i=0; i<n; i++){\\n        \\n        if(i!=0) arr1.push_back(arr[i]);\\n        if(i!=n-1) arr2.push_back(arr[i]);\\n    }\\n    \\n    long long int ans1 = solve(arr1);\\n    long long int ans2 = solve(arr2);\\n    \\n    return max(ans1,ans2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60006,
                "title": "simple-dp-java-solution-in-1ms",
                "content": "public class Solution {\\n\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int rob=0,notrob=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int currob=notrob+nums[i];\\n            notrob=Math.max(rob,notrob);\\n            rob=currob;\\n        }\\n        int firstcase=Math.max(rob,notrob);\\n        rob=0;notrob=0;\\n        for(int i=1;i<nums.length;i++){\\n            int currob=notrob+nums[i];\\n            notrob=Math.max(rob,notrob);\\n            rob=currob;\\n        }\\n        int secondcase=Math.max(rob,notrob);\\n        return Math.max(firstcase,secondcase);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int rob=0,notrob=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int currob=notrob+nums[i];\\n            notrob=Math.max(rob,notrob);\\n            rob=currob;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3826217,
                "title": "dp-memoization-explained-with-intution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince we are given a circular array , means the first and the last index are connected so we cant pick both of them in one case\\nso what we can do is, we will break the problem into two parts\\n1 - from index 0 to n - 1 ( where n is the last element ) -> we are picking the 0th element but not picking the last element\\n2 - from index 1 to n -> here we are not picking the 0th element but picking the last index\\nWe are doing this because our answer will be any ONE from these two cases so we\\'ll return the max of the two cases\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// recursive function to give max of an array not picking adjacent elements\\n\\n    int maxRob(vector<int>& nums, int end , int n , vector<int>& dp ){\\n        if(n == end) return nums[end]; // we we\\'ll reach n == end only when we were previously at n+2, we\\'ll never reach here from n+1, so we dont need to worry about skipping it or not , if we reach here means it WILL get picked\\n        if( n < end ) return 0; // when n = 1 and we picked then we\\'ll call for n-2 and that is -1  so in that case well return 0\\n        if( dp[n] != -1 ) return dp[n];\\n\\n        int pick = nums[n] + maxRob(nums,end, n-2, dp);  // since we are picking that element we\\'ll add that element (nums[n] ) and call for n-2  because we have to skip 1 element\\n        int notPick = 0 + maxRob(nums,end, n-1, dp); // here we are not picking that element ( that\\'s why adding 0 ) and call for n-1 cause we don\\'t need to skip this time since we are not picking the current element\\n\\n        return dp[n] = max(pick, notPick); // store in dp and return max\\n\\n\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        if( n == 1 ) return nums[0];\\n\\n        vector<int> dp1(n+1,-1);\\n        vector<int> dp2(n+1,-1);\\n\\n        int case1 = maxRob(nums,0, n-2, dp1); // in case 1 we are passing the nums array from 0 to n-2 ( excluding one from last but including the 0th element )\\n        int case2 = maxRob(nums,1, n-1, dp2);  // in case 1 we are passing the nums array from 0 to n-1 (till last, but excluding the 0th element)\\n\\n        return max(case1, case2); // we\\'ll return max of case1 and case2\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// recursive function to give max of an array not picking adjacent elements\\n\\n    int maxRob(vector<int>& nums, int end , int n , vector<int>& dp ){\\n        if(n == end) return nums[end]; // we we\\'ll reach n == end only when we were previously at n+2, we\\'ll never reach here from n+1, so we dont need to worry about skipping it or not , if we reach here means it WILL get picked\\n        if( n < end ) return 0; // when n = 1 and we picked then we\\'ll call for n-2 and that is -1  so in that case well return 0\\n        if( dp[n] != -1 ) return dp[n];\\n\\n        int pick = nums[n] + maxRob(nums,end, n-2, dp);  // since we are picking that element we\\'ll add that element (nums[n] ) and call for n-2  because we have to skip 1 element\\n        int notPick = 0 + maxRob(nums,end, n-1, dp); // here we are not picking that element ( that\\'s why adding 0 ) and call for n-1 cause we don\\'t need to skip this time since we are not picking the current element\\n\\n        return dp[n] = max(pick, notPick); // store in dp and return max\\n\\n\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        if( n == 1 ) return nums[0];\\n\\n        vector<int> dp1(n+1,-1);\\n        vector<int> dp2(n+1,-1);\\n\\n        int case1 = maxRob(nums,0, n-2, dp1); // in case 1 we are passing the nums array from 0 to n-2 ( excluding one from last but including the 0th element )\\n        int case2 = maxRob(nums,1, n-1, dp2);  // in case 1 we are passing the nums array from 0 to n-1 (till last, but excluding the 0th element)\\n\\n        return max(case1, case2); // we\\'ll return max of case1 and case2\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772069,
                "title": "easy-java-beats-100-double-tabulation-time-optimized-no-recursion-used",
                "content": "# Intuition\\nEither the problem will contain the first house or the last\\n\\n# Approach\\nUsing tabulation, create two tables\\n- One that contains the first house and not the last.\\n- The other one contaions the last house and not the first.\\n- return the maximum of both possibilities.\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int n = nums.length;\\n        int[] dp1 = new int[n-1];\\n        int[] dp2 = new int[n-1];\\n        dp1[0] = nums[0];\\n        dp1[1] = Math.max(nums[1],dp1[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp1[i] = Math.max(nums[i] + dp1[i-2], dp1[i-1]);\\n        }\\n        dp2[0] = nums[1];\\n        dp2[1] = Math.max(nums[2],dp2[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp2[i] = Math.max(nums[i+1] + dp2[i-2], dp2[i-1]);\\n        }\\n        int f =  Math.max(dp1[n-2],dp1[n-3]);\\n        int s = Math.max(dp2[n-2], dp2[n-3]);\\n        return Math.max(s, f);\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/5fe145aa-ca91-4414-a597-66c52260e2a9_1689488289.7580066.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int n = nums.length;\\n        int[] dp1 = new int[n-1];\\n        int[] dp2 = new int[n-1];\\n        dp1[0] = nums[0];\\n        dp1[1] = Math.max(nums[1],dp1[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp1[i] = Math.max(nums[i] + dp1[i-2], dp1[i-1]);\\n        }\\n        dp2[0] = nums[1];\\n        dp2[1] = Math.max(nums[2],dp2[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp2[i] = Math.max(nums[i+1] + dp2[i-2], dp2[i-1]);\\n        }\\n        int f =  Math.max(dp1[n-2],dp1[n-3]);\\n        int s = Math.max(dp2[n-2], dp2[n-3]);\\n        return Math.max(s, f);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712626,
                "title": "c-2-methods-dp-beats-100-runtime-96-97-memory",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Method2 (Dp) : further space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(1)\\n    */\\n    // /*\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // special case : when (n = 1)\\n        if(n == 1)\\n            return nums[0];\\n        \\n        // exclude element at last index and find \\'ans1\\'\\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n-1; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        int ans1 = prev1;\\n\\n\\n        // exclude element at first index and find \\'ans2\\'\\n        int prev4 = 0;\\n        int prev3 = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n            int incl = prev4 + nums[i];\\n            int excl = prev3 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev4 = prev3;\\n            prev3 = ans;\\n        }\\n\\n        int ans2 = prev3;\\n\\n        return max(ans1, ans2);\\n    }\\n    // */\\n```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    // Method1 (Dp) : space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(n)\\n    */\\n    /*\\n    public:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        return prev1;\\n    }\\n\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> first, last; // SC: O(2n)\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            if(i != n-1)\\n                first.push_back(nums[i]);\\n            if(i != 0)\\n                last.push_back(nums[i]);\\n        }\\n\\n        return max(solve(first), solve(last)); // TC: O(2n)\\n    }\\n    */\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // Method2 (Dp) : further space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(1)\\n    */\\n    // /*\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // special case : when (n = 1)\\n        if(n == 1)\\n            return nums[0];\\n        \\n        // exclude element at last index and find \\'ans1\\'\\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n-1; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        int ans1 = prev1;\\n\\n\\n        // exclude element at first index and find \\'ans2\\'\\n        int prev4 = 0;\\n        int prev3 = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n            int incl = prev4 + nums[i];\\n            int excl = prev3 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev4 = prev3;\\n            prev3 = ans;\\n        }\\n\\n        int ans2 = prev3;\\n\\n        return max(ans1, ans2);\\n    }\\n    // */\\n```\n```\\n    // Method1 (Dp) : space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(n)\\n    */\\n    /*\\n    public:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        return prev1;\\n    }\\n\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> first, last; // SC: O(2n)\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            if(i != n-1)\\n                first.push_back(nums[i]);\\n            if(i != 0)\\n                last.push_back(nums[i]);\\n        }\\n\\n        return max(solve(first), solve(last)); // TC: O(2n)\\n    }\\n    */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634492,
                "title": "using-memoization-easy-c-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->we will check for two cases \\n1- if we rob from first house then we will not rob from last house i,e from i=0 to n-2 .\\n2- if we rob from last house then we will not rob from first house i,e from i=1 to n-1.\\nThen we will return the max from the result of these two cases.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i ,vector<int>& nums,int n, vector<int>&dp)\\n    {\\n        if(i>n)  return 0;      //base case\\n      \\n        if(dp[i]!=-1)return dp[i];  //check if already evaluated for that value of i\\n\\n        int pick = nums[i]+ helper(i+2 ,nums ,n,dp);\\n        int notpick = helper(i+1,nums,n,dp);  //to skip that house\\n        return dp[i]=max(pick ,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return nums[0];\\n        vector<int>dp(n,-1);  \\n        int fHouse = helper(0,nums,n-2,dp); //if we want to take first house\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=-1;  //changing values of dp back to -1\\n        }\\n        int notFirstHouse = helper(1,nums,n-1,dp); //if we want to take last house\\n        return max(fHouse,notFirstHouse);\\n    }\\n};\\n```\\n![leetl.jpg](https://assets.leetcode.com/users/images/6d356838-909e-42c7-83a9-4cd23c179359_1686680032.6498754.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i ,vector<int>& nums,int n, vector<int>&dp)\\n    {\\n        if(i>n)  return 0;      //base case\\n      \\n        if(dp[i]!=-1)return dp[i];  //check if already evaluated for that value of i\\n\\n        int pick = nums[i]+ helper(i+2 ,nums ,n,dp);\\n        int notpick = helper(i+1,nums,n,dp);  //to skip that house\\n        return dp[i]=max(pick ,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return nums[0];\\n        vector<int>dp(n,-1);  \\n        int fHouse = helper(0,nums,n-2,dp); //if we want to take first house\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=-1;  //changing values of dp back to -1\\n        }\\n        int notFirstHouse = helper(1,nums,n-1,dp); //if we want to take last house\\n        return max(fHouse,notFirstHouse);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342983,
                "title": "using-house-robber-1-twice-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int houseRobberOne(vector<int>& arr) {\\n        int N = arr.size();\\n        if (N == 1) return arr[0];\\n        vector<int> dp(N, 0);\\n        dp[0] = arr[0];\\n        dp[1] = max(arr[0], arr[1]);\\n        for(int i = 2; i < N; i++){\\n            dp[i] = max(dp[i-1], dp[i-2] + arr[i]);\\n        }\\n        return dp[N-1];\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N == 1) return nums[0];\\n        vector<int> v1(nums.begin() + 1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end() - 1);\\n        return max(houseRobberOne(v1), houseRobberOne(v2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int houseRobberOne(vector<int>& arr) {\\n        int N = arr.size();\\n        if (N == 1) return arr[0];\\n        vector<int> dp(N, 0);\\n        dp[0] = arr[0];\\n        dp[1] = max(arr[0], arr[1]);\\n        for(int i = 2; i < N; i++){\\n            dp[i] = max(dp[i-1], dp[i-2] + arr[i]);\\n        }\\n        return dp[N-1];\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N == 1) return nums[0];\\n        vector<int> v1(nums.begin() + 1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end() - 1);\\n        return max(houseRobberOne(v1), houseRobberOne(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323600,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> dp1(n, -1), dp2(n, -1);\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(n-2, num1, dp1);\\n        int max2 = solve(n-2, num2, dp2);\\n        return max (max1, max2);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(num1);\\n        int max2 = solve(num2);\\n        return max (max1, max2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> dp1(n, -1), dp2(n, -1);\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(n-2, num1, dp1);\\n        int max2 = solve(n-2, num2, dp2);\\n        return max (max1, max2);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(num1);\\n        int max2 = solve(num2);\\n        return max (max1, max2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261995,
                "title": "python3-very-easy-solution-uwu",
                "content": "\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        def helper(nums):\\n            prev, curr = 0, 0\\n            for n in nums:\\n                prev, curr = curr, max(n + prev, curr)\\n            return curr\\n\\n        return max(helper(nums[1:]), helper(nums[:-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        def helper(nums):\\n            prev, curr = 0, 0\\n            for n in nums:\\n                prev, curr = curr, max(n + prev, curr)\\n            return curr\\n\\n        return max(helper(nums[1:]), helper(nums[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206106,
                "title": "compact-fast-100-and-space-efficient-90",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        if(nums.length==2) return Math.max(nums[nums.length-1],nums[nums.length-2]);\\n        int nums2[] = new int[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0)nums2[i-1]=nums[i];\\n        }\\n        for(int i=2;i<nums2.length;i++){\\n            nums[i]+=(i-3>=0)?Math.max(nums[i-2],nums[i-3]):nums[i-2];\\n            nums2[i]+=(i-3>=0)?Math.max(nums2[i-2],nums2[i-3]):nums2[i-2];\\n        }\\n        return Math.max(Math.max(nums[nums.length-2],nums[nums.length-3]),Math.max(nums2[nums2.length-1],nums2[nums2.length-2]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        if(nums.length==2) return Math.max(nums[nums.length-1],nums[nums.length-2]);\\n        int nums2[] = new int[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0)nums2[i-1]=nums[i];\\n        }\\n        for(int i=2;i<nums2.length;i++){\\n            nums[i]+=(i-3>=0)?Math.max(nums[i-2],nums[i-3]):nums[i-2];\\n            nums2[i]+=(i-3>=0)?Math.max(nums2[i-2],nums2[i-3]):nums2[i-2];\\n        }\\n        return Math.max(Math.max(nums[nums.length-2],nums[nums.length-3]),Math.max(nums2[nums2.length-1],nums2[nums2.length-2]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182033,
                "title": "java-c-100-solution-using-dynamic-programming-house-robber-ii",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return max(tempAns,prev);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return Math.max(tempAns,prev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return max(tempAns,prev);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return Math.max(tempAns,prev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072557,
                "title": "c-very-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        vector<int> dp1(n, 0), dp2(n, 0);\\n        \\n        dp1[1] = nums[0];\\n        dp2[1] = nums[1];\\n        for(int i=2; i<n; i++) {\\n            dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i-1]);\\n            dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i]);\\n        }\\n\\n        return max(dp1[n-1], dp2[n-1]);\\n    }\\n};\\n```\\n\\n# Explanation\\n- ***dp1*** contains the first house, ***dp2*** contains the last house\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        vector<int> dp1(n, 0), dp2(n, 0);\\n        \\n        dp1[1] = nums[0];\\n        dp2[1] = nums[1];\\n        for(int i=2; i<n; i++) {\\n            dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i-1]);\\n            dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i]);\\n        }\\n\\n        return max(dp1[n-1], dp2[n-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507891,
                "title": "c-memoization-solution-100-fast",
                "content": "This problem is a little tricky at first glance. However, if you have finished the House Robber problem, this problem can simply be decomposed into two House Robber problems.\\nSuppose there are n houses, since house 0 and n - 1 are now neighbors, we cannot rob them together and thus the solution is now the maximum of\\n\\nRob houses 0 to n - 2;\\nRob houses 1 to n - 1.\\nThe code is as follows. Some edge cases (n < 2) are handled explicitly.\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums,int i,int j,vector<int> &dp){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,j,dp)+nums[i];\\n        int notake=help(nums,i+1,j,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        vector<int> dp1(nums.size()+1,-1);\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        return max(help(nums,0,nums.size()-1,dp),help(nums,1,nums.size(),dp1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums,int i,int j,vector<int> &dp){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,j,dp)+nums[i];\\n        int notake=help(nums,i+1,j,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        vector<int> dp1(nums.size()+1,-1);\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        return max(help(nums,0,nums.size()-1,dp),help(nums,1,nums.size(),dp1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345845,
                "title": "success-details-runtime-41-ms-python3-vimla-kushwaha",
                "content": "![image](https://assets.leetcode.com/users/images/3b4eb15e-fc7e-4438-9ddc-e7f6ef2b35bf_1659011185.294158.png)\\n**First best Solution**\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        a1 = 0\\n        b1 = nums[0]\\n        a2 = 0\\n        b2 = nums[1]\\n        for i in range(1, len(nums) - 1):\\n            a1, b1 = b1, max(a1 + nums[i], b1)\\n            a2, b2 = b2, max(a2 + nums[i + 1], b2)\\n        return max(b1, b2)\\n```\\n***upvote*** if this helped you out!!\\n\\n**Second Best Solution**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        # step 1 or 2\\n        if n<=2:\\n            return max(nums)\\n        \\n        \\n        return max(self.helper(nums[:-1]),self.helper(nums[1:]))\\n    \\n    \\n    def helper(self,nums):\\n        \\n        \\n        dp=[0]*len(nums)\\n        \\n        \\n        dp[0]=nums[0]\\n        dp[1]=max(nums[0],nums[1])\\n        \\n        for i in range(2,len(nums)):\\n            dp[i]=max(nums[i]+dp[i-2],dp[i-1])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        a1 = 0\\n        b1 = nums[0]\\n        a2 = 0\\n        b2 = nums[1]\\n        for i in range(1, len(nums) - 1):\\n            a1, b1 = b1, max(a1 + nums[i], b1)\\n            a2, b2 = b2, max(a2 + nums[i + 1], b2)\\n        return max(b1, b2)\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        # step 1 or 2\\n        if n<=2:\\n            return max(nums)\\n        \\n        \\n        return max(self.helper(nums[:-1]),self.helper(nums[1:]))\\n    \\n    \\n    def helper(self,nums):\\n        \\n        \\n        dp=[0]*len(nums)\\n        \\n        \\n        dp[0]=nums[0]\\n        dp[1]=max(nums[0],nums[1])\\n        \\n        for i in range(2,len(nums)):\\n            dp[i]=max(nums[i]+dp[i-2],dp[i-1])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183434,
                "title": "java-dp-solution-in-depth-explanation",
                "content": "If you have not completed **LC. 198 House Robber** yet, I strongly recommend you to do that problem first because the problem is a minor extension to the LC.198 House Robber. The only difference between LC. 213 House Robber II and LC. 198 House Robber is that we can see the houses are arranged as a circle here. We can not rob first house and last house simultaenously because the two houses are connected. You can use the image below as a reference. \\n   \\n   Therefore, we can divide the given input array into two diffrent array[ ]. Let\\'s say we create house1 and house2 array:\\n   \\n   `nums    = [7, 4, 1, 9, 3, 8, 6, 5]`\\n   `house1 = [7, 4, 1, 9, 3, 8, 6]`\\n   `house2 = [4, 1, 9, 3, 8, 6, 5]`\\n   \\n   We image us, as the professional robbers, try to rob several houses on **two different streets**. Then we return maxmium profit of these two streets. I believe it\\'s pretty clear at this point. We pass these two ArrayList<Integer> into our helper method, and we return the max profit from two helper methods.\\n   \\n   ![image](https://assets.leetcode.com/users/images/39a30a99-4b56-4112-ab7b-2253d1fbe8cb_1655906349.5961971.png)\\n   \\n   Below is my solution in Java. You could notice we can achieve O(n) time | O(n) space. If you wanna optimize the space complexity, then we don\\'t create ArrayList. We pass startIdx and endIdx into hellper method, and we use variables to track the max profit. Hence, we can achieve O(n) time | O(1) space. \\n   \\n```\\nclass Solution\\n{\\n    public int rob(int[] nums)\\n    {\\n        /*\\n        nums = [7, 4, 1, 9, 3, 8, 6, 5]\\n        Street1 = [7, 4, 1, 9, 3, 8, 6]\\n        Street2 = [4, 1, 9, 3, 8, 6, 5]\\n        */\\n        \\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        ArrayList<Integer> house1 = new ArrayList<>();\\n        ArrayList<Integer> house2 = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n            house1.add(nums[i]);\\n        \\n        for(int i = 1; i < nums.length; i++)\\n            house2.add(nums[i]);\\n        \\n        int max1 = helper(house1);\\n        int max2 = helper(house2);\\n        \\n        \\n        System.out.println(max1);\\n        System.out.println(max2);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    public int helper(ArrayList<Integer> house)\\n    {\\n        if(house.size() == 0)   return 0;\\n        if(house.size() == 1)   return house.get(0);\\n        \\n        int[] maxSum = new int[house.size()];\\n        maxSum[0] = house.get(0);\\n        maxSum[1] = Math.max(house.get(0), house.get(1));\\n        \\n        for(int i = 2; i < house.size(); i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + house.get(i));\\n        \\n        return maxSum[maxSum.length-1];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int rob(int[] nums)\\n    {\\n        /*\\n        nums = [7, 4, 1, 9, 3, 8, 6, 5]\\n        Street1 = [7, 4, 1, 9, 3, 8, 6]\\n        Street2 = [4, 1, 9, 3, 8, 6, 5]\\n        */\\n        \\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        ArrayList<Integer> house1 = new ArrayList<>();\\n        ArrayList<Integer> house2 = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n            house1.add(nums[i]);\\n        \\n        for(int i = 1; i < nums.length; i++)\\n            house2.add(nums[i]);\\n        \\n        int max1 = helper(house1);\\n        int max2 = helper(house2);\\n        \\n        \\n        System.out.println(max1);\\n        System.out.println(max2);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    public int helper(ArrayList<Integer> house)\\n    {\\n        if(house.size() == 0)   return 0;\\n        if(house.size() == 1)   return house.get(0);\\n        \\n        int[] maxSum = new int[house.size()];\\n        maxSum[0] = house.get(0);\\n        maxSum[1] = Math.max(house.get(0), house.get(1));\\n        \\n        for(int i = 2; i < house.size(); i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + house.get(i));\\n        \\n        return maxSum[maxSum.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158878,
                "title": "do-house-robber-twice",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = {}\\n        def getResult(a,i):\\n            if i>=len(a):\\n                return 0\\n            if i in dp:\\n                return dp[i]\\n            \\n            sum = 0\\n            if i<len(a)-1:\\n                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))\\n            else:\\n                sum+=a[i]+getResult(a,i+2)\\n            dp[i] = sum\\n            return sum\\n            \\n        x = getResult(nums[:len(nums)-1],0)\\n        dp = {}\\n        y = getResult(nums[1:],0)\\n            \\n        return max(x, y)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = {}\\n        def getResult(a,i):\\n            if i>=len(a):\\n                return 0\\n            if i in dp:\\n                return dp[i]\\n            \\n            sum = 0\\n            if i<len(a)-1:\\n                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))\\n            else:\\n                sum+=a[i]+getResult(a,i+2)\\n            dp[i] = sum\\n            return sum\\n            \\n        x = getResult(nums[:len(nums)-1],0)\\n        dp = {}\\n        y = getResult(nums[1:],0)\\n            \\n        return max(x, y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880441,
                "title": "100-faster-with-explanation-dp",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Explanation :-**\\n\\n![image](https://assets.leetcode.com/users/images/00257e40-83bb-4806-ab71-9c7aed44b285_1648145851.9563727.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n - 1) , dp2(n);\\n        \\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        if(n == 2){\\n            return max(nums[0] , nums[1]);\\n        }\\n         \\n        dp1[0] = dp1[1] = nums[0]; // First house is robbed\\n        for(int i = 2 ; i < n - 1 ; i++){\\n            dp1[i] = max(dp1[i - 1] , dp1[i - 2] + nums[i]);\\n        }\\n        \\n\\t    dp2[1] = nums[1]; // First house is not robbed\\n        dp2[2] = max(nums[1] , nums[2]);\\n        for(int i = 3 ; i < n ; i++){\\n            dp2[i] = max(dp2[i - 1] , dp2[i - 2] + nums[i]);   \\n        }\\n        return max(dp1[n - 2] , dp2[n - 1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n - 1) , dp2(n);\\n        \\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        if(n == 2){\\n            return max(nums[0] , nums[1]);\\n        }\\n         \\n        dp1[0] = dp1[1] = nums[0]; // First house is robbed\\n        for(int i = 2 ; i < n - 1 ; i++){\\n            dp1[i] = max(dp1[i - 1] , dp1[i - 2] + nums[i]);\\n        }\\n        \\n\\t    dp2[1] = nums[1]; // First house is not robbed\\n        dp2[2] = max(nums[1] , nums[2]);\\n        for(int i = 3 ; i < n ; i++){\\n            dp2[i] = max(dp2[i - 1] , dp2[i - 2] + nums[i]);   \\n        }\\n        return max(dp1[n - 2] , dp2[n - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614654,
                "title": "simple-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n     int solve(vector<int>& nums) {\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        //corner cases\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        if(n==2) return max(nums[0],nums[1]);\\n         \\n        vector<int>v1(nums.begin(),nums.end()-1); //Exculde first house and include last house\\n        vector<int>v2(nums.begin()+1,nums.end()); //Exculde last house and include first house\\n        \\n        return max(solve(v1),solve(v2));\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     int solve(vector<int>& nums) {\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1544251,
                "title": "javascript-memoized-recursion-beats-100-time-commented-code",
                "content": "As the last house is connected back to first house in a circular way, we cannot have a loot which involves both first house and last house. So, we can split the problem into 2 parts: \\n\\t1. To start from house1 and go till house n-1 (last house - 1)\\n\\t2. To start from house2 and go till house n (last house)\\nand then take the maximum of the two loots and return.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar rob = function(nums) {\\n  let dp = []; //to memoize the repetitive calls\\n  \\n  function helpRob(start, house){\\n    //base condition to return 0 if we to try go past the starting house\\n    if(house < start.start) return 0;\\n\\t\\n    //if we have already visited this house, then directly return the value memoized in the array\\n    if(dp[house] >= 0) return dp[house];\\n\\t\\n    //else store and return the maximum of either choosing to rob the current house \\n//and going 2 houses back or choosing to not rob the house and going to the previous house\\n    dp[house] = Math.max((nums[house] + helpRob({start: start.start}, house-2))\\n                          , helpRob({start: start.start}, house-1));\\n    \\n    return dp[house];\\n  }\\n  \\n  if(nums.length === 1) return nums[0];\\n  if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n  \\n  //travelling from house 1 to house n-1\\n  //passing the start as an object as it is passed by reference.\\n  let first = helpRob({start: 0}, nums.length-2);\\n  \\n  //resetting the memoized array after the first travel\\n  dp = [];\\n  \\n  //travelling from house 2 to house n-2\\n  let second = helpRob({start: 1}, nums.length-1);\\n  \\n  //returning the maximum between two traversals\\n  return Math.max(first, second);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar rob = function(nums) {\\n  let dp = []; //to memoize the repetitive calls\\n  \\n  function helpRob(start, house){\\n    //base condition to return 0 if we to try go past the starting house\\n    if(house < start.start) return 0;\\n\\t\\n    //if we have already visited this house, then directly return the value memoized in the array\\n    if(dp[house] >= 0) return dp[house];\\n\\t\\n    //else store and return the maximum of either choosing to rob the current house \\n//and going 2 houses back or choosing to not rob the house and going to the previous house\\n    dp[house] = Math.max((nums[house] + helpRob({start: start.start}, house-2))\\n                          , helpRob({start: start.start}, house-1));\\n    \\n    return dp[house];\\n  }\\n  \\n  if(nums.length === 1) return nums[0];\\n  if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n  \\n  //travelling from house 1 to house n-1\\n  //passing the start as an object as it is passed by reference.\\n  let first = helpRob({start: 0}, nums.length-2);\\n  \\n  //resetting the memoized array after the first travel\\n  dp = [];\\n  \\n  //travelling from house 2 to house n-2\\n  let second = helpRob({start: 1}, nums.length-1);\\n  \\n  //returning the maximum between two traversals\\n  return Math.max(first, second);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265840,
                "title": "java-dynamic-programming-with-explanation",
                "content": "# Approach\\nThe approach is similar to the basic house robber problem. The only new constraint is that the houses are arranged in a circular manner (last house being the neighbor of the first house).\\n\\nSo, if I choose the first house in the final result, last house cannot be included and vice versa. I can split the solution into solving for two arrays, one from index 0 to n - 1 and other from 1 to n (n being the length of the array). Finally I can return the max between these two answers. This leads to a time complexity of twice of the basic house robber problem, but it can be ignored due to being a constant. \\n\\n# Implementations\\n\\n## 1. Recursion\\nTime complexity: O(2^n)\\nSpace complexity: O(n)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n\\t\\t// edge case\\n\\t\\tif (nums.length == 1)\\n            return nums[0];\\n\\t\\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // return maximum between the two cases\\n        return Math.max(recurse(0, nums.length - 1),\\n                        recurse(1, nums.length));\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        return Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n    }\\n}\\n```\\n\\n## 2. Top-down DP\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums, memo;\\n    \\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // initialize dp table\\n        memo = new int[nums.length];\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int first = recurse(0, nums.length - 1);\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int second = recurse(1, nums.length);\\n        \\n        // return the maximum result between the two cases\\n        return Math.max(first, second);\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        else if (memo[cur] != -1) return memo[cur];\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        memo[cur] = Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n        \\n        return memo[cur];\\n    }\\n}\\n```\\n\\n## 3. Bottom-up DP\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        // initialize dp table\\n        int[] memo = new int[nums.length];\\n        \\n        // set base cases\\n        memo[start] = nums[start];\\n        if (end > start + 1)\\n            memo[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]);\\n        }\\n        \\n        return memo[end - 1];\\n    }\\n}\\n```\\n\\n## 4. Bottom-up DP with constant space\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        int oneBack = 0, twoBack = 0;\\n        \\n        // set base cases        \\n        if (end > start + 1) {\\n            oneBack = Math.max(nums[start], nums[start + 1]);\\n            twoBack = nums[start];\\n        }\\n        else {\\n            oneBack = nums[start];\\n        }\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            int cur = Math.max(oneBack, nums[i] + twoBack);\\n            twoBack = oneBack;\\n            oneBack = cur;\\n        }\\n        \\n        return oneBack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n\\t\\t// edge case\\n\\t\\tif (nums.length == 1)\\n            return nums[0];\\n\\t\\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // return maximum between the two cases\\n        return Math.max(recurse(0, nums.length - 1),\\n                        recurse(1, nums.length));\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        return Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    int[] nums, memo;\\n    \\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // initialize dp table\\n        memo = new int[nums.length];\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int first = recurse(0, nums.length - 1);\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int second = recurse(1, nums.length);\\n        \\n        // return the maximum result between the two cases\\n        return Math.max(first, second);\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        else if (memo[cur] != -1) return memo[cur];\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        memo[cur] = Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n        \\n        return memo[cur];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        // initialize dp table\\n        int[] memo = new int[nums.length];\\n        \\n        // set base cases\\n        memo[start] = nums[start];\\n        if (end > start + 1)\\n            memo[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]);\\n        }\\n        \\n        return memo[end - 1];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        int oneBack = 0, twoBack = 0;\\n        \\n        // set base cases        \\n        if (end > start + 1) {\\n            oneBack = Math.max(nums[start], nums[start + 1]);\\n            twoBack = nums[start];\\n        }\\n        else {\\n            oneBack = nums[start];\\n        }\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            int cur = Math.max(oneBack, nums[i] + twoBack);\\n            twoBack = oneBack;\\n            oneBack = cur;\\n        }\\n        \\n        return oneBack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232868,
                "title": "c-0ms-top-down-dp-recursive-memoization-line-by-line-explanation",
                "content": "Step by Step solution. \\n```\\nclass Solution {\\npublic:\\n    int dp[105][2];\\n    int getAns(vector<int>&a,int i,int f){ //f is used to check if the first house is looted or not.\\n        if(i>=a.size())return 0;\\n        if(i==a.size()-1&&f)return 0; // if first house is looted, then he cannot loot in the last house.\\n        if(i==a.size()-1&&!f)return a[i]; // if first house is not looted, he will definitely loot the last house. \\n        if(dp[i][f]!=-1)return dp[i][f];\\n        if(i==0){\\n            \\n        return dp[i][f]=max(a[i]+getAns(a,i+2,1),getAns(a,i+1,0));// at i=0, we have to take both the condition, what will be the max value he get if it loots the first house versus what value he will get if he not loots the first house.\\n        }\\n        else{\\n            //if he will loot the current house, he cannot loot the next house so he will go to i+2 th house., and if he not loots the house he can go to i+1 th house. \\n            return dp[i][f]=max(a[i]+getAns(a,i+2,f),getAns(a,i+1,f));\\n            \\n        }\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return getAns(nums,0,0);   \\n    }\\n};\\n```\\nDo upvote if you liked the solution!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][2];\\n    int getAns(vector<int>&a,int i,int f){ //f is used to check if the first house is looted or not.\\n        if(i>=a.size())return 0;\\n        if(i==a.size()-1&&f)return 0; // if first house is looted, then he cannot loot in the last house.\\n        if(i==a.size()-1&&!f)return a[i]; // if first house is not looted, he will definitely loot the last house. \\n        if(dp[i][f]!=-1)return dp[i][f];\\n        if(i==0){\\n            \\n        return dp[i][f]=max(a[i]+getAns(a,i+2,1),getAns(a,i+1,0));// at i=0, we have to take both the condition, what will be the max value he get if it loots the first house versus what value he will get if he not loots the first house.\\n        }\\n        else{\\n            //if he will loot the current house, he cannot loot the next house so he will go to i+2 th house., and if he not loots the house he can go to i+1 th house. \\n            return dp[i][f]=max(a[i]+getAns(a,i+2,f),getAns(a,i+1,f));\\n            \\n        }\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return getAns(nums,0,0);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894003,
                "title": "c-one-pass-6-lines",
                "content": "Just process the first and last number (house) separately.\\n```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i)\\n\\t\\ta1 = exchange(a2, max(a1 + nums[i], a2)), b1 = exchange(b2, max(b1 + nums[i], b2));\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```\\n\\nCode below does exactly same thing:\\n```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i) {\\n\\t\\tint t = a1;\\n\\t\\ta1 = a2;\\n\\t\\ta2 = max(t + nums[i], a2);\\n\\t\\tt = b1;\\n\\t\\tb1 = b2;\\n\\t\\tb2 = max(t + nums[i], b2);\\n\\t}\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```\\n\\nIf you don\\'t know what => [std::exchange()](https://en.cppreference.com/w/cpp/utility/exchange) <= is",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i)\\n\\t\\ta1 = exchange(a2, max(a1 + nums[i], a2)), b1 = exchange(b2, max(b1 + nums[i], b2));\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```\n```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i) {\\n\\t\\tint t = a1;\\n\\t\\ta1 = a2;\\n\\t\\ta2 = max(t + nums[i], a2);\\n\\t\\tt = b1;\\n\\t\\tb1 = b2;\\n\\t\\tb2 = max(t + nums[i], b2);\\n\\t}\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540739,
                "title": "java-100-dp-solution-no-offset",
                "content": "Just try to find the best solution from two options:\\n1. Dont use the last entry.\\n2. Dont use the first entry.\\n\\n```class Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n                                 \\n        return Math.max(robHelper(nums, 0 , nums.length -1), robHelper(nums, 1 , nums.length)) ;\\n    }\\n    \\n    private int robHelper(int[] nums, int start, int end) {\\n        int[] result = new int[nums.length];\\n        result[start] = nums[start];\\n        result[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        for (int i = 2; i < end; i++){\\n            result[i] = Math.max(result[i - 1],result[i-2] + nums[i]);\\n        }\\n        return Math.max(result[end - 1], result[end - 2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n                                 \\n        return Math.max(robHelper(nums, 0 , nums.length -1), robHelper(nums, 1 , nums.length)) ;\\n    }\\n    \\n    private int robHelper(int[] nums, int start, int end) {\\n        int[] result = new int[nums.length];\\n        result[start] = nums[start];\\n        result[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        for (int i = 2; i < end; i++){\\n            result[i] = Math.max(result[i - 1],result[i-2] + nums[i]);\\n        }\\n        return Math.max(result[end - 1], result[end - 2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409271,
                "title": "python-simple-solution-same-as-house-robber",
                "content": "\\tdef rob(nums):\\n\\t\\tif not nums:\\n\\t\\t\\treturn 0\\n\\t\\tif len(nums)==1:\\n\\t\\t\\treturn nums[0]\\n\\t\\tif len(nums)==2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tdp = nums[:3]+[0]*(len(nums)-3)\\n\\t\\tdp[2]+=nums[0]\\n\\t\\tfor i in range(3,len(nums)):\\n\\t\\t\\tdp[i]=nums[i]+ max(dp[i-2], dp[i-3])\\n\\t\\treturn max(dp[-1], dp[-2])\\n\\n\\tclass Solution:\\n\\t\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\t\\tif not nums:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn nums[0]\\n\\t\\t\\tif len(nums)==2:\\n\\t\\t\\t\\treturn max(nums)\\n\\t\\t\\treturn max([rob(nums[:-1]), rob(nums[1:])])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef rob(nums):\\n\\t\\tif not nums:\\n\\t\\t\\treturn 0\\n\\t\\tif len(nums)==1:\\n\\t\\t\\treturn nums[0]\\n\\t\\tif len(nums)==2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tdp = nums[:3]+[0]*(len(nums)-3)\\n\\t\\tdp[2]+=nums[0]\\n\\t\\tfor i in range(3,len(nums)):\\n\\t\\t\\tdp[i]=nums[i]+ max(dp[i-2], dp[i-3])\\n\\t\\treturn max(dp[-1], dp[-2])\\n\\n\\tclass Solution:\\n\\t\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\t\\tif not nums:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn nums[0]\\n\\t\\t\\tif len(nums)==2:\\n\\t\\t\\t\\treturn max(nums)\\n\\t\\t\\treturn max([rob(nums[:-1]), rob(nums[1:])])",
                "codeTag": "Java"
            },
            {
                "id": 156641,
                "title": "100-single-pass-python",
                "content": "```python\\nclass Solution:\\n    def rob(self, houses):\\n        n = len(houses)\\n        if n == 0:\\n            return 0\\n        if n <= 2:\\n            return max(houses)\\n        a = b = c = d = 0\\n        best = 0\\n        for i, x in enumerate(houses):\\n            if i < n-1:\\n                a, b = b, max(x+a, b)\\n            if i > 0:\\n                c, d = d, max(x+c, d)\\n            best = max(best, b, d)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, houses):\\n        n = len(houses)\\n        if n == 0:\\n            return 0\\n        if n <= 2:\\n            return max(houses)\\n        a = b = c = d = 0\\n        best = 0\\n        for i, x in enumerate(houses):\\n            if i < n-1:\\n                a, b = b, max(x+a, b)\\n            if i > 0:\\n                c, d = d, max(x+c, d)\\n            best = max(best, b, d)\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59966,
                "title": "intuitive-python-dp-solution-one-loop",
                "content": "Two cases:\\n1) Don't rob last house, then it becomes a House Robber I problem from House 1 to House n-1.\\n2) Don't rob first house, then it becomes a House Robber I problem from House 2 to House n.\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 0:\\n            return 0;\\n        elif len(nums) == 1:\\n            return nums[0];\\n        elif len(nums) == 2:\\n            return max(nums[0],nums[1]);\\n        elif len(nums) == 3:\\n            return max(nums[0],nums[1],nums[2]);\\n            \\n        dp1 = [0] * (len(nums)-1);\\n        dp2 = [0] * (len(nums)-1);\\n\\n        dp1[0] = nums[0];\\n        dp1[1] = max(nums[0],nums[1]);\\n        dp2[0] = nums[1];\\n        dp2[1] = max(nums[1],nums[2]);\\n\\n        for i in xrange(2,len(nums)-1):\\n            dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i]);\\n            dp2[i] = max(dp2[i-1],dp2[i-2]+nums[i+1]);\\n        \\n        return max(dp1[-1],dp2[-1]);\\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 0:\\n            return 0;\\n        elif len(nums) == 1:\\n            return nums[0];\\n        elif len(nums) == 2:\\n            return max(nums[0],nums[1]);\\n        elif len(nums) == 3:\\n            return max(nums[0],nums[1],nums[2]);\\n            \\n        dp1 = [0] * (len(nums)-1);\\n        dp2 = [0] * (len(nums)-1);\\n\\n        dp1[0] = nums[0];\\n        dp1[1] = max(nums[0],nums[1]);\\n        dp2[0] = nums[1];\\n        dp2[1] = max(nums[1],nums[2]);\\n\\n        for i in xrange(2,len(nums)-1):\\n            dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i]);\\n            dp2[i] = max(dp2[i-1],dp2[i-2]+nums[i+1]);\\n        \\n        return max(dp1[-1],dp2[-1]);\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59999,
                "title": "java-solution-beats-96-of-submissions",
                "content": "I maintained 4 variables, \\n**firstInc**: the sum that includes the current element of nums[], and can also contain the first number of nums[];\\n\\n**firstExc**: the sum that excludes the current element of nums[], and can also contain the first number of nums[];\\n\\n**nonFirstInc**: the sum that includes the current element of nums[], and DOES NOT contain the first number of nums[];\\n\\n**nonFirstExc**: the sum that excludes the current element of nums[], and DOES NOT contain the first number of nums[];\\n\\n  \\n\\n      public class Solution {\\n            public int rob(int[] nums) {\\n                if(nums.length == 0) return 0;\\n                if(nums.length == 1) return nums[0];\\n                int firstInc = nums[0];\\n                int firstExc = 0;\\n                int nonFirstInc = 0;\\n                int nonFirstExc = 0;\\n                \\n                for(int i = 1; i < nums.length; i++) {\\n                    int preFirstInc = firstInc;\\n                    firstInc = firstExc + nums[i];\\n                    firstExc = Math.max(preFirstInc, firstExc);\\n                    \\n                    int preNFinc = nonFirstInc;\\n                    nonFirstInc = nonFirstExc + nums[i];\\n                    nonFirstExc = Math.max(preNFinc, nonFirstExc);\\n                }\\n                \\n                int maxInc = Math.min(firstInc, nonFirstInc);\\n                \\n                return Math.max(maxInc, firstExc);\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int rob(int[] nums) {\\n                if(nums.length == 0) return 0;\\n                if(nums.length == 1) return nums[0];\\n                int firstInc = nums[0];\\n                int firstExc = 0;\\n                int nonFirstInc = 0;\\n                int nonFirstExc = 0;\\n                \\n                for(int i = 1; i < nums.length; i++) {\\n                    int preFirstInc = firstInc;\\n                    firstInc = firstExc + nums[i];\\n                    firstExc = Math.max(preFirstInc, firstExc);\\n                    \\n                    int preNFinc = nonFirstInc;\\n                    nonFirstInc = nonFirstExc + nums[i];\\n                    nonFirstExc = Math.max(preNFinc, nonFirstExc);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4082265,
                "title": "java-easy-dp-beats-100-runtime-88-memory",
                "content": "**Logic**\\n\\nProblem is very similar to House Robber one and the logic remains mostly the same. I\\'d recommend you try that problem first as it\\'s essentially the foundation for this one. But to quickly go over the base logic, we can break this problem into it\\'s subproblems by simply looking at the max value obtainable in a growing subarray from 1 to n, where n is the length of the array. Since we can\\'t take two adjacent cells, then our dichotemy becomes whether we take the current cell and exclude his neighbors or skip the cell. We can express this in our bellman equation as follows:\\n\\nSolution[i] = max {\\n\\t//take current cell\\n\\tsolution[i-2] + nums[i]\\n\\t//skip cell\\n\\tsolution[i-1]\\n}\\n\\nwhere solution[i] represents the max value at that current index or subarray.\\n\\nThe extra consideration in House Robber II is that taking the start house prevents you from taking the end house as they are neighbors. The question becomes whether to take the start or the end house, how can we do that without breaking the definition of our solution array where each cell is meant to represent the max up until that index? One such way is to add an extra dimension to our solution matrix, or create two arrays. One representing the path where we take the start house, and the other the path where we don\\'t take the start house (where we can possibly take the end house). We can then return the max of the end of these two arrays which should hold the max value possible for that array whether we take the start or end house.\\n\\n**Algorithm**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n\\t\\t//2 solution arrays\\n        int[][] solution = new int[nums.length][2];\\n        \\n        if(nums.length == 1)\\n            return nums[0];\\n        \\n\\t\\t//base cases\\n        solution[0][0] = nums[0];\\n        solution[0][1] = 0;\\n        solution[1][0] = solution[0][0];\\n        solution[1][1] = nums[1];\\n        \\n\\t\\t//iterate over solution array\\n        for(int i = 2; i < solution.length; i++){\\n\\t\\t\\t//if on last house, set path with the start house = to prior max\\n\\t\\t\\t//keep dichotemy of take or leave cell on the path without the start house\\n            if(i == solution.length-1){\\n                solution[i][0] = solution[i-1][0];\\n                solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n                break;\\n            }\\n\\t\\t\\t//Bellman Equation\\n            solution[i][0] = Math.max(solution[i-2][0] + nums[i], solution[i-1][0]);\\n            solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n        }\\n        \\n\\t\\t//return max of path without and with start house which is our solution\\n        return Math.max(solution[nums.length-1][1], solution[nums.length-1][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n\\t\\t//2 solution arrays\\n        int[][] solution = new int[nums.length][2];\\n        \\n        if(nums.length == 1)\\n            return nums[0];\\n        \\n\\t\\t//base cases\\n        solution[0][0] = nums[0];\\n        solution[0][1] = 0;\\n        solution[1][0] = solution[0][0];\\n        solution[1][1] = nums[1];\\n        \\n\\t\\t//iterate over solution array\\n        for(int i = 2; i < solution.length; i++){\\n\\t\\t\\t//if on last house, set path with the start house = to prior max\\n\\t\\t\\t//keep dichotemy of take or leave cell on the path without the start house\\n            if(i == solution.length-1){\\n                solution[i][0] = solution[i-1][0];\\n                solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n                break;\\n            }\\n\\t\\t\\t//Bellman Equation\\n            solution[i][0] = Math.max(solution[i-2][0] + nums[i], solution[i-1][0]);\\n            solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n        }\\n        \\n\\t\\t//return max of path without and with start house which is our solution\\n        return Math.max(solution[nums.length-1][1], solution[nums.length-1][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885713,
                "title": "python-99-19-faster-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(a,n):\\n            n=len(a)\\n            prev=a[0]\\n            prev2=0\\n            curr=0\\n            for i in range(1,n):\\n                pick=a[i]\\n                if i>1:\\n                    pick+=prev2\\n                non_pick=prev\\n                curr=max(pick,non_pick)\\n                prev2=prev\\n                prev=curr\\n            return prev\\n        if len(nums)==1:\\n            return nums[0]\\n        n=len(nums)\\n        return max(solve(nums[1:],n),solve(nums[:-1],n))\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(a,n):\\n            n=len(a)\\n            prev=a[0]\\n            prev2=0\\n            curr=0\\n            for i in range(1,n):\\n                pick=a[i]\\n                if i>1:\\n                    pick+=prev2\\n                non_pick=prev\\n                curr=max(pick,non_pick)\\n                prev2=prev\\n                prev=curr\\n            return prev\\n        if len(nums)==1:\\n            return nums[0]\\n        n=len(nums)\\n        return max(solve(nums[1:],n),solve(nums[:-1],n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881298,
                "title": "memoization-tabulation-space-optimization",
                "content": "**Memoization**\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N) + O(N) (recursive stack space + dp array space)\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1); \\n        int x = solve(nums,0,n-1,dp);\\n        Arrays.fill(dp,-1); \\n        int y = solve(nums,1,n,dp);\\n        return Math.max(x,y);\\n    }\\n    public int solve(int[] nums, int idx, int n, int dp[]){\\n       if(idx>=n){\\n           return 0;\\n       }\\n       if(dp[idx]!=-1){\\n           return dp[idx];\\n       }\\n       return dp[idx]=Math.max(nums[idx] + solve(nums,idx+2,n,dp), 0 + solve(nums,idx+1,n,dp));\\n    }\\n}\\n```\\n\\n**Tabulation**\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N) (dp array space)\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst,dp),solve(includelast,dp));\\n    }\\n    public int solve(int[] nums,int dp[]){\\n        dp[nums.length] = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=dp[i+2];\\n            }\\n            int nottake = 0 + dp[i+1];\\n            dp[i] = Math.max(take,nottake);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n**Space Optimization**\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1)\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst),solve(includelast));\\n    }\\n    public int solve(int[] nums){\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=prev2;\\n            }\\n            int nottake = 0 + prev1;\\n            int cur = Math.max(take,nottake);\\n            prev2 = prev1;\\n            prev1 = cur;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1); \\n        int x = solve(nums,0,n-1,dp);\\n        Arrays.fill(dp,-1); \\n        int y = solve(nums,1,n,dp);\\n        return Math.max(x,y);\\n    }\\n    public int solve(int[] nums, int idx, int n, int dp[]){\\n       if(idx>=n){\\n           return 0;\\n       }\\n       if(dp[idx]!=-1){\\n           return dp[idx];\\n       }\\n       return dp[idx]=Math.max(nums[idx] + solve(nums,idx+2,n,dp), 0 + solve(nums,idx+1,n,dp));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst,dp),solve(includelast,dp));\\n    }\\n    public int solve(int[] nums,int dp[]){\\n        dp[nums.length] = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=dp[i+2];\\n            }\\n            int nottake = 0 + dp[i+1];\\n            dp[i] = Math.max(take,nottake);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst),solve(includelast));\\n    }\\n    public int solve(int[] nums){\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=prev2;\\n            }\\n            int nottake = 0 + prev1;\\n            int cur = Math.max(take,nottake);\\n            prev2 = prev1;\\n            prev1 = cur;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843713,
                "title": "easy-java-solution-beats-100-tabulation-with-space-optimisation-dp",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n\\n        int n = nums.length;\\n        if(n == 1) {\\n            return nums[0];\\n        }\\n        \\n        return Math.max(maxMoney(nums, 0, n - 1), maxMoney(nums, 1, n));\\n    }\\n\\n    static int maxMoney(int[] nums, int start, int end) {\\n\\n        int prev2 = 0;\\n        int prev1 = nums[start];\\n\\n        for(int i = start + 1; i < end; i++) {\\n            int include = prev2 + nums[i];\\n            int exclude = prev1;\\n            int curri = Math.max(include, exclude);\\n            prev2 = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n}\\n```\\n\\n![cat-min.jpeg](https://assets.leetcode.com/users/images/b7d42ed5-428d-4958-abcd-b71eeb9e75c1_1690819411.6471684.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n\\n        int n = nums.length;\\n        if(n == 1) {\\n            return nums[0];\\n        }\\n        \\n        return Math.max(maxMoney(nums, 0, n - 1), maxMoney(nums, 1, n));\\n    }\\n\\n    static int maxMoney(int[] nums, int start, int end) {\\n\\n        int prev2 = 0;\\n        int prev1 = nums[start];\\n\\n        for(int i = start + 1; i < end; i++) {\\n            int include = prev2 + nums[i];\\n            int exclude = prev1;\\n            int curri = Math.max(include, exclude);\\n            prev2 = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717902,
                "title": "0-n-space-solution-using-c",
                "content": "\\n# Approach\\nSince the houses are arranged in a circle, we need to consider two scenarios:\\na. Rob the first house and exclude the last house.\\nb. Rob the last house and exclude the first house.\\n\\nTo handle these scenarios, we can break down the problem into two separate instances of the House Robber problem:\\na. Rob houses from index 0 to n-2 (excluding the last house).\\nb. Rob houses from index 1 to n-1 (excluding the first house).\\n\\nWe can use a similar dynamic programming approach as in the original House Robber problem to calculate the maximum amount of money that can be robbed in each scenario.\\n\\nFor each scenario, we maintain two variables to keep track of the maximum amount of money that can be robbed up to the current house:\\na. prev1: Maximum amount of money that can be robbed up to the previous house.\\nb. prev2: Maximum amount of money that can be robbed up to the second previous house.\\n\\nWe iterate through the house array and calculate the maximum amount by considering whether to include the current house or exclude it:\\na. include = prev2 + current house value\\nb. exclude = prev1\\n\\nUpdate prev2 and prev1 for the next iteration:\\na. prev2 = prev1\\nb. prev1 = max(include, exclude)\\n\\nFinally, return the maximum amount of money obtained from the two scenarios: max(max1, max2).\\n\\nBy breaking down the problem into two instances of the House Robber problem and considering the maximum amount that can be robbed in each scenario, we can solve the House Robber II problem efficiently.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) {\\n            return 0;\\n        } else if (n == 1) {\\n            return nums[0];\\n        }\\n\\n        // Calculate the maximum amount by considering two cases:\\n        // 1. Exclude the first house and consider houses from index 1 to n-1.\\n        // 2. Exclude the last house and consider houses from index 0 to n-2.\\n        int max1 = robHelper(nums, 1, n - 1);\\n        int max2 = robHelper(nums, 0, n - 2);\\n\\n        // Return the maximum amount from the two cases.\\n        return max(max1, max2);\\n    }\\n\\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int prev2 = 0;\\n        int prev1 = 0;\\n\\n        for (int i = start; i <= end; i++) {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) {\\n            return 0;\\n        } else if (n == 1) {\\n            return nums[0];\\n        }\\n\\n        // Calculate the maximum amount by considering two cases:\\n        // 1. Exclude the first house and consider houses from index 1 to n-1.\\n        // 2. Exclude the last house and consider houses from index 0 to n-2.\\n        int max1 = robHelper(nums, 1, n - 1);\\n        int max2 = robHelper(nums, 0, n - 2);\\n\\n        // Return the maximum amount from the two cases.\\n        return max(max1, max2);\\n    }\\n\\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int prev2 = 0;\\n        int prev1 = 0;\\n\\n        for (int i = start; i <= end; i++) {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467225,
                "title": "house-robber-ii-easy-c-code-recursion-memoization",
                "content": "/* we are solving the question using 2 function one will solve from (0 to n-2) index and find out the maximum let say we are storing it in ans1 and another function will solve for (1 to n-1) and we will store it in ans2 and then return the maximum .\\n*/\\n\\nclass Solution {\\npublic:\\n     int solve2(vector<int>& nums , int n  , vector<int>&dp2){\\n        \\n        if(n == nums.size()-2)\\n            return nums[nums.size()-2];\\n        \\n        if(n >= nums.size()-1)\\n            return 0 ;\\n        \\n        if(dp2[n] != -1){\\n            return dp2[n];\\n        }\\n        \\n        int include = nums[n] + solve2(nums , n+2 , dp2);\\n        int exclude = 0 + solve2(nums , n+1 , dp2);\\n        \\n        return dp2[n] =  max(include ,exclude);\\n    }\\n     int solve1(vector<int>& nums , int n  , vector<int>&dp){\\n        \\n        if(n == 1)\\n            return nums[1];\\n        \\n        if(n <= 0)\\n            return 0 ;\\n        \\n        if(dp[n] != -1){\\n            return dp[n];\\n        }\\n        \\n        int include = nums[n] + solve1(nums , n-2 , dp);\\n        int exclude = 0 + solve1(nums , n-1 , dp);\\n        \\n        return dp[n] =  max(include ,exclude);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> dp(n+1 , -1);\\n         vector<int> dp2(n+1 , -1);\\n        int ans1 = solve1(nums , n-1 ,dp);\\n        int ans2 = solve2(nums , 0 , dp2);\\n        return max(ans1 , ans2);\\n\\n        \\n        //int rob(vector<int>& nums) {\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int solve2(vector<int>& nums , int n  , vector<int>&dp2){\\n        \\n        if(n == nums.size()-2)\\n            return nums[nums.size()-2];\\n        \\n        if(n >= nums.size()-1)\\n            return 0 ;\\n        \\n        if(dp2[n] != -1){\\n            return dp2[n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3389174,
                "title": "beats-100-max-adjacent-sum-easy-approach-c",
                "content": "# Intuition and Approach\\n> ***This is just the extended version of max adjacent sum problem.**\\nIf you dont know how to find max adjacent sum then please go through that problem(i.e. House Robber I on leetcode)*\\n\\nThe intution for solving this problem is that if we take first house then we cant rob last house and vice versa if we rob last house then we cant rob first house\\n\\nso with that observation we have to divide the nums vector in two parts such that one part have first house but no last house and second part have last but not the first house\\n\\nthen we can calculate max adjacent sum in both of them and then return the max from both.\\n*refer code \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //code to find max adjacent sum\\n    int max_non_adj(vector<int>& n,int start,int end){\\n        int prev=n[start];\\n        int prev1=0;\\n\\n        int ans=max(prev,prev1);\\n\\n        for(int i=start+1;i<end;i++){\\n            int incl=prev1+n[i];\\n            int excl=prev+0;\\n\\n            ans=max(incl,excl);\\n\\n            prev1=prev;\\n            prev=ans;\\n        }\\n\\n        return ans;\\n    }\\n    //main function\\n    int rob(vector<int>& n) {\\n        int a=n.size();        \\n\\n        if(a==1){\\n            return n[0];\\n        }        \\n        int first =max_non_adj(n,0,a-1);//excluding last house\\n        int second =max_non_adj(n,1,a);//excluding first house\\n\\n        return max(first,second);//return the max of both\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //code to find max adjacent sum\\n    int max_non_adj(vector<int>& n,int start,int end){\\n        int prev=n[start];\\n        int prev1=0;\\n\\n        int ans=max(prev,prev1);\\n\\n        for(int i=start+1;i<end;i++){\\n            int incl=prev1+n[i];\\n            int excl=prev+0;\\n\\n            ans=max(incl,excl);\\n\\n            prev1=prev;\\n            prev=ans;\\n        }\\n\\n        return ans;\\n    }\\n    //main function\\n    int rob(vector<int>& n) {\\n        int a=n.size();        \\n\\n        if(a==1){\\n            return n[0];\\n        }        \\n        int first =max_non_adj(n,0,a-1);//excluding last house\\n        int second =max_non_adj(n,1,a);//excluding first house\\n\\n        return max(first,second);//return the max of both\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357003,
                "title": "dp-solution-easy-to-understand",
                "content": "\\n***Prerequisite:*** Recursion, DP, Max Sum of Non-Adjacent Elements in an array.\\n\\n# Approach\\nCreate two vectors containing elements other than the first and the last respectively. Then proceed with the same trick just like we do while calculating the Max Sum of Non-Adjacent Elements of array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int> a){\\n        int n = a.size();\\n        int prev = a[0];\\n        int prev2 = 0;\\n        for(int i = 1; i < n; i ++){\\n            int take = a[i];\\n                if(i > 1) take += prev2;\\n            int notTake = 0 + prev;\\n            int curri = max( take, notTake);\\n            prev2 = prev;\\n            prev = curri;\\n        }\\n        return prev;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp1,tmp2;\\n        if(n == 1) return nums[0];\\n        for(int i = 0; i < n; i ++){\\n            if(i != 0) tmp1.push_back(nums[i]);\\n            if(i != n-1) tmp2.push_back(nums[i]);\\n        }\\n        return max(solve(tmp1),solve(tmp2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int> a){\\n        int n = a.size();\\n        int prev = a[0];\\n        int prev2 = 0;\\n        for(int i = 1; i < n; i ++){\\n            int take = a[i];\\n                if(i > 1) take += prev2;\\n            int notTake = 0 + prev;\\n            int curri = max( take, notTake);\\n            prev2 = prev;\\n            prev = curri;\\n        }\\n        return prev;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp1,tmp2;\\n        if(n == 1) return nums[0];\\n        for(int i = 0; i < n; i ++){\\n            if(i != 0) tmp1.push_back(nums[i]);\\n            if(i != n-1) tmp2.push_back(nums[i]);\\n        }\\n        return max(solve(tmp1),solve(tmp2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345343,
                "title": "easy-c-solution-using-previous-house-robber-code",
                "content": "# Intuition\\nWe can see that only the last and first houses(elements) cannot be taken together, thus, we can use the same code as in house robber 1, and pass it 2 arrays, one not containing the first element, and the other not containing the last element. As, the answer will def lie in one of those two arrays. Thus, we return the max of the two.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans(vector<int> nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++) {\\n            int curr_i=max(nums[i]+prev2,prev1);\\n            prev2=prev1;\\n            prev1=curr_i;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> v1(nums.begin()+1,nums.end());\\n        vector<int> v2(nums.begin(),nums.end()-1);\\n        return max(ans(v1),ans(v2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans(vector<int> nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++) {\\n            int curr_i=max(nums[i]+prev2,prev1);\\n            prev2=prev1;\\n            prev1=curr_i;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> v1(nums.begin()+1,nums.end());\\n        vector<int> v2(nums.begin(),nums.end()-1);\\n        return max(ans(v1),ans(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188968,
                "title": "house-robber-ii-sabse-easy-solution-no-dp-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Reference\\nhttps://leetcode.com/problems/house-robber/solutions/3188808/sabse-easy-solution-no-dp-100-faster/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        // excluding last element\\n        int prev1 = nums[0], prev2 = 0;\\n        for(int i = 1; i<n-1; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int first = max(prev1, prev2);\\n        \\n        //excluding first element\\n        prev1 = nums[1], prev2 = 0;\\n        for(int i = 2; i<n; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int last = max(prev1, prev2);\\n        \\n        //returning the max of first and last\\n        return max(first, last);\\n    }\\n};\\n```\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        // excluding last element\\n        int prev1 = nums[0], prev2 = 0;\\n        for(int i = 1; i<n-1; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int first = max(prev1, prev2);\\n        \\n        //excluding first element\\n        prev1 = nums[1], prev2 = 0;\\n        for(int i = 2; i<n; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int last = max(prev1, prev2);\\n        \\n        //returning the max of first and last\\n        return max(first, last);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108739,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n        return nums[0];\\n        if(nums.length == 2)\\n        return Math.max(nums[0], nums[1]);\\n        \\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end) {        \\n        if(start == end)\\n        return nums[start];\\n        \\n        int money[] = new int[nums.length];\\n        \\n        money[start] = nums[start];\\n        \\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        return money[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n        return nums[0];\\n        if(nums.length == 2)\\n        return Math.max(nums[0], nums[1]);\\n        \\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end) {        \\n        if(start == end)\\n        return nums[start];\\n        \\n        int money[] = new int[nums.length];\\n        \\n        money[start] = nums[start];\\n        \\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        return money[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030738,
                "title": "c-fast-dp-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* recursion logic for reference only\\n    unordered_map<int,int> memo;\\n    int profit (vector<int>& nums, int house){\\n        if (memo.find(house)!= memo.end()){\\n            return memo[house];\\n        }\\n        if (house >= nums.size()){ //no more house to rob\\n            memo.emplace(house,0);\\n            return 0;\\n        }\\n\\n        int profit1 = nums[house] + profit(nums, house+2);//rob this house\\n        int profit2 = profit(nums,house+1); //not rob this house\\n        memo.emplace(house,max(profit1,profit2));\\n        return memo[house];\\n    }\\n*/\\n    int rob(vector<int>& nums) {\\n        \\n        //if we don\\'t rob the first house, we can rob the last one\\n        //we just need to run the same dp as rob house I until house index number 1\\n        if (nums.size() == 1){\\n            return nums[0];\\n        }\\n        const int n = nums.size()+2;\\n        int dp1[n];\\n        dp1[n-1] = 0;\\n        dp1[n-2] = 0;\\n        for(int i=n-3; i>=1; i--){ //don\\'t rob the first house\\n            dp1[i] = max(nums[i]+ dp1[i+2],dp1[i+1]);\\n        }\\n        //if we rob the first house, we couldn\\'t rob the last one\\n        int dp2[n];\\n        dp2[n-1] = 0;\\n        dp2[n-2] = 0;\\n        dp2[n-3] = 0;//we set up the profit of last house as 0\\n\\n        for(int i=n-4; i>=0; i--){ // rob the first house\\n            dp2[i] = max(nums[i]+ dp2[i+2],dp2[i+1]);\\n        }\\n        return max(dp1[1], dp2[0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* recursion logic for reference only\\n    unordered_map<int,int> memo;\\n    int profit (vector<int>& nums, int house){\\n        if (memo.find(house)!= memo.end()){\\n            return memo[house];\\n        }\\n        if (house >= nums.size()){ //no more house to rob\\n            memo.emplace(house,0);\\n            return 0;\\n        }\\n\\n        int profit1 = nums[house] + profit(nums, house+2);//rob this house\\n        int profit2 = profit(nums,house+1); //not rob this house\\n        memo.emplace(house,max(profit1,profit2));\\n        return memo[house];\\n    }\\n*/\\n    int rob(vector<int>& nums) {\\n        \\n        //if we don\\'t rob the first house, we can rob the last one\\n        //we just need to run the same dp as rob house I until house index number 1\\n        if (nums.size() == 1){\\n            return nums[0];\\n        }\\n        const int n = nums.size()+2;\\n        int dp1[n];\\n        dp1[n-1] = 0;\\n        dp1[n-2] = 0;\\n        for(int i=n-3; i>=1; i--){ //don\\'t rob the first house\\n            dp1[i] = max(nums[i]+ dp1[i+2],dp1[i+1]);\\n        }\\n        //if we rob the first house, we couldn\\'t rob the last one\\n        int dp2[n];\\n        dp2[n-1] = 0;\\n        dp2[n-2] = 0;\\n        dp2[n-3] = 0;//we set up the profit of last house as 0\\n\\n        for(int i=n-4; i>=0; i--){ // rob the first house\\n            dp2[i] = max(nums[i]+ dp2[i+2],dp2[i+1]);\\n        }\\n        return max(dp1[1], dp2[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909931,
                "title": "beats-95-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return max(nums)\\n        def helper(nums):\\n            h1,h2 = 0,0\\n            for n in nums:\\n                h_n = max(n+h1,h2)\\n                h1 = h2\\n                h2 = h_n\\n            return h_n\\n        return max (helper(nums[1:]),helper(nums[:len(nums)-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return max(nums)\\n        def helper(nums):\\n            h1,h2 = 0,0\\n            for n in nums:\\n                h_n = max(n+h1,h2)\\n                h1 = h2\\n                h2 = h_n\\n            return h_n\\n        return max (helper(nums[1:]),helper(nums[:len(nums)-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892140,
                "title": "all-solutions-discussed",
                "content": "**PLS UPVOTE IF You like the SOLUTION:)**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIN THIS problem we reuse the HOUSE ROBBER-1 code \\nsince now the houses are in circular fashion so we cannot pick both first and last indices.\\n\\nThus we make two cases:\\n1. picking first house and not last.\\n2. picking last house but not first.\\n\\nand call the HOUSE ROBBER 1 CODE\\n\\nEXPLANATION OF HOUSE ROBBER\\nWriting BASIC RECURSION:\\nWE start from last index and for a particular index we have two cases that is\\npick - if picked we cannot pick the adjacent element on left side.\\nnot pick-not picked ,move to left index.\\n\\nBASE CASE:-\\nindex=0 :- this is only possible when we come through 2, thus we include this index in our sum as we want maximum.\\n\\nindex<0:- we return 0 since no element exists.\\nALL THREE APPROACHES DISCUSSION:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### Approach 1\\nWe optimise our recursion code by storing the previously already calculated values so that if needed again we can easily look up.(DONE by MEMOISATION)\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N) + O(N)     i.e stack space and array space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Approach 2\\nWe Leave recursion and move to TABULATION thus we now go from bottom to top. Thus we will reach the asked ans by starting from the base cases.\\nSo at a moment, we will do dp[i]=max(pick,notpick) {see code}and in the end return dp[n-1] and make the code iterative.\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)     only array space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Approach 3\\nWe Leave space in Iterative method and we notice a pattern that at a given moment we  are actually doing this:\\n            int curr=max(pick,notpick);\\n            prev2=prev1;\\n            prev1=curr;\\n\\nand our ans in actually prev 1. Thus leaving the extra space here as well\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n#### Solution 1\\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        if(index==chk)\\n            return nums.at(index);\\n        if(index<chk)\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int pick=nums.at(index)+maxm(index-2,chk,nums,dp);\\n        int notpick=0+maxm(index-1,chk,nums,dp);\\n        return dp[index]=max(pick,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};    \\n```\\n#### Solution 2\\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        dp[chk]=nums.at(chk);\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=dp[i-2];\\n            int notpick=0+dp[i-1];\\n            dp[i]=max(pick,notpick);\\n        }\\n        return dp[index];\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n\\n```\\n\\n#### Solution 3\\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums){\\n        int prev1=nums.at(chk),prev2=0;\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=prev2;\\n            int notpick=0+prev1;\\n            int curr=max(pick,notpick);\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        int removeFirst=maxm(index,1,nums);\\n        int removeEnd=maxm(index-1,0,nums);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        if(index==chk)\\n            return nums.at(index);\\n        if(index<chk)\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int pick=nums.at(index)+maxm(index-2,chk,nums,dp);\\n        int notpick=0+maxm(index-1,chk,nums,dp);\\n        return dp[index]=max(pick,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};    \\n```\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        dp[chk]=nums.at(chk);\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=dp[i-2];\\n            int notpick=0+dp[i-1];\\n            dp[i]=max(pick,notpick);\\n        }\\n        return dp[index];\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums){\\n        int prev1=nums.at(chk),prev2=0;\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=prev2;\\n            int notpick=0+prev1;\\n            int curr=max(pick,notpick);\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        int removeFirst=maxm(index,1,nums);\\n        int removeEnd=maxm(index-1,0,nums);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830306,
                "title": "easy-to-understand-c-solution",
                "content": "**class Solution {\\npublic:**\\n    \\n    int sol(vector<vector<int>> &temp,int s,int e,vector<int> &nums,int n){\\n        //if lower index is greater than higher index or s or e go out of range\\n        if(s>e || s<0 || e>=n){\\n            return 0;\\n        }\\n        //if the ans is already computed\\n        else if(temp[s][e]!=-1){\\n            return temp[s][e];\\n        }\\n        //if there is a single element in the range\\n        else if(s==e){\\n            temp[s][e]=nums[s];\\n            return temp[s][e];\\n        }\\n        else{\\n            //temporary variavle\\n            int rt=0;\\n            for(int i=s;i<=e;i++){\\n                //ans = current element + ans from leftside + ans from rightside\\n                rt=max(rt,nums[i]+sol(temp,s,i-2,nums,n)+sol(temp,i+2,e,nums,n));\\n            }\\n            //update th computed solution and return it\\n            temp[s][e]=rt;\\n            return rt;\\n        }\\n        return temp[s][e];\\n    }\\n\\n    \\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n         int ans=0;\\n        //temp vector stores solution for smaller sub cases\\n        vector<vector<int>> temp(n,vector<int>(n,-1));\\n       \\n        \\n        //Case 1  0th element is included\\n        ans=max(ans,nums[0]+sol(temp,2,n-2,nums,n));\\n        \\n        //Case 2 last element is included\\n        ans=max(ans,nums[n-1]+sol(temp,1,n-3,nums,n));\\n        \\n        //Case 3 both the elements are excluded\\n        ans=max(ans,sol(temp,1,n-2,nums,n));\\n      \\n        return ans;\\n    }\\n**};**",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:**\\n    \\n    int sol(vector<vector<int>> &temp,int s,int e,vector<int> &nums,int n){\\n        //if lower index is greater than higher index or s or e go out of range\\n        if(s>e || s<0 || e>=n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2764664,
                "title": "clear-and-concise-video-explanation",
                "content": "I posted a clear and concise video explanation here: https://youtu.be/DL8Ybsy-yq8\\nIt shows the intuition behind the problem and time and space complexities, as well as the code.\\nHope it helps!",
                "solutionTags": [
                    "Python"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2725145,
                "title": "99-faster-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo1=[-1 for i in range(len(nums)-1)]\\n        memo2=[-1 for i in range(len(nums)-1)]\\n        res1= self.solve(nums[0:len(nums)-1],len(nums)-2,memo1)\\n        res2= self.solve(nums[1:],len(nums)-2,memo2)\\n        return max(res1,res2)\\n    def solve(self,nums,n,memo):\\n        if n<0:\\n            return 0\\n        if memo[n]!=-1:\\n            return memo[n]\\n        memo[n]= max(nums[n]+self.solve(nums,n-2,memo),self.solve(nums,n-1,memo))\\n        return memo[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo1=[-1 for i in range(len(nums)-1)]\\n        memo2=[-1 for i in range(len(nums)-1)]\\n        res1= self.solve(nums[0:len(nums)-1],len(nums)-2,memo1)\\n        res2= self.solve(nums[1:],len(nums)-2,memo2)\\n        return max(res1,res2)\\n    def solve(self,nums,n,memo):\\n        if n<0:\\n            return 0\\n        if memo[n]!=-1:\\n            return memo[n]\\n        memo[n]= max(nums[n]+self.solve(nums,n-2,memo),self.solve(nums,n-1,memo))\\n        return memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722568,
                "title": "100-c-solution-commented-and-explained",
                "content": "My dp idea(maybe not the most optimal) is to **create 2 array of size n-1**, arr0 and arr1\\n\\narr0[i] is the max the thief can take until the i\\'th house, stop at arr0[n-1] (don\\'t take into account the last house)\\narr1[i] is the max the thief can take until the (i+1)\\'th house without taking the first house\\n\\n**Define with :**\\narr0[0] = nums[0] | Max(nums[0],nums[1])\\narr1[0] = nums[1] | Max(nums[1],nums[2])\\n\\nand **iterate with** :\\narr0[i]=Max(arr0[i-2]+nums[i],arr0[i-1])\\narr1[i]=Max(arr1[i-2]+nums[i+1],arr1[i-1])\\n\\n**for example** with nums = [10,3,2,1,10] we will have\\narr0=[10,10,12,12]\\narr1=[3,3,4,13]\\nans = max(13,12) = 13\\n\\n**The answer to the problem is** the max of the last element between the 2 array **because the tief can\\'t take the first house and the last house** :\\nanswer = Max(arr0[n-2],arr1[n-2])\\n\\nWhich make\\n**Time Complexity : O(n)**  and reach 100% in time speed\\n**Space Complexity : O(n)**\\n\\nI found this answer by doing several tests with a pen and  paper\\n\\n```\\nint max(int a, int b)  //return the max\\n{\\n    if (a<b){return b;}\\n    return a;\\n}\\n\\nint rob(int* nums, int numsSize)\\n{\\n    if (numsSize == 1 ){return nums[0];}                //if n=1 or n=2\\n    if (numsSize == 2 ){return max(nums[0],nums[1]);}\\n    \\n    int* arr1 =(int*) malloc((numsSize-1)*sizeof(int)); //allocate memory with malloc\\n    int* arr0 =(int*) malloc((numsSize-1)*sizeof(int));\\n    \\n    arr1[0]=nums[1];      //initiate the first 2 elements of each array\\n    arr0[0]=nums[0];\\n    arr1[1]=max(nums[1],nums[2]);\\n    arr0[1]=max(nums[0],nums[1]);\\n    \\n    for (int i = 2;i<(numsSize-1);i++)\\n    {\\n        arr0[i]=max(arr0[i-2]+nums[i],arr0[i-1]);   //iterate each array until the end\\n        arr1[i]=max(arr1[i-2]+nums[i+1],arr1[i-1]);\\n    }\\n    int ans = max(arr0[numsSize-2],arr1[numsSize-2]); \\n\\t//save the answer in order to free both arrays before sending the result\\n    \\n    free(arr1);  //free allocated memory\\n    free(arr0);\\n    return(ans);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint max(int a, int b)  //return the max\\n{\\n    if (a<b){return b;}\\n    return a;\\n}\\n\\nint rob(int* nums, int numsSize)\\n{\\n    if (numsSize == 1 ){return nums[0];}                //if n=1 or n=2\\n    if (numsSize == 2 ){return max(nums[0],nums[1]);}\\n    \\n    int* arr1 =(int*) malloc((numsSize-1)*sizeof(int)); //allocate memory with malloc\\n    int* arr0 =(int*) malloc((numsSize-1)*sizeof(int));\\n    \\n    arr1[0]=nums[1];      //initiate the first 2 elements of each array\\n    arr0[0]=nums[0];\\n    arr1[1]=max(nums[1],nums[2]);\\n    arr0[1]=max(nums[0],nums[1]);\\n    \\n    for (int i = 2;i<(numsSize-1);i++)\\n    {\\n        arr0[i]=max(arr0[i-2]+nums[i],arr0[i-1]);   //iterate each array until the end\\n        arr1[i]=max(arr1[i-2]+nums[i+1],arr1[i-1]);\\n    }\\n    int ans = max(arr0[numsSize-2],arr1[numsSize-2]); \\n\\t//save the answer in order to free both arrays before sending the result\\n    \\n    free(arr1);  //free allocated memory\\n    free(arr0);\\n    return(ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494250,
                "title": "easy-solution-beats-100",
                "content": "House robber 1 but passing two arrays\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n=nums.length;\\n        if(n==1)\\n            return nums[0];\\n        int[] t1=new int[n-1];\\n        int[] t2=new int[n-1];\\n        \\n\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n                t1[a]=nums[i];\\n                a++;\\n            }\\n            if(i!= nums.length-1){\\n                t2[b] =nums[i];\\n                b++;\\n            }\\n        }\\n        \\n        //max of array withput first and arr without last\\n        return Math.max(solve(t1),solve(t2));\\n        \\n    }\\n    \\n    static int solve(int[] arr){\\n        int n = arr.length;\\n        int prev = arr[0];\\n        int prev2 =0;\\n\\n        for(int i=1; i<n; i++){\\n            int pick = arr[i];\\n            if(i>1)\\n                pick += prev2;\\n            int nonPick = 0 + prev;\\n\\n            int cur_i = Math.max(pick, nonPick);\\n            prev2 = prev;\\n            prev= cur_i;\\n\\n        }\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n=nums.length;\\n        if(n==1)\\n            return nums[0];\\n        int[] t1=new int[n-1];\\n        int[] t2=new int[n-1];\\n        \\n\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n                t1[a]=nums[i];\\n                a++;\\n            }\\n            if(i!= nums.length-1){\\n                t2[b] =nums[i];\\n                b++;\\n            }\\n        }\\n        \\n        //max of array withput first and arr without last\\n        return Math.max(solve(t1),solve(t2));\\n        \\n    }\\n    \\n    static int solve(int[] arr){\\n        int n = arr.length;\\n        int prev = arr[0];\\n        int prev2 =0;\\n\\n        for(int i=1; i<n; i++){\\n            int pick = arr[i];\\n            if(i>1)\\n                pick += prev2;\\n            int nonPick = 0 + prev;\\n\\n            int cur_i = Math.max(pick, nonPick);\\n            prev2 = prev;\\n            prev= cur_i;\\n\\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473326,
                "title": "c-easy-and-simple-without-dp",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\n int solve(vector<int>&nums){\\n        int n=nums.size();\\n        \\n         int prev2=0;\\n         int prev1=nums[0];\\n        for(int i=1;i<n;i++){\\n             int include= prev2+nums[i];\\n             int exclude=prev1+0;\\n             int ans=max(include,exclude);\\n            prev2=prev1;\\n            prev1=ans;\\n        }\\n        return prev1;\\n        \\n       \\n    }\\n    int rob(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if(n==0 ) return 0;\\n        if(n==1) return nums[0];\\n        vector<int>first,second;\\n        for(int i=0;i<n;i++){\\n            if(i!=n-1) first.push_back(nums[i]);\\n            if(i!=0) second.push_back(nums[i]);\\n        }\\n        return max(solve(first),solve(second));\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int solve(vector<int>&nums){\\n        int n=nums.size();\\n        \\n         int prev2=0;\\n         int prev1=nums[0];\\n        for(int i=1;i<n;i++){\\n             int include= prev2+nums[i];\\n             int exclude=prev1+0;\\n             int ans=max(include,exclude);\\n            prev2=prev1;\\n            prev1=ans;\\n        }\\n        return prev1;\\n        \\n       \\n    }\\n    int rob(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if(n==0 ) return 0;\\n        if(n==1) return nums[0];\\n        vector<int>first,second;\\n        for(int i=0;i<n;i++){\\n            if(i!=n-1) first.push_back(nums[i]);\\n            if(i!=0) second.push_back(nums[i]);\\n        }\\n        return max(solve(first),solve(second));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355020,
                "title": "python-dp-bottom-up-approach-easy-understanding-memory-better-than-80",
                "content": "## Very important: \\n1) When you create nested list, like this: any_list[x:y], you create a NEW list.  SO, if other function change it, in changes NOT any_list, but any_list[x:y].\\n2) It is pretty obvious, but just so you know, we use self.function, because that is how classes work. If you don\\'t understand it, go and read about classes.\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln < 4:\\n            return max(nums)\\n        elif ln == 4:\\n            return max(nums[0] + nums[2], nums[1] + nums[3])\\n        \\n        return max(self.counter(nums[:-1]), self.counter(nums[1:]))\\n    \\n    \\n    def counter(self, nums):\\n        nums[2] += nums[0]\\n        for x in range(3, len(nums)):\\n            nums[x] += max(nums[x - 2], nums[x - 3])\\n        return max(nums[-1], nums[-2])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln < 4:\\n            return max(nums)\\n        elif ln == 4:\\n            return max(nums[0] + nums[2], nums[1] + nums[3])\\n        \\n        return max(self.counter(nums[:-1]), self.counter(nums[1:]))\\n    \\n    \\n    def counter(self, nums):\\n        nums[2] += nums[0]\\n        for x in range(3, len(nums)):\\n            nums[x] += max(nums[x - 2], nums[x - 3])\\n        return max(nums[-1], nums[-2])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122322,
                "title": "c-greedy-dynamic-programming-faster-than-100-00-0-ms-explained",
                "content": "It was a good continuation to the [House Robber](https://leetcode.com/problems/house-robber/) problem and I was pretty satisfied with the time and space complexity I obtained.\\n\\n**Thinking Process:**\\nAll we need to do here is move our solution up a level. What I mean by that is that we need to decide the inclusion of nums[0] manually and based on that decision we need to do the calculate the answer of the rest of the part, exactly the same way as we did in House Robber problem.\\n\\n- When nums[0] is included:\\n\\tIn this case our only option is to exclude nums[1] (Since nums[0] is included and we cannot rob two adjacent houses). Hence, it is logical to calculate an ans `ans1` according to the nums array from index i=2 to i=n. But we need to make sure that the last element is excluded.\\n- When nums[0] is excluded:\\n\\tIn this case we just need to find out the ans `ans2` based on  the nums array from index i=1 to i=n because we already excluded nums[0] and can now choose for i=1 and so on.\\n\\t\\nThe answer would be the maximum of `ans1` and `ans2`.\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int in1ex = 0;\\n        int ex1ex = 0;\\n        \\n        for(int i=1; i<nums.size(); ++i)  {\\n            int tempin = ex1ex + nums[i];\\n            int tempex = max(ex1ex, in1ex);\\n            \\n            in1ex = tempin;\\n            ex1ex = tempex;\\n        }\\n        \\n        int ans1 = max(in1ex, ex1ex);\\n        \\n        int in1in = nums[0];\\n        int ex1in = nums[0];\\n        \\n        \\n        for(int i=2; i<nums.size(); ++i)  {\\n            int tempin = ex1in + nums[i];\\n            int tempex = max(ex1in, in1in);\\n            \\n            in1in = tempin;\\n            ex1in = tempex;\\n        }\\n        \\n        int ans2 = ex1in;\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n        \\n    }\\n};\\n```\\nPlease upvote if my solution was of any help.\\nP.S.: Comment for any query.\\nHave a great day ;)\\n![image](https://assets.leetcode.com/users/images/57ada758-ab5e-49f0-b3fe-c037dab3eab5_1654603860.3649662.png)\\n\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int in1ex = 0;\\n        int ex1ex = 0;\\n        \\n        for(int i=1; i<nums.size(); ++i)  {\\n            int tempin = ex1ex + nums[i];\\n            int tempex = max(ex1ex, in1ex);\\n            \\n            in1ex = tempin;\\n            ex1ex = tempex;\\n        }\\n        \\n        int ans1 = max(in1ex, ex1ex);\\n        \\n        int in1in = nums[0];\\n        int ex1in = nums[0];\\n        \\n        \\n        for(int i=2; i<nums.size(); ++i)  {\\n            int tempin = ex1in + nums[i];\\n            int tempex = max(ex1in, in1in);\\n            \\n            in1in = tempin;\\n            ex1in = tempex;\\n        }\\n        \\n        int ans2 = ex1in;\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047805,
                "title": "dp-is-new-love",
                "content": "similar as house robber only difference making that in one run we can either include start point or end point \\n```\\nclass Solution {\\n     public int fun(int[]dp,int nums[], int s,int e){\\n            if(e<s)return 0;\\n            if(dp[e]!=-1)return dp[e];\\n            if(e==s+1)return Math.max(nums[e],nums[e-1]);\\n            if(e==s)return nums[s];\\n            return dp[e]=Math.max(nums[e]+fun(dp,nums,s,e-2),fun(dp,nums,s,e-1));\\n}\\n    public int rob(int[] nums) {\\n        if (nums.length==1)return nums[0];\\n       int dp[]=new int [nums.length];\\n        for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int a=fun(dp,nums,0,dp.length-2);\\n         for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int b=fun(dp,nums,1,nums.length-1);\\n        return Math.max(a,b);\\n       // return Math.max(fun(dp,nums,0,dp.length-2),fun(dp,nums,1,nums.length-1));\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     public int fun(int[]dp,int nums[], int s,int e){\\n            if(e<s)return 0;\\n            if(dp[e]!=-1)return dp[e];\\n            if(e==s+1)return Math.max(nums[e],nums[e-1]);\\n            if(e==s)return nums[s];\\n            return dp[e]=Math.max(nums[e]+fun(dp,nums,s,e-2),fun(dp,nums,s,e-1));\\n}\\n    public int rob(int[] nums) {\\n        if (nums.length==1)return nums[0];\\n       int dp[]=new int [nums.length];\\n        for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int a=fun(dp,nums,0,dp.length-2);\\n         for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int b=fun(dp,nums,1,nums.length-1);\\n        return Math.max(a,b);\\n       // return Math.max(fun(dp,nums,0,dp.length-2),fun(dp,nums,1,nums.length-1));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009646,
                "title": "self-explanatory-c-0-ms",
                "content": "**SELF-EXPLANATORY || C++ || 0 ms ||**\\nidea credits : [Tatv Kamdar](https://leetcode.com/kamdartatv1/)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        int prev = 0, prev2 = 0, curr = 0;\\n        // considering last element\\n        for(int i = 1; i < nums.size(); i++){\\n            curr = max(prev, prev2 + nums[i]);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int prev_ = 0, prev2_ = 0, curr_ = 0;\\n        // considering 1st element\\n        for(int i = 0; i < nums.size()-1; i++){\\n            curr_ = max(prev_, prev2_ + nums[i]);\\n            prev2_ = prev_;\\n            prev_ = curr_;\\n        }\\n        return max(curr, curr_);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        int prev = 0, prev2 = 0, curr = 0;\\n        // considering last element\\n        for(int i = 1; i < nums.size(); i++){\\n            curr = max(prev, prev2 + nums[i]);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int prev_ = 0, prev2_ = 0, curr_ = 0;\\n        // considering 1st element\\n        for(int i = 0; i < nums.size()-1; i++){\\n            curr_ = max(prev_, prev2_ + nums[i]);\\n            prev2_ = prev_;\\n            prev_ = curr_;\\n        }\\n        return max(curr, curr_);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008177,
                "title": "javascript-memoization-recursive-approach-dp-fast",
                "content": "```\\n// Recursive Approach: TLE\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    function helper(i, arr) {\\n        if (i < 0) return 0;\\n\\n        return Math.max(\\n            helper(i - 1, arr),\\n            arr[i] + helper(i - 2, arr)\\n        )\\n    }\\n\\n    const arr1 = nums.slice(0, nums.length - 1);\\n    const arr2 = nums.slice(1, nums.length);\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1), helper(n, arr2));\\n};\\n\\n\\n// Memoized Recursion\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    let dp1 = new Array(nums.length).fill(-1);\\n    let dp2 = [...dp1];\\n    function helper(i, arr, dp) {\\n        if (i < 0) return 0;\\n        if (dp[i] !== -1) return dp[i];\\n\\n        return dp[i] = Math.max(\\n            helper(i - 1, arr, dp),\\n            arr[i] + helper(i - 2, arr, dp)\\n        )\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1, dp1), helper(n, arr2, dp2));\\n};\\n\\n// Space optimized solution\\nvar rob = function (nums) {\\n    function helper(arr) {\\n        let rob1 = 0, rob2 = 0;\\n        for (let num of arr) {\\n            const tmp = Math.max(rob1 + num, rob2);\\n            rob1 = rob2;\\n            rob2 = tmp;\\n        }\\n        return rob2;\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(nums[0], helper(arr1), helper(arr2));\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursive Approach: TLE\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    function helper(i, arr) {\\n        if (i < 0) return 0;\\n\\n        return Math.max(\\n            helper(i - 1, arr),\\n            arr[i] + helper(i - 2, arr)\\n        )\\n    }\\n\\n    const arr1 = nums.slice(0, nums.length - 1);\\n    const arr2 = nums.slice(1, nums.length);\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1), helper(n, arr2));\\n};\\n\\n\\n// Memoized Recursion\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    let dp1 = new Array(nums.length).fill(-1);\\n    let dp2 = [...dp1];\\n    function helper(i, arr, dp) {\\n        if (i < 0) return 0;\\n        if (dp[i] !== -1) return dp[i];\\n\\n        return dp[i] = Math.max(\\n            helper(i - 1, arr, dp),\\n            arr[i] + helper(i - 2, arr, dp)\\n        )\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1, dp1), helper(n, arr2, dp2));\\n};\\n\\n// Space optimized solution\\nvar rob = function (nums) {\\n    function helper(arr) {\\n        let rob1 = 0, rob2 = 0;\\n        for (let num of arr) {\\n            const tmp = Math.max(rob1 + num, rob2);\\n            rob1 = rob2;\\n            rob2 = tmp;\\n        }\\n        return rob2;\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(nums[0], helper(arr1), helper(arr2));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988108,
                "title": "c-tabulation-o-n-time-o-1-space",
                "content": "This problem is very similar to House Robber. The only difference is that if the robber chooses to rob the first house, they cannot rob the last and vice versa.\\n\\nGiven this constraint, the problem can be broken down into two subproblems: what is the maximum amount that can be robbed from the first n-1 houses and what is the maximum amount that can be robbed from the last n-1 houses. The maximum amount for the overall problem is the max of these two values.\\n\\nThe `int rob(vector<int>& nums, int start, int len)` helper function executes the house robber algorithm as if the houses are in a line not wrapped in a circle. It uses the tabulation method of dynamic programming to determine the maximum possible amount. Iterating over the vector of houses, the maximum robbery amount for each index is either the max amount for the previous house, or the current house\\'s amount plus the max amount for 2 houses previous.\\n\\n**Time complexity: O(n)** because we are iterating linearly over vector `nums` twice.\\n**Space complexity: O(1)** because even though we are using tabulation which typically uses O(n) space, we only need to maintain the max amounts for the previous 2 houses at any step.\\n\\nThis problem can also be solve with memoization instead of tabulation. That solution would have the same time complexity, but would require recursion and only achieve O(n) space complexity.\\n\\n```\\nclass Solution {\\npublic:\\n    // uses tabulation to determine most money possible from linear set of houses\\n    int rob(vector<int>& nums, int start, int len) {\\n        int prevPrev = 0;       // max sum for 2 houses previous\\n        int prev = nums[start]; // max sum for previous house\\n        int curr;\\n        for (int i = 2; i < len + 1; i++) {\\n            curr = max(prevPrev + nums[start+i-1], prev);\\n            prevPrev = prev;\\n            prev = curr;\\n        }\\n        return curr;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, n-1), rob(nums, 1, n-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // uses tabulation to determine most money possible from linear set of houses\\n    int rob(vector<int>& nums, int start, int len) {\\n        int prevPrev = 0;       // max sum for 2 houses previous\\n        int prev = nums[start]; // max sum for previous house\\n        int curr;\\n        for (int i = 2; i < len + 1; i++) {\\n            curr = max(prevPrev + nums[start+i-1], prev);\\n            prevPrev = prev;\\n            prev = curr;\\n        }\\n        return curr;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, n-1), rob(nums, 1, n-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982836,
                "title": "easy-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        int[] dp1 = new int[n + 2];\\n\\t\\t// with first house\\n        for(int i = n - 2; i >= 0; i--){\\n            dp1[i] = Math.max(dp1[i + 1], nums[i] + dp1[i + 2]);\\n        }\\n        int[] dp2 = new int[n + 2];\\n\\t\\t// without first house but with last house\\n        for(int i = n - 1; i > 0; i--){\\n            dp2[i] = Math.max(dp2[i + 1], nums[i] + dp2[i + 2]);\\n        }\\n\\t\\t// In dp2 array we should take dp2[1] into consideration instead of dp2[0], because dp2[1] is the final ans for dp2.\\n        return Math.max(dp1[0], dp2[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        int[] dp1 = new int[n + 2];\\n\\t\\t// with first house\\n        for(int i = n - 2; i >= 0; i--){\\n            dp1[i] = Math.max(dp1[i + 1], nums[i] + dp1[i + 2]);\\n        }\\n        int[] dp2 = new int[n + 2];\\n\\t\\t// without first house but with last house\\n        for(int i = n - 1; i > 0; i--){\\n            dp2[i] = Math.max(dp2[i + 1], nums[i] + dp2[i + 2]);\\n        }\\n\\t\\t// In dp2 array we should take dp2[1] into consideration instead of dp2[0], because dp2[1] is the final ans for dp2.\\n        return Math.max(dp1[0], dp2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943255,
                "title": "faster-than-100-dp-memoization-concise-solution",
                "content": "class Solution {\\npublic:int dp[101][2];\\n    int solve(int first,int house, vector<int > &nums){\\n        if(house>=nums.size())\\n            return 0;\\n                if( first==1 && house==nums.size()-1)\\n            return 0;\\n        if(dp[house][first]!=-1)\\n            return dp[house][first];\\n        int ans1,ans2;\\n        if(house==0){\\n            ans1=nums[house]+solve(1,house+2,nums);\\n            ans2=solve(0,house+1,nums);\\n        }\\n        else{\\n                        ans1=nums[house]+solve(first,house+2,nums);\\n            ans2=solve(first,house+1,nums);   \\n        }\\n        return dp[house][first]=max(ans1,ans2);\\n    }\\n    int rob(vector<int >& nums) {\\n      memset(dp,-1,sizeof dp);\\n        return solve(0,0,nums);  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:int dp[101][2];\\n    int solve(int first,int house, vector<int > &nums){\\n        if(house>=nums.size())\\n            return 0;\\n                if( first==1 && house==nums.size()-1)\\n            return 0;\\n        if(dp[house][first]!=-1)\\n            return dp[house][first];\\n        int ans1,ans2;\\n        if(house==0){\\n            ans1=nums[house]+solve(1,house+2,nums);\\n            ans2=solve(0,house+1,nums);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1806899,
                "title": "simple-solution-in-java-100-faster-o-1-space-and-o-n-time",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        \\n        int n = nums.length;\\n        \\n        /* The array is in the circular format, we would want to convert it into the linear\\n           In one case, we would allow to rob from the first house then we will make the last house inaccessible\\n           In second case, we would allow to rob in the last house and make the first house robbery inaccessible\\n        */\\n        \\n        // Include first, restrict last \\n        int incl1 = 0;\\n        int excl1 = 0;\\n            \\n        // Restrict first, include last \\n        int incl2 = 0;\\n        int excl2 = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(i >= 0  && i < n-1){\\n                int temp = incl1;\\n                incl1 = Math.max(excl1 + nums[i], incl1);\\n                excl1 = temp;\\n            }\\n            if(i>=1 && i <= n-1){\\n                int temp = incl2;\\n                incl2 = Math.max(excl2 + nums[i], incl2);\\n                excl2 = temp;\\n            }\\n        }\\n        \\n        return Math.max(incl1, incl2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        \\n        int n = nums.length;\\n        \\n        /* The array is in the circular format, we would want to convert it into the linear\\n           In one case, we would allow to rob from the first house then we will make the last house inaccessible\\n           In second case, we would allow to rob in the last house and make the first house robbery inaccessible\\n        */\\n        \\n        // Include first, restrict last \\n        int incl1 = 0;\\n        int excl1 = 0;\\n            \\n        // Restrict first, include last \\n        int incl2 = 0;\\n        int excl2 = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(i >= 0  && i < n-1){\\n                int temp = incl1;\\n                incl1 = Math.max(excl1 + nums[i], incl1);\\n                excl1 = temp;\\n            }\\n            if(i>=1 && i <= n-1){\\n                int temp = incl2;\\n                incl2 = Math.max(excl2 + nums[i], incl2);\\n                excl2 = temp;\\n            }\\n        }\\n        \\n        return Math.max(incl1, incl2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793611,
                "title": "python-solution",
                "content": "This is similar to \\'[House Robber](https://leetcode.com/problems/house-robber/)\\' problem:\\n```\\ndef rob(nums):\\n\\tnums = [0, 0, 0] + nums\\n\\tfor i in range(3, len(nums)):\\n\\t\\tnums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n\\treturn max(nums[-2], nums[-1])\\n```\\nthere\\'s only one difference, you can either rob nums[0] or nums[-1]. So, we are gonne call above function with two different lists as an input:\\n* nums[:-1] to include nums[0]  and exclude nums[-1]\\n* nums[1:] to exclude nums[0]  and include nums[-1]\\n\\nHere\\'s my solution:\\n```\\n# Runtime: 44 ms, faster than 53.19% of Python3 online submissions for House Robber II.\\n# Memory Usage: 14 MB, less than 57.59% of Python3 online submissions for House Robber II.\\nclass Solution:\\n    def rob(self, nums):\\n\\t\\n        def rob(nums):\\n            nums = [0, 0, 0] + nums\\n            for i in range(3, len(nums)):\\n                nums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n            return max(nums[-2], nums[-1])\\n\\t\\t\\n        return max(nums[0], rob(nums[:-1], rob(nums[1:])))\\n```\\nnote: we include nums[0] to handle len(nums)==1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rob(nums):\\n\\tnums = [0, 0, 0] + nums\\n\\tfor i in range(3, len(nums)):\\n\\t\\tnums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n\\treturn max(nums[-2], nums[-1])\\n```\n```\\n# Runtime: 44 ms, faster than 53.19% of Python3 online submissions for House Robber II.\\n# Memory Usage: 14 MB, less than 57.59% of Python3 online submissions for House Robber II.\\nclass Solution:\\n    def rob(self, nums):\\n\\t\\n        def rob(nums):\\n            nums = [0, 0, 0] + nums\\n            for i in range(3, len(nums)):\\n                nums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n            return max(nums[-2], nums[-1])\\n\\t\\t\\n        return max(nums[0], rob(nums[:-1], rob(nums[1:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741405,
                "title": "house-robber-ii-c-easy-dp",
                "content": "\\'\\'\\'\\nPlease upvote the solution if feel it is helpful for you\\nif any doubt please ask and comment below\\n```\\nint solve(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n-1)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        return dp[i]=max(nums[i]+solve(nums,i+2,n,dp),solve(nums,i+1,n,dp));\\n    }\\n     int solve2(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n          return dp[i]=max(nums[i]+solve2(nums,i+2,n,dp),solve2(nums,i+1,n,dp));\\n     }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,-1);\\n        vector<int>dp2(n,-1);\\n       if(n==1)return nums[0];\\n        \\n        int ans1=solve(nums,0,n,dp1);\\n        int ans2=solve2(nums,1,n,dp2);\\n        return max(ans1,ans2);\\n    }",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "\\'\\'\\'\\nPlease upvote the solution if feel it is helpful for you\\nif any doubt please ask and comment below\\n```\\nint solve(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n-1)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        return dp[i]=max(nums[i]+solve(nums,i+2,n,dp),solve(nums,i+1,n,dp));\\n    }\\n     int solve2(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n          return dp[i]=max(nums[i]+solve2(nums,i+2,n,dp),solve2(nums,i+1,n,dp));\\n     }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,-1);\\n        vector<int>dp2(n,-1);\\n       if(n==1)return nums[0];\\n        \\n        int ans1=solve(nums,0,n,dp1);\\n        int ans2=solve2(nums,1,n,dp2);\\n        return max(ans1,ans2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1699138,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>nums) {\\n        if(nums.size()==1)return nums[0];\\n        if(nums.size()==2)return max(nums[0],nums[1]);\\n        nums[2]=max(nums[0]+nums[2],nums[1]);\\n        for(int i=3;i<nums.size();i++){\\n            nums[i]+=max(nums[i-2],nums[i-3]);\\n        }\\n        return max(nums[nums.size()-1],nums[nums.size()-2]);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        if(nums.size()==2) return max(nums[0],nums[1]);\\n        return max(fun(vector<int>(nums.begin()+1,nums.end())),fun(vector<int>(nums.begin(),nums.end()-1)));\\n    } \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>nums) {\\n        if(nums.size()==1)return nums[0];\\n        if(nums.size()==2)return max(nums[0],nums[1]);\\n        nums[2]=max(nums[0]+nums[2],nums[1]);\\n        for(int i=3;i<nums.size();i++){\\n            nums[i]+=max(nums[i-2],nums[i-3]);\\n        }\\n        return max(nums[nums.size()-1],nums[nums.size()-2]);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        if(nums.size()==2) return max(nums[0],nums[1]);\\n        return max(fun(vector<int>(nums.begin()+1,nums.end())),fun(vector<int>(nums.begin(),nums.end()-1)));\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689141,
                "title": "consider-2-cases-runtime-0ms-faster-than-100",
                "content": "**Idea?**\\n* Fix that 1st house is robbed, then last house must not be robbed. Find the maximum amount that can be robbed by considering either current house can be robbed or not?\\n* Again Fix that 1st House shouldn\\'t be robbed...Hence we can rob the last house.\\n* Find the same, maxm amount that can be robbed.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(N)\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums.back();\\n        vector<int> dp1(n),dp2(n);\\n        // rob 1st house fixed\\n        dp1[0] = dp1[1] = nums[0];\\n        for(int i=2;i<n-1;i++)\\n            dp1[i] = max(dp1[i-2]+nums[i],dp1[i-1]);\\n        //  we can\\'t rob the last house since first house is robbed (fixed)\\n        dp1[n-1] = dp1[n-2];\\n        \\n        // don\\'t rob 1st house\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++)\\n            dp2[i] = max(dp2[i-2]+nums[i],dp2[i-1]);\\n        return max(dp1.back(),dp2.back());\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(N)\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums.back();\\n        vector<int> dp1(n),dp2(n);\\n        // rob 1st house fixed\\n        dp1[0] = dp1[1] = nums[0];\\n        for(int i=2;i<n-1;i++)\\n            dp1[i] = max(dp1[i-2]+nums[i],dp1[i-1]);\\n        //  we can\\'t rob the last house since first house is robbed (fixed)\\n        dp1[n-1] = dp1[n-2];\\n        \\n        // don\\'t rob 1st house\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++)\\n            dp2[i] = max(dp2[i-2]+nums[i],dp2[i-1]);\\n        return max(dp1.back(),dp2.back());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600554,
                "title": "dp-based-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[105];\\n    int solution(vector<int> nums, int s){\\n        int n=nums.size();\\n        if(s>=n)\\n            return 0;\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        return dp[s]=max(nums[s]+solution(nums, s+2), solution(nums, s+1));\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        memset(dp, -1, sizeof(dp));\\n        int n=nums.size();\\n        int a1 = solution(nums, 1);\\n        nums.pop_back();\\n        memset(dp, -1, sizeof(dp));\\n        int a2 = solution(nums, 0);\\n        return max(a1, a2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[105];\\n    int solution(vector<int> nums, int s){\\n        int n=nums.size();\\n        if(s>=n)\\n            return 0;\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        return dp[s]=max(nums[s]+solution(nums, s+2), solution(nums, s+1));\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        memset(dp, -1, sizeof(dp));\\n        int n=nums.size();\\n        int a1 = solution(nums, 1);\\n        nums.pop_back();\\n        memset(dp, -1, sizeof(dp));\\n        int a2 = solution(nums, 0);\\n        return max(a1, a2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505691,
                "title": "python-single-pass-iterative-dp",
                "content": "For the first version of the [House Robber](https://leetcode.com/problems/house-robber/), we have the following iterative DP solution:\\n\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = 0\\n        for n in nums: \\n            a, b = b, max(b, a + n)\\n        return b\\n```\\n\\nWe can call the same `rob()` for `nums[:-1]` and `nums[1:]` and then pick the max of the two, which gives us the following two pass solution:\\n_Note: To handle `len(nums) == 1` we can just throw `nums[0]` in the `max()` call_\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        def rob(nums):\\n            a = b = 0\\n            for n in nums: \\n\\t\\t\\t\\ta, b = b, max(b, a + n)\\n            return b\\n        return max(nums[0], rob(nums[:-1]), rob(nums[1:]))\\n```\\n\\nIn fact, we can implement it in a single pass as follows:\\n\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = c = d = 0\\n        for i in range(len(nums)-1):\\n            a, b = b, max(b, a + nums[i])\\n            c, d = d, max(d, c + nums[i+1])\\n        \\n        return max(b, d, nums[0])\\n```\\nTime Complexity: `O(n)`\\nSpace Complecity: `O(1)`\\n\\n_Sorry for the lame choice of variable names_\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = 0\\n        for n in nums: \\n            a, b = b, max(b, a + n)\\n        return b\\n```\n```\\n    def rob(self, nums: List[int]) -> int:\\n        def rob(nums):\\n            a = b = 0\\n            for n in nums: \\n\\t\\t\\t\\ta, b = b, max(b, a + n)\\n            return b\\n        return max(nums[0], rob(nums[:-1]), rob(nums[1:]))\\n```\n```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = c = d = 0\\n        for i in range(len(nums)-1):\\n            a, b = b, max(b, a + nums[i])\\n            c, d = d, max(d, c + nums[i+1])\\n        \\n        return max(b, d, nums[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1495475,
                "title": "c-top-down-recursive-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp1[101];\\n    int helper1(vector<int>& nums,int i)\\n    {\\n        if(nums.size()-1<=i) return 0;\\n        \\n        if(dp1[i]!=-1) return dp1[i];\\n        \\n        int sum1=helper1(nums,i+1);\\n        int sum2=nums[i]+helper1(nums,i+2);\\n        \\n        return dp1[i] =max(sum1,sum2);\\n        \\n    }\\n    \\n    int dp2[101];\\n    int helper2(vector<int>& nums,int i)\\n    {\\n        if(nums.size()<=i) return 0;\\n        \\n        if(dp2[i]!=-1){\\n            return dp2[i];\\n        }\\n        int sum1=helper2(nums,i+1);\\n        int sum2=nums[i]+helper2(nums,i+2);\\n        \\n        return dp2[i]= max(sum1,sum2);\\n        \\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        memset(dp1,-1,sizeof(dp1));\\n        memset(dp2,-1,sizeof(dp2));\\n        \\n        int sum1 = helper1(nums,0);\\n        int sum2 = helper2(nums,1);\\n        cout<<sum1<<\" \"<<sum2;\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp1[101];\\n    int helper1(vector<int>& nums,int i)\\n    {\\n        if(nums.size()-1<=i) return 0;\\n        \\n        if(dp1[i]!=-1) return dp1[i];\\n        \\n        int sum1=helper1(nums,i+1);\\n        int sum2=nums[i]+helper1(nums,i+2);\\n        \\n        return dp1[i] =max(sum1,sum2);\\n        \\n    }\\n    \\n    int dp2[101];\\n    int helper2(vector<int>& nums,int i)\\n    {\\n        if(nums.size()<=i) return 0;\\n        \\n        if(dp2[i]!=-1){\\n            return dp2[i];\\n        }\\n        int sum1=helper2(nums,i+1);\\n        int sum2=nums[i]+helper2(nums,i+2);\\n        \\n        return dp2[i]= max(sum1,sum2);\\n        \\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        memset(dp1,-1,sizeof(dp1));\\n        memset(dp2,-1,sizeof(dp2));\\n        \\n        int sum1 = helper1(nums,0);\\n        int sum2 = helper2(nums,1);\\n        cout<<sum1<<\" \"<<sum2;\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1495268,
                "title": "similar-to-house-robber-problem",
                "content": "This problem is similar to house robber problem \\nIt is divided into 2 subproblems\\n1. we need to find from 0 to n-2\\n2. we need to find from 1 to n-1 \\n    return max of both\\n\\'\\'\\'class Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size(); \\n        if (n < 2) return n ? nums[0] : 0;\\n        return max(robber(nums, 0, n-2), robber(nums, 1, n - 1));\\n    }\\nprivate:\\n    int robber(vector<int>& nums, int l, int r) {\\n        int pre = 0, cur = 0;\\n        for (int i = l; i <= r; i++) {\\n            int temp = max(pre + nums[i], cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size(); \\n        if (n < 2) return n ? nums[0] : 0;\\n        return max(robber(nums, 0, n-2), robber(nums, 1, n - 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1466296,
                "title": "c-100-fast-same-as-house-robber-1-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //helper function same as house robber\\n    int helper(vector<int> nums) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        \\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<=n; i++){\\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        if(n==2) return max(nums[0], nums[1]);\\n        \\n        // a -> ignoring the last element of the array \\n        // when considering first element\\n        int a = helper(vector<int>(nums.begin(), nums.end()-1));\\n        \\n        // b -> ignoring the first element of the array \\n        // when considering last element\\n        int b = helper(vector<int>(nums.begin()+1, nums.end()));\\n        \\n        return max(a,b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //helper function same as house robber\\n    int helper(vector<int> nums) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        \\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<=n; i++){\\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        if(n==2) return max(nums[0], nums[1]);\\n        \\n        // a -> ignoring the last element of the array \\n        // when considering first element\\n        int a = helper(vector<int>(nums.begin(), nums.end()-1));\\n        \\n        // b -> ignoring the first element of the array \\n        // when considering last element\\n        int b = helper(vector<int>(nums.begin()+1, nums.end()));\\n        \\n        return max(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400820,
                "title": "java-dp-solution-in-o-n-using-o-n-space-complexity",
                "content": "This is the follow up of [House Robber](https://leetcode.com/problems/house-robber/) problem. In, house robber we do not have a circular array, so we can freely choose our start and end position. But here due to constraints we need to choose the best outcome, so we can divide the problem in two sub-problems\\n1. Finding the solution for index 0 to n - 2\\n2. Finding the solution for index 1 to n - 1\\nAnd the answer would be the max of these two sub problems\\n\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1)\\n            return nums[0];\\n        return Math.max(solve(Arrays.copyOfRange(nums, 0, n - 1)),solve(Arrays.copyOfRange(nums, 1, n)));\\n    }\\n    \\n    private int solve(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int [n + 1];\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for (int i = 2; i <= n; i++) \\n            dp[i] = Math.max(nums[i - 1] + dp[i - 2], dp[i - 1]);\\n        return dp[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1)\\n            return nums[0];\\n        return Math.max(solve(Arrays.copyOfRange(nums, 0, n - 1)),solve(Arrays.copyOfRange(nums, 1, n)));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1064306,
                "title": "python-dp-o-n",
                "content": "Use house rober 1 logic from [0, N-1] and [1 to N]\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums)==1: return nums[0]\\n        \\n        def f(nums):\\n            prev_max = 0\\n            cur_max = 0\\n            for p in nums:\\n                temp = cur_max\\n                cur_max = max(cur_max, prev_max+p)\\n                prev_max = temp\\n            return cur_max\\n        \\n        return max( f(nums[:-1]), f(nums[1:]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums)==1: return nums[0]\\n        \\n        def f(nums):\\n            prev_max = 0\\n            cur_max = 0\\n            for p in nums:\\n                temp = cur_max\\n                cur_max = max(cur_max, prev_max+p)\\n                prev_max = temp\\n            return cur_max\\n        \\n        return max( f(nums[:-1]), f(nums[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935356,
                "title": "c-dp",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        if (N == 0) return 0;\\n        \\n        if (N == 1) return nums[0];\\n        \\n        vector<int> numsA(nums.begin() + 1, nums.end());\\n        vector<int> numsB(nums.begin(), nums.end()-1);\\n        \\n        return max(robber(numsA), robber(numsB));\\n    }\\n    \\n    int robber (vector<int>& nums)\\n    {\\n        int dp1 = 0, dp2 = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int dp = max(dp2 + nums[i], dp1);\\n            \\n            dp2 = dp1;\\n            \\n            dp1 = dp;\\n        }\\n        \\n        return dp1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        if (N == 0) return 0;\\n        \\n        if (N == 1) return nums[0];\\n        \\n        vector<int> numsA(nums.begin() + 1, nums.end());\\n        vector<int> numsB(nums.begin(), nums.end()-1);\\n        \\n        return max(robber(numsA), robber(numsB));\\n    }\\n    \\n    int robber (vector<int>& nums)\\n    {\\n        int dp1 = 0, dp2 = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int dp = max(dp2 + nums[i], dp1);\\n            \\n            dp2 = dp1;\\n            \\n            dp1 = dp;\\n        }\\n        \\n        return dp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920372,
                "title": "normal-recursive-memory-recursive-dp",
                "content": "\\n#### Normal Recursive\\n```java\\n/**\\n  *  maybe timeout ? \\n  */\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n\\n        if (i == 0) {\\n            return Math.max(nums[i] + process(nums, i + 2, 1), process(nums, i + 1, 0));\\n        } else {\\n            return Math.max(nums[i] + process(nums, i + 2, usingFirst), process(nums, i + 1, usingFirst));\\n        }\\n    }\\n}\\n```\\n\\n#### Memory Search Recursive \\n```java\\n/**\\n  * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n  * Memory Usage: 36.4 MB, less than 5.01% of Java online submissions for House Robber II.\\n  */\\nclass Solution {\\n    \\n    private int[][] cache;\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        cache = new int[2][n + 1];\\n        int[] i1 = new int[n + 1];\\n        int[] i2 = new int[n + 1];\\n        Arrays.fill(i1, -1);\\n        Arrays.fill(i2, -1);\\n        cache[0] = i1;\\n        cache[1] = i2;\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n        \\n        if (cache[usingFirst][i] == -1) {\\n            if (i == 0) {\\n                if (cache[1][i + 2] == -1) {\\n                    cache[1][i + 2] = process(nums, i + 2, 1);\\n                }\\n                if (cache[0][i + 1] == -1) {\\n                    cache[0][i + 1] = process(nums, i + 1, 0);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[1][i + 2], cache[0][i + 1]);\\n            } else {\\n                if (cache[usingFirst][i + 2] == -1) {\\n                    cache[usingFirst][i + 2] = process(nums, i + 2, usingFirst);\\n                }\\n                if (cache[usingFirst][i + 1] == -1) {\\n                    cache[usingFirst][i + 1] = process(nums, i + 1, usingFirst);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[usingFirst][i + 2], cache[usingFirst][i + 1]);\\n            }\\n        }\\n        return cache[usingFirst][i];\\n    }\\n}\\n```\\n\\n#### DP\\n```java\\nclass Solution {\\n    /**\\n\\t * \\n    * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n    * Memory Usage: 35.4 MB, less than 95.01% of Java online submissions for House Robber II.\\n     */\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        int[][] dp = new int[2][n + 1];\\n        dp[0][n - 1] = nums[n - 1];\\n        dp[1][n - 1] = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i == 0) {\\n                dp[0][i] = dp[0][i + 1];\\n                dp[1][i] = nums[i] + dp[1][i + 2];\\n            } else {\\n                dp[0][i] = Math.max(nums[i] + dp[0][i + 2], dp[0][i + 1]);\\n                dp[1][i] = Math.max(nums[i] + dp[1][i + 2], dp[1][i + 1]);\\n            }\\n        }\\n        return Math.max(dp[0][0], dp[1][0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n  *  maybe timeout ? \\n  */\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n\\n        if (i == 0) {\\n            return Math.max(nums[i] + process(nums, i + 2, 1), process(nums, i + 1, 0));\\n        } else {\\n            return Math.max(nums[i] + process(nums, i + 2, usingFirst), process(nums, i + 1, usingFirst));\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n  * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n  * Memory Usage: 36.4 MB, less than 5.01% of Java online submissions for House Robber II.\\n  */\\nclass Solution {\\n    \\n    private int[][] cache;\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        cache = new int[2][n + 1];\\n        int[] i1 = new int[n + 1];\\n        int[] i2 = new int[n + 1];\\n        Arrays.fill(i1, -1);\\n        Arrays.fill(i2, -1);\\n        cache[0] = i1;\\n        cache[1] = i2;\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n        \\n        if (cache[usingFirst][i] == -1) {\\n            if (i == 0) {\\n                if (cache[1][i + 2] == -1) {\\n                    cache[1][i + 2] = process(nums, i + 2, 1);\\n                }\\n                if (cache[0][i + 1] == -1) {\\n                    cache[0][i + 1] = process(nums, i + 1, 0);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[1][i + 2], cache[0][i + 1]);\\n            } else {\\n                if (cache[usingFirst][i + 2] == -1) {\\n                    cache[usingFirst][i + 2] = process(nums, i + 2, usingFirst);\\n                }\\n                if (cache[usingFirst][i + 1] == -1) {\\n                    cache[usingFirst][i + 1] = process(nums, i + 1, usingFirst);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[usingFirst][i + 2], cache[usingFirst][i + 1]);\\n            }\\n        }\\n        return cache[usingFirst][i];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    /**\\n\\t * \\n    * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n    * Memory Usage: 35.4 MB, less than 95.01% of Java online submissions for House Robber II.\\n     */\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        int[][] dp = new int[2][n + 1];\\n        dp[0][n - 1] = nums[n - 1];\\n        dp[1][n - 1] = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i == 0) {\\n                dp[0][i] = dp[0][i + 1];\\n                dp[1][i] = nums[i] + dp[1][i + 2];\\n            } else {\\n                dp[0][i] = Math.max(nums[i] + dp[0][i + 2], dp[0][i + 1]);\\n                dp[1][i] = Math.max(nums[i] + dp[1][i + 2], dp[1][i + 1]);\\n            }\\n        }\\n        return Math.max(dp[0][0], dp[1][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900810,
                "title": "python-w-explanation",
                "content": "**IDEA**: This problem is an extension of the \\'[LC 198: House Robber](https://leetcode.com/problems/house-robber/)\\' problem. (As provided) \\n\\nThe aim of the \\'House Robber\\' problem is to maximize profits while ensuring that none of the two consecutive houses are robbed. (Visualize the street to be linear here)\\nThus, the cases are:\\n1. 1 house only: max profit -> profit from the only house\\n2. 2 houses: max profit -> max(profit from 1st house, profit from 2nd house)\\n3. 3 or more houses: max profit -> max(profit from the last to last house + profit from current house, profit from last house)\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev+num, curr)\\n        return curr\\n```\\n\\nThe current problem has an additional constraint that the street is circular. Thus, the first and the (pseudo) last house can\\'t be robbed together. \\nThus, apart from the cases described abvove, there are two cases in the broader picture:\\n(Assuming houses are 1, 2, 3, 4 ... n )\\n1. Rob houses 1 to (n-1)\\n2. Rob houses 2 to n \\n\\nThus, the above code can be resused with added constraints as under:\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        return max(nums[0] + self._helper(nums[2:-1]), self._helper(nums[1:]))\\n    \\n    def _helper(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev + num, curr)\\n        return curr\\n```\\n\\nTime Complexity: O(N) where, N: length of input list \\'nums\\'\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev+num, curr)\\n        return curr\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        return max(nums[0] + self._helper(nums[2:-1]), self._helper(nums[1:]))\\n    \\n    def _helper(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev + num, curr)\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895299,
                "title": "java-clean-concise-code-dynamic-programming-approach",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int rob (int[] nums) {\\n\\t\\t\\n\\t\\tint n = nums.length;\\n\\t\\tint first = 0;\\n\\t\\tint second1 = n == 1 ? 0 : nums[0];\\n\\t\\tint second2 = nums[0];\\n\\t\\t\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint max = Math.max (second1, first + nums[i]);\\n\\t\\t\\tfirst = second1;\\n\\t\\t\\tsecond1 = second2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = n; i < n + n; i++) {\\n\\t\\t\\tint max = Math.max (second2, first + nums[i - n]);\\n\\t\\t\\tfirst = second2;\\n\\t\\t\\tsecond2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn second2 - second1;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int rob (int[] nums) {\\n\\t\\t\\n\\t\\tint n = nums.length;\\n\\t\\tint first = 0;\\n\\t\\tint second1 = n == 1 ? 0 : nums[0];\\n\\t\\tint second2 = nums[0];\\n\\t\\t\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint max = Math.max (second1, first + nums[i]);\\n\\t\\t\\tfirst = second1;\\n\\t\\t\\tsecond1 = second2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = n; i < n + n; i++) {\\n\\t\\t\\tint max = Math.max (second2, first + nums[i - n]);\\n\\t\\t\\tfirst = second2;\\n\\t\\t\\tsecond2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn second2 - second1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880828,
                "title": "javascript-very-easy-solution-dynamic-programming",
                "content": "```\\nvar rob = function(nums) {\\n    let n = nums.length;\\n    if(n===0) return 0;\\n    if(n===1) return nums[0];\\n    if(n===2) return Math.max(nums[0],nums[1])\\n    \\n    let dp1 = new Array(n);\\n    let dp2 = new Array(n);\\n    \\n    computeResult(0,n-2,dp1,nums);\\n    computeResult(1,n-1,dp2,nums);\\n    \\n    function computeResult(i,n,dp,nums){\\n        dp[i] = nums[i]\\n        dp[i+1] = Math.max(dp[i],nums[i+1])\\n        \\n        for(let j=i+2; j<=n; j++){\\n            dp[j] = Math.max(dp[j-1],dp[j-2]+nums[j])\\n        }\\n    }\\n    return Math.max(dp1[n-2],dp2[n-1])\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    let n = nums.length;\\n    if(n===0) return 0;\\n    if(n===1) return nums[0];\\n    if(n===2) return Math.max(nums[0],nums[1])\\n    \\n    let dp1 = new Array(n);\\n    let dp2 = new Array(n);\\n    \\n    computeResult(0,n-2,dp1,nums);\\n    computeResult(1,n-1,dp2,nums);\\n    \\n    function computeResult(i,n,dp,nums){\\n        dp[i] = nums[i]\\n        dp[i+1] = Math.max(dp[i],nums[i+1])\\n        \\n        for(let j=i+2; j<=n; j++){\\n            dp[j] = Math.max(dp[j-1],dp[j-2]+nums[j])\\n        }\\n    }\\n    return Math.max(dp1[n-2],dp2[n-1])\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 869568,
                "title": "do-dp-twice-the-first-round-rob-house0-the-second-round-not",
                "content": "1. if we do not rob house0, then we could rob house n-1.\\n2. if we rob house0, then we could ignore house n-1, just loop to n-2 \\n\\nchoose the max answer in these 2 options. \\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null) return 0;\\n        int n = nums.length;\\n        if(n ==0) return 0;\\n        if(n ==1) return nums[0];\\n        \\n        int[] dp = new int[n];\\n        \\n        //first round, we do not rob house 0\\n        dp[0] = 0;// do not rob house 0\\n        dp[1] = nums[1];\\n        for(int i=2; i<n; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n\\t\\t\\n        int max = dp[n-1];\\n      \\n        //seond round, rob house0, in this case we could ignore house n-1\\n        dp[0] = nums[0];//rob house 0\\n        dp[1] = dp[0];\\n\\t\\t//loop to n-2, ignore house N-1\\n        for(int i=2; i<n-1; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        max = Math.max(max,dp[n-2]);\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null) return 0;\\n        int n = nums.length;\\n        if(n ==0) return 0;\\n        if(n ==1) return nums[0];\\n        \\n        int[] dp = new int[n];\\n        \\n        //first round, we do not rob house 0\\n        dp[0] = 0;// do not rob house 0\\n        dp[1] = nums[1];\\n        for(int i=2; i<n; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n\\t\\t\\n        int max = dp[n-1];\\n      \\n        //seond round, rob house0, in this case we could ignore house n-1\\n        dp[0] = nums[0];//rob house 0\\n        dp[1] = dp[0];\\n\\t\\t//loop to n-2, ignore house N-1\\n        for(int i=2; i<n-1; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        max = Math.max(max,dp[n-2]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791317,
                "title": "dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        //case 1 rob from 1 to n-1\\n        //case 2 rob from 2 to n\\n        //max of both\\n        int len = nums.length;\\n        if(len == 1){\\n            return nums[0];\\n        }\\n        else if(len==2){\\n            return Math.max(nums[0],nums[1]);// since houses are in circular\\n        }\\n        \\n        \\n        return Math.max(robHouses(nums,0,len-2),robHouses(nums,1,len-1));\\n    }\\n    public int robHouses(int[] nums,int fromIndex,int toIndex){\\n        int prev1 = 0;//amount robbed till previous house\\n        int prev2 = 0;// amount robbed till previous of prev1\\n        for(int i=fromIndex;i<=toIndex;i++){\\n            int temp = prev1;\\n            prev1 = Math.max((prev2+nums[i]),prev1);//robber can either select pre1 or curr+prev2\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        //case 1 rob from 1 to n-1\\n        //case 2 rob from 2 to n\\n        //max of both\\n        int len = nums.length;\\n        if(len == 1){\\n            return nums[0];\\n        }\\n        else if(len==2){\\n            return Math.max(nums[0],nums[1]);// since houses are in circular\\n        }\\n        \\n        \\n        return Math.max(robHouses(nums,0,len-2),robHouses(nums,1,len-1));\\n    }\\n    public int robHouses(int[] nums,int fromIndex,int toIndex){\\n        int prev1 = 0;//amount robbed till previous house\\n        int prev2 = 0;// amount robbed till previous of prev1\\n        for(int i=fromIndex;i<=toIndex;i++){\\n            int temp = prev1;\\n            prev1 = Math.max((prev2+nums[i]),prev1);//robber can either select pre1 or curr+prev2\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703829,
                "title": "javascript-solution",
                "content": "I obviously did not come up with this solution. If you need a good explanation of the code below, I would suggest you look up the submission by [@lxx223](https://leetcode.com/problems/house-robber-ii/discuss/59934/Simple-AC-solution-in-Java-in-O(n)-with-explanation) which is the most voted. For me personally, I thought it will be good to practice the offsetting of indexes for arrays since I been having issues with them in more difficult problems. So, the extra use of the variable `j` and adding 2 zeroes for the dp, and use of  `start + i` was done on purpose. Please let me know if you have any questions or ways of improving the code. Thank you and have a wonderful day all!\\n\\n<br>\\n\\n```\\nvar rob = function(nums) {\\n    \\n    if (!nums || nums.length == 0) return 0; // not neceesary, but for completeness sake\\n    \\n    const n = nums.length;\\n    if (n == 1) return nums[0]; // edge case where there is only 1 element in the array\\n    \\n    return Math.max(robHomes(1, n - 1), robHomes(0, n - 2));\\n    \\n    function robHomes(start, end) {\\n        const len = end - start + 1;\\n        const dp = [];\\n        dp[0] = 0, dp[1] = 0; // For look-backs\\n        \\n        for (let i = 0, j = 2; i < len; i++, j++) {\\n            const num = nums[start + i];\\n            dp[j] = Math.max(num + dp[j - 2], dp[j - 1]);\\n        }\\n        \\n        return dp[dp.length - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    \\n    if (!nums || nums.length == 0) return 0; // not neceesary, but for completeness sake\\n    \\n    const n = nums.length;\\n    if (n == 1) return nums[0]; // edge case where there is only 1 element in the array\\n    \\n    return Math.max(robHomes(1, n - 1), robHomes(0, n - 2));\\n    \\n    function robHomes(start, end) {\\n        const len = end - start + 1;\\n        const dp = [];\\n        dp[0] = 0, dp[1] = 0; // For look-backs\\n        \\n        for (let i = 0, j = 2; i < len; i++, j++) {\\n            const num = nums[start + i];\\n            dp[j] = Math.max(num + dp[j - 2], dp[j - 1]);\\n        }\\n        \\n        return dp[dp.length - 1];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693341,
                "title": "python-6-line-less-obscure-dp-solution",
                "content": "Both `dp1` and `dp2` records the maximum value robbed along the way, however under different conditions:\\n- `dp1`: first house is robbed \\n- `dp2`: first house is NOT robbed\\n\\nApplied a little trick in the initialization of `dp2` to deal with single-house cases.\\n```python\\ndef rob(self, nums: List[int]) -> int:\\n    dp1 = [0, 0]\\n    dp2 = [-nums[0] if len(nums) > 1 else 0, 0]\\n    for i, n in enumerate(nums):\\n        dp1.append(max(dp1[i+1], n + dp1[i]))\\n        dp2.append(max(dp2[i+1], n + dp2[i]))\\n    return max(dp1[-2], dp2[-1])\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef rob(self, nums: List[int]) -> int:\\n    dp1 = [0, 0]\\n    dp2 = [-nums[0] if len(nums) > 1 else 0, 0]\\n    for i, n in enumerate(nums):\\n        dp1.append(max(dp1[i+1], n + dp1[i]))\\n        dp2.append(max(dp2[i+1], n + dp2[i]))\\n    return max(dp1[-2], dp2[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 594651,
                "title": "python3-o-n-solution",
                "content": "2 scenarios: Buy the first one and don\\'t buy the last one or don\\'t buy the first one and consider buying the last one \\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        boughtFirst = self.maxProfit(nums[:len(nums)-1])\\n        boughtFirstNot = self.maxProfit(nums[1:])\\n        return max(boughtFirst, boughtFirstNot)\\n    \\n    def maxProfit(self,nums):\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        dp = [nums[0], max(nums[0],nums[1])]\\n        for i in range(2, len(nums)):\\n            dp.append(max(dp[i-2] + nums[i], dp[i-1]))\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        boughtFirst = self.maxProfit(nums[:len(nums)-1])\\n        boughtFirstNot = self.maxProfit(nums[1:])\\n        return max(boughtFirst, boughtFirstNot)\\n    \\n    def maxProfit(self,nums):\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        dp = [nums[0], max(nums[0],nums[1])]\\n        for i in range(2, len(nums)):\\n            dp.append(max(dp[i-2] + nums[i], dp[i-1]))\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577231,
                "title": "0ms-java-100-simple-solution-dp",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0; \\n        if(nums.length==1)\\n            return nums[0];\\n \\n        int max1 = robHelper(nums, 0, nums.length-2);\\n        int max2 = robHelper(nums, 1, nums.length-1);\\n        return Math.max(max1, max2);\\n    }\\n    public int robHelper(int[] nums, int i, int j){\\n        if(i==j){\\n            return nums[i];\\n        }\\n        int[] dp = new int[nums.length];\\n        dp[i]=nums[i];\\n        dp[i+1]=Math.max(nums[i+1], dp[i]);\\n        for(int k=i+2; k<=j; k++){\\n            dp[k]=Math.max(dp[k-1], dp[k-2]+nums[k]);    \\n        }\\n        return dp[j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0; \\n        if(nums.length==1)\\n            return nums[0];\\n \\n        int max1 = robHelper(nums, 0, nums.length-2);\\n        int max2 = robHelper(nums, 1, nums.length-1);\\n        return Math.max(max1, max2);\\n    }\\n    public int robHelper(int[] nums, int i, int j){\\n        if(i==j){\\n            return nums[i];\\n        }\\n        int[] dp = new int[nums.length];\\n        dp[i]=nums[i];\\n        dp[i+1]=Math.max(nums[i+1], dp[i]);\\n        for(int k=i+2; k<=j; k++){\\n            dp[k]=Math.max(dp[k-1], dp[k-2]+nums[k]);    \\n        }\\n        return dp[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413151,
                "title": "simple-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        \\n        if (n == 0)\\n            return 0;\\n        else if (n==1)\\n            return nums[0];\\n        else if (n==2)\\n            return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[n];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i < n-1;i++){//rob first house\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n            // System.out.println(Arrays.toString(dp));\\n        }\\n        dp[n-1] = dp[n-2]; //only choose between nums[2,n-2], then stay the same\\n        \\n        int tmpMax = dp[n-1] ;\\n        \\n        //skip first house\\n        dp = new int[n];\\n        dp[1] = nums[1]; \\n        dp[2] = Math.max(nums[1],nums[2]);\\n        for (int i = 3; i < n;i++){\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n        }\\n        \\n        return Math.max(dp[n-1],tmpMax);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        \\n        if (n == 0)\\n            return 0;\\n        else if (n==1)\\n            return nums[0];\\n        else if (n==2)\\n            return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[n];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i < n-1;i++){//rob first house\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n            // System.out.println(Arrays.toString(dp));\\n        }\\n        dp[n-1] = dp[n-2]; //only choose between nums[2,n-2], then stay the same\\n        \\n        int tmpMax = dp[n-1] ;\\n        \\n        //skip first house\\n        dp = new int[n];\\n        dp[1] = nums[1]; \\n        dp[2] = Math.max(nums[1],nums[2]);\\n        for (int i = 3; i < n;i++){\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n        }\\n        \\n        return Math.max(dp[n-1],tmpMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408090,
                "title": "swift-with-explanation",
                "content": "This is the same problem as House Robber I except you must solve the problem twice and take the max.\\n1. Solve the problem for the range 0 to n-2. (Excludes the last house)\\n2. Solve the problem for the range 1 to n-1. (Excludes the first house)\\n\\n```\\nfunc rob(_ nums: [Int]) -> Int {\\n\\tguard !nums.isEmpty else { return 0 }\\n\\n\\tif nums.count == 1 { return nums[0] }\\n\\tif nums.count == 2 { return max(nums[0], nums[1]) }\\n\\n\\tlet n = nums.count\\n\\n\\treturn max(robHelper(Array(nums[0...n-2])), robHelper(Array(nums[1...n-1])))\\n}\\n\\nfunc robHelper(_ nums: [Int]) -> Int {\\n\\tvar maxMoney = 0\\n\\tvar dp = Array(repeating: 0, count: nums.count)\\n\\n\\tdp[0] = nums[0]\\n\\tdp[1] = max(nums[1], nums[0])\\n\\n\\tif nums.count == 2 { return dp[1] }\\n\\n\\tfor i in 2..<nums.count {\\n\\t\\tdp[i] = max(dp[i-1], nums[i] + dp[i-2])\\n\\t\\tmaxMoney = max(dp[i], maxMoney)\\n\\t}\\n\\n\\treturn maxMoney\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rob(_ nums: [Int]) -> Int {\\n\\tguard !nums.isEmpty else { return 0 }\\n\\n\\tif nums.count == 1 { return nums[0] }\\n\\tif nums.count == 2 { return max(nums[0], nums[1]) }\\n\\n\\tlet n = nums.count\\n\\n\\treturn max(robHelper(Array(nums[0...n-2])), robHelper(Array(nums[1...n-1])))\\n}\\n\\nfunc robHelper(_ nums: [Int]) -> Int {\\n\\tvar maxMoney = 0\\n\\tvar dp = Array(repeating: 0, count: nums.count)\\n\\n\\tdp[0] = nums[0]\\n\\tdp[1] = max(nums[1], nums[0])\\n\\n\\tif nums.count == 2 { return dp[1] }\\n\\n\\tfor i in 2..<nums.count {\\n\\t\\tdp[i] = max(dp[i-1], nums[i] + dp[i-2])\\n\\t\\tmaxMoney = max(dp[i], maxMoney)\\n\\t}\\n\\n\\treturn maxMoney\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371982,
                "title": "c-o-n-dp-solution",
                "content": "DP1: Include 1st element and ignore last element.\\nDP2: Include last and ignore first.\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        if(n<2) return nums[0];\\n        int dp1[n+1];\\n        int dp2[n+1];\\n        dp1[0] = 0;\\n        dp1[1] = nums[0];\\n        dp2[0] = 0;\\n        dp2[1] = 0;\\n        for(int i = 2; i <= n; i++) {\\n            dp1[i] = max(dp1[i-1], nums[i-1] + dp1[i-2]);\\n            dp2[i] = max(dp2[i-1], nums[i-1] + dp2[i-2]);\\n        }\\n        return max(dp1[n-1], dp2[n]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        if(n<2) return nums[0];\\n        int dp1[n+1];\\n        int dp2[n+1];\\n        dp1[0] = 0;\\n        dp1[1] = nums[0];\\n        dp2[0] = 0;\\n        dp2[1] = 0;\\n        for(int i = 2; i <= n; i++) {\\n            dp1[i] = max(dp1[i-1], nums[i-1] + dp1[i-2]);\\n            dp2[i] = max(dp2[i-1], nums[i-1] + dp2[i-2]);\\n        }\\n        return max(dp1[n-1], dp2[n]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305658,
                "title": "javascript-solution-o-n-time-o-2n-space",
                "content": "```\\nvar rob = function(nums) {\\n  const N = nums.length\\n  if (N === 0) return 0;\\n  if (N === 1) return nums[0];\\n  \\n  // robbing first house\\n  const dp = [nums[0], Math.max(nums[0], nums[1])]\\n  \\n  // robbing last house\\n  const dp2 = [0, nums[1]]\\n  \\n  for (let i = 2; i < N; i++) {\\n    dp[i] = i === N - 1 ? dp[i-1] : Math.max(dp[i-1], dp[i - 2] + nums[i]);\\n    dp2[i] = Math.max(dp2[i-1], dp2[i - 2] + nums[i])\\n  \\n  }\\n\\n  return Math.max(dp[N - 1], dp2[N - 1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rob = function(nums) {\\n  const N = nums.length\\n  if (N === 0) return 0;\\n  if (N === 1) return nums[0];\\n  \\n  // robbing first house\\n  const dp = [nums[0], Math.max(nums[0], nums[1])]\\n  \\n  // robbing last house\\n  const dp2 = [0, nums[1]]\\n  \\n  for (let i = 2; i < N; i++) {\\n    dp[i] = i === N - 1 ? dp[i-1] : Math.max(dp[i-1], dp[i - 2] + nums[i]);\\n    dp2[i] = Math.max(dp2[i-1], dp2[i - 2] + nums[i])\\n  \\n  }\\n\\n  return Math.max(dp[N - 1], dp2[N - 1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295085,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        var n = nums.Length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var numList = new List<int>(nums);\\n        numList.RemoveAt(0);\\n        var candidate1 = Rob(numList);\\n\\n        numList = new List<int>(nums);\\n        numList.RemoveAt(n - 1);\\n        var cnadidate2 = Rob(numList);\\n\\n        return Math.Max(candidate1, cnadidate2);\\n    }\\n\\n    private int Rob(List<int> nums) {\\n        var n = nums.Count;\\n\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var prePre = 0;\\n        var pre = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            var cur = Math.Max(prePre + nums[i], pre);\\n            prePre = pre;\\n            pre = cur;\\n        }\\n\\n        return pre;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        var n = nums.Length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var numList = new List<int>(nums);\\n        numList.RemoveAt(0);\\n        var candidate1 = Rob(numList);\\n\\n        numList = new List<int>(nums);\\n        numList.RemoveAt(n - 1);\\n        var cnadidate2 = Rob(numList);\\n\\n        return Math.Max(candidate1, cnadidate2);\\n    }\\n\\n    private int Rob(List<int> nums) {\\n        var n = nums.Count;\\n\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var prePre = 0;\\n        var pre = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            var cur = Math.Max(prePre + nums[i], pre);\\n            prePre = pre;\\n            pre = cur;\\n        }\\n\\n        return pre;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1763354,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1573452,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1829110,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1566907,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1575858,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1572254,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1567918,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1807059,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1576601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1755175,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1763354,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1573452,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1829110,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1566907,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1575858,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1572254,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1567918,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1807059,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1576601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1755175,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1629825,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1573936,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1568464,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1569025,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1571439,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 2054231,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 2049683,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 2027590,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1980019,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1959915,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1945578,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1940322,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1939538,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1935910,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1927920,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1863467,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1841566,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1785338,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1757520,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1734673,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            }
        ]
    }
]