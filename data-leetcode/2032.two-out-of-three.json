[
    {
        "title": "Two Out of Three",
        "question_content": "Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\nOutput: [3,2]\nExplanation: The values that are present in at least two arrays are:\n- 3, in all three arrays.\n- 2, in nums1 and nums2.\n\nExample 2:\n\nInput: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\nOutput: [2,3,1]\nExplanation: The values that are present in at least two arrays are:\n- 2, in nums2 and nums3.\n- 3, in nums1 and nums2.\n- 1, in nums1 and nums3.\n\nExample 3:\n\nInput: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\nOutput: []\nExplanation: No value is present in at least two arrays.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums1.length, nums2.length, nums3.length <= 100\n\t1 <= nums1[i], nums2[j], nums3[k] <= 100",
        "solutions": [
            {
                "id": 1513355,
                "title": "three-count-arrays",
                "content": "A catch here is that an element can appear in the same array more than once. So we need to somehow count elements independently. Alternatively, we can de-dup arrays first.\\n\\n> See also a few generic versions below.\\n\\n#### Approach 1: Straightforward\\n\\n**C++**\\n```cpp\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        bool cnt[3][101] = {};\\n        vector<int> res;\\n        for (auto n : nums1)\\n            cnt[0][n] = true;\\n        for (auto n : nums2)\\n            cnt[1][n] = true;\\n        for (auto n : nums3)\\n            cnt[2][n] = true;\\n        for (int i = 1; i <= 100; ++i)\\n            if (cnt[0][i] + cnt[1][i] + cnt[2][i] > 1)\\n                res.push_back(i);\\n        return res;\\n    }\\n```\\n\\n#### Approach 2: Generic\\nSame as above, but this can be adapted for any number of input arrays.\\n\\n**C++**\\n```cpp\\nbool cnt[3][101] = {};\\nvector<int> twoOutOfThree(vector<vector<int>> nums) {\\n    vector<int> res;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int n : nums[i])\\n            cnt[i][n] = true;\\n        for (int n = 1; n <= 100; ++n) {\\n            int total = 0;\\n            for (int i = 0; i < nums.size(); ++i)\\n                total += cnt[i][n];\\n            if (total > 1)\\n                res.push_back(n);\\n        }\\n    return res;\\n}\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n    return twoOutOfThree({nums1, nums2, nums3});\\n}\\n```\\n#### Approach 3: Dedup then Count\\nWe can use a single `cnt` array if we de-dup each array first. Note that we sort arrays for the simplicity - which adds to the runtime complexity. We could have used hash set instead.\\n\\n**C++**\\n```cpp\\nint cnt[101] = {};\\nvector<int> twoOutOfThree(vector<vector<int>> nums) {\\n    vector<int> res;\\n    for (auto &num_i : nums) {\\n        sort(begin(num_i), end(num_i));\\n        num_i.erase(unique(begin(num_i), end(num_i)), end(num_i)); \\n        for (int n : num_i)\\n            ++cnt[n];\\n    }\\n    for (int n = 1; n <= 100; ++n)\\n        if (cnt[n] > 1)\\n            res.push_back(n);\\n    return res;\\n}\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n    return twoOutOfThree({nums1, nums2, nums3});\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        bool cnt[3][101] = {};\\n        vector<int> res;\\n        for (auto n : nums1)\\n            cnt[0][n] = true;\\n        for (auto n : nums2)\\n            cnt[1][n] = true;\\n        for (auto n : nums3)\\n            cnt[2][n] = true;\\n        for (int i = 1; i <= 100; ++i)\\n            if (cnt[0][i] + cnt[1][i] + cnt[2][i] > 1)\\n                res.push_back(i);\\n        return res;\\n    }\\n```\n```cpp\\nbool cnt[3][101] = {};\\nvector<int> twoOutOfThree(vector<vector<int>> nums) {\\n    vector<int> res;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int n : nums[i])\\n            cnt[i][n] = true;\\n        for (int n = 1; n <= 100; ++n) {\\n            int total = 0;\\n            for (int i = 0; i < nums.size(); ++i)\\n                total += cnt[i][n];\\n            if (total > 1)\\n                res.push_back(n);\\n        }\\n    return res;\\n}\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n    return twoOutOfThree({nums1, nums2, nums3});\\n}\\n```\n```cpp\\nint cnt[101] = {};\\nvector<int> twoOutOfThree(vector<vector<int>> nums) {\\n    vector<int> res;\\n    for (auto &num_i : nums) {\\n        sort(begin(num_i), end(num_i));\\n        num_i.erase(unique(begin(num_i), end(num_i)), end(num_i)); \\n        for (int n : num_i)\\n            ++cnt[n];\\n    }\\n    for (int n = 1; n <= 100; ++n)\\n        if (cnt[n] > 1)\\n            res.push_back(n);\\n    return res;\\n}\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n    return twoOutOfThree({nums1, nums2, nums3});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1516174,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1513706,
                "title": "java-sets",
                "content": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\tSet<Integer> set1 = new HashSet<>(), set2 = new HashSet<>(), set3 = new HashSet<>(), set = new HashSet<>();\\n\\tfor(int i: nums1) { set1.add(i); set.add(i); }\\n\\tfor(int i: nums2) { set2.add(i); set.add(i); }\\n\\tfor(int i: nums3) { set3.add(i); set.add(i); }\\n\\tList<Integer> result = new ArrayList<>();\\n\\tfor(int i: set) \\n\\t\\tif(set1.contains(i) && set2.contains(i) || set2.contains(i) && set3.contains(i) || set1.contains(i) && set3.contains(i)) result.add(i);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\tSet<Integer> set1 = new HashSet<>(), set2 = new HashSet<>(), set3 = new HashSet<>(), set = new HashSet<>();\\n\\tfor(int i: nums1) { set1.add(i); set.add(i); }\\n\\tfor(int i: nums2) { set2.add(i); set.add(i); }\\n\\tfor(int i: nums3) { set3.add(i); set.add(i); }\\n\\tList<Integer> result = new ArrayList<>();\\n\\tfor(int i: set) \\n\\t\\tif(set1.contains(i) && set2.contains(i) || set2.contains(i) && set3.contains(i) || set1.contains(i) && set3.contains(i)) result.add(i);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513311,
                "title": "python3-set",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/933e9b50b2532374ab8252f431da84b6675663a8) for solutions of weekly 262.\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        s1, s2, s3 = set(nums1), set(nums2), set(nums3)\\n        return (s1&s2) | (s2&s3) | (s1&s3)\\n```\\n\\nAdding an approach by @SunnyvaleCA\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        freq = Counter()\\n        for nums in nums1, nums2, nums3: freq.update(set(nums))\\n        return [k for k, v in freq.items() if v >= 2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        s1, s2, s3 = set(nums1), set(nums2), set(nums3)\\n        return (s1&s2) | (s2&s3) | (s1&s3)\\n```\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        freq = Counter()\\n        for nums in nums1, nums2, nums3: freq.update(set(nums))\\n        return [k for k, v in freq.items() if v >= 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513358,
                "title": "c-map-set",
                "content": "**Any doubts and suggestion please write in the comment**\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int,set<int>>st;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            st[nums1[i]].insert(1);\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            st[nums2[i]].insert(2);\\n        }\\n        for(int i=0;i<nums3.size();i++)\\n        {\\n            st[nums3[i]].insert(3);\\n        }\\n        vector<int>result;\\n        for(auto it=st.begin();it!=st.end();it++)\\n        {\\n            if(it->second.size()>=2)\\n            {\\n                result.push_back(it->first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int,set<int>>st;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            st[nums1[i]].insert(1);\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            st[nums2[i]].insert(2);\\n        }\\n        for(int i=0;i<nums3.size();i++)\\n        {\\n            st[nums3[i]].insert(3);\\n        }\\n        vector<int>result;\\n        for(auto it=st.begin();it!=st.end();it++)\\n        {\\n            if(it->second.size()>=2)\\n            {\\n                result.push_back(it->first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513632,
                "title": "o-n-c-mask",
                "content": "for each array we can have mask and can OR them\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int>f(110, 0);\\n        for (int n : nums1) f[n] |= 1<<0;\\n        for (int n : nums2) f[n] |= 1<<1;\\n        for (int n : nums3) f[n] |= 1<<2;\\n        \\n        vector<int>ret;\\n        for (int i = 1; i <= 100; i++) if (f[i] == 3 || f[i] >= 5) ret.push_back(i);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int>f(110, 0);\\n        for (int n : nums1) f[n] |= 1<<0;\\n        for (int n : nums2) f[n] |= 1<<1;\\n        for (int n : nums3) f[n] |= 1<<2;\\n        \\n        vector<int>ret;\\n        for (int i = 1; i <= 100; i++) if (f[i] == 3 || f[i] >= 5) ret.push_back(i);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513404,
                "title": "c-solution-map-set",
                "content": "\\n \\n \\n \\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int, set<int>> mp;\\n        for(int i = 0 ; i < nums1.size() ; i++){\\n        mp[nums1[i]].insert(1);\\n    }\\n    for(int i = 0 ; i < nums2.size() ; i++){\\n        mp[nums2[i]].insert(2);\\n    }\\n    \\n    for(int i = 0 ; i < nums3.size() ; i++){\\n        mp[nums3[i]].insert(3);\\n    }\\n    vector<int> ans;\\n    \\n    for(auto it = mp.begin() ; it!=mp.end() ; it++){\\n        if(it->second.size()>=2){ans.push_back(it->first);}\\n    }\\n    return ans;\\n\\t}\\n\\t\\n\\t\\n2nd :\\n         \\n    vector<int> twoOutOfThree(vector<int>& num1, vector<int>& num2, vector<int>& num3) {\\n\\t\\tset<int> a,b,c;\\n\\t\\tfor(auto x:num1) a.insert(x);\\n\\t\\tfor(auto x:num2) b.insert(x);\\n\\t\\tfor(auto x:num3) c.insert(x);\\n\\t\\tmap<int,int> ans;\\n\\t\\tfor(auto x : a) ans[x]++;\\n\\t\\tfor(auto x : b) ans[x]++;\\n\\t\\tfor(auto x : c) ans[x]++;\\n\\t\\tvector<int> res;\\n\\t\\tfor(auto x : ans){\\n\\t\\t\\tif(x.second >1) res.push_back(x.first);\\n\\t\\t}\\n\\t\\treturn res;\\n\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n \\n \\n \\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int, set<int>> mp;\\n        for(int i = 0 ; i < nums1.size() ; i++){\\n        mp[nums1[i]].insert(1);\\n    }\\n    for(int i = 0 ; i < nums2.size() ; i++){\\n        mp[nums2[i]].insert(2);\\n    }\\n    \\n    for(int i = 0 ; i < nums3.size() ; i++){\\n        mp[nums3[i]].insert(3);\\n    }\\n    vector<int> ans;\\n    \\n    for(auto it = mp.begin() ; it!=mp.end() ; it++){\\n        if(it->second.size()>=2){ans.push_back(it->first);}\\n    }\\n    return ans;\\n\\t}\\n\\t\\n\\t\\n2nd :\\n         \\n    vector<int> twoOutOfThree(vector<int>& num1, vector<int>& num2, vector<int>& num3) {\\n\\t\\tset<int> a,b,c;\\n\\t\\tfor(auto x:num1) a.insert(x);\\n\\t\\tfor(auto x:num2) b.insert(x);\\n\\t\\tfor(auto x:num3) c.insert(x);\\n\\t\\tmap<int,int> ans;\\n\\t\\tfor(auto x : a) ans[x]++;\\n\\t\\tfor(auto x : b) ans[x]++;\\n\\t\\tfor(auto x : c) ans[x]++;\\n\\t\\tvector<int> res;\\n\\t\\tfor(auto x : ans){\\n\\t\\t\\tif(x.second >1) res.push_back(x.first);\\n\\t\\t}\\n\\t\\treturn res;\\n\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3181557,
                "title": "java-easy-solution-without-using-hashset-set-collections",
                "content": "# Intuition\\nAn easy way to find a solution without using collections other than the List collection\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nRuntime:  1ms     Beats: 100%\\nMemory:  43.3 MB  Beats: 38.77%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\n        /** Since we have 3 arrays of numbers, \\n         * we need 3 boolean arrays.\\n         *  Here is the length of the longest \\n         *  array that can reach the length of the array */\\n        boolean[] b1 = new boolean[101];\\n        boolean[] b2 = new boolean[101];\\n        boolean[] b3 = new boolean[101];\\n\\n        /** where values of the boolean array \\n         * at the corresponding index are changed to true */\\n        for (int num : nums1) b1[num] = true;\\n\\n        for (int num : nums2) b2[num] = true;\\n\\n        for (int num : nums3) b3[num] = true;\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n\\n        for (int i = 1; i <= 100; i++){\\n            if((b1[i] || b2[i]) && (b2[i] || b3[i]) && (b3[i] || b1[i]))\\n                res.add(i);\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\n        /** Since we have 3 arrays of numbers, \\n         * we need 3 boolean arrays.\\n         *  Here is the length of the longest \\n         *  array that can reach the length of the array */\\n        boolean[] b1 = new boolean[101];\\n        boolean[] b2 = new boolean[101];\\n        boolean[] b3 = new boolean[101];\\n\\n        /** where values of the boolean array \\n         * at the corresponding index are changed to true */\\n        for (int num : nums1) b1[num] = true;\\n\\n        for (int num : nums2) b2[num] = true;\\n\\n        for (int num : nums3) b3[num] = true;\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n\\n        for (int i = 1; i <= 100; i++){\\n            if((b1[i] || b2[i]) && (b2[i] || b3[i]) && (b3[i] || b1[i]))\\n                res.add(i);\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514409,
                "title": "java-1-array-bitmasks",
                "content": "This is similar to the three array approach. \\n* We keep an array `count` of 1-100.\\n* When we find number `num` in the first array, we set the bit `0` of `count[num]` using `count[num]|=1`\\n* Similarly we set the second bit for the second array and the third bit for the third.\\n\\n```\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int[] count=new int[101];\\n        List<Integer> result=new ArrayList<>();\\n        for(int num: nums1){count[num]|=1;}\\n        for(int num: nums2){count[num]|=1<<1;}\\n        for(int num: nums3){count[num]|=1<<2;}\\n        for(int i=1;i<=100;i++){if(count[i]==3 || count[i]==5 ||count[i]==6 || count[i]==7)result.add(i);}\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bitmask"
                ],
                "code": "```\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int[] count=new int[101];\\n        List<Integer> result=new ArrayList<>();\\n        for(int num: nums1){count[num]|=1;}\\n        for(int num: nums2){count[num]|=1<<1;}\\n        for(int num: nums3){count[num]|=1<<2;}\\n        for(int i=1;i<=100;i++){if(count[i]==3 || count[i]==5 ||count[i]==6 || count[i]==7)result.add(i);}\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729808,
                "title": "java-1ms-super-fast-simple-bit-masks-no-sets-no-maps-no-counts-explained",
                "content": "The code below ran as fast as 1ms, as of 1/29/2022.  Multiple submits can result in different runtimes, and the code below ran between 1ms and 4ms during multiple submits.\\n\\nThe code below scans each nums array.  Each number `n` from a nums array, is used to index into the array `bits[n]` then bitwise OR a constant bitmask value into that `bits[n]`.  The `bits[]` array is allocated with a length of 101, because the numbers in the nums arrays can have the values 1...100, and those numbers are used to index into the `bits[]` array.\\n\\nEach nums array has its own bitmask to bitwise OR into the `bits[]` array.  These binary bitmasks are:\\n ` ` ` ` ` ` `nums1` ` ` `0b110`\\n ` ` ` ` ` ` `nums2` ` ` `0b101`\\n ` ` ` ` ` ` `nums3` ` ` `0b011`\\nOR\\'ing any two of these masks together will produce a binary value of `0b111` which is decimal 7.  OR\\'ing all three of these together, still produces a value of 7.\\n\\nAfter scanning all three nums arrays and OR\\'ing in their bitmasks, then scan through the `bits[]` array.  Any `bits[i]` value which is `0b111` or decimal 7, implies that the value in `i` appears in two or more nums arrays, and therefore `i` is added to the result List.\\n \\n **If useful, please upvote.**\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int[] bits = new int[101];\\n        for (int n : nums1)  bits[n] |= 0b110;\\n        for (int n : nums2)  bits[n] |= 0b101;\\n        for (int n : nums3)  bits[n] |= 0b011;\\n        List<Integer> result = new ArrayList();\\n        for (int i = bits.length - 1; i > 0; i--)\\n            if (bits[i] == 0b111)\\n                result.add(i);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int[] bits = new int[101];\\n        for (int n : nums1)  bits[n] |= 0b110;\\n        for (int n : nums2)  bits[n] |= 0b101;\\n        for (int n : nums3)  bits[n] |= 0b011;\\n        List<Integer> result = new ArrayList();\\n        for (int i = bits.length - 1; i > 0; i--)\\n            if (bits[i] == 0b111)\\n                result.add(i);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987818,
                "title": "c-o-n-easiest-code-well-commented-out-understood-easily",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int>ans;\\n        map<int,int>mp;\\n        set<int>s1(nums1.begin(),nums1.end());  //Appending into set to eliminate duplicate values\\n        set<int>s2(nums2.begin(),nums2.end());\\n        set<int>s3(nums3.begin(),nums3.end());\\n        for(int i : s1){\\n                mp[i]++;\\n        }\\n        for(int i : s2){\\n                mp[i]++;\\n        }\\n        for(int i : s3){\\n                mp[i]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second>=2){   //if the element present more than 2 array\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it. Happy Coding!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int>ans;\\n        map<int,int>mp;\\n        set<int>s1(nums1.begin(),nums1.end());  //Appending into set to eliminate duplicate values\\n        set<int>s2(nums2.begin(),nums2.end());\\n        set<int>s3(nums3.begin(),nums3.end());\\n        for(int i : s1){\\n                mp[i]++;\\n        }\\n        for(int i : s2){\\n                mp[i]++;\\n        }\\n        for(int i : s3){\\n                mp[i]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second>=2){   //if the element present more than 2 array\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525692,
                "title": "easy-python-solution-faster-than-97-64-ms",
                "content": "# Easy Python Solution | Faster than 97% (64 ms)\\n**Runtime: 64 ms, faster than 97% of Python3 online submissions for Two Out of Three.\\nMemory Usage: 14.2 MB.**\\n\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        ret = []\\n\\n        ret += set(nums1).intersection(set(nums2))\\n        ret += set(nums1).intersection(set(nums3))\\n        ret += set(nums2).intersection(set(nums3))\\n\\n        return set(ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        ret = []\\n\\n        ret += set(nums1).intersection(set(nums2))\\n        ret += set(nums1).intersection(set(nums3))\\n        ret += set(nums2).intersection(set(nums3))\\n\\n        return set(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513907,
                "title": "java-100-faster-only-one-frequency-array-no-sorting-no-set",
                "content": "# ***simple technique use 1,2 and  -1 \\n# Pls upvote***\\n1.  Use   freuency array origin .\\n2. Mark elements from first array  with 1. \\n3.  For element e in 2nd array, if e was not seen in first array put 2 at index e in  the freuency array.  Otherwise add it to our answer list and put -1 in the frequency array at index e so that we will avoid duplicates due to any such elements in the current array or in third array. \\n4.  For element e in 3rd array, if e   was seen in first or second array  add it to our answer list and put -1 in the frequency array at index e so that we will avoid duplicates due to any such elements in the current array .  if e was not seen in previous array we dont need e. So ignore it.\\n\\n\\n# JAVA\\n```\\nclass Solution {\\n\\n  public List < Integer > twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n    List < Integer > ans = new ArrayList < > ();\\n\\n    // initialize array origin   of size 101 .\\n\\n    int[] origin = new int[101];\\n    //for each element in nums1 put 1 at the corresponding index in the above \\n    for (int e: nums1) {\\n      if (origin[e] == 0) origin[e] = 1;\\n    }\\n\\n    for (int e: nums2) {\\n\\n      if (origin[e] == 0) origin[e] = 2; //  e hasnt been seen so mark the value with 2\\n      else if (origin[e] == 1) { // e was seen in nums1 so add to the answer and to avoid duplicate in future mark corresponding index with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n    for (int e: nums3) {\\n\\n      if (origin[e] == 1 || origin[e] == 2) { // seen e in the past so add to ans and mark it with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n\\n    return ans;\\n\\n  }\\n}\\n```\\n# ----------CPP Code---------\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        \\n         vector<int> ans ;\\n\\n    // initialize array origin   of size 101 with 0.\\n\\n    int origin[101]={0};\\n    //for each element in nums1 put 1 at the corresponding index in the above \\n    for (int e: nums1) {\\n      if (origin[e] == 0) origin[e] = 1;\\n    }\\n\\n    for (int e: nums2) {\\n\\n      if (origin[e] == 0) origin[e] = 2; //  e hasnt been seen so mark the value with 2\\n      else if (origin[e] == 1) { // e was seen in nums1 so add to the answer and to avoid duplicate in future mark corresponding index with -1.\\n        ans.push_back(e);\\n        origin[e] = -1;\\n      }\\n    }\\n    for (int e: nums3) {\\n\\n      if (origin[e] == 1 || origin[e] == 2) { // seen e in the past so add to ans and mark it with -1.\\n        ans.push_back(e);\\n        origin[e] = -1;\\n      }\\n    }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\n  public List < Integer > twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n    List < Integer > ans = new ArrayList < > ();\\n\\n    // initialize array origin   of size 101 .\\n\\n    int[] origin = new int[101];\\n    //for each element in nums1 put 1 at the corresponding index in the above \\n    for (int e: nums1) {\\n      if (origin[e] == 0) origin[e] = 1;\\n    }\\n\\n    for (int e: nums2) {\\n\\n      if (origin[e] == 0) origin[e] = 2; //  e hasnt been seen so mark the value with 2\\n      else if (origin[e] == 1) { // e was seen in nums1 so add to the answer and to avoid duplicate in future mark corresponding index with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n    for (int e: nums3) {\\n\\n      if (origin[e] == 1 || origin[e] == 2) { // seen e in the past so add to ans and mark it with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n\\n    return ans;\\n\\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        \\n         vector<int> ans ;\\n\\n    // initialize array origin   of size 101 with 0.\\n\\n    int origin[101]={0};\\n    //for each element in nums1 put 1 at the corresponding index in the above \\n    for (int e: nums1) {\\n      if (origin[e] == 0) origin[e] = 1;\\n    }\\n\\n    for (int e: nums2) {\\n\\n      if (origin[e] == 0) origin[e] = 2; //  e hasnt been seen so mark the value with 2\\n      else if (origin[e] == 1) { // e was seen in nums1 so add to the answer and to avoid duplicate in future mark corresponding index with -1.\\n        ans.push_back(e);\\n        origin[e] = -1;\\n      }\\n    }\\n    for (int e: nums3) {\\n\\n      if (origin[e] == 1 || origin[e] == 2) { // seen e in the past so add to ans and mark it with -1.\\n        ans.push_back(e);\\n        origin[e] = -1;\\n      }\\n    }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582258,
                "title": "java-3-sets-o-n",
                "content": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\tSet<Integer> common = new HashSet<>();\\n\\tSet<Integer> set1 = new HashSet<>();\\n\\tSet<Integer> set2 = new HashSet<>();\\n\\n\\tfor (int num : nums1) set1.add(num);\\n\\n\\tfor (int num : nums2) {\\n\\t\\tif (set1.contains(num)) common.add(num);\\n\\t\\telse set2.add(num);\\n\\t}\\n\\n\\tfor (int num : nums3) if (set1.contains(num) || set2.contains(num)) common.add(num);\\n\\n\\treturn new ArrayList<>(common);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\tSet<Integer> common = new HashSet<>();\\n\\tSet<Integer> set1 = new HashSet<>();\\n\\tSet<Integer> set2 = new HashSet<>();\\n\\n\\tfor (int num : nums1) set1.add(num);\\n\\n\\tfor (int num : nums2) {\\n\\t\\tif (set1.contains(num)) common.add(num);\\n\\t\\telse set2.add(num);\\n\\t}\\n\\n\\tfor (int num : nums3) if (set1.contains(num) || set2.contains(num)) common.add(num);\\n\\n\\treturn new ArrayList<>(common);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524405,
                "title": "c-solution-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        bool arr1[101]={0};\\n        bool arr2[101]={0};\\n        bool arr3[101]={0};\\n        for(const auto &i:nums1) arr1[i]=true;\\n        for(const auto &i:nums2) arr2[i]=true;\\n        for(const auto &i:nums3) arr3[i]=true;\\n        vector<int> ans;\\n        for(int i=1;i<=100;++i){\\n            if((arr1[i] and arr2[i]) or (arr2[i] and arr3[i]) or (arr3[i] and arr1[i])) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        bool arr1[101]={0};\\n        bool arr2[101]={0};\\n        bool arr3[101]={0};\\n        for(const auto &i:nums1) arr1[i]=true;\\n        for(const auto &i:nums2) arr2[i]=true;\\n        for(const auto &i:nums3) arr3[i]=true;\\n        vector<int> ans;\\n        for(int i=1;i<=100;++i){\\n            if((arr1[i] and arr2[i]) or (arr2[i] and arr3[i]) or (arr3[i] and arr1[i])) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514507,
                "title": "2032-two-out-of-three",
                "content": "---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n    var twoOutOfThree = function (nums1, nums2, nums3) {\\n        let ans = new Set();\\n\\n        let set1 = new Set();\\n        for (let n of nums1) {\\n            set1.add(n);\\n        }\\n\\n        let set2 = new Set();\\n        for (let n of nums2) {\\n            set2.add(n);\\n            if (set1.has(n)) {\\n                ans.add(n);\\n            }\\n        }\\n        for (let n of nums3)\\n            if (set1.has(n) || set2.has(n)) {\\n                ans.add(n);\\n            }\\n\\n        return [...ans];\\n    };\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n    var twoOutOfThree = function (nums1, nums2, nums3) {\\n        let ans = new Set();\\n\\n        let set1 = new Set();\\n        for (let n of nums1) {\\n            set1.add(n);\\n        }\\n\\n        let set2 = new Set();\\n        for (let n of nums2) {\\n            set2.add(n);\\n            if (set1.has(n)) {\\n                ans.add(n);\\n            }\\n        }\\n        for (let n of nums3)\\n            if (set1.has(n) || set2.has(n)) {\\n                ans.add(n);\\n            }\\n\\n        return [...ans];\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1518788,
                "title": "simple-c-solution",
                "content": "* Make three sets.\\n* Insert each array in each set.\\n* Iterate from [0 -> 100] and check, if i-th element is present in atleast two. \\n* keep adding in a vector.\\n* print the vector.\\n\\n**C++ solution.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        set<int> set1, set2, set3;\\n        \\n        for(int i = 0; i < nums1.size(); ++i) set1.insert(nums1[i]);\\n        for(int i = 0; i < nums2.size(); ++i) set2.insert(nums2[i]);\\n        for(int i = 0; i < nums3.size(); ++i) set3.insert(nums3[i]);\\n\\n        vector<int> res;\\n        \\n        for(int i = 0; i <= 100; ++i) {\\n            int x = set1.count(i), y = set2.count(i), z = set3.count(i);\\n            if(x + y + z > 1)  res.push_back(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        set<int> set1, set2, set3;\\n        \\n        for(int i = 0; i < nums1.size(); ++i) set1.insert(nums1[i]);\\n        for(int i = 0; i < nums2.size(); ++i) set2.insert(nums2[i]);\\n        for(int i = 0; i < nums3.size(); ++i) set3.insert(nums3[i]);\\n\\n        vector<int> res;\\n        \\n        for(int i = 0; i <= 100; ++i) {\\n            int x = set1.count(i), y = set2.count(i), z = set3.count(i);\\n            if(x + y + z > 1)  res.push_back(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515973,
                "title": "c-super-simple-and-easy-solution-explained",
                "content": "**Idea:**\\nWe store the numbers in an unordered_map, where the key is the number and the value is a char which represents the arrays it appears in.\\nSo we mark for each array the right bit.\\nThen we check if we have at least 2 set bits.\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, char> m;\\n        \\n        for (int i = 0; i < nums1.size(); i++) \\n            m[nums1[i]] |= 1;\\n        \\n        for (int i = 0; i < nums2.size(); i++) \\n            m[nums2[i]] |= 2;\\n        \\n        for (int i = 0; i < nums3.size(); i++) \\n            m[nums3[i]] |= 4;\\n        \\n        vector<int> res;\\n        for (auto [num, count] : m) {\\n            if ((!!(count & 1) + !!(count & 2) + !!(count & 4)) >= 2) \\n                res.push_back(num);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, char> m;\\n        \\n        for (int i = 0; i < nums1.size(); i++) \\n            m[nums1[i]] |= 1;\\n        \\n        for (int i = 0; i < nums2.size(); i++) \\n            m[nums2[i]] |= 2;\\n        \\n        for (int i = 0; i < nums3.size(); i++) \\n            m[nums3[i]] |= 4;\\n        \\n        vector<int> res;\\n        for (auto [num, count] : m) {\\n            if ((!!(count & 1) + !!(count & 2) + !!(count & 4)) >= 2) \\n                res.push_back(num);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513528,
                "title": "3-python-solutions",
                "content": "* Using sets\\n```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        nums1 = set(nums1)\\n        nums2 = set(nums2)\\n        nums3 = set(nums3)\\n        ans = set()\\n        for num in nums1:\\n            if num in nums2 or num in nums3: ans.add(num)\\n\\n        for num in nums2:\\n            if num in nums1 or num in nums3: ans.add(num)\\n                \\n        for num in nums3:\\n            if num in nums1 or num in nums2: ans.add(num)\\n                \\n        return list(ans)\\n```\\nor as @user0488IR suggested, in one line:\\n```\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```\\n* Track the numbers in each list\\n```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        check = [[0]*101 for _ in range(3)]\\n        \\n        for i, nums in enumerate([nums1, nums2, nums3]):\\n            for num in nums:\\n                check[i][num] = 1\\n                \\n        for num in range(101):\\n            if sum(check[j][num] for j in range(3)) > 1: \\n                yield num\\n```\\n* Python one-liner using counter\\n```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return [num for num, freq in Counter(list(set(nums1)) + list(set(nums2)) + list(set(nums3))).items() if freq > 1]\\n```\\t\\t\\nor as @stefan4trivia suggested:\\n```\\n    return [num for num, freq in Counter([*{*nums1}, *{*nums2}, *{*nums3}]).items() if freq > 1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        nums1 = set(nums1)\\n        nums2 = set(nums2)\\n        nums3 = set(nums3)\\n        ans = set()\\n        for num in nums1:\\n            if num in nums2 or num in nums3: ans.add(num)\\n\\n        for num in nums2:\\n            if num in nums1 or num in nums3: ans.add(num)\\n                \\n        for num in nums3:\\n            if num in nums1 or num in nums2: ans.add(num)\\n                \\n        return list(ans)\\n```\n```\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```\n```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        check = [[0]*101 for _ in range(3)]\\n        \\n        for i, nums in enumerate([nums1, nums2, nums3]):\\n            for num in nums:\\n                check[i][num] = 1\\n                \\n        for num in range(101):\\n            if sum(check[j][num] for j in range(3)) > 1: \\n                yield num\\n```\n```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return [num for num, freq in Counter(list(set(nums1)) + list(set(nums2)) + list(set(nums3))).items() if freq > 1]\\n```\n```\\n    return [num for num, freq in Counter([*{*nums1}, *{*nums2}, *{*nums3}]).items() if freq > 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3399648,
                "title": "c-solution-just-a-simple-neive-map-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,pair<bool,pair<bool,bool>>> mp;\\n        for(auto i:nums1){\\n            mp[i].first=true;\\n        }\\n        for(auto i:nums2){\\n            mp[i].second.first=true;\\n        }  \\n        for(auto i:nums3){\\n            mp[i].second.second=true;\\n        }\\n\\n        vector<int> ans;\\n        for(auto i: mp){\\n            int no=0;\\n            if(i.second.first==true){\\n                no++;\\n            }\\n            if(i.second.second.first==true){\\n                no++;\\n            }\\n            if(i.second.second.second==true){\\n                no++;\\n            }\\n            if(no>1){\\n                ans.push_back(i.first);\\n            }\\n        }          \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,pair<bool,pair<bool,bool>>> mp;\\n        for(auto i:nums1){\\n            mp[i].first=true;\\n        }\\n        for(auto i:nums2){\\n            mp[i].second.first=true;\\n        }  \\n        for(auto i:nums3){\\n            mp[i].second.second=true;\\n        }\\n\\n        vector<int> ans;\\n        for(auto i: mp){\\n            int no=0;\\n            if(i.second.first==true){\\n                no++;\\n            }\\n            if(i.second.second.first==true){\\n                no++;\\n            }\\n            if(i.second.second.second==true){\\n                no++;\\n            }\\n            if(no>1){\\n                ans.push_back(i.first);\\n            }\\n        }          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780956,
                "title": "92-66-fastest-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function (nums1, nums2, nums3) {\\n    let result = []\\n    for (let i = 1; i <= 100; i++) {\\n        if (nums1.includes(i) && nums2.includes(i)) {\\n            result.push(i)\\n        }\\n        else if (nums1.includes(i) && nums3.includes(i)) {\\n            result.push(i)\\n        }\\n        else if (nums2.includes(i) && nums3.includes(i)) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function (nums1, nums2, nums3) {\\n    let result = []\\n    for (let i = 1; i <= 100; i++) {\\n        if (nums1.includes(i) && nums2.includes(i)) {\\n            result.push(i)\\n        }\\n        else if (nums1.includes(i) && nums3.includes(i)) {\\n            result.push(i)\\n        }\\n        else if (nums2.includes(i) && nums3.includes(i)) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2669585,
                "title": "c-most-optimized-only-using-single-unordered-map-sol-highly-explained-and-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,int> mp; vector<int> ans;\\n\\t\\t// Just set count of each elemt for 1st vector as 1\\n        for(auto it:nums1) mp[it]=1;\\n\\t\\t\\n\\t\\t/* \\n\\t\\t   In second vector check if each elemet has count already equal to 1 or not if yes then set it 2\\n\\t\\t   Else if does not exist in the first vector then set it to -1\\n\\t\\t   The condition (mp[it]==2) is being checked if the elemets repeat \\n\\t\\t   then mp[it] == -1 does not satisfy mp[it] == 1 \\n\\t\\t   so we also need to chech mp[it]==2\\n\\t\\t*/\\n        for(auto it:nums2) if(mp[it]==1 or mp[it]==2)mp[it]=2;else mp[it]=-1;\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\tFinally we check it the 3rd vector elemnts have any comman elements between\\n\\t\\t\\t1st vector or 2nd vector.\\n\\t\\t*/\\n        for(auto it:nums3) if(mp[it]==1 or mp[it]==-1) mp[it]=2;\\n        for(auto it:mp) if(it.second>1)ans.push_back(it.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,int> mp; vector<int> ans;\\n\\t\\t// Just set count of each elemt for 1st vector as 1\\n        for(auto it:nums1) mp[it]=1;\\n\\t\\t\\n\\t\\t/* \\n\\t\\t   In second vector check if each elemet has count already equal to 1 or not if yes then set it 2\\n\\t\\t   Else if does not exist in the first vector then set it to -1\\n\\t\\t   The condition (mp[it]==2) is being checked if the elemets repeat \\n\\t\\t   then mp[it] == -1 does not satisfy mp[it] == 1 \\n\\t\\t   so we also need to chech mp[it]==2\\n\\t\\t*/\\n        for(auto it:nums2) if(mp[it]==1 or mp[it]==2)mp[it]=2;else mp[it]=-1;\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\tFinally we check it the 3rd vector elemnts have any comman elements between\\n\\t\\t\\t1st vector or 2nd vector.\\n\\t\\t*/\\n        for(auto it:nums3) if(mp[it]==1 or mp[it]==-1) mp[it]=2;\\n        for(auto it:mp) if(it.second>1)ans.push_back(it.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645487,
                "title": "a-simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int[] shoot1 = new int[101];\\n        int[] shoot2 = new int[101];\\n        int[] shoot3 = new int[101];\\n        \\n        addValues(shoot1, nums1);\\n        addValues(shoot2, nums2);\\n        addValues(shoot3, nums3);\\n        \\n        for(int i = 0; i < 101; i++){\\n            int res = shoot1[i] + shoot2[i] + shoot3[i];\\n            if(res > 1)\\n                result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n    public static void addValues(int[] shoot, int[] nums){\\n        for(int num : nums)\\n            shoot[num] = 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int[] shoot1 = new int[101];\\n        int[] shoot2 = new int[101];\\n        int[] shoot3 = new int[101];\\n        \\n        addValues(shoot1, nums1);\\n        addValues(shoot2, nums2);\\n        addValues(shoot3, nums3);\\n        \\n        for(int i = 0; i < 101; i++){\\n            int res = shoot1[i] + shoot2[i] + shoot3[i];\\n            if(res > 1)\\n                result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n    public static void addValues(int[] shoot, int[] nums){\\n        for(int num : nums)\\n            shoot[num] = 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962602,
                "title": "javascript-solution-faster-than-100-56ms",
                "content": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let newArr = [];\\n    newArr.push(...nums1.filter(num => nums2.includes(num) || nums3.includes(num)))\\n    newArr.push(...nums2.filter(num => nums1.includes(num) || nums3.includes(num)))\\n    return Array.from(new Set(newArr))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let newArr = [];\\n    newArr.push(...nums1.filter(num => nums2.includes(num) || nums3.includes(num)))\\n    newArr.push(...nums2.filter(num => nums1.includes(num) || nums3.includes(num)))\\n    return Array.from(new Set(newArr))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1781055,
                "title": "c-solution-using-hash-table-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, set<int>> ump;\\n        for(int i = 0; i < nums1.size(); ++i)\\n            ump[nums1[i]].insert(1);\\n        for(int i = 0; i < nums2.size(); ++i)\\n            ump[nums2[i]].insert(2);\\n        for(int i = 0; i < nums3.size(); ++i)\\n            ump[nums3[i]].insert(3);\\n        vector<int> res;\\n        for(auto it = ump.begin(); it != ump.end(); ++it)\\n            if(it->second.size() >= 2)\\n                res.push_back(it->first);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, set<int>> ump;\\n        for(int i = 0; i < nums1.size(); ++i)\\n            ump[nums1[i]].insert(1);\\n        for(int i = 0; i < nums2.size(); ++i)\\n            ump[nums2[i]].insert(2);\\n        for(int i = 0; i < nums3.size(); ++i)\\n            ump[nums3[i]].insert(3);\\n        vector<int> res;\\n        for(auto it = ump.begin(); it != ump.end(); ++it)\\n            if(it->second.size() >= 2)\\n                res.push_back(it->first);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513818,
                "title": "c-map-set",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> twoOutOfThree(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3)\\n    {\\n        vector<int> v;\\n        set<int> s, s1, s2;\\n\\n        for (auto i : nums1)\\n        {\\n            s.insert(i);\\n        }\\n\\n        for (auto i : nums2)\\n        {\\n            s1.insert(i);\\n        }\\n\\n        for (auto i : nums3)\\n        {\\n            s2.insert(i);\\n        }\\n\\n        unordered_map<int, int> mp;\\n\\n        for (auto i : s)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for (auto i : s1)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for (auto i : s2)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for (auto i : mp)\\n        {\\n            if (i.second >= 2)\\n            {\\n                v.push_back(i.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> twoOutOfThree(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3)\\n    {\\n        vector<int> v;\\n        set<int> s, s1, s2;\\n\\n        for (auto i : nums1)\\n        {\\n            s.insert(i);\\n        }\\n\\n        for (auto i : nums2)\\n        {\\n            s1.insert(i);\\n        }\\n\\n        for (auto i : nums3)\\n        {\\n            s2.insert(i);\\n        }\\n\\n        unordered_map<int, int> mp;\\n\\n        for (auto i : s)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for (auto i : s1)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for (auto i : s2)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for (auto i : mp)\\n        {\\n            if (i.second >= 2)\\n            {\\n                v.push_back(i.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177395,
                "title": "c-faster-than-100-using-map-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstore the values adjacent to the nums array they occured and then remove the duplicate from the same array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore all the nums in a map and using set to remove the duplicates from them. (as set store unique value.)\\ncheck the size for every value greater than and equal to 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ for traversal of values and then $$O(n)$$ for map traversal.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ for storing the unique value of all the nums array.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, set<int>> mp;\\n        vector<int> res;\\n\\n        for(auto i: nums1)\\n            mp[i].insert(0);\\n        for(auto i: nums2)\\n            mp[i].insert(1);\\n        for(auto i: nums3)\\n            mp[i].insert(2);\\n        \\n        for(auto it: mp){\\n            if(it.second.size() >= 2)\\n                res.push_back(it.first);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, set<int>> mp;\\n        vector<int> res;\\n\\n        for(auto i: nums1)\\n            mp[i].insert(0);\\n        for(auto i: nums2)\\n            mp[i].insert(1);\\n        for(auto i: nums3)\\n            mp[i].insert(2);\\n        \\n        for(auto it: mp){\\n            if(it.second.size() >= 2)\\n                res.push_back(it.first);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850991,
                "title": "java-hashset-and-hashmap",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int n1 = nums1.length , n2 = nums2.length , n3 = nums3.length;\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0 ; i < n1 ; i++){\\n            if(set1.add(nums1[i])){\\n                map.put(nums1[i], map.getOrDefault(nums1[i],0)+1);\\n            }\\n        }\\n        for(int i = 0 ; i < n2 ; i++){\\n            if(set2.add(nums2[i])){\\n                map.put(nums2[i], map.getOrDefault(nums2[i],0)+1);\\n            }\\n        }\\n        for(int i = 0 ; i < n3 ; i++){\\n            if(set3.add(nums3[i])){\\n                map.put(nums3[i], map.getOrDefault(nums3[i],0)+1);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        ArrayList<Integer> list1 = new ArrayList<>(set1);\\n        ArrayList<Integer> list2 = new ArrayList<>(set2);\\n        ArrayList<Integer> list3 = new ArrayList<>(set3);\\n        for (int i = 0; i < list1.size(); i++) {\\n            if (map.get(list1.get(i))>1) {\\n                ans.add(list1.get(i));\\n                map.put(list1.get(i),0);\\n            }\\n        }\\n        for (int i = 0; i < list2.size(); i++) {\\n            if (map.get(list2.get(i))>1) {\\n                ans.add(list2.get(i));\\n                map.put(list2.get(i),0);\\n            }\\n        }\\n        for (int i = 0; i < list3.size(); i++) {\\n            if (map.get(list3.get(i))>1){\\n                ans.add(list3.get(i));\\n                map.put(list3.get(i),0);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int n1 = nums1.length , n2 = nums2.length , n3 = nums3.length;\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0 ; i < n1 ; i++){\\n            if(set1.add(nums1[i])){\\n                map.put(nums1[i], map.getOrDefault(nums1[i],0)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2646238,
                "title": "simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n      \\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n        \\n        for(int a : nums1) set1.add(a);\\n        for(int a : nums2) set2.add(a);\\n        for(int a : nums3) set3.add(a);\\n        \\n        for(int a : set1) \\n              if(set2.contains(a)) \\n                   ans.add(a);\\n        \\n        for(int a : set2) \\n              if(set3.contains(a)  && !set1.contains(a)) \\n                   ans.add(a);\\n        \\n        for(int a : set3) \\n              if(set1.contains(a)  && !set2.contains(a)) \\n                   ans.add(a);\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n      \\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n        \\n        for(int a : nums1) set1.add(a);\\n        for(int a : nums2) set2.add(a);\\n        for(int a : nums3) set3.add(a);\\n        \\n        for(int a : set1) \\n              if(set2.contains(a)) \\n                   ans.add(a);\\n        \\n        for(int a : set2) \\n              if(set3.contains(a)  && !set1.contains(a)) \\n                   ans.add(a);\\n        \\n        for(int a : set3) \\n              if(set1.contains(a)  && !set2.contains(a)) \\n                   ans.add(a);\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982928,
                "title": "very-easy-javascript-solution-with-using-very-less-space",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let set = new Set(nums1), res = new Set();\\n    nums1 = new Set();\\n    \\n    for(let num of nums2) {\\n        if(set.has(num)) res.add(num);\\n        nums1.add(num);\\n    }\\n    \\n    for(let num of nums3) {\\n        if(set.has(num) || nums1.has(num)) res.add(num);\\n    }\\n    \\n    return [...res];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let set = new Set(nums1), res = new Set();\\n    nums1 = new Set();\\n    \\n    for(let num of nums2) {\\n        if(set.has(num)) res.add(num);\\n        nums1.add(num);\\n    }\\n    \\n    for(let num of nums3) {\\n        if(set.has(num) || nums1.has(num)) res.add(num);\\n    }\\n    \\n    return [...res];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701141,
                "title": "swift-sets-intersections-unions",
                "content": "```\\nclass Solution {\\n    func twoOutOfThree(_ nums1: [Int], _ nums2: [Int], _ nums3: [Int]) -> [Int] {\\n        let setA = Set(nums1)\\n        let setB = Set(nums2)\\n        let setC = Set(nums3)\\n        let a = setA.intersection(setB)\\n        let b = setB.intersection(setC)\\n        let c = setA.intersection(setC)\\n        return Array(a.union(b).union(c))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    func twoOutOfThree(_ nums1: [Int], _ nums2: [Int], _ nums3: [Int]) -> [Int] {\\n        let setA = Set(nums1)\\n        let setB = Set(nums2)\\n        let setC = Set(nums3)\\n        let a = setA.intersection(setB)\\n        let b = setB.intersection(setC)\\n        let c = setA.intersection(setC)\\n        return Array(a.union(b).union(c))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668225,
                "title": "single-map-easy-solution-c",
                "content": "`This is a problem which can be use to find the common elements in \\'n\\' number of Array`.\\n\\n# Algorithm:\\n* Create a map with key as element and value as a pair of {count,last_arr} :\\n                            1. `count = Number of arrays in which it\\'s found`.\\n                            2. `last_arr = Array number in which it was found`.\\n* Moto of Using last_arr is to skip the increment in count , if it was incremented by the identical element in the same array before, then it\\'s {last_arr ==current row number}.\\n\\n`You can use pair<int,int> in place of struct, i did it for changing the name of variables for clear recognition`.\\n\\n**Time Complexity**     -    O(N1+N2+N3+number of keys in map) ` {Insertion in hasmap is O(1)}`\\n**Space  Complexity**  -  Number of unique element in all three arrays\\n\\n# C++:\\n\\n    //Derived Data-type\\n    struct pair{\\n        int count;     //total number of array in which it\\'s found...\\n        int last_arr;  //array number in which it was found last.....\\n    };\\n    vector<int> twoOutOfThree(vector<int>& n1, vector<int>& n2, vector<int>& n3){\\n        unordered_map<int,pair> mp;\\n        vector<int> ans;\\n\\t\\t\\n        //Lamda Function\\n        auto call=[&](vector<int>& inp , int arr_num , unordered_map<int,pair>& mp){\\n            for(auto i:inp)\\n                if(mp[i].last_arr != arr_num)  mp[i].count++, mp[i].last_arr =arr_num; \\n        };\\n\\t\\t\\n        call(n1,1,mp), call(n2,2,mp), call(n3,3,mp);\\n\\t\\t\\n        //put common elements   \\n        for(auto i:mp)  if(i.second.count>=2) ans.push_back(i.first);\\n        return ans;\\n    }\\n\\t\\n #Like it ? please upvote !",
                "solutionTags": [
                    "C"
                ],
                "code": "`This is a problem which can be use to find the common elements in \\'n\\' number of Array`.\\n\\n# Algorithm:\\n* Create a map with key as element and value as a pair of {count,last_arr} :\\n                            1. `count = Number of arrays in which it\\'s found`.\\n                            2. `last_arr = Array number in which it was found`.\\n* Moto of Using last_arr is to skip the increment in count , if it was incremented by the identical element in the same array before, then it\\'s {last_arr ==current row number}.\\n\\n`You can use pair<int,int> in place of struct, i did it for changing the name of variables for clear recognition`.\\n\\n**Time Complexity**     -    O(N1+N2+N3+number of keys in map) ` {Insertion in hasmap is O(1)}`\\n**Space  Complexity**  -  Number of unique element in all three arrays\\n\\n# C++:\\n\\n    //Derived Data-type\\n    struct pair{\\n        int count;     //total number of array in which it\\'s found...\\n        int last_arr;  //array number in which it was found last.....\\n    };\\n    vector<int> twoOutOfThree(vector<int>& n1, vector<int>& n2, vector<int>& n3){\\n        unordered_map<int,pair> mp;\\n        vector<int> ans;\\n\\t\\t\\n        //Lamda Function\\n        auto call=[&](vector<int>& inp , int arr_num , unordered_map<int,pair>& mp){\\n            for(auto i:inp)\\n                if(mp[i].last_arr != arr_num)  mp[i].count++, mp[i].last_arr =arr_num; \\n        };\\n\\t\\t\\n        call(n1,1,mp), call(n2,2,mp), call(n3,3,mp);\\n\\t\\t\\n        //put common elements   \\n        for(auto i:mp)  if(i.second.count>=2) ans.push_back(i.first);\\n        return ans;\\n    }\\n\\t\\n #Like it ? please upvote !",
                "codeTag": "Unknown"
            },
            {
                "id": 1647683,
                "title": "python-easy-understanding-solution-using-set-and-dict",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        d = collections.Counter(list(set(nums1))+list(set(nums2))+list(set(nums3)))\\n        l = []\\n        for i,v in d.items():\\n            if v >= 2: l.append(i)\\n        return l\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        d = collections.Counter(list(set(nums1))+list(set(nums2))+list(set(nums3)))\\n        l = []\\n        for i,v in d.items():\\n            if v >= 2: l.append(i)\\n        return l\\n",
                "codeTag": "Java"
            },
            {
                "id": 1553645,
                "title": "python3-easy-set-solution",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        set3 = set(nums3)\\n        set12 = set1.intersection(set2)\\n        set23 = set2.intersection(set3)\\n        set13 = set1.intersection(set3)\\n        \\n        return (set12.union(set23)).union(set13)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        set3 = set(nums3)\\n        set12 = set1.intersection(set2)\\n        set23 = set2.intersection(set3)\\n        set13 = set1.intersection(set3)\\n        \\n        return (set12.union(set23)).union(set13)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538774,
                "title": "kotlin",
                "content": "```\\nfun twoOutOfThree(a: IntArray, b: IntArray, c: IntArray) = (a + b + c).toSet().filter {\\n    arrayOf(a, b, c).count { ar -> ar.contains(it) } > 1\\n}\\n```\\n*Or:*\\n```\\nfun twoOutOfThree(a: IntArray, b: IntArray, c: IntArray) = (a + b + c).toSet().filter {\\n    a.contains(it) && b.contains(it) || b.contains(it) && c.contains(it) || a.contains(it) && c.contains(it)\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun twoOutOfThree(a: IntArray, b: IntArray, c: IntArray) = (a + b + c).toSet().filter {\\n    arrayOf(a, b, c).count { ar -> ar.contains(it) } > 1\\n}\\n```\n```\\nfun twoOutOfThree(a: IntArray, b: IntArray, c: IntArray) = (a + b + c).toSet().filter {\\n    a.contains(it) && b.contains(it) || b.contains(it) && c.contains(it) || a.contains(it) && c.contains(it)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514549,
                "title": "python3-one-line",
                "content": "Looking for intersections of every two lists\\n\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2) | set(nums1) & set(nums3) | set(nums2) & set(nums3))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2) | set(nums1) & set(nums3) | set(nums2) & set(nums3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513348,
                "title": "c-brute-force-solution",
                "content": "```\\n\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        unordered_map<int,int> mp3;\\n        vector<int> ans;\\n        \\n        for(int n : nums1) mp1[n]++;\\n        for(int n : nums2) mp2[n]++;\\n        for(int n : nums3) mp3[n]++;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(mp2.find(nums1[i])!=mp2.end())\\n            {\\n                mp1.erase(nums1[i]);\\n                mp2.erase(nums1[i]);   \\n                ans.push_back(nums1[i]);\\n            }\\n        }\\n        \\n        for(int i=0; i<nums3.size(); i++)\\n        {\\n            if(mp1.find(nums3[i])!=mp1.end())\\n            {\\n                ans.push_back(nums3[i]);\\n                mp1.erase(nums3[i]);\\n            }\\n            if(mp2.find(nums3[i])!=mp2.end())\\n            {\\n                ans.push_back(nums3[i]);\\n                mp2.erase(nums3[i]);\\n            }            \\n        }\\n        \\n        return ans;       \\n        \\n    }\\n",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        unordered_map<int,int> mp3;\\n        vector<int> ans;\\n        \\n        for(int n : nums1) mp1[n]++;\\n        for(int n : nums2) mp2[n]++;\\n        for(int n : nums3) mp3[n]++;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(mp2.find(nums1[i])!=mp2.end())\\n            {\\n                mp1.erase(nums1[i]);\\n                mp2.erase(nums1[i]);   \\n                ans.push_back(nums1[i]);\\n            }\\n        }\\n        \\n        for(int i=0; i<nums3.size(); i++)\\n        {\\n            if(mp1.find(nums3[i])!=mp1.end())\\n            {\\n                ans.push_back(nums3[i]);\\n                mp1.erase(nums3[i]);\\n            }\\n            if(mp2.find(nums3[i])!=mp2.end())\\n            {\\n                ans.push_back(nums3[i]);\\n                mp2.erase(nums3[i]);\\n            }            \\n        }\\n        \\n        return ans;       \\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3889687,
                "title": "using-unordered-set-c-so-many-sets",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> twoOutOfThree(vector<int> &nums1, vector<int> &nums2, vector< int > &nums3)\\n        {\\n            unordered_set<int> s1(nums1.begin(), nums1.end()), s2(nums2.begin(), nums2.end()), s3(nums3.begin(), nums3.end());\\n\\n            unordered_set<int> common;\\n            for (auto &x: nums1) common.insert(x);\\n            for (auto &x: nums2) common.insert(x);\\n            for (auto &x: nums3) common.insert(x);\\n\\n            vector<int> ans;\\n            for (auto &x: common)\\n            {\\n                if ((s1.count(x) && s2.count(x)) or(s2.count(x) && s3.count(x)) or(s3.count(x) && s1.count(x)))\\n                {\\n                    ans.push_back(x);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> twoOutOfThree(vector<int> &nums1, vector<int> &nums2, vector< int > &nums3)\\n        {\\n            unordered_set<int> s1(nums1.begin(), nums1.end()), s2(nums2.begin(), nums2.end()), s3(nums3.begin(), nums3.end());\\n\\n            unordered_set<int> common;\\n            for (auto &x: nums1) common.insert(x);\\n            for (auto &x: nums2) common.insert(x);\\n            for (auto &x: nums3) common.insert(x);\\n\\n            vector<int> ans;\\n            for (auto &x: common)\\n            {\\n                if ((s1.count(x) && s2.count(x)) or(s2.count(x) && s3.count(x)) or(s3.count(x) && s1.count(x)))\\n                {\\n                    ans.push_back(x);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173499,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        \\n    vector<int> ans;\\n    bool count[3][101] = {};\\n    for(auto n:nums1)\\n    {\\n        count[0][n]=true;\\n    }\\n    for(auto n:nums2)\\n    {\\n        count[1][n]=true;\\n    }\\n    for(auto n:nums3)\\n    {\\n        count[2][n]=true;\\n    }\\n    for (int i = 1; i <= 100; i++)\\n    {\\n        if (count[0][i] + count[1][i] + count[2][i] > 1)\\n        {\\n            ans.push_back(i);   \\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        \\n    vector<int> ans;\\n    bool count[3][101] = {};\\n    for(auto n:nums1)\\n    {\\n        count[0][n]=true;\\n    }\\n    for(auto n:nums2)\\n    {\\n        count[1][n]=true;\\n    }\\n    for(auto n:nums3)\\n    {\\n        count[2][n]=true;\\n    }\\n    for (int i = 1; i <= 100; i++)\\n    {\\n        if (count[0][i] + count[1][i] + count[2][i] > 1)\\n        {\\n            ans.push_back(i);   \\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173069,
                "title": "java-brute-force",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> s = new HashSet<>();\\n        Set<Integer> ss = new HashSet<>();\\n        Set<Integer> sss = new HashSet<>();\\n\\n        for (int i = 0; i < nums1.length || i < nums2.length || i < nums3.length; ++i) {\\n            if (i < nums1.length) s.add(nums1[i]);\\n            if (i < nums2.length) ss.add(nums2[i]);\\n            if (i < nums3.length) sss.add(nums3[i]);\\n        }\\n\\n        Set<Integer> ans = new HashSet<>();\\n\\n        for (int i: s) {\\n            if (ss.contains(i) || sss.contains(i)) ans.add(i);\\n        }\\n        for (int i: ss) {\\n            if (s.contains(i) || sss.contains(i)) ans.add(i);\\n        }\\n\\n        // upvote if helpful\\n        return new ArrayList<>(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> s = new HashSet<>();\\n        Set<Integer> ss = new HashSet<>();\\n        Set<Integer> sss = new HashSet<>();\\n\\n        for (int i = 0; i < nums1.length || i < nums2.length || i < nums3.length; ++i) {\\n            if (i < nums1.length) s.add(nums1[i]);\\n            if (i < nums2.length) ss.add(nums2[i]);\\n            if (i < nums3.length) sss.add(nums3[i]);\\n        }\\n\\n        Set<Integer> ans = new HashSet<>();\\n\\n        for (int i: s) {\\n            if (ss.contains(i) || sss.contains(i)) ans.add(i);\\n        }\\n        for (int i: ss) {\\n            if (s.contains(i) || sss.contains(i)) ans.add(i);\\n        }\\n\\n        // upvote if helpful\\n        return new ArrayList<>(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164456,
                "title": "c-line-by-line-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTaking Three Auxilary array to Compare given all three distinct arrays and finding common amongs them.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int n1=nums1.size();int n2=nums2.size();int n3=nums3.size();\\n        int A[101]={0}; int B[101]={0}; int C[101]={0};//creating 3 Auxilary arrays\\n        for(int i=0;i<n1;i++){ //copying values from given array to Auxilary arrays.\\n            A[nums1[i]]++;\\n        }\\n        for(int i=0;i<n2;i++){\\n            B[nums2[i]]++;\\n        }\\n        for(int i=0;i<n3;i++){\\n            C[nums3[i]]++;\\n        }\\n        vector<int>k;\\n        for(int i=1;i<=100;i++){\\n            if(A[i]>=1&&B[i]>=1||B[i]>=1&&C[i]>=1||C[i]>=1&&A[i]>=1)//comparing Two out of three arrays \\n            k.push_back(i);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int n1=nums1.size();int n2=nums2.size();int n3=nums3.size();\\n        int A[101]={0}; int B[101]={0}; int C[101]={0};//creating 3 Auxilary arrays\\n        for(int i=0;i<n1;i++){ //copying values from given array to Auxilary arrays.\\n            A[nums1[i]]++;\\n        }\\n        for(int i=0;i<n2;i++){\\n            B[nums2[i]]++;\\n        }\\n        for(int i=0;i<n3;i++){\\n            C[nums3[i]]++;\\n        }\\n        vector<int>k;\\n        for(int i=1;i<=100;i++){\\n            if(A[i]>=1&&B[i]>=1||B[i]>=1&&C[i]>=1||C[i]>=1&&A[i]>=1)//comparing Two out of three arrays \\n            k.push_back(i);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096527,
                "title": "easy-java-solution-hashing-based-solution-beats-87-runtime-3ms",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashSet<Integer> ans = new HashSet<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        \\n\\n        for(int i=0;i<nums1.length;i++){\\n            set.add(nums1[i]);\\n        }\\n\\n        for(int i=0;i<nums2.length;i++){\\n            if(set.contains(nums2[i])){\\n                ans.add(nums2[i]);\\n            }else{\\n                set1.add(nums2[i]);\\n            }\\n        }\\n\\n        for(int i=0;i<nums3.length;i++){\\n            if(set.contains(nums3[i])||set1.contains(nums3[i])){\\n                ans.add(nums3[i]);\\n            }\\n        }\\n\\n        return new ArrayList(ans);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashSet<Integer> ans = new HashSet<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        \\n\\n        for(int i=0;i<nums1.length;i++){\\n            set.add(nums1[i]);\\n        }\\n\\n        for(int i=0;i<nums2.length;i++){\\n            if(set.contains(nums2[i])){\\n                ans.add(nums2[i]);\\n            }else{\\n                set1.add(nums2[i]);\\n            }\\n        }\\n\\n        for(int i=0;i<nums3.length;i++){\\n            if(set.contains(nums3[i])||set1.contains(nums3[i])){\\n                ans.add(nums3[i]);\\n            }\\n        }\\n\\n        return new ArrayList(ans);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953169,
                "title": "using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n            vector <int>v1(101),v2(101),v3(101);\\n            vector<int>ans;\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                v1[nums1[i]]=1;\\n            }\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                v2[nums2[i]]=1;\\n            }\\n            for(int i=0;i<nums3.size();i++)\\n            {\\n                v3[nums3[i]]=1;\\n            }\\n            for(int i=1;i<=100;i++)\\n            {\\n                if(v1[i]+v2[i]+v3[i]>=2)\\n                {\\n                    ans.push_back(i);\\n                }\\n            }\\n            return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n            vector <int>v1(101),v2(101),v3(101);\\n            vector<int>ans;\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                v1[nums1[i]]=1;\\n            }\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                v2[nums2[i]]=1;\\n            }\\n            for(int i=0;i<nums3.size();i++)\\n            {\\n                v3[nums3[i]]=1;\\n            }\\n            for(int i=1;i<=100;i++)\\n            {\\n                if(v1[i]+v2[i]+v3[i]>=2)\\n                {\\n                    ans.push_back(i);\\n                }\\n            }\\n            return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903580,
                "title": "js-very-easy-solution-and-fast-with-o-nums1-length-nums2-length-nums3-length",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const output = [];\\n    const setmap1 = new Set([...nums1]);\\n    const setmap2 = new Set();\\n    const setmap3 = new Set();\\n\\n    for (let i = 0; i < nums2.length; i++) {\\n        const num = nums2[i];\\n        if (setmap1.has(num) && !setmap2.has(num)) {\\n            output.push(num);\\n        }\\n        setmap2.add(num);\\n    }\\n\\n    for (let i = 0; i < nums3.length; i++) {\\n        const num = nums3[i];\\n        if (setmap1.has(num) && !setmap2.has(num) && !setmap3.has(num)) {\\n            output.push(num);\\n        }\\n        if (setmap2.has(num) && !setmap1.has(num) && !setmap3.has(num)) {\\n            output.push(num);\\n        }\\n        setmap3.add(num);\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const output = [];\\n    const setmap1 = new Set([...nums1]);\\n    const setmap2 = new Set();\\n    const setmap3 = new Set();\\n\\n    for (let i = 0; i < nums2.length; i++) {\\n        const num = nums2[i];\\n        if (setmap1.has(num) && !setmap2.has(num)) {\\n            output.push(num);\\n        }\\n        setmap2.add(num);\\n    }\\n\\n    for (let i = 0; i < nums3.length; i++) {\\n        const num = nums3[i];\\n        if (setmap1.has(num) && !setmap2.has(num) && !setmap3.has(num)) {\\n            output.push(num);\\n        }\\n        if (setmap2.has(num) && !setmap1.has(num) && !setmap3.has(num)) {\\n            output.push(num);\\n        }\\n        setmap3.add(num);\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832663,
                "title": "java-two-out-of-three",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> l=new ArrayList<>();\\n        Set<Integer> l1=new HashSet<>();\\n        Set<Integer> l2=new HashSet<>();\\n        \\n        for(int i:nums1)\\n            l1.add(i);\\n        \\n        \\n        for(int i:nums2)\\n        {\\n            if(l1.contains(i)&&!l.contains(i))l.add(i);\\n            l2.add(i);\\n        }\\n        \\n        for(int i:nums3)\\n        {\\n            if((l1.contains(i)||l2.contains(i))&&!l.contains(i))l.add(i);\\n        }\\n        return l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> l=new ArrayList<>();\\n        Set<Integer> l1=new HashSet<>();\\n        Set<Integer> l2=new HashSet<>();\\n        \\n        for(int i:nums1)\\n            l1.add(i);\\n        \\n        \\n        for(int i:nums2)\\n        {\\n            if(l1.contains(i)&&!l.contains(i))l.add(i);\\n            l2.add(i);\\n        }\\n        \\n        for(int i:nums3)\\n        {\\n            if((l1.contains(i)||l2.contains(i))&&!l.contains(i))l.add(i);\\n        }\\n        return l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769622,
                "title": "java-clear-easy-to-understand-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n     Set<Integer> set = new HashSet<>(), set1 = new HashSet<>(), set2 = new HashSet<>(), set3 = new HashSet<>();\\n     for(int i : nums1) {\\n         set.add(i); set1.add(i);\\n     } \\n     for(int i : nums2) {\\n         set.add(i); set2.add(i);\\n     } \\n     for(int i : nums3) {\\n         set.add(i); set3.add(i); \\n     } \\n     List<Integer> ans = new ArrayList<>();\\n     for(int i : set) {\\n         if(set1.contains(i) && set2.contains(i) || set2.contains(i) && set3.contains(i) || set1.contains(i) && set3.contains(i))  ans.add(i);\\n     }\\n     return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n     Set<Integer> set = new HashSet<>(), set1 = new HashSet<>(), set2 = new HashSet<>(), set3 = new HashSet<>();\\n     for(int i : nums1) {\\n         set.add(i); set1.add(i);\\n     } \\n     for(int i : nums2) {\\n         set.add(i); set2.add(i);\\n     } \\n     for(int i : nums3) {\\n         set.add(i); set3.add(i); \\n     } \\n     List<Integer> ans = new ArrayList<>();\\n     for(int i : set) {\\n         if(set1.contains(i) && set2.contains(i) || set2.contains(i) && set3.contains(i) || set1.contains(i) && set3.contains(i))  ans.add(i);\\n     }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623873,
                "title": "java-best-solution-time-o-n-m-k-set",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num : nums1)\\n            set.add(num);\\n        \\n        List<Integer> result = new ArrayList<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for(int num : nums2){\\n            if(set.contains(num) && !set2.contains(num))\\n                result.add(num);\\n         \\n            set2.add(num);\\n        }\\n        \\n        for(int num : nums3)\\n            if(!result.contains(num) && (set.contains(num) || set2.contains(num)))\\n                result.add(num);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num : nums1)\\n            set.add(num);\\n        \\n        List<Integer> result = new ArrayList<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for(int num : nums2){\\n            if(set.contains(num) && !set2.contains(num))\\n                result.add(num);\\n         \\n            set2.add(num);\\n        }\\n        \\n        for(int num : nums3)\\n            if(!result.contains(num) && (set.contains(num) || set2.contains(num)))\\n                result.add(num);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546115,
                "title": "python-brute-force-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        \\n        final=[]\\n        for i in nums1:\\n            if i in nums2 or i in nums3:\\n                final.append(i)\\n        for j in nums2:\\n            if j in nums3:\\n                final.append(j)\\n                \\n        return (set(final))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        \\n        final=[]\\n        for i in nums1:\\n            if i in nums2 or i in nums3:\\n                final.append(i)\\n        for j in nums2:\\n            if j in nums3:\\n                final.append(j)\\n                \\n        return (set(final))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535893,
                "title": "java-2ms-faster-easy-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] flag1 = new boolean[101];\\n        boolean[] flag2 = new boolean[101];\\n        boolean[] flag3 = new boolean[101];\\n        \\n        for(int num: nums1){\\n            flag1[num] = true;\\n        }\\n        for(int num: nums2){\\n            flag2[num] = true;\\n        }\\n        for(int num: nums3){\\n            flag3[num] = true;\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=1; i<=100; i++){\\n            if((flag1[i] || flag2[i]) && (flag2[i] || flag3[i]) && (flag3[i] || flag1[i])){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] flag1 = new boolean[101];\\n        boolean[] flag2 = new boolean[101];\\n        boolean[] flag3 = new boolean[101];\\n        \\n        for(int num: nums1){\\n            flag1[num] = true;\\n        }\\n        for(int num: nums2){\\n            flag2[num] = true;\\n        }\\n        for(int num: nums3){\\n            flag3[num] = true;\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=1; i<=100; i++){\\n            if((flag1[i] || flag2[i]) && (flag2[i] || flag3[i]) && (flag3[i] || flag1[i])){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508937,
                "title": "java-stream-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<int[]> ints = Arrays.asList(nums1, nums2, nums3);\\n        return ints.stream()\\n                .flatMapToInt(item -> Arrays.stream(item).distinct())\\n                .boxed()\\n                .collect(Collectors.toMap(item -> item, value -> 1, Integer::sum))\\n                .entrySet()\\n                .stream()\\n                .filter(item -> item.getValue() >= 2)\\n                .map(Map.Entry::getKey)\\n                .collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<int[]> ints = Arrays.asList(nums1, nums2, nums3);\\n        return ints.stream()\\n                .flatMapToInt(item -> Arrays.stream(item).distinct())\\n                .boxed()\\n                .collect(Collectors.toMap(item -> item, value -> 1, Integer::sum))\\n                .entrySet()\\n                .stream()\\n                .filter(item -> item.getValue() >= 2)\\n                .map(Map.Entry::getKey)\\n                .collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459124,
                "title": "simple-with-go",
                "content": "```\\nfunc twoOutOfThree(nums1 []int, nums2 []int, nums3 []int) []int {\\n    one, two, three := make([]int, 101), make([]int, 101), make([]int, 101)\\n    \\n    for _, num := range nums1 {\\n        one[num]++\\n    }\\n    \\n    for _, num := range nums2 {\\n        two[num]++\\n    }\\n    \\n    for _, num := range nums3 {\\n        three[num]++\\n    }\\n    \\n    var res []int\\n    \\n    for i := 1; i < 101; i++ {\\n        if one[i] > 0 && two[i] > 0 {\\n            res = append(res, i)\\n        } else if two[i] > 0 && three[i] > 0 {\\n            res = append(res, i)\\n        } else if three[i] > 0 && one[i] > 0 {\\n            res = append(res, i)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc twoOutOfThree(nums1 []int, nums2 []int, nums3 []int) []int {\\n    one, two, three := make([]int, 101), make([]int, 101), make([]int, 101)\\n    \\n    for _, num := range nums1 {\\n        one[num]++\\n    }\\n    \\n    for _, num := range nums2 {\\n        two[num]++\\n    }\\n    \\n    for _, num := range nums3 {\\n        three[num]++\\n    }\\n    \\n    var res []int\\n    \\n    for i := 1; i < 101; i++ {\\n        if one[i] > 0 && two[i] > 0 {\\n            res = append(res, i)\\n        } else if two[i] > 0 && three[i] > 0 {\\n            res = append(res, i)\\n        } else if three[i] > 0 && one[i] > 0 {\\n            res = append(res, i)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276863,
                "title": "solution-with-c",
                "content": "```\\nint* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize){\\n    int *arr;\\n    int count[101] = {0};\\n    int distinct[101] = {0};\\n    int i = 0,j,k;\\n    \\n    arr = (int *)malloc(sizeof(int) * 101);\\n    \\n    j = 0;\\n    while(j < nums1Size)\\n    {\\n        if(count[nums1[j]] != 1)\\n            count[nums1[j]]++;\\n        j++;\\n    }\\n    \\n    j = 0;\\n    while(j < nums2Size)\\n    {\\n        if(count[nums2[j]] == 0)\\n        {\\n            count[nums2[j]]++;\\n            distinct[nums2[j]] = 1;\\n        }\\n        else if(count[nums2[j]] == 1 && distinct[nums2[j]] == 0)\\n            count[nums2[j]]++;\\n        j++;\\n    }\\n    \\n    memset(distinct, 0, 101 * sizeof(int));   //initalize with 0 again\\n    j = 0;\\n    while(j < nums3Size)\\n    {\\n        if(count[nums3[j]] == 0)\\n        {\\n            count[nums3[j]]++;\\n            distinct[nums3[j]] = 1;\\n        }\\n        else if(count[nums3[j]] == 1 && distinct[nums3[j]] == 0)\\n        {\\n            count[nums3[j]]++;\\n            distinct[nums3[j]] = 1;\\n        }\\n        else if(count[nums3[j]] == 2 && distinct[nums3[j]] == 0)\\n            count[nums3[j]]++;\\n        j++;\\n    }\\n    \\n    j = 0;\\n    k = 0;\\n    while(j < 101)\\n    {\\n        if(count[j] >= 2)\\n            arr[k++] = j;\\n        j++;\\n    }\\n    *returnSize = k;\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize){\\n    int *arr;\\n    int count[101] = {0};\\n    int distinct[101] = {0};\\n    int i = 0,j,k;\\n    \\n    arr = (int *)malloc(sizeof(int) * 101);\\n    \\n    j = 0;\\n    while(j < nums1Size)\\n    {\\n        if(count[nums1[j]] != 1)\\n            count[nums1[j]]++;\\n        j++;\\n    }\\n    \\n    j = 0;\\n    while(j < nums2Size)\\n    {\\n        if(count[nums2[j]] == 0)\\n        {\\n            count[nums2[j]]++;\\n            distinct[nums2[j]] = 1;\\n        }\\n        else if(count[nums2[j]] == 1 && distinct[nums2[j]] == 0)\\n            count[nums2[j]]++;\\n        j++;\\n    }\\n    \\n    memset(distinct, 0, 101 * sizeof(int));   //initalize with 0 again\\n    j = 0;\\n    while(j < nums3Size)\\n    {\\n        if(count[nums3[j]] == 0)\\n        {\\n            count[nums3[j]]++;\\n            distinct[nums3[j]] = 1;\\n        }\\n        else if(count[nums3[j]] == 1 && distinct[nums3[j]] == 0)\\n        {\\n            count[nums3[j]]++;\\n            distinct[nums3[j]] = 1;\\n        }\\n        else if(count[nums3[j]] == 2 && distinct[nums3[j]] == 0)\\n            count[nums3[j]]++;\\n        j++;\\n    }\\n    \\n    j = 0;\\n    k = 0;\\n    while(j < 101)\\n    {\\n        if(count[j] >= 2)\\n            arr[k++] = j;\\n        j++;\\n    }\\n    *returnSize = k;\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258661,
                "title": "java-easy-solution-frequency-array-faster-than-97-46",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] flag1 = new boolean[101];\\n        boolean[] flag2 = new boolean[101];\\n        boolean[] flag3 = new boolean[101];\\n        \\n        for(int num: nums1){\\n            flag1[num] = true;\\n        }\\n        for(int num: nums2){\\n            flag2[num] = true;\\n        }\\n        for(int num: nums3){\\n            flag3[num] = true;\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=1; i<=100; i++){\\n            if((flag1[i] || flag2[i]) && (flag2[i] || flag3[i]) && (flag3[i] || flag1[i])){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] flag1 = new boolean[101];\\n        boolean[] flag2 = new boolean[101];\\n        boolean[] flag3 = new boolean[101];\\n        \\n        for(int num: nums1){\\n            flag1[num] = true;\\n        }\\n        for(int num: nums2){\\n            flag2[num] = true;\\n        }\\n        for(int num: nums3){\\n            flag3[num] = true;\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=1; i<=100; i++){\\n            if((flag1[i] || flag2[i]) && (flag2[i] || flag3[i]) && (flag3[i] || flag1[i])){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165717,
                "title": "javascript-three-arrays",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let dp1 = new Array(101).fill(0)\\n    let dp2 = new Array(101).fill(0)\\n    let dp3 = new Array(101).fill(0)\\n    \\n    for (let num of nums1) {\\n        dp1[num] = 1\\n    }\\n    \\n    for (let num of nums2) {\\n        dp2[num] = 1\\n    }\\n    \\n    for (let num of nums3) {\\n        dp3[num] = 1\\n    }\\n    \\n    let res = [];\\n    for (let i = 0; i < 101; i++) {\\n        if (dp1[i] + dp2[i] + dp3[i] >=2) res.push(i)\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let dp1 = new Array(101).fill(0)\\n    let dp2 = new Array(101).fill(0)\\n    let dp3 = new Array(101).fill(0)\\n    \\n    for (let num of nums1) {\\n        dp1[num] = 1\\n    }\\n    \\n    for (let num of nums2) {\\n        dp2[num] = 1\\n    }\\n    \\n    for (let num of nums3) {\\n        dp3[num] = 1\\n    }\\n    \\n    let res = [];\\n    for (let i = 0; i < 101; i++) {\\n        if (dp1[i] + dp2[i] + dp3[i] >=2) res.push(i)\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2163679,
                "title": "c-best-solution",
                "content": "\\t**********please upvote if you like*****\\n\\t`class Solution {\\n\\tpublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int n3=nums3.size();\\n        unordered_map<int,int>m1,m2,m3;\\n        vector<int>ans;\\n        for(auto x:nums1){\\n            m1[x]++;\\n        }\\n          for(auto x:nums2){\\n            m2[x]++;\\n        }\\n          for(auto x:nums3){\\n            m3[x]++;\\n        }\\n        for(auto x:m1){\\n            if(m2.find(x.first)!=m2.end()||m3.find(x.first)!=m3.end()){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        for(auto x:m2){\\n            if(m1.find(x.first)!=m1.end()||m3.find(x.first)!=m3.end()){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        unordered_set<int>s;\\n        for(auto x:ans){\\n            s.insert(x);\\n        }\\n        ans.clear();\\n        for(auto x:s){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n        \\n        \\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int n3=nums3.size();\\n        unordered_map<int,int>m1,m2,m3;\\n        vector<int>ans;\\n        for(auto x:nums1){\\n            m1[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2138556,
                "title": "python-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        countMap = {}\\n        \\n        for i in set(nums1):\\n            countMap[i] = 1 + countMap.get(i, 0)\\n        \\n        for i in set(nums2):\\n            countMap[i] = 1 + countMap.get(i, 0)\\n        \\n        for i in set(nums3):\\n            countMap[i] = 1 + countMap.get(i, 0)\\n            \\n        res = []\\n        \\n        for i in countMap:\\n            if countMap[i] >= 2:\\n                res.append(i)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        countMap = {}\\n        \\n        for i in set(nums1):\\n            countMap[i] = 1 + countMap.get(i, 0)\\n        \\n        for i in set(nums2):\\n            countMap[i] = 1 + countMap.get(i, 0)\\n        \\n        for i in set(nums3):\\n            countMap[i] = 1 + countMap.get(i, 0)\\n            \\n        res = []\\n        \\n        for i in countMap:\\n            if countMap[i] >= 2:\\n                res.append(i)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837934,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) Space O(n)\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const array = [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)]\\n    const map = {}\\n    const result = []\\n    \\n    for(const number of array) {\\n        if(map[number]) {\\n            map[number] += 1\\n        } else {\\n            map[number] = 1\\n        }\\n    }\\n    \\n    for(const key in map) {\\n        if(map[key] >= 2) {\\n            result.push(key)\\n        }\\n    }\\n    \\n  return result  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) Space O(n)\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const array = [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)]\\n    const map = {}\\n    const result = []\\n    \\n    for(const number of array) {\\n        if(map[number]) {\\n            map[number] += 1\\n        } else {\\n            map[number] = 1\\n        }\\n    }\\n    \\n    for(const key in map) {\\n        if(map[key] >= 2) {\\n            result.push(key)\\n        }\\n    }\\n    \\n  return result  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829146,
                "title": "c-obvious-implementation",
                "content": "```\\n vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int> ans;\\n        set<int> answers;\\n        unordered_map<int,int> first,second,third;\\n        for(int &i:nums1)\\n            first[i]++;\\n        for(int &i:nums2)\\n            second[i]++;\\n        for(int &i:nums3)\\n            third[i]++;       \\n        for(int &i:nums1)\\n            if(second[i]>0 || third[i]>0)\\n           answers.insert(i);\\n        for(int &i:nums2)\\n            if(first[i]>0|| third[i]>0)\\n                answers.insert(i);\\n        for(int &i:nums3)\\n            if(first[i]>0 || second[i]>0)\\n                answers.insert(i);\\n        for(auto it=answers.begin();it!=answers.end();it++)\\n            ans.push_back(*it);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int> ans;\\n        set<int> answers;\\n        unordered_map<int,int> first,second,third;\\n        for(int &i:nums1)\\n            first[i]++;\\n        for(int &i:nums2)\\n            second[i]++;\\n        for(int &i:nums3)\\n            third[i]++;       \\n        for(int &i:nums1)\\n            if(second[i]>0 || third[i]>0)\\n           answers.insert(i);\\n        for(int &i:nums2)\\n            if(first[i]>0|| third[i]>0)\\n                answers.insert(i);\\n        for(int &i:nums3)\\n            if(first[i]>0 || second[i]>0)\\n                answers.insert(i);\\n        for(auto it=answers.begin();it!=answers.end();it++)\\n            ans.push_back(*it);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1744857,
                "title": "c-simple-solution-count-unique-frequencies-bucket",
                "content": "`n` : size of input array, `m` : range of value in each array.\\n* time: `O(n+m)`\\n* space: `O(m)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int> res, cnt1(101, 0), cnt2(101, 0), cnt3(101, 0);\\n        for (auto &num: nums1) {\\n            cnt1[num] = 1;\\n        }\\n        for (auto &num: nums2) {\\n            cnt2[num] = 1;\\n        }\\n        for (auto &num: nums3) {\\n            cnt3[num] = 1;\\n        }\\n        for (int i = 1; i <= 100; ++i) {\\n            if (cnt1[i]+cnt2[i]+cnt3[i] > 1) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int> res, cnt1(101, 0), cnt2(101, 0), cnt3(101, 0);\\n        for (auto &num: nums1) {\\n            cnt1[num] = 1;\\n        }\\n        for (auto &num: nums2) {\\n            cnt2[num] = 1;\\n        }\\n        for (auto &num: nums3) {\\n            cnt3[num] = 1;\\n        }\\n        for (int i = 1; i <= 100; ++i) {\\n            if (cnt1[i]+cnt2[i]+cnt3[i] > 1) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723326,
                "title": "python-3-use-addition-of-counter-s-of-sets",
                "content": "Title says all.\\n```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        set1,set2,set3 = set(nums1),set(nums2),set(nums3)\\n        cntr = Counter(set1) + Counter(set2) + Counter(set3)\\n        return [ k for k in cntr if cntr[k]>1 ]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        set1,set2,set3 = set(nums1),set(nums2),set(nums3)\\n        cntr = Counter(set1) + Counter(set2) + Counter(set3)\\n        return [ k for k in cntr if cntr[k]>1 ]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1705285,
                "title": "java-solution-using-three-hashmap",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        HashSet<Integer> set3=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            set2.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums3.length;i++)\\n        {\\n            set3.add(nums3[i]);\\n        }\\n        HashSet<Integer> set=new HashSet();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(set2.contains(nums1[i]) || set3.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(set1.contains(nums2[i]) || set3.contains(nums2[i]))\\n                set.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums3.length;i++)\\n        {\\n            if(set2.contains(nums3[i]) || set1.contains(nums3[i]))\\n                set.add(nums3[i]);\\n        }\\n        List<Integer> list=new ArrayList<Integer>(set);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        HashSet<Integer> set3=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            set2.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums3.length;i++)\\n        {\\n            set3.add(nums3[i]);\\n        }\\n        HashSet<Integer> set=new HashSet();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(set2.contains(nums1[i]) || set3.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(set1.contains(nums2[i]) || set3.contains(nums2[i]))\\n                set.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums3.length;i++)\\n        {\\n            if(set2.contains(nums3[i]) || set1.contains(nums3[i]))\\n                set.add(nums3[i]);\\n        }\\n        List<Integer> list=new ArrayList<Integer>(set);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594167,
                "title": "python3-1-line",
                "content": "* & = intersection of sets,   | = concatenation of sets\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return set(nums1)&set(nums2)|set(nums1)&set(nums3)|set(nums2)&set(nums3)\\n```\\n* Readable version:\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        s1,s2,s3=set(nums1),set(nums2),set(nums3)\\n        return s1&s2 | s1&s3 | s2&s3\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return set(nums1)&set(nums2)|set(nums1)&set(nums3)|set(nums2)&set(nums3)\\n```\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        s1,s2,s3=set(nums1),set(nums2),set(nums3)\\n        return s1&s2 | s1&s3 | s2&s3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567717,
                "title": "java-solution-with-explaination-96-82-faster-and-89-35-less-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> res = new ArrayList<>(nums1.length);\\n\\t\\t\\n\\t\\t// Initializing three boolean arrays for checking.\\n\\t\\t// Length is 101 according to the test case.\\n        boolean[] num1check = new boolean[101];\\n        boolean[] num2check = new boolean[101];\\n        boolean[] num3check = new boolean[101];\\n        \\n\\t\\t// Using all the elements in first array as indexes of first checker array.\\n\\t\\t// Setting checker[index] = true.\\n        for (int i : nums1)\\n            num1check[i] = true;\\n        \\n\\t\\t// Same as previous for second array.\\n        for (int i : nums2)\\n            num2check[i] = true;\\n                \\n\\t\\t// Same as previous for third array.\\n        for (int i : nums3)\\n            num3check[i] = true;\\n        \\n\\t\\t// Iterating through the loop 101 times.\\n        for (int i = 0; i < 101; i++) {\\n\\t\\t\\t// Condition checks if \\'i\\' exists in atleast two of the input arrays.\\n\\t\\t\\t// If true, \\'i\\' is added in the resultant array.\\n            if ((num1check[i] && num2check[i]) || \\n                (num2check[i] && num3check[i]) ||\\n                (num1check[i] && num3check[i])) {\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> res = new ArrayList<>(nums1.length);\\n\\t\\t\\n\\t\\t// Initializing three boolean arrays for checking.\\n\\t\\t// Length is 101 according to the test case.\\n        boolean[] num1check = new boolean[101];\\n        boolean[] num2check = new boolean[101];\\n        boolean[] num3check = new boolean[101];\\n        \\n\\t\\t// Using all the elements in first array as indexes of first checker array.\\n\\t\\t// Setting checker[index] = true.\\n        for (int i : nums1)\\n            num1check[i] = true;\\n        \\n\\t\\t// Same as previous for second array.\\n        for (int i : nums2)\\n            num2check[i] = true;\\n                \\n\\t\\t// Same as previous for third array.\\n        for (int i : nums3)\\n            num3check[i] = true;\\n        \\n\\t\\t// Iterating through the loop 101 times.\\n        for (int i = 0; i < 101; i++) {\\n\\t\\t\\t// Condition checks if \\'i\\' exists in atleast two of the input arrays.\\n\\t\\t\\t// If true, \\'i\\' is added in the resultant array.\\n            if ((num1check[i] && num2check[i]) || \\n                (num2check[i] && num3check[i]) ||\\n                (num1check[i] && num3check[i])) {\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539339,
                "title": "rust-counter-approach",
                "content": "```\\nimpl Solution {\\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\\n        let mut counts1: [i32;101] = [0;101];\\n        let mut counts2: [i32;101] = [0;101];\\n        let mut counts3: [i32;101] = [0;101];\\n\\n        for n in nums1 {\\n            counts1[n as usize] = 1;\\n        }\\n\\n        for n in nums2 {\\n            counts2[n as usize] = 1;\\n        }\\n\\n        for n in nums3 {\\n            counts3[n as usize] = 1;\\n        }\\n\\n        let mut res: Vec<i32> = Vec::new();\\n\\n        for v in 1..101 {\\n            if counts1[v] + counts2[v] + counts3[v] >= 2 {\\n                res.push(v as i32);\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\\n        let mut counts1: [i32;101] = [0;101];\\n        let mut counts2: [i32;101] = [0;101];\\n        let mut counts3: [i32;101] = [0;101];\\n\\n        for n in nums1 {\\n            counts1[n as usize] = 1;\\n        }\\n\\n        for n in nums2 {\\n            counts2[n as usize] = 1;\\n        }\\n\\n        for n in nums3 {\\n            counts3[n as usize] = 1;\\n        }\\n\\n        let mut res: Vec<i32> = Vec::new();\\n\\n        for v in 1..101 {\\n            if counts1[v] + counts2[v] + counts3[v] >= 2 {\\n                res.push(v as i32);\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529510,
                "title": "c-bit-ops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, int> mp;\\n        constexpr int mask1 = 1 << 0;\\n        constexpr int mask2 = 1 << 1;\\n        constexpr int mask3 = 1 << 2;\\n        for(int i : nums1) {\\n            mp[i] |= mask1;\\n        }\\n        for(int i : nums2) {\\n            mp[i] |= mask2;\\n        }\\n        for(int i : nums3) {\\n            mp[i] |= mask3;\\n        }\\n        vector<int> ret;\\n        for(const auto &p : mp) {\\n            if(p.second != mask1 && p.second != mask2 && p.second != mask3) {\\n                ret.push_back(p.first);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, int> mp;\\n        constexpr int mask1 = 1 << 0;\\n        constexpr int mask2 = 1 << 1;\\n        constexpr int mask3 = 1 << 2;\\n        for(int i : nums1) {\\n            mp[i] |= mask1;\\n        }\\n        for(int i : nums2) {\\n            mp[i] |= mask2;\\n        }\\n        for(int i : nums3) {\\n            mp[i] |= mask3;\\n        }\\n        vector<int> ret;\\n        for(const auto &p : mp) {\\n            if(p.second != mask1 && p.second != mask2 && p.second != mask3) {\\n                ret.push_back(p.first);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522179,
                "title": "c",
                "content": "```\\npublic IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\tvar list = new List<int>();\\n\\tlist.AddRange(nums1.Distinct());\\n\\tlist.AddRange(nums2.Distinct());\\n\\tlist.AddRange(nums3.Distinct());\\n\\treturn list.GroupBy(x => x).Where(x => x.Count() > 1).Select(x => x.Key).ToList();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\tvar list = new List<int>();\\n\\tlist.AddRange(nums1.Distinct());\\n\\tlist.AddRange(nums2.Distinct());\\n\\tlist.AddRange(nums3.Distinct());\\n\\treturn list.GroupBy(x => x).Where(x => x.Count() > 1).Select(x => x.Key).ToList();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519325,
                "title": "simple-c-solution-with-std-set",
                "content": "24ms, 26.9MB\\n\\n```cpp\\n#include <set>\\n\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        set<int> mem;\\n        set<int> res;\\n        \\n        for (int i : nums1) {\\n            mem.insert(i);\\n        }\\n        \\n        for (int i : nums2) {\\n            if (mem.find(i) != mem.end()) {\\n                res.insert(i);\\n            }\\n        }\\n        \\n        for (int i : nums2) {\\n            mem.insert(i);\\n        }\\n        \\n        for (int i : nums3) {\\n            if (mem.find(i) != mem.end()) {\\n                res.insert(i);\\n            }\\n        }\\n        \\n        return vector<int>(res.begin(), res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\n#include <set>\\n\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        set<int> mem;\\n        set<int> res;\\n        \\n        for (int i : nums1) {\\n            mem.insert(i);\\n        }\\n        \\n        for (int i : nums2) {\\n            if (mem.find(i) != mem.end()) {\\n                res.insert(i);\\n            }\\n        }\\n        \\n        for (int i : nums2) {\\n            mem.insert(i);\\n        }\\n        \\n        for (int i : nums3) {\\n            if (mem.find(i) != mem.end()) {\\n                res.insert(i);\\n            }\\n        }\\n        \\n        return vector<int>(res.begin(), res.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1514967,
                "title": "c-2032-two-out-of-three",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, int> freq; \\n        for (auto& nums : {nums1, nums2, nums3}) {\\n            unordered_set<int> st(nums.begin(), nums.end()); \\n            for (auto& x : st) ++freq[x]; \\n        }\\n        vector<int> ans; \\n        for (auto& [k, v] : freq)\\n            if (v >= 2) ans.push_back(k); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, int> freq; \\n        for (auto& nums : {nums1, nums2, nums3}) {\\n            unordered_set<int> st(nums.begin(), nums.end()); \\n            for (auto& x : st) ++freq[x]; \\n        }\\n        vector<int> ans; \\n        for (auto& [k, v] : freq)\\n            if (v >= 2) ans.push_back(k); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514434,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\\n        let mut counter = [0_i32; 101];\\n        nums1.iter().for_each(|&x| counter[x as usize] |= 0b001);\\n        nums2.iter().for_each(|&x| counter[x as usize] |= 0b010);\\n        nums3.iter().for_each(|&x| counter[x as usize] |= 0b100);\\n        counter\\n            .iter()\\n            .cloned()\\n            .enumerate()\\n            .filter_map(|(ind, x)| match x.count_ones() >= 2 {\\n                true => Some(ind as i32),\\n                false => None,\\n            })\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\\n        let mut counter = [0_i32; 101];\\n        nums1.iter().for_each(|&x| counter[x as usize] |= 0b001);\\n        nums2.iter().for_each(|&x| counter[x as usize] |= 0b010);\\n        nums3.iter().for_each(|&x| counter[x as usize] |= 0b100);\\n        counter\\n            .iter()\\n            .cloned()\\n            .enumerate()\\n            .filter_map(|(ind, x)| match x.count_ones() >= 2 {\\n                true => Some(ind as i32),\\n                false => None,\\n            })\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513788,
                "title": "java-concise-solution-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        Set<Integer> set3 = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i : nums1){\\n            set1.add(i);\\n            set.add(i);\\n        }\\n        for(int i : nums2){\\n            set2.add(i);\\n            set.add(i);\\n        }\\n        for(int i : nums3){\\n            set3.add(i);\\n            set.add(i);\\n        }\\n        \\n        for(int i : set){\\n            if(set1.contains(i) && set2.contains(i) || set2.contains(i) && set3.contains(i) || set3.contains(i) && set1.contains(i))res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        Set<Integer> set3 = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i : nums1){\\n            set1.add(i);\\n            set.add(i);\\n        }\\n        for(int i : nums2){\\n            set2.add(i);\\n            set.add(i);\\n        }\\n        for(int i : nums3){\\n            set3.add(i);\\n            set.add(i);\\n        }\\n        \\n        for(int i : set){\\n            if(set1.contains(i) && set2.contains(i) || set2.contains(i) && set3.contains(i) || set3.contains(i) && set1.contains(i))res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513519,
                "title": "java-simple-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> ret = new ArrayList<>();\\n        int [] nums = new int[101];\\n        Arrays.fill(nums,0);\\n        Set<Integer> s = convertToSet(nums1);\\n        for (int num : s)nums[num]++;\\n        s = convertToSet(nums2);\\n        for (int num : s)nums[num]++;\\n        s = convertToSet(nums3);\\n        for (int num : s)nums[num]++;\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] >=2) ret.add(i);\\n        }\\n        return ret;\\n\\n\\n    }\\n\\n    private Set<Integer> convertToSet(int[] nums) {\\n        HashSet<Integer> hashSet = new HashSet<>();\\n        for (int n : nums)hashSet.add(n);\\n        return hashSet;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> ret = new ArrayList<>();\\n        int [] nums = new int[101];\\n        Arrays.fill(nums,0);\\n        Set<Integer> s = convertToSet(nums1);\\n        for (int num : s)nums[num]++;\\n        s = convertToSet(nums2);\\n        for (int num : s)nums[num]++;\\n        s = convertToSet(nums3);\\n        for (int num : s)nums[num]++;\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] >=2) ret.add(i);\\n        }\\n        return ret;\\n\\n\\n    }\\n\\n    private Set<Integer> convertToSet(int[] nums) {\\n        HashSet<Integer> hashSet = new HashSet<>();\\n        for (int n : nums)hashSet.add(n);\\n        return hashSet;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513403,
                "title": "java-map-set-o-n-discussions-are-welcome-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();\\n        Set<Integer> set3 = new HashSet<Integer>();\\n        for(int i=0; i<nums1.length; i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            set2.add(nums2[i]);\\n        }\\n        for(int i=0; i<nums3.length; i++){\\n            set3.add(nums3[i]);\\n        }\\n        Map<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(int val : set1){\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        for(int val : set2){\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        for(int val : set3){\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i : map.keySet()){\\n            int val = map.get(i);\\n            if(val >= 2){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();\\n        Set<Integer> set3 = new HashSet<Integer>();\\n        for(int i=0; i<nums1.length; i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            set2.add(nums2[i]);\\n        }\\n        for(int i=0; i<nums3.length; i++){\\n            set3.add(nums3[i]);\\n        }\\n        Map<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(int val : set1){\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        for(int val : set2){\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        for(int val : set3){\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i : map.keySet()){\\n            int val = map.get(i);\\n            if(val >= 2){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513392,
                "title": "python-set-list",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        k= set(nums1).intersection(set(nums2))\\n        k1= set(nums1).intersection(set(nums3))\\n        k2= set(nums2).intersection(set(nums3))\\n        l=[]\\n        for i in k:\\n            if i not in l:\\n                l.append(i)\\n        for i in k1:\\n            if i not in l:\\n                l.append(i)\\n        for i in k2:\\n            if i not in l:\\n                l.append(i)\\n        return l\\n```\\n**DO UPVOTE, IF IT HELPS:)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        k= set(nums1).intersection(set(nums2))\\n        k1= set(nums1).intersection(set(nums3))\\n        k2= set(nums2).intersection(set(nums3))\\n        l=[]\\n        for i in k:\\n            if i not in l:\\n                l.append(i)\\n        for i in k1:\\n            if i not in l:\\n                l.append(i)\\n        for i in k2:\\n            if i not in l:\\n                l.append(i)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513334,
                "title": "c-map-without-removing-duplicate-values",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,vector<int>> map;\\n        for(int num : nums1) {\\n            if(map.find(num) == map.end()) {\\n                map[num] = {1, 1};\\n            }\\n        }\\n        \\n        for(int num : nums2) {\\n            if(map.find(num) == map.end()) {\\n                map[num] = {2, 1};\\n            } else {\\n                if(map[num][0] == 1) {\\n                    map[num] = {2, 2};\\n                }\\n            }\\n        }\\n        \\n        for(int num : nums3) {\\n            if(map.find(num) == map.end()) {\\n                map[num] = {3, 1};\\n            } else {\\n                if(map[num][0] != 3) {\\n                    int numnew = map[num][1]+1;\\n                    map[num] = {3, numnew};\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(auto m : map) {\\n            if(m.second[1] >= 2) {\\n                res.push_back(m.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,vector<int>> map;\\n        for(int num : nums1) {\\n            if(map.find(num) == map.end()) {\\n                map[num] = {1, 1};\\n            }\\n        }\\n        \\n        for(int num : nums2) {\\n            if(map.find(num) == map.end()) {\\n                map[num] = {2, 1};\\n            } else {\\n                if(map[num][0] == 1) {\\n                    map[num] = {2, 2};\\n                }\\n            }\\n        }\\n        \\n        for(int num : nums3) {\\n            if(map.find(num) == map.end()) {\\n                map[num] = {3, 1};\\n            } else {\\n                if(map[num][0] != 3) {\\n                    int numnew = map[num][1]+1;\\n                    map[num] = {3, numnew};\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(auto m : map) {\\n            if(m.second[1] >= 2) {\\n                res.push_back(m.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810091,
                "title": "java-beats-90-using-hashset-explained",
                "content": "# Approach\\nWe add the first and second array to seperate HashSets. That way, while iterating through the second array, we can look for duplicates in the first array (which is now copied to `set1`), while adding all the elements from `nums2` to `set2`.\\nIf we find a duplicate either while iterating through the second or third array, we check if `l1` already contains it, if not we add it to the List.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> l1 = new ArrayList<>();\\n\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n\\n        for(int i:nums1){\\n            set1.add(i);\\n\\n        }\\n\\n        for(int i:nums2){\\n            if(set1.contains(i) && l1.contains(i)==false){l1.add(i);}\\n            else{set2.add(i);}\\n        }\\n\\n        for(int i:nums3){\\n            if(set1.contains(i) && l1.contains(i)==false){l1.add(i); }\\n            if(set2.contains(i) && l1.contains(i)==false){l1.add(i); }\\n        }\\n\\n        return l1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> l1 = new ArrayList<>();\\n\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n\\n        for(int i:nums1){\\n            set1.add(i);\\n\\n        }\\n\\n        for(int i:nums2){\\n            if(set1.contains(i) && l1.contains(i)==false){l1.add(i);}\\n            else{set2.add(i);}\\n        }\\n\\n        for(int i:nums3){\\n            if(set1.contains(i) && l1.contains(i)==false){l1.add(i); }\\n            if(set2.contains(i) && l1.contains(i)==false){l1.add(i); }\\n        }\\n\\n        return l1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579763,
                "title": "explained-in-a-basic-way-very-easy-to-understand",
                "content": "\\n# Approach\\n we will push every unique value from every vector into map and then triverse map if for any of them map value is gretor then 1 we will push them in a vector and at last return the vector\\n       \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        // we will push every unique value from every vector into map and then triverse map if for any of them map value is gretor then 1 we will push them in a vector and at last return the vector\\n          map<int,int>map;\\n          vector<int>ans;\\n          set<int> set1;\\n\\n          for(int i=0;i<nums1.size();i++){\\n              set1.insert(nums1[i]);\\n              //for unique value of the nums1 like  1 2 3\\n          }\\n           set<int> set2;\\n          for(int i=0;i<nums2.size();i++){\\n              set2.insert(nums2[i]);\\n                 //for unique value of the nums2. 2 3 \\n          }\\n           set<int> set3;\\n          for(int i=0;i<nums3.size();i++){\\n              set3.insert(nums3[i]);\\n                 //for unique value of the nums3. 3\\n          }\\n\\n           for(auto i: set1){\\n               map[i]++;\\n               //pushing unique value of the nums1 into the map\\n           }\\n           for(auto i: set2){\\n               map[i]++;\\n                 //pushing unique value of the nums2 into the map\\n           }\\n           \\n            for(auto i: set3){\\n               map[i]++;\\n                 //pushing unique value of the nums3 into the map\\n           }\\n        //    end map will look likee this 1->0,  2->2,  3->3\\n            for(auto i: map){\\n              if(i.second>1){\\n                  //any value in the map gretor then one time will push into the vector\\n                  ans.push_back(i.first);\\n              }\\n           }\\n    //return vector\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        // we will push every unique value from every vector into map and then triverse map if for any of them map value is gretor then 1 we will push them in a vector and at last return the vector\\n          map<int,int>map;\\n          vector<int>ans;\\n          set<int> set1;\\n\\n          for(int i=0;i<nums1.size();i++){\\n              set1.insert(nums1[i]);\\n              //for unique value of the nums1 like  1 2 3\\n          }\\n           set<int> set2;\\n          for(int i=0;i<nums2.size();i++){\\n              set2.insert(nums2[i]);\\n                 //for unique value of the nums2. 2 3 \\n          }\\n           set<int> set3;\\n          for(int i=0;i<nums3.size();i++){\\n              set3.insert(nums3[i]);\\n                 //for unique value of the nums3. 3\\n          }\\n\\n           for(auto i: set1){\\n               map[i]++;\\n               //pushing unique value of the nums1 into the map\\n           }\\n           for(auto i: set2){\\n               map[i]++;\\n                 //pushing unique value of the nums2 into the map\\n           }\\n           \\n            for(auto i: set3){\\n               map[i]++;\\n                 //pushing unique value of the nums3 into the map\\n           }\\n        //    end map will look likee this 1->0,  2->2,  3->3\\n            for(auto i: map){\\n              if(i.second>1){\\n                  //any value in the map gretor then one time will push into the vector\\n                  ans.push_back(i.first);\\n              }\\n           }\\n    //return vector\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491349,
                "title": "c",
                "content": "# Intuition\\nuse dictionary and index to count distinct number in numbers array\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. use dictionary to record appear number\\n2. use index to record when the number appear\\n3. use int array to record count and index\\n4. create a function and reuse it\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            int index = -1;\\n            Dictionary<int, int[]> record= new Dictionary<int, int[]>();\\n            public IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3)\\n            {\\n                RecordArray(nums1);\\n                RecordArray(nums2);\\n                RecordArray(nums3);\\n                List<int> result = new List<int>();\\n                foreach(int key in record.Keys)\\n                    if (record[key][1] >=2)\\n                        result.Add(key);\\n                return result;\\n            }\\n\\n            public void RecordArray(int[] nums)\\n            {\\n                index++;\\n                foreach(int num in nums)\\n                {\\n                    if(record.Keys.Contains(num))\\n                    {\\n                        if(record[num][0] != index)\\n                        {\\n                            record[num][0] = index;\\n                            record[num][1]++;\\n                        }                        \\n                    }                        \\n                    else\\n                        record[num] = new int[2] {index,1};\\n                }\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            int index = -1;\\n            Dictionary<int, int[]> record= new Dictionary<int, int[]>();\\n            public IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3)\\n            {\\n                RecordArray(nums1);\\n                RecordArray(nums2);\\n                RecordArray(nums3);\\n                List<int> result = new List<int>();\\n                foreach(int key in record.Keys)\\n                    if (record[key][1] >=2)\\n                        result.Add(key);\\n                return result;\\n            }\\n\\n            public void RecordArray(int[] nums)\\n            {\\n                index++;\\n                foreach(int num in nums)\\n                {\\n                    if(record.Keys.Contains(num))\\n                    {\\n                        if(record[num][0] != index)\\n                        {\\n                            record[num][0] = index;\\n                            record[num][1]++;\\n                        }                        \\n                    }                        \\n                    else\\n                        record[num] = new int[2] {index,1};\\n                }\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399458,
                "title": "dictionary-hashset-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Dictionary<int, int> numCount = new Dictionary<int, int>();\\n        List<int> res = new List<int>();\\n\\n        CheckArray(nums1, numCount);\\n        CheckArray(nums2, numCount);\\n        CheckArray(nums3, numCount);\\n       \\n        foreach(var i in numCount)\\n        {\\n            if(i.Value >= 2) res.Add(i.Key);\\n        }\\n\\n        return res;\\n    }\\n\\n    public void CheckArray(int[] nums, Dictionary<int, int> numCount)\\n    {\\n        HashSet<int> numSet = new HashSet<int>();\\n        foreach(int i in nums)\\n        {\\n            if(!numCount.ContainsKey(i))\\n            {\\n                numCount.Add(i, 1);\\n                numSet.Add(i);\\n            }\\n            else if(!numSet.Contains(i)) numCount[i]++; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Dictionary<int, int> numCount = new Dictionary<int, int>();\\n        List<int> res = new List<int>();\\n\\n        CheckArray(nums1, numCount);\\n        CheckArray(nums2, numCount);\\n        CheckArray(nums3, numCount);\\n       \\n        foreach(var i in numCount)\\n        {\\n            if(i.Value >= 2) res.Add(i.Key);\\n        }\\n\\n        return res;\\n    }\\n\\n    public void CheckArray(int[] nums, Dictionary<int, int> numCount)\\n    {\\n        HashSet<int> numSet = new HashSet<int>();\\n        foreach(int i in nums)\\n        {\\n            if(!numCount.ContainsKey(i))\\n            {\\n                numCount.Add(i, 1);\\n                numSet.Add(i);\\n            }\\n            else if(!numSet.Contains(i)) numCount[i]++; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376132,
                "title": "frequency-array-concept-beats-100-o-n-time-and-o-n-space",
                "content": "# Intuition\\n  Just check whether the frequency of every element is either present in the two of Array and push it into the list !!\\n\\n# Approach\\n  Frequency Array Concept !!! , The reason why I take the array of 101 is because of the question constraint , as there is also mentioned in the question that all the values of an array are lies in the range of [1,101] so I just use array values as indices of the frequency array to count the frequency of all the elements !!\\n\\n# Complexity\\n- Time complexity:\\n  O(n) as all the three arrays took linear time to traverse !!\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer>ans = new ArrayList<>();\\n        int []freq1 = new int[101];\\n        int []freq2 = new int[101];\\n        int []freq3 = new int[101];\\n        \\n        for(int x:nums1){\\n            if(freq1[x]<1) freq1[x]++;\\n        }\\n\\n        for(int x:nums2){\\n            if(freq2[x]<1) freq2[x]++;\\n        }\\n\\n        for(int x:nums3){\\n            if(freq3[x]<1) freq3[x]++;\\n        }\\n\\n        for(int i=1;i<101;i++){\\n            if(freq1[i]>=1 && freq2[i]>=1) ans.add(i);\\n            else if(freq1[i]>=1 && freq3[i]>=1) ans.add(i);\\n            else if(freq2[i]>=1 && freq3[i]>=1) ans.add(i);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n\\n\\n**PLEASE UPVOTE MY ANSWER !!**\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer>ans = new ArrayList<>();\\n        int []freq1 = new int[101];\\n        int []freq2 = new int[101];\\n        int []freq3 = new int[101];\\n        \\n        for(int x:nums1){\\n            if(freq1[x]<1) freq1[x]++;\\n        }\\n\\n        for(int x:nums2){\\n            if(freq2[x]<1) freq2[x]++;\\n        }\\n\\n        for(int x:nums3){\\n            if(freq3[x]<1) freq3[x]++;\\n        }\\n\\n        for(int i=1;i<101;i++){\\n            if(freq1[i]>=1 && freq2[i]>=1) ans.add(i);\\n            else if(freq1[i]>=1 && freq3[i]>=1) ans.add(i);\\n            else if(freq2[i]>=1 && freq3[i]>=1) ans.add(i);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n\\n\\n**PLEASE UPVOTE MY ANSWER !!**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292514,
                "title": "two-out-of-three-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int i, j, k=0;\\n        vector<int> ans;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        sort(nums3.begin(), nums3.end());\\n        for(i=1 ; i<nums1.size() ; i++)\\n        {\\n            if(nums1[i]==nums1[i-1])\\n            {\\n                nums1[i-1] = -1;\\n            }\\n        }\\n        for(i=1 ; i<nums2.size() ; i++)\\n        {\\n            if(nums2[i]==nums2[i-1])\\n            {\\n                nums2[i-1] = -1;\\n            }\\n        }\\n        for(i=1 ; i<nums3.size() ; i++)\\n        {\\n            if(nums3[i]==nums3[i-1])\\n            {\\n                nums3[i-1] = -1;\\n            }\\n        }\\n\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end());\\n        nums1.insert(nums1.end(), nums3.begin(), nums3.end());\\n\\n        \\n        for(i=0 ; i<nums1.size()-1 ; i++)\\n        {\\n            for(j=i+1 ; j<nums1.size() ; j++)\\n            {\\n                if(nums1[i]==nums1[j] && nums1[i]!=-1)\\n                {\\n                    ans.push_back(nums1[i]);\\n                    nums1[i] = -1;\\n                    nums1[j] = -1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int i, j, k=0;\\n        vector<int> ans;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        sort(nums3.begin(), nums3.end());\\n        for(i=1 ; i<nums1.size() ; i++)\\n        {\\n            if(nums1[i]==nums1[i-1])\\n            {\\n                nums1[i-1] = -1;\\n            }\\n        }\\n        for(i=1 ; i<nums2.size() ; i++)\\n        {\\n            if(nums2[i]==nums2[i-1])\\n            {\\n                nums2[i-1] = -1;\\n            }\\n        }\\n        for(i=1 ; i<nums3.size() ; i++)\\n        {\\n            if(nums3[i]==nums3[i-1])\\n            {\\n                nums3[i-1] = -1;\\n            }\\n        }\\n\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end());\\n        nums1.insert(nums1.end(), nums3.begin(), nums3.end());\\n\\n        \\n        for(i=0 ; i<nums1.size()-1 ; i++)\\n        {\\n            for(j=i+1 ; j<nums1.size() ; j++)\\n            {\\n                if(nums1[i]==nums1[j] && nums1[i]!=-1)\\n                {\\n                    ans.push_back(nums1[i]);\\n                    nums1[i] = -1;\\n                    nums1[j] = -1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188830,
                "title": "java-solution-beats-100",
                "content": "\\n```\\nclass Solution {\\n\\n  public List < Integer > twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n    List < Integer > ans = new ArrayList < > ();\\n\\n    // initialize array origin   of size 101 .\\n\\n    int[] origin = new int[101];\\n    //for each element in nums1 put 1 at the corresponding index in the above \\n    for (int e: nums1) {\\n      if (origin[e] == 0) origin[e] = 1;\\n    }\\n\\n    for (int e: nums2) {\\n\\n      if (origin[e] == 0) origin[e] = 2; //  e hasnt been seen so mark the value with 2\\n      else if (origin[e] == 1) { // e was seen in nums1 so add to the answer and to avoid duplicate in future mark corresponding index with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n    for (int e: nums3) {\\n\\n      if (origin[e] == 1 || origin[e] == 2) { // seen e in the past so add to ans and mark it with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n\\n    return ans;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  public List < Integer > twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n    List < Integer > ans = new ArrayList < > ();\\n\\n    // initialize array origin   of size 101 .\\n\\n    int[] origin = new int[101];\\n    //for each element in nums1 put 1 at the corresponding index in the above \\n    for (int e: nums1) {\\n      if (origin[e] == 0) origin[e] = 1;\\n    }\\n\\n    for (int e: nums2) {\\n\\n      if (origin[e] == 0) origin[e] = 2; //  e hasnt been seen so mark the value with 2\\n      else if (origin[e] == 1) { // e was seen in nums1 so add to the answer and to avoid duplicate in future mark corresponding index with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n    for (int e: nums3) {\\n\\n      if (origin[e] == 1 || origin[e] == 2) { // seen e in the past so add to ans and mark it with -1.\\n        ans.add(e);\\n        origin[e] = -1;\\n      }\\n    }\\n\\n    return ans;\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157056,
                "title": "easy-to-understand-c-solution-with-3ms-run-time",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/8dd8627c-9760-4620-95d0-234c0d74f67f_1675792010.2774177.png)\\n\\n# Approach\\nFinding the elements present in atleast 2 vectors and inserting into set. Then we simply iterate the set and push it in vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        vector<int>ans;\\n        set<int>s;\\n        for(auto i:nums1)\\n        {\\n            if(find(nums2.begin(), nums2.end(), i) != nums2.end() || find(nums3.begin(), nums3.end(), i) != nums3.end())\\n                s.insert(i);\\n        }\\n        \\n        for(auto i:nums2)\\n        {\\n            if(find(nums1.begin(), nums1.end(), i) != nums1.end() || find(nums3.begin(), nums3.end(), i) != nums3.end())\\n                s.insert(i);\\n        }\\n        \\n        for(auto i:nums3)\\n        {\\n            if(find(nums1.begin(), nums1.end(), i) != nums1.end() || find(nums2.begin(), nums2.end(), i) != nums2.end())\\n                s.insert(i);\\n        }\\n\\n        for(auto i:s)\\n            ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        vector<int>ans;\\n        set<int>s;\\n        for(auto i:nums1)\\n        {\\n            if(find(nums2.begin(), nums2.end(), i) != nums2.end() || find(nums3.begin(), nums3.end(), i) != nums3.end())\\n                s.insert(i);\\n        }\\n        \\n        for(auto i:nums2)\\n        {\\n            if(find(nums1.begin(), nums1.end(), i) != nums1.end() || find(nums3.begin(), nums3.end(), i) != nums3.end())\\n                s.insert(i);\\n        }\\n        \\n        for(auto i:nums3)\\n        {\\n            if(find(nums1.begin(), nums1.end(), i) != nums1.end() || find(nums2.begin(), nums2.end(), i) != nums2.end())\\n                s.insert(i);\\n        }\\n\\n        for(auto i:s)\\n            ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044417,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int a=*max_element(nums1.begin(),nums1.end());\\n        int b=*max_element(nums2.begin(),nums2.end());\\n        int c=*max_element(nums3.begin(),nums3.end());\\n        int d=max(a,max(b,c));\\n        unordered_set<int>s1(nums1.begin(),nums1.end());\\n        unordered_set<int>s2(nums2.begin(),nums2.end());\\n        unordered_set<int>s3(nums3.begin(),nums3.end());\\n\\n        int arr[d+1];\\n        memset(arr,0,sizeof(arr));\\n        for(auto it=s1.begin();it!=s1.end();it++)\\n        {\\n            arr[*it]++;\\n        }\\n        for(auto it=s2.begin();it!=s2.end();it++)\\n        {\\n            arr[*it]++;\\n        }\\n        for(auto it=s3.begin();it!=s3.end();it++)\\n        {\\n            arr[*it]++;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<=d;i++)\\n        {\\n            if(arr[i]>=2)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int a=*max_element(nums1.begin(),nums1.end());\\n        int b=*max_element(nums2.begin(),nums2.end());\\n        int c=*max_element(nums3.begin(),nums3.end());\\n        int d=max(a,max(b,c));\\n        unordered_set<int>s1(nums1.begin(),nums1.end());\\n        unordered_set<int>s2(nums2.begin(),nums2.end());\\n        unordered_set<int>s3(nums3.begin(),nums3.end());\\n\\n        int arr[d+1];\\n        memset(arr,0,sizeof(arr));\\n        for(auto it=s1.begin();it!=s1.end();it++)\\n        {\\n            arr[*it]++;\\n        }\\n        for(auto it=s2.begin();it!=s2.end();it++)\\n        {\\n            arr[*it]++;\\n        }\\n        for(auto it=s3.begin();it!=s3.end();it++)\\n        {\\n            arr[*it]++;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<=d;i++)\\n        {\\n            if(arr[i]>=2)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965920,
                "title": "c-easy-and-simple-solution-using-map",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(I+J+K)<br>\\nI is the size of nums1<br>\\nJ is the size fo nums2<br>\\nK is the size of nums3<br>\\n\\n- Space complexity:\\nO(I+J+K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int,vector<int>>mapping;\\n        set<int>a;\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++){\\n            mapping[nums1[i]].push_back(0);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            mapping[nums2[i]].push_back(1);\\n        }\\n        for(int i=0;i<nums3.size();i++){\\n            mapping[nums3[i]].push_back(2);\\n        }\\n        for(auto i : mapping){\\n            map<int,int>mapping;\\n            for(auto j : i.second){\\n                mapping[j]++;\\n            }\\n            if(mapping.size()>=2) ans.push_back(i.first);\\n        }\\n        return ans;        \\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int,vector<int>>mapping;\\n        set<int>a;\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++){\\n            mapping[nums1[i]].push_back(0);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            mapping[nums2[i]].push_back(1);\\n        }\\n        for(int i=0;i<nums3.size();i++){\\n            mapping[nums3[i]].push_back(2);\\n        }\\n        for(auto i : mapping){\\n            map<int,int>mapping;\\n            for(auto j : i.second){\\n                mapping[j]++;\\n            }\\n            if(mapping.size()>=2) ans.push_back(i.first);\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748153,
                "title": "java-hashmap-easy-solution",
                "content": "```\\n\\n```class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> arr= new ArrayList<>();\\n        HashMap<Integer, Integer> map= new HashMap();\\n        for(int i=0; i<nums1.length; i++)\\n            map.put(nums1[i], 1);\\n        for(int i=0; i<nums2.length; i++)\\n        {\\n            if(map.containsKey(nums2[i]))\\n            {\\n                if(map.get(nums2[i])==1)\\n                {\\n                    arr.add(nums2[i]);\\n                    map.put(nums2[i], 2);   \\n                }\\n            }\\n        }\\n        for(int i=0; i<nums2.length; i++)\\n        {\\n            if(!map.containsKey(nums2[i]))\\n                map.put(nums2[i], 1);\\n        }\\n        for(int i=0; i<nums3.length; i++)\\n        {\\n            if(map.containsKey(nums3[i]))\\n            {\\n                if(map.get(nums3[i])==1)\\n                {\\n                    arr.add(nums3[i]);\\n                    map.put(nums3[i], 2);   \\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736096,
                "title": "python-one-line-solution-99-63-faster",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return list(set(nums1)&set(nums2) | set(nums1)&set(nums3) | set(nums2)&set(nums3))\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return list(set(nums1)&set(nums2) | set(nums1)&set(nums3) | set(nums2)&set(nums3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684727,
                "title": "python-one-row-88-83",
                "content": "```\\ndef twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return list(set(list(set(nums1) & set(nums2))+list(set(nums2) & set(nums3))+list(set(nums1) & set(nums3))))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        return list(set(list(set(nums1) & set(nums2))+list(set(nums2) & set(nums3))+list(set(nums1) & set(nums3))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2662639,
                "title": "java-hashset-with-explanation",
                "content": "\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        int n3 = nums3.length;\\n        \\n        HashSet<Integer> ans  = new HashSet<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n        \\n        for(int x: nums1){\\n            set1.add(x);\\n        }\\n        for(int x: nums2){\\n            set2.add(x);\\n        }\\n        for(int x: nums3){\\n            set3.add(x);\\n        }\\n        // find distinct elements and store in seprate sets.\\n        //compare  set1 with set2 and set3, if anything common then add it in ans hashset.\\n        for(int p:set1){\\n            if(set2.contains(p)){\\n                ans.add(p);\\n            }\\n            else if(set3.contains(p)){\\n                ans.add(p);\\n            }\\n        }\\n\\t\\t// check commons in set2 and set3 if so then add them to ans hashset\\n        for(int p:set2){\\n            if(set3.contains(p)){\\n                ans.add(p);\\n            }\\n        }\\n\\t\\t// convert hashset to arraylist and return. \\n        List<Integer> al = new ArrayList<>();\\n        for(int p: ans){\\n            al.add(p);\\n        }\\n        return al;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        int n3 = nums3.length;\\n        \\n        HashSet<Integer> ans  = new HashSet<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n        \\n        for(int x: nums1){\\n            set1.add(x);\\n        }\\n        for(int x: nums2){\\n            set2.add(x);\\n        }\\n        for(int x: nums3){\\n            set3.add(x);\\n        }\\n        // find distinct elements and store in seprate sets.\\n        //compare  set1 with set2 and set3, if anything common then add it in ans hashset.\\n        for(int p:set1){\\n            if(set2.contains(p)){\\n                ans.add(p);\\n            }\\n            else if(set3.contains(p)){\\n                ans.add(p);\\n            }\\n        }\\n\\t\\t// check commons in set2 and set3 if so then add them to ans hashset\\n        for(int p:set2){\\n            if(set3.contains(p)){\\n                ans.add(p);\\n            }\\n        }\\n\\t\\t// convert hashset to arraylist and return. \\n        List<Integer> al = new ArrayList<>();\\n        for(int p: ans){\\n            al.add(p);\\n        }\\n        return al;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2622706,
                "title": "c-easy-to-understand-short",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& a, vector<int>& b, vector<int>& c) \\n    {\\n        vector<int>res;\\n        map<int,int> mapa,mapb,mapc;\\n        for(int i=0;i<a.size();i++)\\n            mapa[a[i]]=1;\\n        for(int i=0;i<b.size();i++)\\n            mapb[b[i]]=1;\\n        for(int i=0;i<c.size();i++)\\n            mapc[c[i]]=1;\\n        for(int i=0;i<101;i++)\\n        {\\n            if(mapa[i]+mapb[i]+mapc[i]==3||mapa[i]+mapb[i]+mapc[i]==2)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& a, vector<int>& b, vector<int>& c) \\n    {\\n        vector<int>res;\\n        map<int,int> mapa,mapb,mapc;\\n        for(int i=0;i<a.size();i++)\\n            mapa[a[i]]=1;\\n        for(int i=0;i<b.size();i++)\\n            mapb[b[i]]=1;\\n        for(int i=0;i<c.size();i++)\\n            mapc[c[i]]=1;\\n        for(int i=0;i<101;i++)\\n        {\\n            if(mapa[i]+mapb[i]+mapc[i]==3||mapa[i]+mapb[i]+mapc[i]==2)\\n                res.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2593575,
                "title": "javascript-easy-solution-easy-to-understand-for-beginners",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n\\t/* Getting an array of all unique numbers from nums1, nums2, nums3 and Spreading them to concate all three arrays */\\n    let num = [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)];\\n\\t/*An empty array to store result*/\\n    let arr = [];\\n\\t/* Using Lodash to count the frequency of all elements. It\\'ll return an Object */\\n    let freq = _.countBy(num);\\n    \\n\\t/* Getting Keys of the object \"freq\". It\\'ll return an array of all Keys of the key-value pairs */\\n    let keys = Object.keys(freq);\\n\\t\\n\\t/* Looping through the Keys and checking if the value of freq[key] is greater or equal 2. If it is, pushing the key into \"arr\" array */\\n    keys.forEach(key => {\\n        if(freq[key] >= 2){\\n            arr.push(key)\\n        }\\n    })\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n\\t/* Getting an array of all unique numbers from nums1, nums2, nums3 and Spreading them to concate all three arrays */\\n    let num = [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)];\\n\\t/*An empty array to store result*/\\n    let arr = [];\\n\\t/* Using Lodash to count the frequency of all elements. It\\'ll return an Object */\\n    let freq = _.countBy(num);\\n    \\n\\t/* Getting Keys of the object \"freq\". It\\'ll return an array of all Keys of the key-value pairs */\\n    let keys = Object.keys(freq);\\n\\t\\n\\t/* Looping through the Keys and checking if the value of freq[key] is greater or equal 2. If it is, pushing the key into \"arr\" array */\\n    keys.forEach(key => {\\n        if(freq[key] >= 2){\\n            arr.push(key)\\n        }\\n    })\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547190,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        getFreq(nums1);\\n        getFreq(nums2);\\n        getFreq(nums3);\\n        \\n        for(Map.Entry<Integer,Integer> m : map.entrySet()){\\n            if(m.getValue()>1){\\n                res.add(m.getKey());\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void getFreq(int[] nums){\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int num: nums){\\n            set.add(num);\\n        }\\n        \\n        Iterator<Integer> setItr = set.iterator();\\n        while(setItr.hasNext()){\\n            int temp = setItr.next();\\n            map.put(temp, map.getOrDefault(temp,0)+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        getFreq(nums1);\\n        getFreq(nums2);\\n        getFreq(nums3);\\n        \\n        for(Map.Entry<Integer,Integer> m : map.entrySet()){\\n            if(m.getValue()>1){\\n                res.add(m.getKey());\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void getFreq(int[] nums){\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int num: nums){\\n            set.add(num);\\n        }\\n        \\n        Iterator<Integer> setItr = set.iterator();\\n        while(setItr.hasNext()){\\n            int temp = setItr.next();\\n            map.put(temp, map.getOrDefault(temp,0)+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502033,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        unordered_set<int>s(nums2.begin(),nums2.end());\\n        for(auto i:nums1){\\n            mp[i]=1;\\n        }\\n       for(auto i:s){\\n            if(mp[i]==1)mp[i]=2;\\n            else \\n                mp[i]=1;\\n       }\\n        for(auto i:nums3){\\n            if(mp[i]==2)mp[i]=3;\\n            else if(mp[i]==1)mp[i]=2;\\n        }\\n        for(auto i:mp){\\n            if(i.second>1)ans.push_back(i.first);\\n        }\\n        return  ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        unordered_set<int>s(nums2.begin(),nums2.end());\\n        for(auto i:nums1){\\n            mp[i]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2420903,
                "title": "c-using-maps-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int,int> m;\\n        vector<int> v;\\n        for(int i:nums1)\\n        {\\n            m[i]=1;\\n        }\\n        for(int i:nums2)\\n        {\\n            if(m.find(i)!=m.end() && (m[i]==1||m[i]==10))\\n            {\\n                m[i]=10;\\n            }\\n            else\\n                m[i]=2;\\n        }\\n        for(int i:nums3)\\n        {\\n            if(m.find(i)!=m.end() && (m[i]==1 || m[i]==2 || m[i]==10))\\n            {\\n                m[i]=10;\\n            }\\n            else\\n                m[i]=3;\\n        }\\n        \\n        for(auto &it:m)\\n        {\\n            if(it.second==10)\\n            {\\n                v.push_back(it.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map<int,int> m;\\n        vector<int> v;\\n        for(int i:nums1)\\n        {\\n            m[i]=1;\\n        }\\n        for(int i:nums2)\\n        {\\n            if(m.find(i)!=m.end() && (m[i]==1||m[i]==10))\\n            {\\n                m[i]=10;\\n            }\\n            else\\n                m[i]=2;\\n        }\\n        for(int i:nums3)\\n        {\\n            if(m.find(i)!=m.end() && (m[i]==1 || m[i]==2 || m[i]==10))\\n            {\\n                m[i]=10;\\n            }\\n            else\\n                m[i]=3;\\n        }\\n        \\n        for(auto &it:m)\\n        {\\n            if(it.second==10)\\n            {\\n                v.push_back(it.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385902,
                "title": "using-map-simple-easy-to-understand",
                "content": "\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n       \\n        for(int num : nums1) {\\n            map.put(num, 1);\\n        }\\n        \\n        Arrays.stream(nums2).distinct().forEach(num ->{\\n            if(map.get(num) != null) {\\n                map.put(num, map.get(num) + 1);\\n            } else {\\n                map.put(num, 1);\\n            }\\n        });\\n        \\n        Arrays.stream(nums3).distinct().forEach(num ->{\\n            if(map.get(num) != null) {\\n                map.put(num, map.get(num) + 1);\\n            } else {\\n                map.put(num, 1);\\n            }\\n        });\\n        \\n        return map.entrySet().stream().filter(entry -> entry.getValue() >=2 ).map(entry ->   entry.getKey()).collect(Collectors.toList());",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n       \\n        for(int num : nums1) {\\n            map.put(num, 1);\\n        }\\n        \\n        Arrays.stream(nums2).distinct().forEach(num ->{\\n            if(map.get(num) != null) {\\n                map.put(num, map.get(num) + 1);\\n            } else {\\n                map.put(num, 1);\\n            }\\n        });\\n        \\n        Arrays.stream(nums3).distinct().forEach(num ->{\\n            if(map.get(num) != null) {\\n                map.put(num, map.get(num) + 1);\\n            } else {\\n                map.put(num, 1);\\n            }\\n        });\\n        \\n        return map.entrySet().stream().filter(entry -> entry.getValue() >=2 ).map(entry ->   entry.getKey()).collect(Collectors.toList());",
                "codeTag": "Unknown"
            },
            {
                "id": 2252112,
                "title": "java",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer> ret  = new ArrayList();\\n        \\n        HashSet<Integer> temp1 = new HashSet();        \\n        for(int i = 0; i< nums1.length; i++){            \\n            temp1.add(nums1[i]);\\n        }\\n        \\n        HashSet<Integer> temp2 = new HashSet();        \\n        for(int i = 0; i< nums2.length; i++){            \\n            temp2.add(nums2[i]);\\n        }\\n        \\n        HashSet<Integer> temp3 = new HashSet();        \\n        for(int i = 0; i< nums3.length; i++){            \\n            temp3.add(nums3[i]);\\n        }\\n        \\n        for (Integer i : temp2){\\n            if (temp1.contains(i)){\\n               if (!ret.contains(i)){\\n                    ret.add(i);    \\n               }                   \\n            }\\n            else{\\n                temp1.add(i);\\n            }\\n        }\\n        \\n        for (Integer i : temp3){\\n            if (temp1.contains(i)){\\n                if (!ret.contains(i)){\\n                    ret.add(i);    \\n               }                 \\n            }\\n            else{\\n                temp1.add(i);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<Integer> ret  = new ArrayList();\\n        \\n        HashSet<Integer> temp1 = new HashSet();        \\n        for(int i = 0; i< nums1.length; i++){            \\n            temp1.add(nums1[i]);\\n        }\\n        \\n        HashSet<Integer> temp2 = new HashSet();        \\n        for(int i = 0; i< nums2.length; i++){            \\n            temp2.add(nums2[i]);\\n        }\\n        \\n        HashSet<Integer> temp3 = new HashSet();        \\n        for(int i = 0; i< nums3.length; i++){            \\n            temp3.add(nums3[i]);\\n        }\\n        \\n        for (Integer i : temp2){\\n            if (temp1.contains(i)){\\n               if (!ret.contains(i)){\\n                    ret.add(i);    \\n               }                   \\n            }\\n            else{\\n                temp1.add(i);\\n            }\\n        }\\n        \\n        for (Integer i : temp3){\\n            if (temp1.contains(i)){\\n                if (!ret.contains(i)){\\n                    ret.add(i);    \\n               }                 \\n            }\\n            else{\\n                temp1.add(i);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249235,
                "title": "a-clean-and-simple-code",
                "content": "*sets will store each elem once\\nmap will store occurance of each elem in all the sets which contain unique values\\nif freq of some elem is 2 means it is present in two-arrays\\nand if freq is 3 , means its present all 3 of them*\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        \\n        unordered_set<int> s1 , s2 , s3 ;\\n        for ( auto &it : nums1 ) s1.insert(it) ;\\n        for ( auto &it : nums2 ) s2.insert(it) ;\\n        for ( auto &it : nums3 ) s3.insert(it) ;\\n        \\n        unordered_map<int,int> m ;\\n        for ( auto &it : s1 ) m[it]++ ;\\n        for ( auto &it : s2 ) m[it]++ ;\\n        for ( auto &it : s3 ) m[it]++ ;\\n        \\n        vector<int> ans ;\\n        for ( auto &it : m ) \\n            if( it.second >= 2 ) ans.push_back( it.first ) ;\\n        \\n        return ans ;\\n    }\\n};\\n```\\n\\nOther :\\n```\\nclass Solution {\\npublic:\\n   vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        bool cnt[3][101] = {};\\n        vector<int> res;\\n        for (auto n : nums1)\\n            cnt[0][n] = true;\\n        for (auto n : nums2)\\n            cnt[1][n] = true;\\n        for (auto n : nums3)\\n            cnt[2][n] = true;\\n        for (int i = 1; i <= 100; ++i)\\n            if (cnt[0][i] + cnt[1][i] + cnt[2][i] > 1)\\n                res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        \\n        unordered_set<int> s1 , s2 , s3 ;\\n        for ( auto &it : nums1 ) s1.insert(it) ;\\n        for ( auto &it : nums2 ) s2.insert(it) ;\\n        for ( auto &it : nums3 ) s3.insert(it) ;\\n        \\n        unordered_map<int,int> m ;\\n        for ( auto &it : s1 ) m[it]++ ;\\n        for ( auto &it : s2 ) m[it]++ ;\\n        for ( auto &it : s3 ) m[it]++ ;\\n        \\n        vector<int> ans ;\\n        for ( auto &it : m ) \\n            if( it.second >= 2 ) ans.push_back( it.first ) ;\\n        \\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        bool cnt[3][101] = {};\\n        vector<int> res;\\n        for (auto n : nums1)\\n            cnt[0][n] = true;\\n        for (auto n : nums2)\\n            cnt[1][n] = true;\\n        for (auto n : nums3)\\n            cnt[2][n] = true;\\n        for (int i = 1; i <= 100; ++i)\\n            if (cnt[0][i] + cnt[1][i] + cnt[2][i] > 1)\\n                res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236516,
                "title": "c-solution-using-unordered-map",
                "content": "**Approach:** First, remove all duplicates from all the given vectors and then count each element present in each vectors after removing duplicates, create an array and push all element which comes more than one time and return it.\\n```\\nclass Solution {\\npublic:\\n    void unique(vector<int>& nums1){\\n        unordered_map<int,int> u;\\n        for(int i=0;i<nums1.size();i++){\\n            if(u.count(nums1[i])>0){\\n                nums1.erase(nums1.begin()+i);\\n                i--;\\n            }\\n            else\\n                u[nums1[i]]++;\\n            \\n        }\\n    }\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unique(nums1);\\n        unique(nums2);\\n        unique(nums3);\\n        vector<int> ans;\\n        unordered_map<int,int> u;\\n        for(auto ele:nums1){\\n            u[ele]++;\\n        }\\n        for(auto ele:nums2){\\n            u[ele]++;\\n        }\\n        for(auto ele:nums3){\\n            u[ele]++;\\n        }\\n        for(auto ele:u){\\n            if(ele.second>1){\\n                ans.push_back(ele.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void unique(vector<int>& nums1){\\n        unordered_map<int,int> u;\\n        for(int i=0;i<nums1.size();i++){\\n            if(u.count(nums1[i])>0){\\n                nums1.erase(nums1.begin()+i);\\n                i--;\\n            }\\n            else\\n                u[nums1[i]]++;\\n            \\n        }\\n    }\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unique(nums1);\\n        unique(nums2);\\n        unique(nums3);\\n        vector<int> ans;\\n        unordered_map<int,int> u;\\n        for(auto ele:nums1){\\n            u[ele]++;\\n        }\\n        for(auto ele:nums2){\\n            u[ele]++;\\n        }\\n        for(auto ele:nums3){\\n            u[ele]++;\\n        }\\n        for(auto ele:u){\\n            if(ele.second>1){\\n                ans.push_back(ele.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221047,
                "title": "c-easy-solution-using-set",
                "content": "```\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        set<int> ans;\\n        set<int> s1;\\n        set<int> s2;\\n        set<int> s3;\\n        for (auto i: nums1) {\\n            s1.insert(i);\\n        }\\n        for (auto i: nums2) {\\n            s2.insert(i);\\n        }\\n        for (auto i: nums3) {\\n            s3.insert(i);\\n        }\\n        for (auto i: nums1) {\\n            if (s2.find(i) != s2.end() || s3.find(i) != s3.end())\\n                ans.insert(i);\\n        }\\n        for (auto i: nums2) {\\n            if (s1.find(i) != s1.end() || s3.find(i) != s3.end())\\n                ans.insert(i);\\n        }\\n        vector<int> v;\\n        for (auto i: ans) {\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        set<int> ans;\\n        set<int> s1;\\n        set<int> s2;\\n        set<int> s3;\\n        for (auto i: nums1) {\\n            s1.insert(i);\\n        }\\n        for (auto i: nums2) {\\n            s2.insert(i);\\n        }\\n        for (auto i: nums3) {\\n            s3.insert(i);\\n        }\\n        for (auto i: nums1) {\\n            if (s2.find(i) != s2.end() || s3.find(i) != s3.end())\\n                ans.insert(i);\\n        }\\n        for (auto i: nums2) {\\n            if (s1.find(i) != s1.end() || s3.find(i) != s3.end())\\n                ans.insert(i);\\n        }\\n        vector<int> v;\\n        for (auto i: ans) {\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200465,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ret=[]\\n        d={}\\n        for i in nums1:\\n            if(i not in d):\\n                d[i]=1\\n        for i in nums2:\\n            if(i in d):\\n                if(d[i]==1):\\n                    ret.append(i)\\n                    d[i]=0\\n            else:\\n                d[i]=2\\n        for i in nums3:\\n            if(i in d):\\n                if(d[i]==1 or d[i]==2):\\n                    ret.append(i)\\n                    d[i]=0\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ret=[]\\n        d={}\\n        for i in nums1:\\n            if(i not in d):\\n                d[i]=1\\n        for i in nums2:\\n            if(i in d):\\n                if(d[i]==1):\\n                    ret.append(i)\\n                    d[i]=0\\n            else:\\n                d[i]=2\\n        for i in nums3:\\n            if(i in d):\\n                if(d[i]==1 or d[i]==2):\\n                    ret.append(i)\\n                    d[i]=0\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072967,
                "title": "javascript-one-liner-sets-and-filter",
                "content": "```\\nconst twoOutOfThree = (nums1, nums2, nums3) => [\\n  ...new Set(\\n    [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)].filter(\\n      (x, _, arr) => arr.indexOf(x) !== arr.lastIndexOf(x)\\n    )\\n  ),\\n];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst twoOutOfThree = (nums1, nums2, nums3) => [\\n  ...new Set(\\n    [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)].filter(\\n      (x, _, arr) => arr.indexOf(x) !== arr.lastIndexOf(x)\\n    )\\n  ),\\n];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2070438,
                "title": "c-dry-array-map",
                "content": "```cpp\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int m[3][101] = {0};\\n        vector<int> solution;\\n        for(int e : nums1) m[0][e] = 1;\\n        for(int e : nums2) m[1][e] = 1;\\n        for(int e : nums3) m[2][e] = 1;\\n        for(int i = 0; i < 101 ; i++) {\\n            int sum = m[0][i] + m[1][i] + m[2][i] ;\\n            if(sum > 1) solution.push_back(i);\\n        }\\n        return solution;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        int m[3][101] = {0};\\n        vector<int> solution;\\n        for(int e : nums1) m[0][e] = 1;\\n        for(int e : nums2) m[1][e] = 1;\\n        for(int e : nums3) m[2][e] = 1;\\n        for(int i = 0; i < 101 ; i++) {\\n            int sum = m[0][i] + m[1][i] + m[2][i] ;\\n            if(sum > 1) solution.push_back(i);\\n        }\\n        return solution;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064003,
                "title": "java-clean-and-concise-solution-with-set",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set = new HashSet();\\n        Set<Integer> result =  new HashSet();\\n        for(int i : nums1) //add all number on nums1 to set\\n            set.add(i);\\n        for(int i : nums2) // findout if there any intersection with nums2\\n            if(set.contains(i)) result.add(i);\\n        for(int i : nums2) //lately add all numbers from nums2 to set.\\n            set.add(i);\\n        for(int i : nums3) // check if there is intersection with again for nums3\\n            if(set.contains(i)) result.add(i);\\n        return new ArrayList(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set = new HashSet();\\n        Set<Integer> result =  new HashSet();\\n        for(int i : nums1) //add all number on nums1 to set\\n            set.add(i);\\n        for(int i : nums2) // findout if there any intersection with nums2\\n            if(set.contains(i)) result.add(i);\\n        for(int i : nums2) //lately add all numbers from nums2 to set.\\n            set.add(i);\\n        for(int i : nums3) // check if there is intersection with again for nums3\\n            if(set.contains(i)) result.add(i);\\n        return new ArrayList(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056691,
                "title": "80-faster-c-best-easy-understanding-solution-time-o-n-space-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/2400185d-0056-45dd-9a03-834303f8a031_1653041201.757947.png)\\n\\n```\\nclass Solution {\\n    void removeDUP(vector<int>& nums){\\n        int i = 0, j = 1;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        while(j<n){\\n            if(nums[i]!=nums[j]){\\n                nums[++i] = nums[j];\\n            }\\n            j++;\\n        }\\n        int rem = n-1-i;\\n        while(rem--){\\n            nums.pop_back();\\n        }\\n    }\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        removeDUP(nums1);\\n        removeDUP(nums2);\\n        removeDUP(nums3);\\n        unordered_map<int,int> mp;\\n        for(auto it:nums1){\\n            mp[it]++;\\n        }\\n        for(auto it:nums2){\\n            mp[it]++;\\n        }\\n        for(auto it:nums3){\\n            mp[it]++;\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it:mp){\\n            if(it.second>=2){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void removeDUP(vector<int>& nums){\\n        int i = 0, j = 1;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        while(j<n){\\n            if(nums[i]!=nums[j]){\\n                nums[++i] = nums[j];\\n            }\\n            j++;\\n        }\\n        int rem = n-1-i;\\n        while(rem--){\\n            nums.pop_back();\\n        }\\n    }\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        removeDUP(nums1);\\n        removeDUP(nums2);\\n        removeDUP(nums3);\\n        unordered_map<int,int> mp;\\n        for(auto it:nums1){\\n            mp[it]++;\\n        }\\n        for(auto it:nums2){\\n            mp[it]++;\\n        }\\n        for(auto it:nums3){\\n            mp[it]++;\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it:mp){\\n            if(it.second>=2){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051524,
                "title": "100-0ms-concise-code",
                "content": "```\\npublic List<Integer> twoOutOfThree(int[] a1, int[] a2, int[] a3) {\\n        int[][] a = {a1, a2, a3}, c = new int[3][101];\\n        for (int i = 0; i < a.length; i++)\\n            for (int n : a[i])\\n                c[i][n] = 1;\\n        return IntStream.range(1, 101).filter(n -> c[0][n] + c[1][n] + c[2][n] >= 2).boxed().collect(Collectors.toList());\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\npublic List<Integer> twoOutOfThree(int[] a1, int[] a2, int[] a3) {\\n        int[][] a = {a1, a2, a3}, c = new int[3][101];\\n        for (int i = 0; i < a.length; i++)\\n            for (int n : a[i])\\n                c[i][n] = 1;\\n        return IntStream.range(1, 101).filter(n -> c[0][n] + c[1][n] + c[2][n] >= 2).boxed().collect(Collectors.toList());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045983,
                "title": "java-o-n-m-k",
                "content": "```\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] bool1 = new boolean[101];\\n        boolean[] bool2 = new boolean[101];\\n        boolean[] bool3 = new boolean[101];\\n\\n        for (int i : nums1) bool1[i] = true;\\n        for (int i : nums2) bool2[i] = true;\\n        for (int i : nums3) bool3[i] = true;\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < bool1.length; i++) {\\n            if (bool1[i] && bool2[i]\\n                    || bool2[i] && bool3[i]\\n                    || bool1[i] && bool3[i]) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] bool1 = new boolean[101];\\n        boolean[] bool2 = new boolean[101];\\n        boolean[] bool3 = new boolean[101];\\n\\n        for (int i : nums1) bool1[i] = true;\\n        for (int i : nums2) bool2[i] = true;\\n        for (int i : nums3) bool3[i] = true;\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < bool1.length; i++) {\\n            if (bool1[i] && bool2[i]\\n                    || bool2[i] && bool3[i]\\n                    || bool1[i] && bool3[i]) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041066,
                "title": "c-solution",
                "content": "\\n      \\n      /**\\n       * Note: The returned array must be malloced, assume caller calls free().\\n       */\\n\\t\\t  int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize)\\n      {\\n          \\n          int *arr = (int*)malloc(sizeof(int) * 100);\\n          int counter = 0;\\n          int hashtable[101]  = {0};\\n          int hashtable1[101] = {0};\\n          int hashtable2[101] = {0};\\n      \\n          \\n          \\n          for ( int i = 0 ; i < nums1Size ; i++)\\n          {\\n              if ( hashtable[nums1[i]] == 0)\\n              {\\n                  hashtable[nums1[i]]++;\\n              }\\n          }\\n          \\n          \\n        for ( int i = 0 ; i < nums2Size ; i++)\\n          {\\n              if ( hashtable1[nums2[i]] == 0 )\\n              {\\n                  hashtable1[nums2[i]]++;\\n              }   \\n          } \\n          \\n          \\n          for ( int i = 0 ; i < nums3Size ; i++)\\n          {\\n              if ( hashtable2[nums3[i]] == 0 )\\n              {\\n                  hashtable2[nums3[i]]++;\\n              }\\n          } \\n          \\n          \\n          \\n          for ( int i = 0 ; i < 101 ; i++)\\n          {\\n              if (  (hashtable[i] + hashtable1[i]+  hashtable2[i]) >= 2)\\n              {\\n                  arr[counter] = i;\\n                  counter++;\\n              }\\n              \\n          }\\n          \\n          * returnSize  = counter;\\n          \\n          \\n          return arr;\\n      \\n      }",
                "solutionTags": [],
                "code": "\\n      \\n      /**\\n       * Note: The returned array must be malloced, assume caller calls free().\\n       */\\n\\t\\t  int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize)\\n      {\\n          \\n          int *arr = (int*)malloc(sizeof(int) * 100);\\n          int counter = 0;\\n          int hashtable[101]  = {0};\\n          int hashtable1[101] = {0};\\n          int hashtable2[101] = {0};\\n      \\n          \\n          \\n          for ( int i = 0 ; i < nums1Size ; i++)\\n          {\\n              if ( hashtable[nums1[i]] == 0)\\n              {\\n                  hashtable[nums1[i]]++;\\n              }\\n          }\\n          \\n          \\n        for ( int i = 0 ; i < nums2Size ; i++)\\n          {\\n              if ( hashtable1[nums2[i]] == 0 )\\n              {\\n                  hashtable1[nums2[i]]++;\\n              }   \\n          } \\n          \\n          \\n          for ( int i = 0 ; i < nums3Size ; i++)\\n          {\\n              if ( hashtable2[nums3[i]] == 0 )\\n              {\\n                  hashtable2[nums3[i]]++;\\n              }\\n          } \\n          \\n          \\n          \\n          for ( int i = 0 ; i < 101 ; i++)\\n          {\\n              if (  (hashtable[i] + hashtable1[i]+  hashtable2[i]) >= 2)\\n              {\\n                  arr[counter] = i;\\n                  counter++;\\n              }\\n              \\n          }\\n          \\n          * returnSize  = counter;\\n          \\n          \\n          return arr;\\n      \\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 2035913,
                "title": "one-line-python-solution-two-out-of-three",
                "content": "\\n        return (set(nums1)& set(nums2))|(set(nums2)& set(nums3))|(set(nums1)& set(nums3))\\n",
                "solutionTags": [],
                "code": "\\n        return (set(nums1)& set(nums2))|(set(nums2)& set(nums3))|(set(nums1)& set(nums3))\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1968701,
                "title": "efficiency-better-than-98-simple-application-of-sets",
                "content": "Keep time complexity to O(n) with help of clever usage of sets.\\n\\n\\n```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        \\n        main_set = set()\\n        \\n        num = list(set(nums1)) + list(set(nums2)) + list(set(nums3))\\n        result = set()\\n        for ele in num:\\n            if ele in main_set:\\n                result.add(ele)\\n            main_set.add(ele)\\n            \\n        return list(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        \\n        main_set = set()\\n        \\n        num = list(set(nums1)) + list(set(nums2)) + list(set(nums3))\\n        result = set()\\n        for ele in num:\\n            if ele in main_set:\\n                result.add(ele)\\n            main_set.add(ele)\\n            \\n        return list(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940755,
                "title": "fastest-java-solution-using-hashmap-hashset",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) \\n    {\\n        List<Integer> list=new ArrayList<>();\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        HashSet<Integer> hset=new HashSet<>();\\n        for(int i:nums1)\\n            if(!hmap.containsKey(i))\\n                hmap.put(i,1);\\n        \\n        for(int i:nums2)\\n        {\\n            if(!hmap.containsKey(i))\\n            {\\n                hmap.put(i,1);\\n                hset.add(i);\\n            }\\n            else\\n                if(!hset.contains(i))\\n                    hmap.put(i,2);\\n        }\\n        \\n        for(int i:nums3)\\n            if(hmap.containsKey(i))\\n                hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        \\n        for(Integer key:hmap.keySet())\\n            if(hmap.get(key)>1)\\n                list.add(key);\\n        \\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) \\n    {\\n        List<Integer> list=new ArrayList<>();\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        HashSet<Integer> hset=new HashSet<>();\\n        for(int i:nums1)\\n            if(!hmap.containsKey(i))\\n                hmap.put(i,1);\\n        \\n        for(int i:nums2)\\n        {\\n            if(!hmap.containsKey(i))\\n            {\\n                hmap.put(i,1);\\n                hset.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1923579,
                "title": "java-solution-using-set",
                "content": "```\\nclass Solution {\\n   \\n   \\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\n        Set<Integer> values = new HashSet<>();\\n        Set<Integer> values2 = new HashSet<>();\\n        Set<Integer> values3 = new HashSet<>();\\n\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            values.add(nums1[i]);\\n        }\\n        for (int i = 0; i < nums2.length; i++) {\\n            values2.add(nums2[i]);\\n        }\\n        for (int i = 0; i < nums3.length; i++) {\\n            values3.add(nums3[i]);\\n        }\\n        for (int i = 0; i <= 100; i++) {\\n            if ((values.contains(i) && values2.contains(i))\\n                    || (values.contains(i) && values3.contains(i))\\n                    || (values2.contains(i) && values3.contains(i)))\\n                result.add(i);\\n        }\\n\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n   \\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\n        Set<Integer> values = new HashSet<>();\\n        Set<Integer> values2 = new HashSet<>();\\n        Set<Integer> values3 = new HashSet<>();\\n\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            values.add(nums1[i]);\\n        }\\n        for (int i = 0; i < nums2.length; i++) {\\n            values2.add(nums2[i]);\\n        }\\n        for (int i = 0; i < nums3.length; i++) {\\n            values3.add(nums3[i]);\\n        }\\n        for (int i = 0; i <= 100; i++) {\\n            if ((values.contains(i) && values2.contains(i))\\n                    || (values.contains(i) && values3.contains(i))\\n                    || (values2.contains(i) && values3.contains(i)))\\n                result.add(i);\\n        }\\n\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901617,
                "title": "python-set-and-dictionary-faster-than-87",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\t\\t#Convert to set and then to list again (To remove duplicates)\\n        nums1, nums2, nums3 = list(set(nums1)), list(set(nums2)), list(set(nums3))\\n        \\n\\t\\t#Iterate over the longest array\\n\\t\\tln = [len(nums1), len(nums2), len(nums3)]\\n        n = max(ln)\\n\\t\\t\\n\\t\\t#Empty Dictionary as a counter\\n        keys = {}\\n\\n        for i in range(n):\\n            if i<len(nums1):\\n\\t\\t\\t\\t#Check it number already there, if there add to counter,\\n\\t\\t\\t\\t#else add to the dict\\n                if nums1[i] not in keys:\\n                    keys[nums1[i]]=1\\n                else:\\n                    keys[nums1[i]]+=1\\n            if i<len(nums2):\\n                if nums2[i] not in keys:\\n                    keys[nums2[i]]=1\\n                else:\\n                    keys[nums2[i]]+=1\\n            if i<len(nums3):\\n                if nums3[i] not in keys:\\n                    keys[nums3[i]]=1\\n                else:\\n                    keys[nums3[i]]+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t#Check which numbers have count>=2, and add to list\\n        res = []\\n        for k, v in keys.items():\\n            if v>1:\\n                res.append(k)\\n                \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\t\\t#Convert to set and then to list again (To remove duplicates)\\n        nums1, nums2, nums3 = list(set(nums1)), list(set(nums2)), list(set(nums3))\\n        \\n\\t\\t#Iterate over the longest array\\n\\t\\tln = [len(nums1), len(nums2), len(nums3)]\\n        n = max(ln)\\n\\t\\t\\n\\t\\t#Empty Dictionary as a counter\\n        keys = {}\\n\\n        for i in range(n):\\n            if i<len(nums1):\\n\\t\\t\\t\\t#Check it number already there, if there add to counter,\\n\\t\\t\\t\\t#else add to the dict\\n                if nums1[i] not in keys:\\n                    keys[nums1[i]]=1\\n                else:\\n                    keys[nums1[i]]+=1\\n            if i<len(nums2):\\n                if nums2[i] not in keys:\\n                    keys[nums2[i]]=1\\n                else:\\n                    keys[nums2[i]]+=1\\n            if i<len(nums3):\\n                if nums3[i] not in keys:\\n                    keys[nums3[i]]=1\\n                else:\\n                    keys[nums3[i]]+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t#Check which numbers have count>=2, and add to list\\n        res = []\\n        for k, v in keys.items():\\n            if v>1:\\n                res.append(k)\\n                \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898003,
                "title": "typescript-set-solution-faster-than-100",
                "content": "```\\nfunction twoOutOfThree(nums1: number[], nums2: number[], nums3: number[]): number[] {\\n    const set = new Set<number>()\\n    for (let num of nums1) {\\n        if (nums2.includes(num) || nums3.includes(num)) {\\n            set.add(num)\\n        }\\n    }\\n    \\n    for (let num of nums2) {\\n        if (nums3.includes(num)) {\\n            set.add(num)\\n        }\\n    }\\n    return Array.from(set)\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction twoOutOfThree(nums1: number[], nums2: number[], nums3: number[]): number[] {\\n    const set = new Set<number>()\\n    for (let num of nums1) {\\n        if (nums2.includes(num) || nums3.includes(num)) {\\n            set.add(num)\\n        }\\n    }\\n    \\n    for (let num of nums2) {\\n        if (nums3.includes(num)) {\\n            set.add(num)\\n        }\\n    }\\n    return Array.from(set)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872809,
                "title": "2032-two-out-of-three-3-hashmap-8ms-41-2mb-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashMap<Integer , Integer> map1 = new HashMap<>();\\n        HashMap<Integer , Integer> map2 = new HashMap<>();\\n        HashMap<Integer , Integer> map3 = new HashMap<>();\\n        \\n        for(int i=0; i<nums1.length; i++)\\n        {\\n            map1.put(nums1[i] , 1);\\n        }\\n        for(int i=0; i<nums2.length; i++)\\n        {\\n            map2.put(nums2[i] , 1);\\n        }\\n        for(int i=0; i<nums3.length; i++)\\n        {\\n            map3.put(nums3[i] , 1);\\n        }\\n        \\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0; i<nums2.length; i++)\\n        {\\n            if(map1.containsKey(nums2[i]) || map3.containsKey(nums2[i]))\\n            {\\n                if(!arr.contains(nums2[i]))\\n                {\\n                    arr.add(nums2[i]);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<nums3.length; i++)\\n        {\\n            if(map1.containsKey(nums3[i]) || map2.containsKey(nums3[i]))\\n            {\\n                if(!arr.contains(nums3[i]))\\n                {\\n                    arr.add(nums3[i]);\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\nIf you like it please **UPVOTE**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashMap<Integer , Integer> map1 = new HashMap<>();\\n        HashMap<Integer , Integer> map2 = new HashMap<>();\\n        HashMap<Integer , Integer> map3 = new HashMap<>();\\n        \\n        for(int i=0; i<nums1.length; i++)\\n        {\\n            map1.put(nums1[i] , 1);\\n        }\\n        for(int i=0; i<nums2.length; i++)\\n        {\\n            map2.put(nums2[i] , 1);\\n        }\\n        for(int i=0; i<nums3.length; i++)\\n        {\\n            map3.put(nums3[i] , 1);\\n        }\\n        \\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0; i<nums2.length; i++)\\n        {\\n            if(map1.containsKey(nums2[i]) || map3.containsKey(nums2[i]))\\n            {\\n                if(!arr.contains(nums2[i]))\\n                {\\n                    arr.add(nums2[i]);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<nums3.length; i++)\\n        {\\n            if(map1.containsKey(nums3[i]) || map2.containsKey(nums3[i]))\\n            {\\n                if(!arr.contains(nums3[i]))\\n                {\\n                    arr.add(nums3[i]);\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859650,
                "title": "python-efficient-solution",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        all_distinct = set(nums1 + nums2 + nums3)\\n        count = 0\\n        res = []\\n        for i in all_distinct:\\n            if i in nums1:\\n                count += 1\\n            if i in nums2:\\n                count += 1\\n            if i in nums3:\\n                count += 1\\n            if count >= 2:\\n                res.append(i)\\n            count = 0\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        all_distinct = set(nums1 + nums2 + nums3)\\n        count = 0\\n        res = []\\n        for i in all_distinct:\\n            if i in nums1:\\n                count += 1\\n            if i in nums2:\\n                count += 1\\n            if i in nums3:\\n                count += 1\\n            if count >= 2:\\n                res.append(i)\\n            count = 0\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1769867,
                "title": "javascript-easy-accepted-solution-runtime-84-ms",
                "content": "![image](https://assets.leetcode.com/users/images/996c86e2-a97b-40f7-9156-0debc6a4d347_1644818639.1404116.png)\\n\\n```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let arr = [];\\n    let ans = [];\\n    for (let i = 1; i < 101; i++) {\\n        arr.push(i);\\n    }\\n    for (const val of arr) {\\n        if(\\n            nums1.includes(val) && nums2.includes(val) ||\\n            nums2.includes(val) && nums3.includes(val) ||\\n            nums3.includes(val) && nums1.includes(val)\\n        ){\\n            ans.push(val);\\n        }\\n    }\\n    return ans;\\n};",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/996c86e2-a97b-40f7-9156-0debc6a4d347_1644818639.1404116.png)\\n\\n```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let arr = [];\\n    let ans = [];\\n    for (let i = 1; i < 101; i++) {\\n        arr.push(i);\\n    }\\n    for (const val of arr) {\\n        if(\\n            nums1.includes(val) && nums2.includes(val) ||\\n            nums2.includes(val) && nums3.includes(val) ||\\n            nums3.includes(val) && nums1.includes(val)\\n        ){\\n            ans.push(val);\\n        }\\n    }\\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1763977,
                "title": "c-interesting-solution-12ms-using-hash-table",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n      unordered_map<int,int> hash;\\n        vector<int> output;\\n        sort( nums1.begin(), nums1.end() );\\n        nums1.erase( unique( nums1.begin(), nums1.end() ), nums1.end() ); // remove duplicates\\n        sort( nums2.begin(), nums2.end() );\\n        nums2.erase( unique( nums2.begin(), nums2.end() ), nums2.end() );\\n        sort( nums3.begin(), nums3.end() );\\n        nums3.erase( unique( nums3.begin(), nums3.end() ), nums3.end() );\\n        for(int i = 0; i < nums1.size();i++){\\n            hash[nums1[i]] += 1;\\n        }\\n        for(int i = 0; i < nums2.size();i++){\\n            hash[nums2[i]] += 1;\\n            if(hash[nums2[i]] >= 2){\\n                output.push_back(nums2[i]);\\n            }\\n            \\n        }\\n        for(int i = 0; i < nums3.size();i++){\\n            hash[nums3[i]] += 1;\\n            if(hash[nums3[i]] >= 2){\\n                output.push_back(nums3[i]);\\n            }\\n        }\\n        sort( output.begin(), output.end() );\\n        output.erase( unique( output.begin(), output.end() ), output.end() );\\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n      unordered_map<int,int> hash;\\n        vector<int> output;\\n        sort( nums1.begin(), nums1.end() );\\n        nums1.erase( unique( nums1.begin(), nums1.end() ), nums1.end() ); // remove duplicates\\n        sort( nums2.begin(), nums2.end() );\\n        nums2.erase( unique( nums2.begin(), nums2.end() ), nums2.end() );\\n        sort( nums3.begin(), nums3.end() );\\n        nums3.erase( unique( nums3.begin(), nums3.end() ), nums3.end() );\\n        for(int i = 0; i < nums1.size();i++){\\n            hash[nums1[i]] += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1754346,
                "title": "java-solution-using-arraylist",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n         ArrayList<Integer> al = new ArrayList<>();\\n\\t\\t \\n     ArrayList<Integer> al1 = new ArrayList<>();\\n      for(int i=0; i<nums1.length; i++){\\n          if(!al1.contains(nums1[i])){\\n              al1.add(nums1[i]);\\n          }\\n      }\\n       ArrayList<Integer> al2 = new ArrayList<>();\\n      for(int i=0; i<nums2.length; i++){\\n          if(!al2.contains(nums2[i])){\\n              al2.add(nums2[i]);\\n          }\\n      }\\n        ArrayList<Integer> al3 = new ArrayList<>();\\n      for(int i=0; i<nums3.length; i++){\\n          if(!al3.contains(nums3[i])){\\n              al3.add(nums3[i]);\\n          }\\n      }\\n      int[] a = new int[101];\\n      for(int i=0; i<al1.size(); i++){\\n    \\t  int val = al1.get(i);\\n          a[val]++;\\n      }\\n      for(int i=0; i<al2.size(); i++){\\n    \\t  int val = al2.get(i);\\n          a[val]++;\\n      }\\n      for(int i=0; i<al3.size(); i++){\\n    \\t  int val = al3.get(i);\\n          a[val]++;\\n      }\\n        for(int i=0; i<a.length; i++){\\n            if(a[i] >= 2){\\n                al.add(i);\\n            }\\n        }\\n      return al;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n         ArrayList<Integer> al = new ArrayList<>();\\n\\t\\t \\n     ArrayList<Integer> al1 = new ArrayList<>();\\n      for(int i=0; i<nums1.length; i++){\\n          if(!al1.contains(nums1[i])){\\n              al1.add(nums1[i]);\\n          }\\n      }\\n       ArrayList<Integer> al2 = new ArrayList<>();\\n      for(int i=0; i<nums2.length; i++){\\n          if(!al2.contains(nums2[i])){\\n              al2.add(nums2[i]);\\n          }\\n      }\\n        ArrayList<Integer> al3 = new ArrayList<>();\\n      for(int i=0; i<nums3.length; i++){\\n          if(!al3.contains(nums3[i])){\\n              al3.add(nums3[i]);\\n          }\\n      }\\n      int[] a = new int[101];\\n      for(int i=0; i<al1.size(); i++){\\n    \\t  int val = al1.get(i);\\n          a[val]++;\\n      }\\n      for(int i=0; i<al2.size(); i++){\\n    \\t  int val = al2.get(i);\\n          a[val]++;\\n      }\\n      for(int i=0; i<al3.size(); i++){\\n    \\t  int val = al3.get(i);\\n          a[val]++;\\n      }\\n        for(int i=0; i<a.length; i++){\\n            if(a[i] >= 2){\\n                al.add(i);\\n            }\\n        }\\n      return al;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726760,
                "title": "c-one-line-linq",
                "content": "```\\n public static IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) =>\\n            nums1.Intersect(nums2).Concat(nums3.Intersect(nums2)).Concat(nums1.Intersect(nums3)).Distinct().ToList();\\n``` \\n",
                "solutionTags": [],
                "code": "```\\n public static IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) =>\\n            nums1.Intersect(nums2).Concat(nums3.Intersect(nums2)).Concat(nums1.Intersect(nums3)).Distinct().ToList();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703844,
                "title": "c-time-complexity-o-n-space-complexity-o-n-hash-set-and-searching",
                "content": "```\\n/*\\n * author: deytulsi18\\n * problem: https://leetcode.com/problems/two-out-of-three/\\n * time complexity: O(n)\\n * space complexity: O(n)\\n * language: cpp\\n */\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_set<int> freq;\\n        unordered_set<int> temp;\\n        vector<int> res;\\n        \\n        for (auto i : nums1) freq.insert(i);\\n        \\n        for (auto i : nums2)\\n            if (freq.find(i) != freq.end())\\n                temp.insert(i);\\n        \\n        for (auto i : nums2) freq.insert(i);\\n\\n        for (auto i : nums3)\\n            if (freq.find(i) != freq.end())\\n                temp.insert(i);\\n        \\n        for (auto i : temp)\\n            res.emplace_back(i);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n * author: deytulsi18\\n * problem: https://leetcode.com/problems/two-out-of-three/\\n * time complexity: O(n)\\n * space complexity: O(n)\\n * language: cpp\\n */\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_set<int> freq;\\n        unordered_set<int> temp;\\n        vector<int> res;\\n        \\n        for (auto i : nums1) freq.insert(i);\\n        \\n        for (auto i : nums2)\\n            if (freq.find(i) != freq.end())\\n                temp.insert(i);\\n        \\n        for (auto i : nums2) freq.insert(i);\\n\\n        for (auto i : nums3)\\n            if (freq.find(i) != freq.end())\\n                temp.insert(i);\\n        \\n        for (auto i : temp)\\n            res.emplace_back(i);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687005,
                "title": "2032-two-out-of-three-c-map-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, unordered_set<int>> map;\\n        for(auto& i : nums1) map[i].insert(1);\\n        for(auto& i : nums2) map[i].insert(2);\\n        for(auto& i : nums3) map[i].insert(3);\\n        vector<int> ans;\\n        for(auto& [x, y] : map){\\n            if(y.size() >= 2) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, unordered_set<int>> map;\\n        for(auto& i : nums1) map[i].insert(1);\\n        for(auto& i : nums2) map[i].insert(2);\\n        for(auto& i : nums3) map[i].insert(3);\\n        vector<int> ans;\\n        for(auto& [x, y] : map){\\n            if(y.size() >= 2) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645672,
                "title": "rust-linear-scan-with-hashset",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc2032)\\n\\n```\\nuse std::collections::HashSet;\\n/// @author: LEon\\n/// https://leetcode.com/problems/two-out-of-three/\\n/// Time Complexity:    O(`_len_n1` + `_len_n2` + `_len_n3`)\\n/// Space Complexity:   O(`_len_n1` + `_len_n2` + `_len_n3`)\\nimpl Solution {\\n    const RANGE: usize = 100 + 1;\\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\\n        let mut vec_num_to_set: Vec<HashSet<i32>> = vec![HashSet::new(); Self::RANGE];\\n        for num in nums1{\\n            vec_num_to_set[num as usize].insert(1);\\n        }\\n        for num in nums2{\\n            vec_num_to_set[num as usize].insert(2);\\n        }\\n        for num in nums3{\\n            vec_num_to_set[num as usize].insert(3);\\n        }\\n        let ans: Vec<i32> = {\\n            let mut ans: Vec<i32> = Vec::new();\\n            for (idx, hs) in vec_num_to_set.into_iter().enumerate() {\\n                if hs.len() >= 2 {\\n                    ans.push(idx as i32);\\n                }\\n            }\\n            ans\\n        };\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n/// @author: LEon\\n/// https://leetcode.com/problems/two-out-of-three/\\n/// Time Complexity:    O(`_len_n1` + `_len_n2` + `_len_n3`)\\n/// Space Complexity:   O(`_len_n1` + `_len_n2` + `_len_n3`)\\nimpl Solution {\\n    const RANGE: usize = 100 + 1;\\n    pub fn two_out_of_three(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>) -> Vec<i32> {\\n        let mut vec_num_to_set: Vec<HashSet<i32>> = vec![HashSet::new(); Self::RANGE];\\n        for num in nums1{\\n            vec_num_to_set[num as usize].insert(1);\\n        }\\n        for num in nums2{\\n            vec_num_to_set[num as usize].insert(2);\\n        }\\n        for num in nums3{\\n            vec_num_to_set[num as usize].insert(3);\\n        }\\n        let ans: Vec<i32> = {\\n            let mut ans: Vec<i32> = Vec::new();\\n            for (idx, hs) in vec_num_to_set.into_iter().enumerate() {\\n                if hs.len() >= 2 {\\n                    ans.push(idx as i32);\\n                }\\n            }\\n            ans\\n        };\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1637668,
                "title": "java-solution",
                "content": "class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> ans=new ArrayList<>();\\n        Map<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n          hm.put(nums1[i],1);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(hm.containsKey(nums2[i]) && hm.get(nums2[i])==1 && ans.contains(nums2[i])==false)\\n            ans.add(nums2[i]);\\n            else\\n                hm.put(nums2[i],2);\\n        }\\n        for(int i=0;i<nums3.length;i++)\\n        {\\n            if(hm.containsKey(nums3[i]) && ans.contains(nums3[i])==false)\\n            ans.add(nums3[i]);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> ans=new ArrayList<>();\\n        Map<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n          hm.put(nums1[i],1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1634060,
                "title": "java-sets-clean-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> hs = new HashSet<Integer>();\\n        Set<Integer> ans = new HashSet<Integer>();\\n        findContains(hs, ans, nums1);\\n        findContains(hs, ans, nums2);\\n        findContains(hs, ans, nums3);\\n        return new ArrayList(ans);\\n    }\\n    \\n    public void findContains(Set<Integer> hs, Set<Integer> ans, int[] nums){\\n        Set<Integer> temp = new HashSet<Integer>();\\n        for(int num : nums){\\n            if(hs.contains(num))\\n                ans.add(num);\\n            temp.add(num);\\n        }\\n        hs.addAll(temp);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> hs = new HashSet<Integer>();\\n        Set<Integer> ans = new HashSet<Integer>();\\n        findContains(hs, ans, nums1);\\n        findContains(hs, ans, nums2);\\n        findContains(hs, ans, nums3);\\n        return new ArrayList(ans);\\n    }\\n    \\n    public void findContains(Set<Integer> hs, Set<Integer> ans, int[] nums){\\n        Set<Integer> temp = new HashSet<Integer>();\\n        for(int num : nums){\\n            if(hs.contains(num))\\n                ans.add(num);\\n            temp.add(num);\\n        }\\n        hs.addAll(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615212,
                "title": "simple-python-code",
                "content": "class Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        li=[]\\n        for i in nums1:\\n            if i in nums2 or i in nums3:\\n                li.append(i)\\n        for i in nums2:\\n            if i in nums1 or i in nums3:\\n                li.append(i)\\n        for i in nums3:\\n            if i in nums2 or i in nums1:\\n                li.append(i)\\n* return set(li)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        li=[]\\n        for i in nums1:\\n            if i in nums2 or i in nums3:\\n                li.append(i)\\n        for i in nums2:\\n            if i in nums1 or i in nums3:\\n                li.append(i)\\n        for i in nums3:\\n            if i in nums2 or i in nums1:\\n                li.append(i)\\n* return set(li)",
                "codeTag": "Java"
            },
            {
                "id": 1614436,
                "title": "c-mad",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map <int, int> d;\\n        vector<int> ans;\\n        \\n        set<int> s1(begin(nums1), end(nums1));\\n        set<int> s2(begin(nums2), end(nums2));\\n        set<int> s3(begin(nums3), end(nums3));\\n               \\n        vector<int> v1(begin(s1), end(s1));\\n        vector<int> v2(begin(s2), end(s2));\\n        vector<int> v3(begin(s3), end(s3));\\n        \\n        v1.insert(end(v1), begin(v2), end(v2));\\n        v1.insert(end(v1), begin(v3), end(v3));\\n        \\n        for (auto el: v1)\\n            d[el]++;\\n        \\n        for (auto [key, value]: d)\\n            if (value >= 2)\\n                ans.push_back(key);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        map <int, int> d;\\n        vector<int> ans;\\n        \\n        set<int> s1(begin(nums1), end(nums1));\\n        set<int> s2(begin(nums2), end(nums2));\\n        set<int> s3(begin(nums3), end(nums3));\\n               \\n        vector<int> v1(begin(s1), end(s1));\\n        vector<int> v2(begin(s2), end(s2));\\n        vector<int> v3(begin(s3), end(s3));\\n        \\n        v1.insert(end(v1), begin(v2), end(v2));\\n        v1.insert(end(v1), begin(v3), end(v3));\\n        \\n        for (auto el: v1)\\n            d[el]++;\\n        \\n        for (auto [key, value]: d)\\n            if (value >= 2)\\n                ans.push_back(key);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610007,
                "title": "java-solution",
                "content": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int hash1[] = new int[101], hash2[] = new int[101], \\n        hash3[] = new int[101];\\n        for(int i: nums1) hash1[i]++;\\n        for(int i: nums2) hash2[i]++;\\n        for(int i: nums3) hash3[i]++;\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 1; i < 101; i++){\\n            if(hash1[i] > 0 && hash2[i] > 0){\\n                ans.add(i);\\n            }else if(hash2[i] > 0 && hash3[i] > 0){\\n                ans.add(i);\\n            }else if(hash1[i] > 0 && hash3[i] > 0){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int hash1[] = new int[101], hash2[] = new int[101], \\n        hash3[] = new int[101];\\n        for(int i: nums1) hash1[i]++;\\n        for(int i: nums2) hash2[i]++;\\n        for(int i: nums3) hash3[i]++;\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 1; i < 101; i++){\\n            if(hash1[i] > 0 && hash2[i] > 0){\\n                ans.add(i);\\n            }else if(hash2[i] > 0 && hash3[i] > 0){\\n                ans.add(i);\\n            }else if(hash1[i] > 0 && hash3[i] > 0){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1603640,
                "title": "python-set-and-list",
                "content": "```\\n\\nclass Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        s12 = set(nums1) & set(nums2)\\n        s13 = set(nums1) & set(nums3)\\n        s23 = set(nums2) & set(nums3)\\n        return set(list(s12) + list(s13) + list(s23))\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        s12 = set(nums1) & set(nums2)\\n        s13 = set(nums1) & set(nums3)\\n        s23 = set(nums2) & set(nums3)\\n        return set(list(s12) + list(s13) + list(s23))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597176,
                "title": "using-unordered-map-and-unordered-set-c-lengthy-but-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3)\\n    {\\n        unordered_map<int,int>mp1,mp2,mp3;\\n        vector<int>ans;\\n        unordered_set<int>s;\\n        \\n        for(auto x:nums1){\\n            mp1[x]++;\\n        }\\n        \\n        for(auto x:nums2){\\n            mp2[x]++;\\n        }\\n        \\n        for(auto x:nums3){\\n            mp3[x]++;\\n        }\\n        \\n       for(auto x:nums2){\\n            if(mp1.count(x)||mp3.count(x)){\\n                s.insert(x);\\n            }\\n       }\\n           \\n           for(auto x:nums1){\\n            if(mp2.count(x)||mp3.count(x))\\n            {\\n                s.insert(x);\\n            }\\n               \\n            }\\n               \\n               for(auto x:nums3){\\n            if(mp1.count(x)||mp2.count(x)){\\n                s.insert(x);\\n            }\\n               }\\n                   for(auto x:s){\\n                       ans.push_back(x);\\n                   }\\n                   \\n                   return ans;\\n                   \\n        }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3)\\n    {\\n        unordered_map<int,int>mp1,mp2,mp3;\\n        vector<int>ans;\\n        unordered_set<int>s;\\n        \\n        for(auto x:nums1){\\n            mp1[x]++;\\n        }\\n        \\n        for(auto x:nums2){\\n            mp2[x]++;\\n        }\\n        \\n        for(auto x:nums3){\\n            mp3[x]++;\\n        }\\n        \\n       for(auto x:nums2){\\n            if(mp1.count(x)||mp3.count(x)){\\n                s.insert(x);\\n            }\\n       }\\n           \\n           for(auto x:nums1){\\n            if(mp2.count(x)||mp3.count(x))\\n            {\\n                s.insert(x);\\n            }\\n               \\n            }\\n               \\n               for(auto x:nums3){\\n            if(mp1.count(x)||mp2.count(x)){\\n                s.insert(x);\\n            }\\n               }\\n                   for(auto x:s){\\n                       ans.push_back(x);\\n                   }\\n                   \\n                   return ans;\\n                   \\n        }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584519,
                "title": "js-89-faster",
                "content": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let map = new Map();\\n    let set=new Set();\\n    \\n    for(let j = 0; j<3; j++){\\n       let arr = j===0? nums1:j===1?nums2 :nums3; \\n       for(let i=0; i<arr.length; i++ ){\\n            if(map.has(arr[i]) ===false){\\n                map.set(arr[i], new Set([j]));\\n            }else{\\n                let newset = map.get(arr[i]).add(j);\\n                map.set(arr[i], newset);\\n                if(newset.size>=2){\\n                   set.add(arr[i]);\\n                }\\n            }\\n        }\\n    }\\n    return  Array.from(set);\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    let map = new Map();\\n    let set=new Set();\\n    \\n    for(let j = 0; j<3; j++){\\n       let arr = j===0? nums1:j===1?nums2 :nums3; \\n       for(let i=0; i<arr.length; i++ ){\\n            if(map.has(arr[i]) ===false){\\n                map.set(arr[i], new Set([j]));\\n            }else{\\n                let newset = map.get(arr[i]).add(j);\\n                map.set(arr[i], newset);\\n                if(newset.size>=2){\\n                   set.add(arr[i]);\\n                }\\n            }\\n        }\\n    }\\n    return  Array.from(set);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579629,
                "title": "python-brute-force-solution",
                "content": "```\\ndef twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        l=[]\\n        for i in nums1:\\n            if (i in nums2 or i in nums3) and (i not in l):\\n                l.append(i)\\n        for j in nums2:\\n            if (j in nums1 or j in nums3) and (j not in l):\\n                l.append(j)\\n        for k in nums3:\\n            if (k in nums1 or k in nums2) and (k not in l):\\n                l.append(k)\\n        return l\\n```\\nNot the fastest, but a simple brute force solution :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        l=[]\\n        for i in nums1:\\n            if (i in nums2 or i in nums3) and (i not in l):\\n                l.append(i)\\n        for j in nums2:\\n            if (j in nums1 or j in nums3) and (j not in l):\\n                l.append(j)\\n        for k in nums3:\\n            if (k in nums1 or k in nums2) and (k not in l):\\n                l.append(k)\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1568487,
                "title": "the-fastest-minumum-memory-usage-solution-using-bit-representation",
                "content": "Which array the number exists can be expressed in bits.\\nSo we don\\'t need to use map or multiple array.\\n\\nFor example, \\n000 -> That number is not in any array.\\n001 -> That number is in nums1 array.\\n010 -> That number is in nums2 array.\\n100 -> That number is in nums3 array.\\n011 -> That number is in nums1 & nums2 array.\\n\\n\\n```golang\\nfunc twoOutOfThree(nums1 []int, nums2 []int, nums3 []int) []int {\\n    res := []int{}\\n    arr := make([]int, 101)\\n    \\n    for _, n := range nums1 { arr[n] = arr[n]|1 }\\n    for _, n := range nums2 { arr[n] = arr[n]|2 }\\n    for _, n := range nums3 { arr[n] = arr[n]|4 }\\n    \\n    for i := 1; i <= 100; i++ {\\n        if arr[i]!=4 && arr[i]>=3 {\\n            res = append(res, i)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc twoOutOfThree(nums1 []int, nums2 []int, nums3 []int) []int {\\n    res := []int{}\\n    arr := make([]int, 101)\\n    \\n    for _, n := range nums1 { arr[n] = arr[n]|1 }\\n    for _, n := range nums2 { arr[n] = arr[n]|2 }\\n    for _, n := range nums3 { arr[n] = arr[n]|4 }\\n    \\n    for i := 1; i <= 100; i++ {\\n        if arr[i]!=4 && arr[i]>=3 {\\n            res = append(res, i)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566419,
                "title": "python3-solution-faster-than-99-04-solutions",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        \\n        arr = []\\n        arr.extend(list(set(nums1)))\\n        arr.extend(list(set(nums2)))\\n        arr.extend(list(set(nums3)))\\n        \\n        hm = {}\\n        \\n        for num in arr:\\n            if num in hm:\\n                hm[num] += 1\\n                \\n            else:\\n                hm[num] = 1\\n                \\n        return [key for key,val in hm.items() if val > 1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        \\n        arr = []\\n        arr.extend(list(set(nums1)))\\n        arr.extend(list(set(nums2)))\\n        arr.extend(list(set(nums3)))\\n        \\n        hm = {}\\n        \\n        for num in arr:\\n            if num in hm:\\n                hm[num] += 1\\n                \\n            else:\\n                hm[num] = 1\\n                \\n        return [key for key,val in hm.items() if val > 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562900,
                "title": "javascript-simple-solution-w-explanation",
                "content": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n\\t// check if arr2/arr3 contains numbers from arr1\\n    const arr1 = nums1.filter(num => {\\n        return nums2.includes(num) || nums3.includes(num) ? true : false\\n    })\\n    \\n\\t// check if arr1/arr3 contains numbers from arr2\\n    const arr2 = nums2.filter(num => {\\n        return nums1.includes(num) || nums3.includes(num) ? true : false\\n    })\\n    \\n\\t// concat the array and put it into a set as there will be overlapping values, and then return the set into Array form\\n    return Array.from(new Set(arr1.concat(arr2)))\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n\\t// check if arr2/arr3 contains numbers from arr1\\n    const arr1 = nums1.filter(num => {\\n        return nums2.includes(num) || nums3.includes(num) ? true : false\\n    })\\n    \\n\\t// check if arr1/arr3 contains numbers from arr2\\n    const arr2 = nums2.filter(num => {\\n        return nums1.includes(num) || nums3.includes(num) ? true : false\\n    })\\n    \\n\\t// concat the array and put it into a set as there will be overlapping values, and then return the set into Array form\\n    return Array.from(new Set(arr1.concat(arr2)))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541024,
                "title": "very-easy-c-approach-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int> ans;\\n        unordered_set<int> st;\\n        \\n//         add element that is present both in nums1 and nums2\\n        for(int i=0; i<nums1.size(); i++){\\n            if(find(nums2.begin(), nums2.end(), nums1[i]) != nums2.end()){\\n               st.insert(nums1[i]);\\n            }\\n        }\\n        \\n//         add element that is present both in nums2 and nums3\\n        for(int i=0; i<nums2.size(); i++){\\n            if(find(nums3.begin(), nums3.end(), nums2[i]) != nums3.end()){\\n                st.insert(nums2[i]);\\n            }\\n        }\\n        \\n//         add element that is present both in nums1 and nums3\\n        for(int i=0; i<nums3.size(); i++){\\n            if(find(nums1.begin(), nums1.end(), nums3[i]) != nums1.end()){\\n                st.insert(nums3[i]);\\n            }\\n        }\\n        ans.insert(ans.begin(), st.begin(), st.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        vector<int> ans;\\n        unordered_set<int> st;\\n        \\n//         add element that is present both in nums1 and nums2\\n        for(int i=0; i<nums1.size(); i++){\\n            if(find(nums2.begin(), nums2.end(), nums1[i]) != nums2.end()){\\n               st.insert(nums1[i]);\\n            }\\n        }\\n        \\n//         add element that is present both in nums2 and nums3\\n        for(int i=0; i<nums2.size(); i++){\\n            if(find(nums3.begin(), nums3.end(), nums2[i]) != nums3.end()){\\n                st.insert(nums2[i]);\\n            }\\n        }\\n        \\n//         add element that is present both in nums1 and nums3\\n        for(int i=0; i<nums3.size(); i++){\\n            if(find(nums1.begin(), nums1.end(), nums3[i]) != nums1.end()){\\n                st.insert(nums3[i]);\\n            }\\n        }\\n        ans.insert(ans.begin(), st.begin(), st.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529019,
                "title": "simple-java-o-n",
                "content": "First we add the element in  the set for removal duplicate \\nthen add the element in to the map and count the frequency  too.\\nand iterate the map element and added to the list which value is more then or equal to  2\\n\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set = new HashSet<>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<Integer> list = new ArrayList<>();\\n        // first array\\n        for(int i : nums1){\\n            set.add(i);\\n        }\\n        for(Integer i : set){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        //clear the set\\n        set.clear();\\n        \\n        // second array\\n        for(int i : nums2)\\n            set.add(i);\\n\\n        for(Integer i : set)\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        \\n        set.clear();\\n        \\n        // third array\\n        for(int i : nums3)\\n            set.add(i);\\n\\n        for(Integer i : set)\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        \\n        set.clear();\\n        \\n        // iterate the map element and add into the list whose freequmce is greater or eqaul 2\\n        for(Map.Entry<Integer,Integer> entry  : map.entrySet()){\\n            if(entry.getValue()>=2){\\n                list.add(entry.getKey());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        Set<Integer> set = new HashSet<>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<Integer> list = new ArrayList<>();\\n        // first array\\n        for(int i : nums1){\\n            set.add(i);\\n        }\\n        for(Integer i : set){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        //clear the set\\n        set.clear();\\n        \\n        // second array\\n        for(int i : nums2)\\n            set.add(i);\\n\\n        for(Integer i : set)\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        \\n        set.clear();\\n        \\n        // third array\\n        for(int i : nums3)\\n            set.add(i);\\n\\n        for(Integer i : set)\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        \\n        set.clear();\\n        \\n        // iterate the map element and add into the list whose freequmce is greater or eqaul 2\\n        for(Map.Entry<Integer,Integer> entry  : map.entrySet()){\\n            if(entry.getValue()>=2){\\n                list.add(entry.getKey());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525017,
                "title": "ac-java-solution-two-out-of-three-beats-95",
                "content": "The trick here is to use a frequency map to maintain the count of the seen values, but only do this once per array.  If you do it more than once per array, you will count duplicates, which will give a false \"multi-list-frequeny\" in the final count.\\n\\nTo do the above you can use another temp set to make sure you\\'ve only seen an index once per array iteration.\\n\\nFinally, to the result add the values those in the frequency map which appear more than once accross all the sets (because of the above operation this should be guaranteed)\\n\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int[] freqMap = new int[101];\\n        List<Integer> result = new ArrayList<Integer>();\\n        \\n        int[][] all = {nums1, nums2, nums3};\\n        for(int j = 0; j < all.length; j++) {\\n            boolean[] tempSeen = new boolean[101];\\n            for (int i = 0; i < all[j].length; i++) {\\n                int val = all[j][i];\\n                if(!tempSeen[val]) {\\n                    freqMap[val] = freqMap[val] + 1;\\n                    tempSeen[val] = true;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < freqMap.length; i++) {\\n            if(freqMap[i] >= 2) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int[] freqMap = new int[101];\\n        List<Integer> result = new ArrayList<Integer>();\\n        \\n        int[][] all = {nums1, nums2, nums3};\\n        for(int j = 0; j < all.length; j++) {\\n            boolean[] tempSeen = new boolean[101];\\n            for (int i = 0; i < all[j].length; i++) {\\n                int val = all[j][i];\\n                if(!tempSeen[val]) {\\n                    freqMap[val] = freqMap[val] + 1;\\n                    tempSeen[val] = true;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < freqMap.length; i++) {\\n            if(freqMap[i] >= 2) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522778,
                "title": "accepted-java-solution-using-count-array",
                "content": "```\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\t\\t// arrays for count freq of elements\\n        int[] arr1 = new int[101];\\n        int[] arr2 = new int[101];\\n        int[] arr3 = new int[101];\\n        \\n\\t\\t// mark 1 if element is present\\n        for(int e : nums1) arr1[e] = 1;\\n        for(int e : nums2) arr2[e] = 1;\\n        for(int e : nums3) arr3[e] = 1;\\n        \\n        List<Integer> res = new ArrayList();\\n        for(int i = 1; i < 101; i++){\\n\\t\\t\\t// sum of all marking is greater or equal to 2 it means element is present in at least 2 array\\n            if(arr1[i] + arr2[i] + arr3[i] >= 2) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\t\\t// arrays for count freq of elements\\n        int[] arr1 = new int[101];\\n        int[] arr2 = new int[101];\\n        int[] arr3 = new int[101];\\n        \\n\\t\\t// mark 1 if element is present\\n        for(int e : nums1) arr1[e] = 1;\\n        for(int e : nums2) arr2[e] = 1;\\n        for(int e : nums3) arr3[e] = 1;\\n        \\n        List<Integer> res = new ArrayList();\\n        for(int i = 1; i < 101; i++){\\n\\t\\t\\t// sum of all marking is greater or equal to 2 it means element is present in at least 2 array\\n            if(arr1[i] + arr2[i] + arr3[i] >= 2) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520630,
                "title": "java-optimised-approach-faster-than-90",
                "content": "int[][] count = new int[3][101];\\n        \\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n\\t\\t/* Save the frequency of occurance of unique number in count array. Eliminate duplicates */\\n\\t\\tfor(int i:nums1) {\\n\\t\\t\\tcount[0][i] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i:nums2) {\\n\\t\\t\\tcount[1][i] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i:nums3) {\\n\\t\\t\\tcount[2][i] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=1;i<=100;i++) {\\n\\t\\t    /* If the occurance of a number is greater than 1 from the count array, add it to the result lst */\\n\\t\\t\\tif(count[0][i] + count[1][i] + count[2][i] > 1) {\\n\\t\\t\\t\\tans.add(i);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        return ans;",
                "solutionTags": [],
                "code": "int[][] count = new int[3][101];\\n        \\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n\\t\\t/* Save the frequency of occurance of unique number in count array. Eliminate duplicates */\\n\\t\\tfor(int i:nums1) {\\n\\t\\t\\tcount[0][i] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i:nums2) {\\n\\t\\t\\tcount[1][i] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i:nums3) {\\n\\t\\t\\tcount[2][i] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=1;i<=100;i++) {\\n\\t\\t    /* If the occurance of a number is greater than 1 from the count array, add it to the result lst */\\n\\t\\t\\tif(count[0][i] + count[1][i] + count[2][i] > 1) {\\n\\t\\t\\t\\tans.add(i);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1519092,
                "title": "python-3-dictionary-concept",
                "content": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        l=[]\\n        m=[]\\n        n=[]\\n        for each in nums1:\\n            if each not in l:\\n                l.append(each)\\n        for each in nums2:\\n            if each not in m:\\n                m.append(each)\\n        for each in nums3:\\n            if each not in n:\\n                n.append(each)\\n        for each in m:\\n            l.append(each)\\n        for each in n:\\n            l.append(each)\\n        d={}\\n        answer=[]\\n        for i in l:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for key in d:\\n            if d[key]>=2:\\n                answer.append(key)\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n        l=[]\\n        m=[]\\n        n=[]\\n        for each in nums1:\\n            if each not in l:\\n                l.append(each)\\n        for each in nums2:\\n            if each not in m:\\n                m.append(each)\\n        for each in nums3:\\n            if each not in n:\\n                n.append(each)\\n        for each in m:\\n            l.append(each)\\n        for each in n:\\n            l.append(each)\\n        d={}\\n        answer=[]\\n        for i in l:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for key in d:\\n            if d[key]>=2:\\n                answer.append(key)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518809,
                "title": "c-super-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,int>mp1,mp2;\\n        vector<int>ans;\\n        vector<bool>visited(105,false);\\n        for(auto x:nums1){\\n            mp1[x]++;\\n        }\\n        for(auto x:nums2){\\n            if(mp1.find(x)!=mp1.end() && visited[x]==false){\\n               ans.push_back(x); \\n                visited[x]=true;\\n            }\\n            mp2[x]++;\\n        }\\n        \\n        for(auto x:nums3){\\n            if( (mp1.find(x)!=mp1.end() || mp2.find(x)!=mp2.end()) && visited[x]==false){\\n                ans.push_back(x);\\n                visited[x]=true;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int,int>mp1,mp2;\\n        vector<int>ans;\\n        vector<bool>visited(105,false);\\n        for(auto x:nums1){\\n            mp1[x]++;\\n        }\\n        for(auto x:nums2){\\n            if(mp1.find(x)!=mp1.end() && visited[x]==false){\\n               ans.push_back(x); \\n                visited[x]=true;\\n            }\\n            mp2[x]++;\\n        }\\n        \\n        for(auto x:nums3){\\n            if( (mp1.find(x)!=mp1.end() || mp2.find(x)!=mp2.end()) && visited[x]==false){\\n                ans.push_back(x);\\n                visited[x]=true;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518069,
                "title": "easy-kotlin",
                "content": "If it helps, do upvote! :)\\n```\\nclass Solution {\\n    fun twoOutOfThree(nums1: IntArray, nums2: IntArray, nums3: IntArray): List<Int> {\\n        var arr=Array(3){IntArray(101)}\\n        for(i in 0..nums1.size-1){\\n            arr[0][nums1[i]]=1\\n        }\\n        for(i in 0..nums2.size-1){\\n            arr[1][nums2[i]]=1\\n        }\\n        for(i in 0..nums3.size-1){\\n            arr[2][nums3[i]]=1\\n        }\\n        var ans=mutableListOf<Int>()\\n        for(i in 0..100){\\n            if(arr[0][i]+arr[1][i]+arr[2][i]>=2) ans.add(i) \\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun twoOutOfThree(nums1: IntArray, nums2: IntArray, nums3: IntArray): List<Int> {\\n        var arr=Array(3){IntArray(101)}\\n        for(i in 0..nums1.size-1){\\n            arr[0][nums1[i]]=1\\n        }\\n        for(i in 0..nums2.size-1){\\n            arr[1][nums2[i]]=1\\n        }\\n        for(i in 0..nums3.size-1){\\n            arr[2][nums3[i]]=1\\n        }\\n        var ans=mutableListOf<Int>()\\n        for(i in 0..100){\\n            if(arr[0][i]+arr[1][i]+arr[2][i]>=2) ans.add(i) \\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517099,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const set1 = new Set(nums1), set2 = new Set(nums2), set3 = new Set(nums3)\\n    const set = new Set([...set1, ...set2, ...set3])\\n    \\n    \\n    const counts = new Map()\\n    let result = []\\n    for (const val of set.values()) {\\n        let count = 0\\n        if (set1.has(val))  count++\\n        if (set2.has(val))  count++\\n        if (set3.has(val))  count++\\n        \\n        if (count >= 2) result.push(val)\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[]} nums3\\n * @return {number[]}\\n */\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const set1 = new Set(nums1), set2 = new Set(nums2), set3 = new Set(nums3)\\n    const set = new Set([...set1, ...set2, ...set3])\\n    \\n    \\n    const counts = new Map()\\n    let result = []\\n    for (const val of set.values()) {\\n        let count = 0\\n        if (set1.has(val))  count++\\n        if (set2.has(val))  count++\\n        if (set3.has(val))  count++\\n        \\n        if (count >= 2) result.push(val)\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515630,
                "title": "python-simple-and-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def twoOutOfThree(self, num1, num2, num3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        d1,d2,d3={},{},{}\\n        for i in num1:\\n            if i in d1:\\n                d1[i]+=1\\n            else:\\n                d1[i]=1\\n        for i in num2:\\n            if i in d2:\\n                d2[i]+=1\\n            else:\\n                d2[i]=1\\n        for i in num3:\\n            if i in d3:\\n                d3[i]+=1\\n            else:\\n                d3[i]=1\\n                \\n                \\n        for key,val in d1.items():\\n            if key in d2.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d2[key]-=1\\n            if key in d3.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d3[key]-=1\\n                    \\n                    \\n        for key,val in d2.items():\\n            if key in d1.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d1[key]-=1\\n            if key in d3.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d3[key]-=1\\n                    \\n                    \\n        for key,val in d3.items():\\n            if key in d2.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d2[key]-=1\\n            if key in d1.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d1[key]-=1\\n            \\n        return list(set(res))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoOutOfThree(self, num1, num2, num3):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        d1,d2,d3={},{},{}\\n        for i in num1:\\n            if i in d1:\\n                d1[i]+=1\\n            else:\\n                d1[i]=1\\n        for i in num2:\\n            if i in d2:\\n                d2[i]+=1\\n            else:\\n                d2[i]=1\\n        for i in num3:\\n            if i in d3:\\n                d3[i]+=1\\n            else:\\n                d3[i]=1\\n                \\n                \\n        for key,val in d1.items():\\n            if key in d2.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d2[key]-=1\\n            if key in d3.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d3[key]-=1\\n                    \\n                    \\n        for key,val in d2.items():\\n            if key in d1.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d1[key]-=1\\n            if key in d3.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d3[key]-=1\\n                    \\n                    \\n        for key,val in d3.items():\\n            if key in d2.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d2[key]-=1\\n            if key in d1.keys():\\n                if val>0:\\n                    res.append(int(key))\\n                    val-=1\\n                    d1[key]-=1\\n            \\n        return list(set(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514938,
                "title": "c-set-of-bitsets",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, bitset<3>> m;\\n        for(int n : nums1) {\\n            m[n].set(0);\\n        }\\n        \\n        for(int n : nums2) {\\n            m[n].set(1);\\n        }\\n        \\n        for(int n : nums3) {\\n            m[n].set(2);\\n        }\\n        \\n        vector<int> res;\\n        for(auto& i : m) {\\n            if (i.second.count() > 1) {\\n                res.emplace_back(i.first);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\\n        unordered_map<int, bitset<3>> m;\\n        for(int n : nums1) {\\n            m[n].set(0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1514865,
                "title": "c-solution",
                "content": "**Complexity**\\n- Time: O(L1 + L2 + L3). L1, L2, and L3 are the lengths of ```nums1```, ```nums2``` and ```nums3``` respectively.\\n- Space: O(L1 + L2 + L3)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<int> res = new List<int>(); \\n        Dictionary<int,int> dic = new Dictionary<int,int>();       \\n        helper(nums1, dic);\\n        helper(nums2, dic);\\n        helper(nums3, dic);\\n            \\n        foreach(var kv in dic)\\n        {\\n            if(kv.Value >= 2)\\n                res.Add(kv.Key);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void helper(int[] nums, Dictionary<int,int> dic)\\n    {\\n        HashSet<int> set = new HashSet<int>();      \\n        foreach(var num in nums)\\n        {\\n            if(!set.Contains(num))\\n            {\\n                if(dic.ContainsKey(num))\\n                    dic[num]++;\\n                else\\n                    dic.Add(num,1);\\n                set.Add(num);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```nums1```\n```nums2```\n```nums3```\n```\\npublic class Solution {\\n    public IList<int> TwoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        \\n        List<int> res = new List<int>(); \\n        Dictionary<int,int> dic = new Dictionary<int,int>();       \\n        helper(nums1, dic);\\n        helper(nums2, dic);\\n        helper(nums3, dic);\\n            \\n        foreach(var kv in dic)\\n        {\\n            if(kv.Value >= 2)\\n                res.Add(kv.Key);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void helper(int[] nums, Dictionary<int,int> dic)\\n    {\\n        HashSet<int> set = new HashSet<int>();      \\n        foreach(var num in nums)\\n        {\\n            if(!set.Contains(num))\\n            {\\n                if(dic.ContainsKey(num))\\n                    dic[num]++;\\n                else\\n                    dic.Add(num,1);\\n                set.Add(num);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514646,
                "title": "java-solution",
                "content": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n       // Convert input array into Set; to de-dup \\n        Set<Integer> set1 = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\\n        Set<Integer> set2 = Arrays.stream(nums2).boxed().collect(Collectors.toSet());\\n        Set<Integer> set3 = Arrays.stream(nums3).boxed().collect(Collectors.toSet());\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 1; i <= 100; i++) { // from problem constraint\\n            int score = 0;\\n            score += set1.contains(i) ? 1 : 0;\\n            score += set2.contains(i) ? 1 : 0;\\n            score += set3.contains(i) ? 1 : 0;\\n\\n            if (score >= 2) list.add(i);\\n        }\\n\\n        return list;\\n\\n\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n       // Convert input array into Set; to de-dup \\n        Set<Integer> set1 = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\\n        Set<Integer> set2 = Arrays.stream(nums2).boxed().collect(Collectors.toSet());\\n        Set<Integer> set3 = Arrays.stream(nums3).boxed().collect(Collectors.toSet());\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 1; i <= 100; i++) { // from problem constraint\\n            int score = 0;\\n            score += set1.contains(i) ? 1 : 0;\\n            score += set2.contains(i) ? 1 : 0;\\n            score += set3.contains(i) ? 1 : 0;\\n\\n            if (score >= 2) list.add(i);\\n        }\\n\\n        return list;\\n\\n\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514515,
                "title": "a-few-solutions",
                "content": "Use 3 sets: `a`,`b`,`c` and 1 map `m` to count unique values `x`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun twoOutOfThree(A: IntArray, B: IntArray, C: IntArray): List<Int> {\\n        var m = mutableMapOf<Int, Int>()\\n        var (a, b, c) = listOf(A.toSet(), B.toSet(), C.toSet())\\n        for (x in a) m[x] = 1 + m.getOrDefault(x, 0)\\n        for (x in b) m[x] = 1 + m.getOrDefault(x, 0)\\n        for (x in c) m[x] = 1 + m.getOrDefault(x, 0)\\n        return m.filter{ (x, cnt) -> 2 <= cnt }.map{ (x, _) -> x }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet twoOutOfThree = (A, B, C, m = new Map()) => {\\n    let [a, b, c] = [new Set(A), new Set(B), new Set(C)];\\n    for (let x of a) m.set(x, 1 + (m.get(x) || 0));\\n    for (let x of b) m.set(x, 1 + (m.get(x) || 0));\\n    for (let x of c) m.set(x, 1 + (m.get(x) || 0));\\n    return [...m].filter(([x, cnt]) => 2 <= cnt).map(([x, _]) => x);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def twoOutOfThree(self, A: List[int], B: List[int], C: List[int]) -> List[int]:\\n        m = {}\\n        a, b, c = set(A), set(B), set(C)\\n        for x in a: m[x] = 1 + (m[x] if x in m else 0)\\n        for x in b: m[x] = 1 + (m[x] if x in m else 0)\\n        for x in c: m[x] = 1 + (m[x] if x in m else 0)\\n        return [x for x, cnt in m.items() if 2 <= cnt]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, int>;\\n    VI twoOutOfThree(VI& A, VI& B, VI& C, Map m = {}, VI ans = {}) {\\n        Set a{ A.begin(), A.end() },\\n            b{ B.begin(), B.end() },\\n            c{ C.begin(), C.end() };\\n        for (auto x: a) ++m[x];\\n        for (auto x: b) ++m[x];\\n        for (auto x: c) ++m[x];\\n        for (auto [x, cnt]: m)\\n            if (2 <= cnt)\\n                ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun twoOutOfThree(A: IntArray, B: IntArray, C: IntArray): List<Int> {\\n        var m = mutableMapOf<Int, Int>()\\n        var (a, b, c) = listOf(A.toSet(), B.toSet(), C.toSet())\\n        for (x in a) m[x] = 1 + m.getOrDefault(x, 0)\\n        for (x in b) m[x] = 1 + m.getOrDefault(x, 0)\\n        for (x in c) m[x] = 1 + m.getOrDefault(x, 0)\\n        return m.filter{ (x, cnt) -> 2 <= cnt }.map{ (x, _) -> x }\\n    }\\n}\\n```\n```\\nlet twoOutOfThree = (A, B, C, m = new Map()) => {\\n    let [a, b, c] = [new Set(A), new Set(B), new Set(C)];\\n    for (let x of a) m.set(x, 1 + (m.get(x) || 0));\\n    for (let x of b) m.set(x, 1 + (m.get(x) || 0));\\n    for (let x of c) m.set(x, 1 + (m.get(x) || 0));\\n    return [...m].filter(([x, cnt]) => 2 <= cnt).map(([x, _]) => x);\\n};\\n```\n```\\nclass Solution:\\n    def twoOutOfThree(self, A: List[int], B: List[int], C: List[int]) -> List[int]:\\n        m = {}\\n        a, b, c = set(A), set(B), set(C)\\n        for x in a: m[x] = 1 + (m[x] if x in m else 0)\\n        for x in b: m[x] = 1 + (m[x] if x in m else 0)\\n        for x in c: m[x] = 1 + (m[x] if x in m else 0)\\n        return [x for x, cnt in m.items() if 2 <= cnt]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, int>;\\n    VI twoOutOfThree(VI& A, VI& B, VI& C, Map m = {}, VI ans = {}) {\\n        Set a{ A.begin(), A.end() },\\n            b{ B.begin(), B.end() },\\n            c{ C.begin(), C.end() };\\n        for (auto x: a) ++m[x];\\n        for (auto x: b) ++m[x];\\n        for (auto x: c) ++m[x];\\n        for (auto [x, cnt]: m)\\n            if (2 <= cnt)\\n                ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513915,
                "title": "frequency-arrays",
                "content": "**IDEA:**\\nHere Contraint are very small . If contraint are high go for hashset.\\n* Make frequency array for 3 arrays.\\n* We need output of distinct number who have appeared in more than 1 array. This can be easily identified with the help of frequency array.\\n\\n**CODE:**\\n```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] f1 = frequency(nums1);\\n        int[] f2 = frequency(nums2);\\n        int[] f3 = frequency(nums3);\\n        \\n        for(int i=1;i<=100;i++){\\n            if((f1[i]>0 && f2[i]>0) || (f1[i]>0 && f3[i]>0) || (f2[i]>0 && f3[i]>0)) res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int[] frequency(int[] arr){\\n        int[] f = new int[101];\\n        for(int val : arr) f[val]++;\\n        return f;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n```\\nTime : O(n) , where n : Max length among num1,num2,num3\\nSpace : O(constant) , 3 array of fix length (101)\\n```\\n\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] f1 = frequency(nums1);\\n        int[] f2 = frequency(nums2);\\n        int[] f3 = frequency(nums3);\\n        \\n        for(int i=1;i<=100;i++){\\n            if((f1[i]>0 && f2[i]>0) || (f1[i]>0 && f3[i]>0) || (f2[i]>0 && f3[i]>0)) res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int[] frequency(int[] arr){\\n        int[] f = new int[101];\\n        for(int val : arr) f[val]++;\\n        return f;\\n    }\\n}\\n```\n```\\nTime : O(n) , where n : Max length among num1,num2,num3\\nSpace : O(constant) , 3 array of fix length (101)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513781,
                "title": "javascript-4-sets-solution-88-ms",
                "content": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const num1Set = new Set(nums1);\\n    const num2Set = new Set(nums2);\\n    const num3Set = new Set(nums3);\\n    const result = new Set();\\n    \\n    for (const num of nums1) {\\n        if (num2Set.has(num) || num3Set.has(num)) result.add(num);\\n    }\\n    \\n    for (const num of nums2) {\\n        if (num1Set.has(num) || num3Set.has(num)) result.add(num);\\n    }\\n    \\n    return Array.from(result);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar twoOutOfThree = function(nums1, nums2, nums3) {\\n    const num1Set = new Set(nums1);\\n    const num2Set = new Set(nums2);\\n    const num3Set = new Set(nums3);\\n    const result = new Set();\\n    \\n    for (const num of nums1) {\\n        if (num2Set.has(num) || num3Set.has(num)) result.add(num);\\n    }\\n    \\n    for (const num of nums2) {\\n        if (num1Set.has(num) || num3Set.has(num)) result.add(num);\\n    }\\n    \\n    return Array.from(result);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513694,
                "title": "java-map-set",
                "content": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        HashSet<Integer>res=new HashSet<Integer>();\\n        for(int i=0;i<nums1.length;++i){\\n            map.put(\"n1\"+nums1[i],1);\\n        }\\n        \\n        for(int i=0;i<nums2.length;++i){\\n            if(map.containsKey(\"n1\"+nums2[i])){\\n                res.add(nums2[i]);\\n            }else{map.put(\"n2\"+nums2[i],1);}\\n        }\\n        \\n        for(int i=0;i<nums3.length;++i){\\n            if(map.containsKey(\"n1\"+nums3[i])||map.containsKey(\"n2\"+nums3[i])){\\n                res.add(nums3[i]);\\n            }\\n        }\\n        List<Integer> anw=new ArrayList<Integer>(res);\\n        \\n        return anw;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        HashSet<Integer>res=new HashSet<Integer>();\\n        for(int i=0;i<nums1.length;++i){\\n            map.put(\"n1\"+nums1[i],1);\\n        }\\n        \\n        for(int i=0;i<nums2.length;++i){\\n            if(map.containsKey(\"n1\"+nums2[i])){\\n                res.add(nums2[i]);\\n            }else{map.put(\"n2\"+nums2[i],1);}\\n        }\\n        \\n        for(int i=0;i<nums3.length;++i){\\n            if(map.containsKey(\"n1\"+nums3[i])||map.containsKey(\"n2\"+nums3[i])){\\n                res.add(nums3[i]);\\n            }\\n        }\\n        List<Integer> anw=new ArrayList<Integer>(res);\\n        \\n        return anw;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1698409,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            },
            {
                "id": 1809734,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            },
            {
                "id": 1847530,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            },
            {
                "id": 1795931,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            },
            {
                "id": 1765177,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            },
            {
                "id": 1732534,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            },
            {
                "id": 1652223,
                "content": [
                    {
                        "username": "topswe",
                        "content": "Use sets!"
                    },
                    {
                        "username": "sakshamxx2769",
                        "content": "it ran for 287/ 288 test cases, im crying myself lol"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "https://leetcode.com/problems/two-out-of-three/solutions/3356773/easy-python-solutions/"
                    },
                    {
                        "username": "jemsa12",
                        "content": "loops beats"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "This question is a little bit ambiguous. I thought the new array must be distinct from the three original arrays. This introduced an extra complexity of searching through the permutation space of the resulting array."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "We can use map . I solved this using map . <br> My solution Link : ->https://leetcode.com/problems/two-out-of-three/solutions/2965920/c-easy-and-simple-solution-using-map/"
                    },
                    {
                        "username": "sunilband0007",
                        "content": "asd"
                    }
                ]
            }
        ]
    }
]