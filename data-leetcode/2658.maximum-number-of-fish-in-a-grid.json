[
    {
        "title": "Maximum Number of Fish in a Grid",
        "question_content": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\n\tA land cell if grid[r][c] = 0, or\n\tA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\n\tCatch all the fish at cell (r, c), or\n\tMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nOutput: 7\nExplanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3)&nbsp;and collect 4 fish.\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nOutput: 1\nExplanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 10\n\t0 <= grid[i][j] <= 10",
        "solutions": [
            {
                "id": 3466724,
                "title": "explained-dfs-with-node-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\nTrick is to keep traversing the grid from (0,0) with dfs & adding the values of each dfs traverse.\\nKeep adding all non-zero value traversed is the total no of fish possible on that connected cells.\\nSo keep taking the maximum of each dfs run and return it as the answer.\\n\\nNote : Set the node value to 0 once we traversed a node, to avoid retraversing the same node again.\\n\\n# Code \\n\\n```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n\\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\\n        int res = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto d: dir)  res += dfs(grid, r+d[0], c+d[1]);\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n\\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\\n        int res = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto d: dir)  res += dfs(grid, r+d[0], c+d[1]);\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466649,
                "title": "day-394-dfs-vs-bfs-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe are given a 2D matrix grid representing land cells and water cells containing fish.\\n##### \\u2022\\tWe need to find the maximum number of fish that can be caught by a fisher starting from any water cell.\\n##### \\u2022\\tWe can start by iterating over all water cells in the grid and using a depth-first search (DFS) to explore all adjacent water cells and calculate the maximum number of fish that can be caught starting from that cell.\\n##### \\u2022\\tIn the DFS, we start with the current water cell and explore all adjacent water cells using a 2D array  dr that contains the four possible directions. For each adjacent water cell, we calculate the total number of fish that can be caught starting from the current cell and add it to the maximum number of fish caught so far. We also remove each water cell from the map as we visit it to avoid visiting the same cell twice.\\n##### \\u2022\\tWe keep track of the maximum number of fish caught so far and return it as the answer.\\n##### \\u2022\\tSince we explore each water cell in the grid only once and perform constant time operations for each cell, the time complexity of this solution is O(n), where n is the total number of cells in the grid.\\n##### \\u2022\\tWe can also optimize the solution by using memoization to avoid recomputing the maximum number of fish caught starting from a water cell that has already been visited.\\n\\n\\n\\n# Code\\n```java []\\npublic int findFish(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int maxFish = 0; // variable to store the maximum number of fish caught\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                maxFish = Math.max(maxFish, dfs(i, j, grid, n, m)); // update the maximum number of fish caught\\n            }\\n        }\\n    }\\n    return maxFish; // return the maximum number of fish caught\\n}\\n\\n// array to store the four possible directions\\nprivate final int[] dr = {0, 1, 0, -1, 0};\\n\\n// function to perform DFS and count the number of fish caught\\nint dfs(int i, int j, int[][] grid, int n, int m) {\\n    int fish = grid[i][j]; // count the number of fish caught in the current cell\\n    grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n        int nr = i + dr[k], nc = j + dr[k + 1]; // calculate the coordinates of the adjacent cell\\n        if(nr < n && nr >= 0 && nc < m && nc >= 0 && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n            fish += dfs(nr, nc, grid, n, m); // count the number of fish caught in the adjacent cell\\n        }\\n    }\\n    return fish; // return the total number of fish caught\\n}\\n```\\n```c++ []\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) {\\n                ans = max(ans, dfs(i, j, grid, n, m));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nint dfs(int i, int j, vector<vector<int>>& grid, int n, int m) {\\n    int f = grid[i][j];\\n    grid[i][j] = 0;\\n    int dr[] = {0, 1, 0, -1, 0};\\n    for(int k = 0; k < 4; k++) {\\n        int nr = i + dr[k];\\n        int nc = j + dr[k + 1];\\n        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n            f += dfs(nr, nc, grid, n, m);\\n        }\\n    }\\n    return f;\\n}\\n```\\n```python []\\ndef findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans\\n\\ndef dfs(self, i: int, j: int, grid: List[List[int]], n: int, m: int) -> int:\\n    f = grid[i][j]\\n    grid[i][j] = 0\\n    dr = [0, 1, 0, -1, 0]\\n    for k in range(4):\\n        nr = i + dr[k]\\n        nc = j + dr[k + 1]\\n        if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n            f += self.dfs(nr, nc, grid, n, m)\\n    return f\\n```\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n# BFS \\n\\nWe start by iterating over all water cells in the grid and checking if they contain fish. If a water cell contains fish, we add it to a queue and start the BFS. We also set the value of the current water cell to 0 to mark it as visited.\\n\\nIn the BFS, we explore all adjacent water cells using two arrays  dr and  dc that contain the four possible directions. For each adjacent water cell, we add the number of fish it contains to the total number of fish caught so far and mark it as visited by setting its value to 0. We also add it to the queue to explore its adjacent water cells in the next iteration.\\n\\nAfter the BFS is complete, we update the maximum number of fish caught so far and continue iterating over the remaining water cells.\\n\\nSince we explore each water cell in the grid only once and perform constant time operations for each cell, the time complexity of this solution is O(n), where n is the total number of cells in the grid.\\n```java []\\nint findMaxFish[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int ans = 0; // variable to store the maximum number of fish caught\\n    int[] dr = {0, 1, 0, -1}; // array to store the four possible directions\\n    int[] dc = {1, 0, -1, 0};\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                Queue<int[]> q = new LinkedList<>(); // create a queue to perform BFS\\n                q.offer(new int[]{i, j}); // add the current cell to the queue\\n                int f = grid[i][j]; // count the number of fish caught in the current cell\\n                grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n                while(!q.isEmpty()) { // while there are cells in the queue\\n                    int[] curr = q.poll(); // remove the first cell from the queue\\n                    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n                        int nr = curr[0] + dr[k]; // calculate the coordinates of the adjacent cell\\n                        int nc = curr[1] + dc[k];\\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n                            f += grid[nr][nc]; // count the number of fish caught in the adjacent cell\\n                            grid[nr][nc] = 0; // mark the adjacent cell as visited by setting its value to 0\\n                            q.offer(new int[]{nr, nc}); // add the adjacent cell to the queue\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, f); // update the maximum number of fish caught so far\\n            }\\n        }\\n    }\\n    return ans; // return the maximum number of fish caught\\n}\\n```\\n```c++ []\\nclass Solutionpublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<int> dr = {0, 1, 0, -1};\\n        vector<int> dc = {1, 0, -1, 0};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int f = grid[i][j];\\n                    grid[i][j] = 0;\\n                    while(!q.empty()) {\\n                        auto curr = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            int nr = curr.first + dr[k];\\n                            int nc = curr.second + dc[k];\\n                            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n                                f += grid[nr][nc];\\n                                grid[nr][nc] = 0;\\n                                q.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, f);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        dr = [0, 1, 0, -1]\\n        dc = [1, 0, -1, 0]\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] > 0:\\n                    q = deque()\\n                    q.append((i, j))\\n                    f = grid[i][j]\\n                    grid[i][j] = 0\\n                    while q:\\n                        curr = q.popleft()\\n                        for k in range(4):\\n                            nr = curr[0] + dr[k]\\n                            nc = curr[1] + dc[k]\\n                            if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n                                f += grid[nr][nc]\\n                                grid[nr][nc] = 0\\n                                q.append((nr, nc))\\n                    ans = max(ans, f)\\n        return ans\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/maximum-number-of-fish-in-a-grid/solutions/3466649/day-394-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```java []\\npublic int findFish(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int maxFish = 0; // variable to store the maximum number of fish caught\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                maxFish = Math.max(maxFish, dfs(i, j, grid, n, m)); // update the maximum number of fish caught\\n            }\\n        }\\n    }\\n    return maxFish; // return the maximum number of fish caught\\n}\\n\\n// array to store the four possible directions\\nprivate final int[] dr = {0, 1, 0, -1, 0};\\n\\n// function to perform DFS and count the number of fish caught\\nint dfs(int i, int j, int[][] grid, int n, int m) {\\n    int fish = grid[i][j]; // count the number of fish caught in the current cell\\n    grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n        int nr = i + dr[k], nc = j + dr[k + 1]; // calculate the coordinates of the adjacent cell\\n        if(nr < n && nr >= 0 && nc < m && nc >= 0 && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n            fish += dfs(nr, nc, grid, n, m); // count the number of fish caught in the adjacent cell\\n        }\\n    }\\n    return fish; // return the total number of fish caught\\n}\\n```\n```c++ []\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) {\\n                ans = max(ans, dfs(i, j, grid, n, m));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nint dfs(int i, int j, vector<vector<int>>& grid, int n, int m) {\\n    int f = grid[i][j];\\n    grid[i][j] = 0;\\n    int dr[] = {0, 1, 0, -1, 0};\\n    for(int k = 0; k < 4; k++) {\\n        int nr = i + dr[k];\\n        int nc = j + dr[k + 1];\\n        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n            f += dfs(nr, nc, grid, n, m);\\n        }\\n    }\\n    return f;\\n}\\n```\n```python []\\ndef findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans\\n\\ndef dfs(self, i: int, j: int, grid: List[List[int]], n: int, m: int) -> int:\\n    f = grid[i][j]\\n    grid[i][j] = 0\\n    dr = [0, 1, 0, -1, 0]\\n    for k in range(4):\\n        nr = i + dr[k]\\n        nc = j + dr[k + 1]\\n        if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n            f += self.dfs(nr, nc, grid, n, m)\\n    return f\\n```\n```java []\\nint findMaxFish[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int ans = 0; // variable to store the maximum number of fish caught\\n    int[] dr = {0, 1, 0, -1}; // array to store the four possible directions\\n    int[] dc = {1, 0, -1, 0};\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                Queue<int[]> q = new LinkedList<>(); // create a queue to perform BFS\\n                q.offer(new int[]{i, j}); // add the current cell to the queue\\n                int f = grid[i][j]; // count the number of fish caught in the current cell\\n                grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n                while(!q.isEmpty()) { // while there are cells in the queue\\n                    int[] curr = q.poll(); // remove the first cell from the queue\\n                    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n                        int nr = curr[0] + dr[k]; // calculate the coordinates of the adjacent cell\\n                        int nc = curr[1] + dc[k];\\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n                            f += grid[nr][nc]; // count the number of fish caught in the adjacent cell\\n                            grid[nr][nc] = 0; // mark the adjacent cell as visited by setting its value to 0\\n                            q.offer(new int[]{nr, nc}); // add the adjacent cell to the queue\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, f); // update the maximum number of fish caught so far\\n            }\\n        }\\n    }\\n    return ans; // return the maximum number of fish caught\\n}\\n```\n```c++ []\\nclass Solutionpublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<int> dr = {0, 1, 0, -1};\\n        vector<int> dc = {1, 0, -1, 0};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int f = grid[i][j];\\n                    grid[i][j] = 0;\\n                    while(!q.empty()) {\\n                        auto curr = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            int nr = curr.first + dr[k];\\n                            int nc = curr.second + dc[k];\\n                            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n                                f += grid[nr][nc];\\n                                grid[nr][nc] = 0;\\n                                q.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, f);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        dr = [0, 1, 0, -1]\\n        dc = [1, 0, -1, 0]\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] > 0:\\n                    q = deque()\\n                    q.append((i, j))\\n                    f = grid[i][j]\\n                    grid[i][j] = 0\\n                    while q:\\n                        curr = q.popleft()\\n                        for k in range(4):\\n                            nr = curr[0] + dr[k]\\n                            nc = curr[1] + dc[k]\\n                            if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n                                f += grid[nr][nc]\\n                                grid[nr][nc] = 0\\n                                q.append((nr, nc))\\n                    ans = max(ans, f)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466627,
                "title": "695-max-area-of-island",
                "content": "This is similar to [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/).\\n\\nFor each \"island\" of water, it does not matter where fisherman starts. We just need to mark a visited cell by setting it to zero.\\n\\n```cpp    \\nint dfs(int r, int c, vector<vector<int>>& g) {\\n    if (min(r, c) < 0 || r == g.size() || c == g[r].size() || g[r][c] == 0)\\n        return 0;\\n    return exchange(g[r][c], 0) + dfs(r + 1, c, g) + dfs(r, c + 1, g) + dfs(r - 1, c, g) + dfs(r, c - 1, g);\\n}\\nint findMaxFish(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (int r = 0; r < g.size(); ++r)\\n        for (int c = 0; c < g[r].size(); ++c)\\n            res = max(res, dfs(r, c, g));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint dfs(int r, int c, vector<vector<int>>& g) {\\n    if (min(r, c) < 0 || r == g.size() || c == g[r].size() || g[r][c] == 0)\\n        return 0;\\n    return exchange(g[r][c], 0) + dfs(r + 1, c, g) + dfs(r, c + 1, g) + dfs(r - 1, c, g) + dfs(r, c - 1, g);\\n}\\nint findMaxFish(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (int r = 0; r < g.size(); ++r)\\n        for (int c = 0; c < g[r].size(); ++c)\\n            res = max(res, dfs(r, c, g));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466637,
                "title": "explained-c-java-dfs-bfs-beginner-friendly-code",
                "content": "**DFS Approach**\\n\\n```\\n1. Define a helper function dfs that takes the grid, the row index r, and the column index c as arguments. The function returns the total number of fish caught starting from the cell (r, c).\\n2. In the dfs function, check if the current cell is out of bounds or a land cell. If so, return 0 (base case).\\n3. Otherwise, catch the fish at the current cell by storing its value in a variable fishCaught.\\n4. Mark the current cell as caught by setting its value to 0 in the grid.\\n5. Define an array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n6. For each possible movement in moves, calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n7. Recursively call the dfs function with the new cell coordinates, and add the result to fishCaught.\\n8. Return fishCaught.\\n9. In the findMaxFish function, initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n10. Iterate over every cell in the grid.\\n11. For each water cell (i.e., cells with a positive value), start a DFS search using the dfs function to find the maximum number of fish that can be caught starting from this cell.\\n12. Update maxFish to the maximum value between maxFish and the number of fish caught starting from the current water cell.\\n13. Return maxFish.\\n```\\n\\n**C++ Code For DFS Approach**\\n```\\nint dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**Java Code For DFS Approach**\\n```\\npublic int dfs(int[][] grid, int r, int c) {\\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int[] move : moves) {\\n        int newR = r + move[0];\\n        int newC = c + move[1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**BFS Approach:**\\n```\\n1. Initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n2. Get the size of the grid m x n.\\n3. Define a 2D array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n4. Iterate over every cell in the grid.\\n5. For each water cell (i.e., cells with a positive value), start a BFS search to find the maximum number of fish that can be caught starting from this cell.\\n6. Initialize a queue and add the current water cell coordinates to the queue.\\n7. Initialize a variable fishCaught to 0 to keep track of the number of fish caught starting from the current water cell.\\n8. While the queue is not empty, do the following:\\n\\ta. Dequeue the front element of the queue, representing the current water cell coordinates.\\n\\tb. If the current cell contains fish (i.e., has a positive value), catch the fish and add its value to fishCaught. Set the     cell value to 0 to mark it as caught.\\n\\tc. Iterate over every possible movement in the moves array.\\n\\td. Calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n\\te. If the new cell is within the bounds of the grid and is a water cell (i.e., has a positive value), add its coordinates     to the queue.\\n9. Update maxFish to the maximum value between maxFish and fishCaught.\\n10. Return maxFish.\\n```\\n\\n**C++ Code For BFS Approach**\\n```\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible moves\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) { // Start at a water cell\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                int fishCaught = 0;\\n                while (!q.empty()) {\\n                    int r = q.front().first;\\n                    int c = q.front().second;\\n                    q.pop();\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (auto& move : moves) { // Iterate over possible moves\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] > 0) {\\n                            q.push({newR, newC}); // Add new water cell to queue\\n                        }\\n                    }\\n                }\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    \\n    return maxFish;\\n}\\n```\\n\\n**Java Code For BFS Approach**\\n\\n```\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start BFS search from water cell\\n                int fishCaught = 0;\\n                Queue<int[]> queue = new LinkedList<>(); // Queue for BFS\\n                queue.offer(new int[]{i, j}); // Enqueue current cell\\n                while (!queue.isEmpty()) {\\n                    int[] curr = queue.poll(); // Dequeue first cell\\n                    int r = curr[0];\\n                    int c = curr[1];\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (int[] move : moves) {\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && grid[newR][newC] > 0) {\\n                            queue.offer(new int[]{newR, newC}); // Enqueue adjacent water cell\\n                        }\\n                    }\\n                }\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n1. Define a helper function dfs that takes the grid, the row index r, and the column index c as arguments. The function returns the total number of fish caught starting from the cell (r, c).\\n2. In the dfs function, check if the current cell is out of bounds or a land cell. If so, return 0 (base case).\\n3. Otherwise, catch the fish at the current cell by storing its value in a variable fishCaught.\\n4. Mark the current cell as caught by setting its value to 0 in the grid.\\n5. Define an array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n6. For each possible movement in moves, calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n7. Recursively call the dfs function with the new cell coordinates, and add the result to fishCaught.\\n8. Return fishCaught.\\n9. In the findMaxFish function, initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n10. Iterate over every cell in the grid.\\n11. For each water cell (i.e., cells with a positive value), start a DFS search using the dfs function to find the maximum number of fish that can be caught starting from this cell.\\n12. Update maxFish to the maximum value between maxFish and the number of fish caught starting from the current water cell.\\n13. Return maxFish.\\n```\n```\\nint dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\n```\\npublic int dfs(int[][] grid, int r, int c) {\\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int[] move : moves) {\\n        int newR = r + move[0];\\n        int newC = c + move[1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\n```\\n1. Initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n2. Get the size of the grid m x n.\\n3. Define a 2D array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n4. Iterate over every cell in the grid.\\n5. For each water cell (i.e., cells with a positive value), start a BFS search to find the maximum number of fish that can be caught starting from this cell.\\n6. Initialize a queue and add the current water cell coordinates to the queue.\\n7. Initialize a variable fishCaught to 0 to keep track of the number of fish caught starting from the current water cell.\\n8. While the queue is not empty, do the following:\\n\\ta. Dequeue the front element of the queue, representing the current water cell coordinates.\\n\\tb. If the current cell contains fish (i.e., has a positive value), catch the fish and add its value to fishCaught. Set the     cell value to 0 to mark it as caught.\\n\\tc. Iterate over every possible movement in the moves array.\\n\\td. Calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n\\te. If the new cell is within the bounds of the grid and is a water cell (i.e., has a positive value), add its coordinates     to the queue.\\n9. Update maxFish to the maximum value between maxFish and fishCaught.\\n10. Return maxFish.\\n```\n```\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible moves\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) { // Start at a water cell\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                int fishCaught = 0;\\n                while (!q.empty()) {\\n                    int r = q.front().first;\\n                    int c = q.front().second;\\n                    q.pop();\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (auto& move : moves) { // Iterate over possible moves\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] > 0) {\\n                            q.push({newR, newC}); // Add new water cell to queue\\n                        }\\n                    }\\n                }\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    \\n    return maxFish;\\n}\\n```\n```\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start BFS search from water cell\\n                int fishCaught = 0;\\n                Queue<int[]> queue = new LinkedList<>(); // Queue for BFS\\n                queue.offer(new int[]{i, j}); // Enqueue current cell\\n                while (!queue.isEmpty()) {\\n                    int[] curr = queue.poll(); // Dequeue first cell\\n                    int r = curr[0];\\n                    int c = curr[1];\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (int[] move : moves) {\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && grid[newR][newC] > 0) {\\n                            queue.offer(new int[]{newR, newC}); // Enqueue adjacent water cell\\n                        }\\n                    }\\n                }\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466794,
                "title": "easy-peasy-dfs",
                "content": "```\\nclass Solution {\\n    \\n    private int solve(int i, int j, int m, int n, int[][] grid, boolean[][] vis){\\n       // return if wrong position\\n\\t   if(i < 0 || j < 0 || i == m || j == n || vis[i][j] || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// mark visited\\n        vis[i][j] = true;\\n\\t\\t\\n        // call 4 directions\\n        int total = grid[i][j];\\n        total += solve(i+1, j, m, n, grid, vis);\\n        total += solve(i, j+1, m, n, grid, vis);\\n        total += solve(i, j-1, m, n, grid, vis);\\n        total += solve(i-1, j, m, n, grid, vis);\\n        return total;\\n    }    \\n\\t\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int max = 0;\\n        boolean[][] vis = new boolean[m][n];\\n\\t\\t\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    max = Math.max(max, solve(i, j, m, n, grid, vis));\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/60965b38-0d54-43b0-bf48-49629fbf0e73_1682785742.352511.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int solve(int i, int j, int m, int n, int[][] grid, boolean[][] vis){\\n       // return if wrong position\\n\\t   if(i < 0 || j < 0 || i == m || j == n || vis[i][j] || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// mark visited\\n        vis[i][j] = true;\\n\\t\\t\\n        // call 4 directions\\n        int total = grid[i][j];\\n        total += solve(i+1, j, m, n, grid, vis);\\n        total += solve(i, j+1, m, n, grid, vis);\\n        total += solve(i, j-1, m, n, grid, vis);\\n        total += solve(i-1, j, m, n, grid, vis);\\n        return total;\\n    }    \\n\\t\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int max = 0;\\n        boolean[][] vis = new boolean[m][n];\\n\\t\\t\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    max = Math.max(max, solve(i, j, m, n, grid, vis));\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466685,
                "title": "c-dfs-bfs-union-find-maximum-of-water-components",
                "content": "# Intuition\\nWe can traverse only one complete component of water cells and catch all the fishes in it. Do a DFS/BFS traversal on every water component and count total number of fishes in that component. Take maximum of all possible water components.\\n\\n# Recursive DFS\\n```\\nclass Solution {\\nprivate:\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        if (r == -1 || r == grid.size() || c == -1 || c == grid[0].size() || !grid[r][c] || visited[r][c]) {\\n            return 0;\\n        }\\n        visited[r][c] = true;\\n        return grid[r][c] +\\n            countFishes(grid, visited, r, c + 1) +\\n            countFishes(grid, visited, r, c - 1) +\\n            countFishes(grid, visited, r + 1, c) +\\n            countFishes(grid, visited, r - 1, c);\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Iterative DFS\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        stack<pair<int, int>> s;\\n        s.push({r, c});\\n        visited[r][c] = true;\\n        while (!s.empty()) {\\n            r = s.top().first, c = s.top().second; s.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    s.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Iterative BFS\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        queue<pair<int, int>> q;\\n        q.push({r, c});\\n        visited[r][c] = true;\\n        while (!q.empty()) {\\n            r = q.front().first, c = q.front().second; q.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    q.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Union Find\\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, compSize, fishes;\\n\\npublic:\\n    UnionFind(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), mn = m * n;\\n        parent.resize(mn);\\n        compSize.resize(mn, 1);\\n        fishes.resize(mn);\\n        iota(parent.begin(), parent.end(), 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                fishes[n * i + j] = grid[i][j];\\n            }\\n        }\\n    }\\n\\n    int getParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n            fishes[parx] += fishes[pary];\\n        }\\n    }\\n\\n    int getFishes(int x) {\\n        return fishes[getParent(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector<int> dr{0, 0, 1, -1}, dc{1, -1, 0, 0};\\n        UnionFind dsu(grid);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c]) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int r1 = r + dr[k], c1 = c + dc[k];\\n                        if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1]) {\\n                            dsu.unionSet(n * r + c, n * r1 + c1);\\n                        }\\n                    }\\n                    result = max(result, dsu.getFishes(n * r + c));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        if (r == -1 || r == grid.size() || c == -1 || c == grid[0].size() || !grid[r][c] || visited[r][c]) {\\n            return 0;\\n        }\\n        visited[r][c] = true;\\n        return grid[r][c] +\\n            countFishes(grid, visited, r, c + 1) +\\n            countFishes(grid, visited, r, c - 1) +\\n            countFishes(grid, visited, r + 1, c) +\\n            countFishes(grid, visited, r - 1, c);\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        stack<pair<int, int>> s;\\n        s.push({r, c});\\n        visited[r][c] = true;\\n        while (!s.empty()) {\\n            r = s.top().first, c = s.top().second; s.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    s.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        queue<pair<int, int>> q;\\n        q.push({r, c});\\n        visited[r][c] = true;\\n        while (!q.empty()) {\\n            r = q.front().first, c = q.front().second; q.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    q.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, compSize, fishes;\\n\\npublic:\\n    UnionFind(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), mn = m * n;\\n        parent.resize(mn);\\n        compSize.resize(mn, 1);\\n        fishes.resize(mn);\\n        iota(parent.begin(), parent.end(), 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                fishes[n * i + j] = grid[i][j];\\n            }\\n        }\\n    }\\n\\n    int getParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n            fishes[parx] += fishes[pary];\\n        }\\n    }\\n\\n    int getFishes(int x) {\\n        return fishes[getParent(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector<int> dr{0, 0, 1, -1}, dc{1, -1, 0, 0};\\n        UnionFind dsu(grid);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c]) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int r1 = r + dr[k], c1 = c + dc[k];\\n                        if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1]) {\\n                            dsu.unionSet(n * r + c, n * r1 + c1);\\n                        }\\n                    }\\n                    result = max(result, dsu.getFishes(n * r + c));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466626,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466670,
                "title": "easy-to-understand-simple-dfs",
                "content": "#Given : We can start at any water cell \\n#So why not do the same\\n#For a given water cell, collect all the fishes from the cells which are **\\u2018connected\\u2019 [directly/indirectly]** from that cell\\n#So **get the count of fishes for each connected component, and then take the maximum**\\n\\n![image](https://assets.leetcode.com/users/images/3c92b14c-6fce-4335-9244-561701786f6b_1682784101.8203545.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>rowDir = {-1, 1, 0, 0}; //top, bottom, left, right\\n    vector<int>colDir = {0, 0, -1, 1};\\n    int dfs(vector<vector<int>>&grid, int row, int col)\\n    {\\n        if (row < 0 || col < 0 || row == grid.size() || col == grid[0].size()) return 0;\\n        if (grid[row][col] == 0) return 0;\\n       \\n        int sum = grid[row][col]; //include fish count of current cell\\n        grid[row][col] = 0; //mark curr cell as visited [make it a water cell]\\n        for (int dirIdx = 0; dirIdx < 4; dirIdx++)\\n        {\\n            int newRow = row + rowDir[dirIdx];\\n            int newCol = col + colDir[dirIdx];\\n            sum += dfs(grid, newRow, newCol); //add fish count of all connected cells to sum\\n        }\\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int maxCount = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0) continue; //if it is a water cell \\n                \\n                int collectedCount = dfs(grid, i, j);\\n                maxCount = max(maxCount, collectedCount);\\n            }\\n        }\\n        return maxCount;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>rowDir = {-1, 1, 0, 0}; //top, bottom, left, right\\n    vector<int>colDir = {0, 0, -1, 1};\\n    int dfs(vector<vector<int>>&grid, int row, int col)\\n    {\\n        if (row < 0 || col < 0 || row == grid.size() || col == grid[0].size()) return 0;\\n        if (grid[row][col] == 0) return 0;\\n       \\n        int sum = grid[row][col]; //include fish count of current cell\\n        grid[row][col] = 0; //mark curr cell as visited [make it a water cell]\\n        for (int dirIdx = 0; dirIdx < 4; dirIdx++)\\n        {\\n            int newRow = row + rowDir[dirIdx];\\n            int newCol = col + colDir[dirIdx];\\n            sum += dfs(grid, newRow, newCol); //add fish count of all connected cells to sum\\n        }\\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int maxCount = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0) continue; //if it is a water cell \\n                \\n                int collectedCount = dfs(grid, i, j);\\n                maxCount = max(maxCount, collectedCount);\\n            }\\n        }\\n        return maxCount;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467962,
                "title": "python-3-8-lines-dfs-t-m-92-68",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def dfs(r,c):\\n\\n            if (r,c) not in unseen:return 0\\n            unseen.remove((r,c))\\n            return grid[r][c] + dfs(r+1,c)+dfs(r,c+1)+dfs(r-1,c)+dfs(r,c-1)\\n            \\n        m, n, ans = len(grid), len(grid[0]), 0\\n        unseen = {(i,j) for i,j in product(range(m),range(n))\\n                                                if grid[i][j]}\\n        while unseen: ans = max(ans,dfs(*min(unseen)))\\n\\n        return ans \\n```\\n[https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/submissions/975947247/](http://)\\n\\n\\n\\nI\\'m surely wrong, but I think that time complexity might be--worstcase-- *O*(*MN*^2), and space complexity might be *O*(*MN*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def dfs(r,c):\\n\\n            if (r,c) not in unseen:return 0\\n            unseen.remove((r,c))\\n            return grid[r][c] + dfs(r+1,c)+dfs(r,c+1)+dfs(r-1,c)+dfs(r,c-1)\\n            \\n        m, n, ans = len(grid), len(grid[0]), 0\\n        unseen = {(i,j) for i,j in product(range(m),range(n))\\n                                                if grid[i][j]}\\n        while unseen: ans = max(ans,dfs(*min(unseen)))\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467188,
                "title": "bfs-c-easy-solution",
                "content": "# Approach\\nSimple BFS approach.\\nEnter in a cell when grid[r][c]!=0 and search in neighbours cell using bfs whenever leaving that particular cell add this to our fish variable and put it equal to 0 that is grid[r][c]=0.\\n\\n# Complexity\\n- Time complexity:\\n  O(n*m)\\n\\n- Space complexity:\\n  O(min(n,m))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> v={0,-1,0,1,0};\\n        int ans=0,mx=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    queue<pair<int,int>> q;\\n                    q.push({i,j});\\n                    ans+=grid[i][j];\\n                    grid[i][j]=0;\\n                    while(!q.empty())\\n                    {\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int r1=q.front().first+v[k];\\n                            int c1=q.front().second+v[k+1];\\n                            if(r1>=0 && r1<n && c1>=0 && c1<m && grid[r1][c1]!=0)\\n                            {\\n                                ans+=grid[r1][c1];\\n                                q.push({r1,c1});\\n                                grid[r1][c1]=0;\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n                 mx=max(mx,ans);\\n            }\\n         }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> v={0,-1,0,1,0};\\n        int ans=0,mx=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    queue<pair<int,int>> q;\\n                    q.push({i,j});\\n                    ans+=grid[i][j];\\n                    grid[i][j]=0;\\n                    while(!q.empty())\\n                    {\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int r1=q.front().first+v[k];\\n                            int c1=q.front().second+v[k+1];\\n                            if(r1>=0 && r1<n && c1>=0 && c1<m && grid[r1][c1]!=0)\\n                            {\\n                                ans+=grid[r1][c1];\\n                                q.push({r1,c1});\\n                                grid[r1][c1]=0;\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n                 mx=max(mx,ans);\\n            }\\n         }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467122,
                "title": "java-bfs-code-with-explanation",
                "content": "# ********** Please upvote if it is helpful **********\\n\\n# Explanation\\n- Given that we have to choose optimal cell i.e grid[r][c] > 0 { water cell } in order to find the maximum fishes we can get.\\n- Traverse the given grid and apply **BFS** on grid[r][c] > 0\\n- We have to calculate the maximum fishes using bfs function.\\n- # BFS function explanation\\n- First of all add the cell into a queue and mark the cell as visited.\\n- Since you are on the cell which have water that consists of fishes so add grid[r][c] to your collection of fishes.\\n- Now check all adjacent sides of current cell whose value should not be \\'0\\' i.e it should be a water cell since if grid[r][c] = 0 it is land and you cant caught fish from land. \\n- If it is water cell then it consists of fishes so, add grid[r][c] it to your collection of fishes.\\n- Now add the adjacent cell to queue if not visited yet.\\n- Lastly **BFS** function returns the number of fishes that you are collected from present cell.\\n-  And each time the max fishes that are collected from each cell{grid[r][c] > 0} calculated in main function.\\n\\n# Complexity\\n- Time complexity: O(N + M) \\n- Space Complexity : O(N)\\n\\n# Code\\n```\\nclass Solution {\\n     int[] x = {-1,0,1,0};\\n     int[] y = {0,1,0,-1};\\n     class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first,int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n   \\n   \\n   \\n    public int bfs(int i,int j,boolean[][] vis,int[][] grid) {\\n       \\n        int sum = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        vis[i][j] = true;\\n        sum += grid[i][j];\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            int first = p.first;\\n            int second = p.second;\\n            \\n           \\n            \\n            for(int k = 0;k<4;k++) {\\n                \\n                int ind1 = x[k] + first;\\n                int ind2 = y[k] + second;\\n              \\n                if(ind1 >=0 && ind2 >=0 && ind1 < grid.length && ind2 < grid[0].length && !vis[ind1][ind2] ){\\n                    \\n                    \\n                     if(grid[ind1][ind2] > 0) {\\n                       \\n                          sum += grid[ind1][ind2];\\n                          q.add(new Pair(ind1,ind2));\\n                          vis[ind1][ind2] = true;\\n                     }\\n                   \\n                     \\n                }\\n                \\n            }\\n           \\n        }\\n        return sum;\\n    }\\n\\n     public int findMaxFish(int[][] grid) {\\n      int ans= 0;\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i<grid.length;i++) {\\n            for(int j = 0;j<grid[i].length;j++) {\\n                if(!vis[i][j] && grid[i][j] != 0) {\\n                    ans = Math.max(ans,bfs(i,j,vis,grid));\\n                    \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n     int[] x = {-1,0,1,0};\\n     int[] y = {0,1,0,-1};\\n     class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first,int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n   \\n   \\n   \\n    public int bfs(int i,int j,boolean[][] vis,int[][] grid) {\\n       \\n        int sum = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        vis[i][j] = true;\\n        sum += grid[i][j];\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            int first = p.first;\\n            int second = p.second;\\n            \\n           \\n            \\n            for(int k = 0;k<4;k++) {\\n                \\n                int ind1 = x[k] + first;\\n                int ind2 = y[k] + second;\\n              \\n                if(ind1 >=0 && ind2 >=0 && ind1 < grid.length && ind2 < grid[0].length && !vis[ind1][ind2] ){\\n                    \\n                    \\n                     if(grid[ind1][ind2] > 0) {\\n                       \\n                          sum += grid[ind1][ind2];\\n                          q.add(new Pair(ind1,ind2));\\n                          vis[ind1][ind2] = true;\\n                     }\\n                   \\n                     \\n                }\\n                \\n            }\\n           \\n        }\\n        return sum;\\n    }\\n\\n     public int findMaxFish(int[][] grid) {\\n      int ans= 0;\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i<grid.length;i++) {\\n            for(int j = 0;j<grid[i].length;j++) {\\n                if(!vis[i][j] && grid[i][j] != 0) {\\n                    ans = Math.max(ans,bfs(i,j,vis,grid));\\n                    \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466750,
                "title": "c-best-solution-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        visited[r][c] = true;\\n        int  cnt = grid[r][c], n = grid.size(), m = grid[0].size();\\n        \\n        if(c+1<m && grid[r][c+1] && !visited[r][c+1])   {\\n            cnt += solve(grid, visited, r, c+1);\\n        }\\n        \\n        if(c-1>=0 && grid[r][c-1] && !visited[r][c-1])  {\\n            cnt += solve(grid, visited, r, c-1);\\n        }\\n            \\n        if(r+1<n && grid[r+1][c] && !visited[r+1][c])   {\\n            cnt += solve(grid, visited, r+1, c);\\n        }\\n            \\n        if(r-1>=0 && grid[r-1][c] && !visited[r-1][c])  {\\n            cnt += solve(grid, visited, r-1, c);\\n        }\\n            \\n        return cnt;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<n; i++)  for(int j=0; j<m; j++) \\n                // if it is water cell and not visited the call the dfs function to calculate the total fish and compare with the maximum\\n                if(grid[i][j] && !visited[i][j])   {\\n                    int x = solve(grid, visited, i,  j);\\n                    maxi = max(maxi, x);\\n                }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        visited[r][c] = true;\\n        int  cnt = grid[r][c], n = grid.size(), m = grid[0].size();\\n        \\n        if(c+1<m && grid[r][c+1] && !visited[r][c+1])   {\\n            cnt += solve(grid, visited, r, c+1);\\n        }\\n        \\n        if(c-1>=0 && grid[r][c-1] && !visited[r][c-1])  {\\n            cnt += solve(grid, visited, r, c-1);\\n        }\\n            \\n        if(r+1<n && grid[r+1][c] && !visited[r+1][c])   {\\n            cnt += solve(grid, visited, r+1, c);\\n        }\\n            \\n        if(r-1>=0 && grid[r-1][c] && !visited[r-1][c])  {\\n            cnt += solve(grid, visited, r-1, c);\\n        }\\n            \\n        return cnt;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<n; i++)  for(int j=0; j<m; j++) \\n                // if it is water cell and not visited the call the dfs function to calculate the total fish and compare with the maximum\\n                if(grid[i][j] && !visited[i][j])   {\\n                    int x = solve(grid, visited, i,  j);\\n                    maxi = max(maxi, x);\\n                }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949641,
                "title": "best-o-m-n-solution",
                "content": "# Approach\\nBFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int traversal(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int m = grid.size(), n = grid[0].size();\\n        int fish = 0;\\n        queue <pair<int, int>> q;\\n        q.push({i, j});\\n        vis[i][j] = 1;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            fish += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + drow[i];\\n                int nc = c + dcol[i];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\\n                    && grid[nr][nc] > 0 && !vis[nr][nc]) {\\n                       q.push({nr, nc});\\n                       vis[nr][nc] = 1;\\n                   }\\n            }\\n        }\\n        return fish;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        int maxFish = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = traversal(i, j, grid, vis);\\n                    maxFish = max (maxFish, fish);\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int traversal(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int m = grid.size(), n = grid[0].size();\\n        int fish = 0;\\n        queue <pair<int, int>> q;\\n        q.push({i, j});\\n        vis[i][j] = 1;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            fish += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + drow[i];\\n                int nc = c + dcol[i];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\\n                    && grid[nr][nc] > 0 && !vis[nr][nc]) {\\n                       q.push({nr, nc});\\n                       vis[nr][nc] = 1;\\n                   }\\n            }\\n        }\\n        return fish;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        int maxFish = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = traversal(i, j, grid, vis);\\n                    maxFish = max (maxFish, fish);\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492192,
                "title": "c-dfs",
                "content": "# Approach\\nAPPLE DFS\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &m,int &n,vector<vector<int>> &g,int &k){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0)return;\\n        k += g[i][j];\\n        g[i][j]  = 0;\\n        solve(i+1,j,m,n,g,k);\\n        solve(i,j+1,m,n,g,k);\\n        solve(i-1,j,m,n,g,k);\\n        solve(i,j-1,m,n,g,k);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]){\\n                    k = 0;\\n                    solve(i,j,m,n,grid,k);\\n                    cout<<k<<\" \";\\n                    ans = max(ans,k);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &m,int &n,vector<vector<int>> &g,int &k){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0)return;\\n        k += g[i][j];\\n        g[i][j]  = 0;\\n        solve(i+1,j,m,n,g,k);\\n        solve(i,j+1,m,n,g,k);\\n        solve(i-1,j,m,n,g,k);\\n        solve(i,j-1,m,n,g,k);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]){\\n                    k = 0;\\n                    solve(i,j,m,n,grid,k);\\n                    cout<<k<<\" \";\\n                    ans = max(ans,k);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468865,
                "title": "easy-solution-java-dfs",
                "content": "# Intuition\\nTo find the maximum fish a fisherman can obtain. The zero represent the land and the numbers represent the number of available fish.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the maximum variable as global\\n- Create a boolean matrix called visited to keep track on the visited grid.\\n- Create a function dfs, it helps to move to adjacent cells in deep and stop if the grid is already visted or the land is reached.\\n- Increase the max for eachs recursive call.\\n- Update the maximum vairalbe for each dfs call from the findMaxFish() function.\\n> Upvote\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int max;\\n    public int findMaxFish(int[][] grid) {\\n        int rlen = grid.length;\\n        int clen = grid[0].length;\\n        int answer = 0;\\n        boolean visited[][] = new boolean[rlen][clen];\\n        for(int i=0;i<rlen;i++){\\n            for(int j=0;j<clen;j++){\\n                if(grid[i][j]!=0 && !visited[i][j]){\\n                    max = 0;\\n                    dfs(grid, rlen, clen,visited, i, j);\\n                    answer = Math.max(max, answer );\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public void dfs(int[][] grid, int rlen, int clen, boolean[][] visited, int i, int j){\\n        if(i<0||i>=rlen||j<0||j>=clen||visited[i][j]||grid[i][j] == 0){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        max +=grid[i][j];\\n        dfs(grid, rlen, clen, visited, i+1, j);\\n        dfs(grid, rlen, clen, visited, i-1, j);\\n        dfs(grid, rlen, clen, visited, i, j+1);\\n        dfs(grid, rlen, clen, visited, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int max;\\n    public int findMaxFish(int[][] grid) {\\n        int rlen = grid.length;\\n        int clen = grid[0].length;\\n        int answer = 0;\\n        boolean visited[][] = new boolean[rlen][clen];\\n        for(int i=0;i<rlen;i++){\\n            for(int j=0;j<clen;j++){\\n                if(grid[i][j]!=0 && !visited[i][j]){\\n                    max = 0;\\n                    dfs(grid, rlen, clen,visited, i, j);\\n                    answer = Math.max(max, answer );\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public void dfs(int[][] grid, int rlen, int clen, boolean[][] visited, int i, int j){\\n        if(i<0||i>=rlen||j<0||j>=clen||visited[i][j]||grid[i][j] == 0){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        max +=grid[i][j];\\n        dfs(grid, rlen, clen, visited, i+1, j);\\n        dfs(grid, rlen, clen, visited, i-1, j);\\n        dfs(grid, rlen, clen, visited, i, j+1);\\n        dfs(grid, rlen, clen, visited, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466636,
                "title": "simple-java-bfs",
                "content": "```\\nclass pair{\\n    int x;int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int max=0;\\n      //  System.out.print(bfs(0,1,grid,m,n)+\" \");\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                 //   System.out.print(bfs(i,j,grid,m,n)+\" \");\\n                    \\n                    max=Math.max(max,bfs(i,j,grid,m,n));\\n                }\\n            }\\n        }\\n        return max;\\n       \\n    }\\n    public int bfs(int i,int j,int grid[][],int m,int n){\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(i,j));\\n         int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n      //  int max=0;\\n        int sum=grid[i][j];\\n        grid[i][j]=0;\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n          //  System.out.print(x+\" \"+y);\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]==0)continue;\\n                q.add(new pair(newx,newy));\\n               \\n                sum+=grid[newx][newy];\\n                 grid[newx][newy]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass pair{\\n    int x;int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int max=0;\\n      //  System.out.print(bfs(0,1,grid,m,n)+\" \");\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                 //   System.out.print(bfs(i,j,grid,m,n)+\" \");\\n                    \\n                    max=Math.max(max,bfs(i,j,grid,m,n));\\n                }\\n            }\\n        }\\n        return max;\\n       \\n    }\\n    public int bfs(int i,int j,int grid[][],int m,int n){\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(i,j));\\n         int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n      //  int max=0;\\n        int sum=grid[i][j];\\n        grid[i][j]=0;\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n          //  System.out.print(x+\" \"+y);\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]==0)continue;\\n                q.add(new pair(newx,newy));\\n               \\n                sum+=grid[newx][newy];\\n                 grid[newx][newy]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673143,
                "title": "easy-approach-c-depth-first-search-maximum-number-of-fishes-in-a-grid",
                "content": "# Approach\\nDepth first Search.\\n- Converted each traversed path to land cell so that a separate `visited` array is not required.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int dfs(vector<vector<int>>& grid, int row, int col){\\n        int n = grid.size(), m = grid[0].size();\\n        if(!isValid(row, col, n, m) || grid[row][col] == 0) return 0;\\n        int direc[5] = {0, 1, 0, -1, 0};\\n        int res = grid[row][col];\\n        grid[row][col] = 0;\\n        for(int k=0; k<4; k++) { \\n            res += dfs(grid, row+direc[k], col+direc[k+1]);\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int dfs(vector<vector<int>>& grid, int row, int col){\\n        int n = grid.size(), m = grid[0].size();\\n        if(!isValid(row, col, n, m) || grid[row][col] == 0) return 0;\\n        int direc[5] = {0, 1, 0, -1, 0};\\n        int res = grid[row][col];\\n        grid[row][col] = 0;\\n        for(int k=0; k<4; k++) { \\n            res += dfs(grid, row+direc[k], col+direc[k+1]);\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468041,
                "title": "fully-explained-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t// Loop over the Entire Grid\\n        for(int i=0;i< grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\t\\t\\t    // only call the dfs call when we encounter a value>0, then find the number of connected land and calculate value and compare it with the previous max\\n                if(grid[i][j]>0){\\n                    max= Math.max(max, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] grid, int i, int j){\\n\\t\\t// if we gets out of bound or its a 0 i.e. water then return 0\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return 0;\\n\\t\\t// if not then mark the grid value to 0 to make sure we do not come back to the same piece of land and cause infinite recursion i.e. stack over flow\\n        int val = grid[i][j];\\n        grid[i][j]=0;\\n\\t\\t// now just go to all 4 direction get the respective counts and add it all together and return it\\n        return val+ dfs(grid, i-1, j)+ dfs(grid, i+1, j)+ dfs(grid, i, j-1)+ dfs(grid, i, j+1);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t// Loop over the Entire Grid\\n        for(int i=0;i< grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\t\\t\\t    // only call the dfs call when we encounter a value>0, then find the number of connected land and calculate value and compare it with the previous max\\n                if(grid[i][j]>0){\\n                    max= Math.max(max, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] grid, int i, int j){\\n\\t\\t// if we gets out of bound or its a 0 i.e. water then return 0\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return 0;\\n\\t\\t// if not then mark the grid value to 0 to make sure we do not come back to the same piece of land and cause infinite recursion i.e. stack over flow\\n        int val = grid[i][j];\\n        grid[i][j]=0;\\n\\t\\t// now just go to all 4 direction get the respective counts and add it all together and return it\\n        return val+ dfs(grid, i-1, j)+ dfs(grid, i+1, j)+ dfs(grid, i, j-1)+ dfs(grid, i, j+1);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467257,
                "title": "c-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467120,
                "title": "python-3-easy-solution",
                "content": "The function then defines an inner function called **dfs** that performs a depth-first search on the grid starting from a given position (i,j) and returns the sum of fish in the connected region.\\n\\nThe dfs function first checks if the **current** position is **outside the bounds** of the grid or if the position corresponds to a cell with value **0 or -1** (0 - water, -1 - visited). If any of these conditions is true, the function returns 0 (**no fish here**).\\nOtherwise, the function retrieves the number of fish fish in the current cell, sets the cell value to -1 (*to mark it as visited*), and recursively calls itself on the four adjacent cells (up, left, down, and right), accumulating the fish counts in a variable temp.\\n\\n```\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        N, M = len(grid), len(grid[0])\\n        \\n        def dfs(i, j, temp):\\n            if i < 0 or j < 0 or i >= N or j >= M or grid[i][j] in [0, -1]:\\n                return 0\\n            \\n            fish = grid[i][j]\\n            grid[i][j] = -1  # visited\\n            temp += (fish + dfs(i-1, j, temp) + dfs(i, j-1, temp) + dfs(i+1, j, temp) + dfs(i, j+1, temp))\\n\\n            return temp \\n        \\n        maxi = 0\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] > 0:\\n                    maxi = max(maxi, dfs(i, j, 0))\\n                \\n        return maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        N, M = len(grid), len(grid[0])\\n        \\n        def dfs(i, j, temp):\\n            if i < 0 or j < 0 or i >= N or j >= M or grid[i][j] in [0, -1]:\\n                return 0\\n            \\n            fish = grid[i][j]\\n            grid[i][j] = -1  # visited\\n            temp += (fish + dfs(i-1, j, temp) + dfs(i, j-1, temp) + dfs(i+1, j, temp) + dfs(i, j+1, temp))\\n\\n            return temp \\n        \\n        maxi = 0\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] > 0:\\n                    maxi = max(maxi, dfs(i, j, 0))\\n                \\n        return maxi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466759,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\npublic class Solution {\\n    int max = 0, cur = 0;\\n    public int findMaxFish(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                pass(grid, i, j);\\n                cur = 0;\\n            }\\n        }\\n        return max;\\n    }\\n    void pass(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0)    return;\\n        cur += grid[i][j];\\n        grid[i][j] = 0;\\n        max = Math.max(max,cur);\\n        pass(grid, i+1, j);\\n        pass(grid, i-1, j);\\n        pass(grid, i, j+1);\\n        pass(grid, i, j-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic class Solution {\\n    int max = 0, cur = 0;\\n    public int findMaxFish(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                pass(grid, i, j);\\n                cur = 0;\\n            }\\n        }\\n        return max;\\n    }\\n    void pass(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0)    return;\\n        cur += grid[i][j];\\n        grid[i][j] = 0;\\n        max = Math.max(max,cur);\\n        pass(grid, i+1, j);\\n        pass(grid, i-1, j);\\n        pass(grid, i, j+1);\\n        pass(grid, i, j-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466660,
                "title": "easy-to-understand-clean-solution-dfs-python-java",
                "content": "**T.C : O(n^2)**\\n\\n**Python**\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0\\n\\n        def catchFish(r, c):\\n            nonlocal fish\\n            if 0 <= r < m and 0 <= c < n and grid[r][c] > 0:\\n                fish += grid[r][c]\\n                grid[r][c] = 0  # mark cell as visited\\n                catchFish(r+1, c)\\n                catchFish(r-1, c)\\n                catchFish(r, c+1)\\n                catchFish(r, c-1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] > 0:\\n                    fish = 0\\n                    catchFish(r, c)\\n                    fishes = max(fishes, fish)\\n\\n        return fishes\\n```\\n\\n**Java**\\n\\n```\\npublic class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int fishes = 0;\\n\\n        // Helper function to catch fish recursively\\n        // Updates the \\'fishes\\' variable as it catches fish\\n        void catchFish(int r, int c) {\\n            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] > 0) {\\n                fishes += grid[r][c];\\n                grid[r][c] = 0; // mark cell as visited\\n                catchFish(r+1, c);\\n                catchFish(r-1, c);\\n                catchFish(r, c+1);\\n                catchFish(r, c-1);\\n            }\\n        }\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] > 0) {\\n                    int fish = 0;\\n                    catchFish(r, c);\\n                    fishes = Math.max(fishes, fish);\\n                }\\n            }\\n        }\\n\\n        return fishes;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0\\n\\n        def catchFish(r, c):\\n            nonlocal fish\\n            if 0 <= r < m and 0 <= c < n and grid[r][c] > 0:\\n                fish += grid[r][c]\\n                grid[r][c] = 0  # mark cell as visited\\n                catchFish(r+1, c)\\n                catchFish(r-1, c)\\n                catchFish(r, c+1)\\n                catchFish(r, c-1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] > 0:\\n                    fish = 0\\n                    catchFish(r, c)\\n                    fishes = max(fishes, fish)\\n\\n        return fishes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511854,
                "title": "dfs-approach-easy-to-understand-standard-method-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a standard traversal problem where we will traverse each component, find the sum of fishes on each component and find out the maximum of all the sums.\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    void dfs(vvi& grid, int i,int j, int& sum){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i>=m || i<0 || j<0 || j>=n){\\n            return;\\n        }\\n        if(grid[i][j]!=0 && grid[i][j]!=-1){\\n            sum += grid[i][j];\\n            grid[i][j]=-1;\\n            dfs(grid,i+1,j,sum);\\n            dfs(grid,i,j+1,sum);\\n            dfs(grid,i-1,j,sum);\\n            dfs(grid,i,j-1,sum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = INT_MIN;\\n        int sum=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                    dfs(grid,i,j,sum);\\n                    ans = max(ans,sum);\\n                    sum=0;\\n                }\\n            }\\n        }\\n    \\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    void dfs(vvi& grid, int i,int j, int& sum){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i>=m || i<0 || j<0 || j>=n){\\n            return;\\n        }\\n        if(grid[i][j]!=0 && grid[i][j]!=-1){\\n            sum += grid[i][j];\\n            grid[i][j]=-1;\\n            dfs(grid,i+1,j,sum);\\n            dfs(grid,i,j+1,sum);\\n            dfs(grid,i-1,j,sum);\\n            dfs(grid,i,j-1,sum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = INT_MIN;\\n        int sum=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                    dfs(grid,i,j,sum);\\n                    ans = max(ans,sum);\\n                    sum=0;\\n                }\\n            }\\n        }\\n    \\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497476,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- BFS traversal on the Connected Components. Just a variation of LC #200[Number Of Islands]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a breadth-first search (BFS) approach to traverse the water cells in the given grid and calculate the maximum number of fish that can be caught.\\n\\n- For each water cell in the grid, the BFS is applied to find out  all the connected water cells and count the total number of fish in those cells.\\n\\n- The maximum fish count obtained from all the BFS traversals is then returned as the result.\\n\\n# Complexity\\nTime complexity:  O(m * n(m + n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- where m and n are the number of rows and columns in the input grid. In the worst case, we may have to traverse all the water cells in the grid, and each BFS traversal takes O(m + n) time.\\n\\nSpace complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- since we are using a 2D visited matrix to keep track of the visited water cells. In the worst case, all the water cells may need to be visited, requiring a visited matrix of size mn. Additionally, the queue used in BFS will hold a maximum of O(m*n) water cell positions at any point in time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxFishes = INT_MIN;\\n\\n    void bfs(int row, int col, vector <vector<int>> &grid, vector <vector<int>> &vis, int dx[], int dy[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vis[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n\\n        int fishes = 0;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n\\n            //adding the count of the number of fishes in the current cell\\n            fishes += grid[x][y];\\n            q.pop();\\n\\n            //finding out the current cell neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nRow = x + dx[i];\\n                int nCol = y + dy[i];\\n                \\n                //check for the validity of neighbouring row & col\\n                if(nRow >= 0 && nRow < n && nCol >= 0 && nCol < m && grid[nRow][nCol] > 0 && !vis[nRow][nCol])\\n                {\\n                    vis[nRow][nCol] = 1;\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n\\n        maxFishes = max(maxFishes, fishes);\\n        return;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        //no of rows\\n        int n = grid.size();\\n        \\n        //no of cols\\n        int m = grid[0].size();\\n        \\n        //create the visited matrix to keep track of the water cell\\n        vector <vector <int>> vis(n, vector <int> (m, 0));\\n        \\n        //can move only in 4-directions\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};    \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0 && !vis[i][j])\\n                    bfs(i, j, grid, vis, dx, dy);\\n            }\\n        }\\n        \\n        return maxFishes == INT_MIN ? 0 : maxFishes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxFishes = INT_MIN;\\n\\n    void bfs(int row, int col, vector <vector<int>> &grid, vector <vector<int>> &vis, int dx[], int dy[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vis[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n\\n        int fishes = 0;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n\\n            //adding the count of the number of fishes in the current cell\\n            fishes += grid[x][y];\\n            q.pop();\\n\\n            //finding out the current cell neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nRow = x + dx[i];\\n                int nCol = y + dy[i];\\n                \\n                //check for the validity of neighbouring row & col\\n                if(nRow >= 0 && nRow < n && nCol >= 0 && nCol < m && grid[nRow][nCol] > 0 && !vis[nRow][nCol])\\n                {\\n                    vis[nRow][nCol] = 1;\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n\\n        maxFishes = max(maxFishes, fishes);\\n        return;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        //no of rows\\n        int n = grid.size();\\n        \\n        //no of cols\\n        int m = grid[0].size();\\n        \\n        //create the visited matrix to keep track of the water cell\\n        vector <vector <int>> vis(n, vector <int> (m, 0));\\n        \\n        //can move only in 4-directions\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};    \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0 && !vis[i][j])\\n                    bfs(i, j, grid, vis, dx, dy);\\n            }\\n        }\\n        \\n        return maxFishes == INT_MIN ? 0 : maxFishes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470839,
                "title": "c-dfs-similar-to-number-of-islands",
                "content": "# Intuition\\nSimple DFS involves calculating the sum of different islands and taking the maximum one.\\nSimilar to Number of Islands problem (https://leetcode.com/problems/number-of-islands/).\\n# Approach\\nDepth First Search\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n    void dfs(int x,int y,vector<vector<int>>& grid,int* ans){\\n        for(int next = 0;next<4;next++){\\n            int x1 = x + dx[next];\\n            int y1 = y + dy[next];\\n            if(x1>=0 and y1>=0 and y1<grid[0].size() and x1<grid.size() and grid[x1][y1]!=0){\\n                *ans += grid[x1][y1];\\n                grid[x1][y1] = 0;\\n                dfs(x1,y1,grid,ans);\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n  = grid[0].size();\\n        //vector<vector<int>> vis(m,vector<int>(m,0));\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(grid[i][j] != 0){\\n                    int count = grid[i][j];\\n                    grid[i][j] = 0;\\n                    dfs(i,j,grid,&count);\\n                    ans = max(ans,count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n    void dfs(int x,int y,vector<vector<int>>& grid,int* ans){\\n        for(int next = 0;next<4;next++){\\n            int x1 = x + dx[next];\\n            int y1 = y + dy[next];\\n            if(x1>=0 and y1>=0 and y1<grid[0].size() and x1<grid.size() and grid[x1][y1]!=0){\\n                *ans += grid[x1][y1];\\n                grid[x1][y1] = 0;\\n                dfs(x1,y1,grid,ans);\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n  = grid[0].size();\\n        //vector<vector<int>> vis(m,vector<int>(m,0));\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(grid[i][j] != 0){\\n                    int count = grid[i][j];\\n                    grid[i][j] = 0;\\n                    dfs(i,j,grid,&count);\\n                    ans = max(ans,count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467138,
                "title": "c-simple-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    void f(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>> &vis)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        vis[i][j]=1;\\n        int s=0;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            s+=grid[x][y];\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=m or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==0)\\n                    continue;\\n                q.push({newx,newy});\\n                vis[newx][newy]=1;\\n            }\\n        }\\n        maxi=max(maxi,s);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0 and !vis[i][j])\\n                {\\n                    f(i,j,m,n,grid,vis);\\n                }\\n            }\\n        }\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    void f(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>> &vis)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        vis[i][j]=1;\\n        int s=0;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            s+=grid[x][y];\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=m or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==0)\\n                    continue;\\n                q.push({newx,newy});\\n                vis[newx][newy]=1;\\n            }\\n        }\\n        maxi=max(maxi,s);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0 and !vis[i][j])\\n                {\\n                    f(i,j,m,n,grid,vis);\\n                }\\n            }\\n        }\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467125,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS 2D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, cnt, vis[11][11];\\n    \\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and grids[x][y]) return true;\\n        else return false;\\n    }\\n    \\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            vis[x][y] = 1;\\n            cnt += grids[x][y];\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        grids = grid;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(!vis[i][j] and grid[i][j]) {\\n                    cnt = 0;\\n                    dfs(i, j);\\n                    ans = max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, cnt, vis[11][11];\\n    \\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and grids[x][y]) return true;\\n        else return false;\\n    }\\n    \\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            vis[x][y] = 1;\\n            cnt += grids[x][y];\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        grids = grid;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(!vis[i][j] and grid[i][j]) {\\n                    cnt = 0;\\n                    dfs(i, j);\\n                    ans = max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466879,
                "title": "dfs-most-simple-solution-c",
                "content": "\\n````\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &a,int &b,int &sum,int &ans,vector<vector<int>> &g){\\n        ans = max(ans,sum);\\n        if(i<0||j<0||i>=a||j>=b||g[i][j]==0){\\n            return;\\n        }\\n        sum += g[i][j];\\n        g[i][j] = 0;\\n        solve(i+1,j,a,b,sum,ans,g);\\n        solve(i,j+1,a,b,sum,ans,g);\\n        solve(i-1,j,a,b,sum,ans,g);\\n        solve(i,j-1,a,b,sum,ans,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,a = grid.size(),b = grid[0].size();\\n        int sum = 0;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]){\\n                    sum = 0;\\n                    solve(i,j,a,b,sum,ans,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &a,int &b,int &sum,int &ans,vector<vector<int>> &g){\\n        ans = max(ans,sum);\\n        if(i<0||j<0||i>=a||j>=b||g[i][j]==0){\\n            return;\\n        }\\n        sum += g[i][j];\\n        g[i][j] = 0;\\n        solve(i+1,j,a,b,sum,ans,g);\\n        solve(i,j+1,a,b,sum,ans,g);\\n        solve(i-1,j,a,b,sum,ans,g);\\n        solve(i,j-1,a,b,sum,ans,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,a = grid.size(),b = grid[0].size();\\n        int sum = 0;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]){\\n                    sum = 0;\\n                    solve(i,j,a,b,sum,ans,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466830,
                "title": "intuitive-javascript-solution-using-dfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M * N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    // returns the sum of fishes possible\\n    const DFS = (r, c, visit) => {\\n        \\n        // base cases returns 0; \\n        if( r < 0 || r >= ROW ||\\n            c < 0 || c >= COL || \\n            visit.has(`${r}_${c}`) ||\\n            grid[r][c] == 0 \\n          ){\\n            return 0;\\n        }\\n        \\n        // set visted\\n        visit.add(`${r}_${c}`);\\n        \\n        let sum = grid[r][c]; // add current value to sum\\n        \\n        // check the surrounding nodes\\n        sum += DFS(r, c + 1, visit);\\n        sum += DFS(r, c - 1, visit);\\n        sum += DFS(r + 1, c, visit);\\n        sum += DFS(r - 1, c, visit);\\n        \\n        return sum;\\n    }\\n    \\n    let set = new Set(); // to record all visted nodes\\n    \\n    // go through each cell\\n    for(let r = 0; r < ROW; r++){\\n       for(let c = 0; c < COL; c++){\\n            // if the cell is water\\n           if(grid[r][c] != 0){ \\n               let res = DFS(r, c, set);\\n\\n               //compare the result from DFS to main global variable \\n               max_fishes = Math.max(res, max_fishes);\\n           }\\n       }\\n    }\\n    \\n    return max_fishes; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    // returns the sum of fishes possible\\n    const DFS = (r, c, visit) => {\\n        \\n        // base cases returns 0; \\n        if( r < 0 || r >= ROW ||\\n            c < 0 || c >= COL || \\n            visit.has(`${r}_${c}`) ||\\n            grid[r][c] == 0 \\n          ){\\n            return 0;\\n        }\\n        \\n        // set visted\\n        visit.add(`${r}_${c}`);\\n        \\n        let sum = grid[r][c]; // add current value to sum\\n        \\n        // check the surrounding nodes\\n        sum += DFS(r, c + 1, visit);\\n        sum += DFS(r, c - 1, visit);\\n        sum += DFS(r + 1, c, visit);\\n        sum += DFS(r - 1, c, visit);\\n        \\n        return sum;\\n    }\\n    \\n    let set = new Set(); // to record all visted nodes\\n    \\n    // go through each cell\\n    for(let r = 0; r < ROW; r++){\\n       for(let c = 0; c < COL; c++){\\n            // if the cell is water\\n           if(grid[r][c] != 0){ \\n               let res = DFS(r, c, set);\\n\\n               //compare the result from DFS to main global variable \\n               max_fishes = Math.max(res, max_fishes);\\n           }\\n       }\\n    }\\n    \\n    return max_fishes; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466744,
                "title": "simple-bfs-solution-connected-components-c",
                "content": "\\n# Approach\\nSame as island problem connected component. Using BFS traverse all the components and return the maximum sum of the the components.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   /*  dfs(int row,int col,vector<vector<int>>&vis,cnt){\\n        vis[row][col]=1;\\n        cnt+=grid[row][col];\\n        \\n    }*/\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\nvector<vector<int>>vis;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int fish = grid[i][j];\\n                    grid[i][j] = 0;\\n\\n                    while (!q.empty())\\n                    {\\n                        int row = q.front().first;\\n                        int col = q.front().second;\\n                        q.pop();\\n\\n                        if (row > 0 && grid[row - 1][col] > 0)\\n                        {\\n                            fish += grid[row - 1][col];\\n                            q.push({row - 1, col});\\n                            grid[row - 1][col] = 0;\\n                        }\\n                        if (row < m - 1 && grid[row + 1][col] > 0)\\n                        {\\n                            fish += grid[row + 1][col];\\n                            q.push({row + 1, col});\\n                            grid[row + 1][col] = 0;\\n                        }\\n                        if (col > 0 && grid[row][col - 1] > 0)\\n                        {\\n                            fish += grid[row][col - 1];\\n                            q.push({row, col - 1});\\n                            grid[row][col - 1] = 0;\\n                        }\\n                        if (col < n - 1 && grid[row][col + 1] > 0)\\n                        {\\n                            fish += grid[row][col + 1];\\n                            q.push({row, col + 1});\\n                            grid[row][col + 1] = 0;\\n                        }\\n                    }\\n\\n                    cnt = max(cnt, fish);\\n                              grid[i][j] = fish;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /*  dfs(int row,int col,vector<vector<int>>&vis,cnt){\\n        vis[row][col]=1;\\n        cnt+=grid[row][col];\\n        \\n    }*/\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\nvector<vector<int>>vis;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int fish = grid[i][j];\\n                    grid[i][j] = 0;\\n\\n                    while (!q.empty())\\n                    {\\n                        int row = q.front().first;\\n                        int col = q.front().second;\\n                        q.pop();\\n\\n                        if (row > 0 && grid[row - 1][col] > 0)\\n                        {\\n                            fish += grid[row - 1][col];\\n                            q.push({row - 1, col});\\n                            grid[row - 1][col] = 0;\\n                        }\\n                        if (row < m - 1 && grid[row + 1][col] > 0)\\n                        {\\n                            fish += grid[row + 1][col];\\n                            q.push({row + 1, col});\\n                            grid[row + 1][col] = 0;\\n                        }\\n                        if (col > 0 && grid[row][col - 1] > 0)\\n                        {\\n                            fish += grid[row][col - 1];\\n                            q.push({row, col - 1});\\n                            grid[row][col - 1] = 0;\\n                        }\\n                        if (col < n - 1 && grid[row][col + 1] > 0)\\n                        {\\n                            fish += grid[row][col + 1];\\n                            q.push({row, col + 1});\\n                            grid[row][col + 1] = 0;\\n                        }\\n                    }\\n\\n                    cnt = max(cnt, fish);\\n                              grid[i][j] = fish;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466663,
                "title": "concise-dfs-c",
                "content": "```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int n, int m) {\\n        vis[i][j] = 1;\\n        int cnt = grid[i][j];\\n        \\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && !vis[x][y]) {\\n                cnt += dfs(x, y, grid, vis, n, m);\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    ans = max(ans, dfs(i, j, grid, vis, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int n, int m) {\\n        vis[i][j] = 1;\\n        int cnt = grid[i][j];\\n        \\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && !vis[x][y]) {\\n                cnt += dfs(x, y, grid, vis, n, m);\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    ans = max(ans, dfs(i, j, grid, vis, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003882,
                "title": "easy-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool check(int row, int col, int n, int m)\\n    {\\n        if (row >= 0 && row < n && col >= 0 && col < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(vector<vector<int>> &grid, int row, int col, vector<vector<bool>> &visited)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if (!check(row, col, n, m) || grid[row][col] == 0 || visited[row][col])\\n        {\\n            return 0;\\n        }\\n        \\n        visited[row][col] = true;\\n        int curr_fish = grid[row][col];\\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newR = row + dir[i][0];\\n            int newC = col + dir[i][1];\\n            curr_fish += dfs(grid, newR, newC, visited);\\n        }\\n        \\n        return curr_fish;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>> &grid)\\n    {\\n        int max_fish = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0)\\n                {\\n                    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n                    int curr_fish_now = dfs(grid, i, j, visited);\\n                    max_fish = max(curr_fish_now, max_fish);\\n                }\\n            }\\n        }\\n        \\n        return max_fish;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(int row, int col, int n, int m)\\n    {\\n        if (row >= 0 && row < n && col >= 0 && col < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(vector<vector<int>> &grid, int row, int col, vector<vector<bool>> &visited)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if (!check(row, col, n, m) || grid[row][col] == 0 || visited[row][col])\\n        {\\n            return 0;\\n        }\\n        \\n        visited[row][col] = true;\\n        int curr_fish = grid[row][col];\\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newR = row + dir[i][0];\\n            int newC = col + dir[i][1];\\n            curr_fish += dfs(grid, newR, newC, visited);\\n        }\\n        \\n        return curr_fish;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>> &grid)\\n    {\\n        int max_fish = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0)\\n                {\\n                    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n                    int curr_fish_now = dfs(grid, i, j, visited);\\n                    max_fish = max(curr_fish_now, max_fish);\\n                }\\n            }\\n        }\\n        \\n        return max_fish;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843214,
                "title": "easy-dfs-beats-70-java",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$ , stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}, new Integer[]{-1, 0}, new Integer[]{0, 1}, new Integer[]{0, -1}\\n    );\\n\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) maxFish = Math.max(maxFish, dfs(i, j, grid));\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (notValid(i, j, grid) || grid[i][j] == 0) return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            fish += dfs(x, y, grid);\\n        }\\n        return fish;\\n    }\\n\\n    private boolean notValid(int i, int j, int[][] grid) {\\n        return i < 0 || i >= grid.length || j < 0 || j >= grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}, new Integer[]{-1, 0}, new Integer[]{0, 1}, new Integer[]{0, -1}\\n    );\\n\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) maxFish = Math.max(maxFish, dfs(i, j, grid));\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (notValid(i, j, grid) || grid[i][j] == 0) return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            fish += dfs(x, y, grid);\\n        }\\n        return fish;\\n    }\\n\\n    private boolean notValid(int i, int j, int[][] grid) {\\n        return i < 0 || i >= grid.length || j < 0 || j >= grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670649,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    int fish = 0;\\n                    cout<<i<<\" \"<<j<<endl;\\n                    bfs(i,j,fish,vis,grid);\\n                    ans = max(fish,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void bfs(int i, int j,int &fish, vector<vector<int>>& vis,vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        \\n        vis[i][j] = 1;\\n        fish += grid[i][j];\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol] > 0 ){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = 1;\\n                    fish += grid[nrow][ncol];\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    int fish = 0;\\n                    cout<<i<<\" \"<<j<<endl;\\n                    bfs(i,j,fish,vis,grid);\\n                    ans = max(fish,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void bfs(int i, int j,int &fish, vector<vector<int>>& vis,vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        \\n        vis[i][j] = 1;\\n        fish += grid[i][j];\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol] > 0 ){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = 1;\\n                    fish += grid[nrow][ncol];\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3666202,
                "title": "java-dfs-boolean-array-of-visited-cells",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < visited.length; i++) for (int j = 0; j < visited[i].length; j++) if (grid[i][j] == 0) visited[i][j] = true;\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (visited[i][j]) continue;\\n                int fish = dfs(i, j, grid, visited, directions);\\n                max = Math.max(fish, max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited, int[][] directions) {\\n        if (!cellExists(r, c, grid)) return 0;\\n\\n        if (visited[r][c]) return 0;\\n        visited[r][c] = true;\\n        int sum = grid[r][c];\\n        for (int[] dir : directions) {\\n            sum += dfs(r + dir[0], c + dir[1], grid, visited, directions);\\n        }\\n        return sum;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < visited.length; i++) for (int j = 0; j < visited[i].length; j++) if (grid[i][j] == 0) visited[i][j] = true;\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (visited[i][j]) continue;\\n                int fish = dfs(i, j, grid, visited, directions);\\n                max = Math.max(fish, max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited, int[][] directions) {\\n        if (!cellExists(r, c, grid)) return 0;\\n\\n        if (visited[r][c]) return 0;\\n        visited[r][c] = true;\\n        int sum = grid[r][c];\\n        for (int[] dir : directions) {\\n            sum += dfs(r + dir[0], c + dir[1], grid, visited, directions);\\n        }\\n        return sum;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617423,
                "title": "java-simple-dfs-algorithm-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dir[][]={{0,1},{0,-1},{1,0},{-1,0}};\\n    public int explore(int a[][],int i,int j,boolean vis[][]){\\n        if(i<0||j<0||i>=a.length||j>=a[0].length||a[i][j]==0||vis[i][j]){\\n            return 0;\\n        }\\n        vis[i][j] = true;\\n        int sum = 0 ;\\n    for(int t=0;t<dir.length;t++){\\n      sum+=  explore(a,i+dir[t][0],j+dir[t][1],vis);\\n    }\\n\\n    return sum+a[i][j];\\n\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    int val = explore(grid,  i,  j,vis);\\n                    if(max<val)max = val;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int dir[][]={{0,1},{0,-1},{1,0},{-1,0}};\\n    public int explore(int a[][],int i,int j,boolean vis[][]){\\n        if(i<0||j<0||i>=a.length||j>=a[0].length||a[i][j]==0||vis[i][j]){\\n            return 0;\\n        }\\n        vis[i][j] = true;\\n        int sum = 0 ;\\n    for(int t=0;t<dir.length;t++){\\n      sum+=  explore(a,i+dir[t][0],j+dir[t][1],vis);\\n    }\\n\\n    return sum+a[i][j];\\n\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    int val = explore(grid,  i,  j,vis);\\n                    if(max<val)max = val;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551393,
                "title": "bfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>grid,int delrow[],int delcol[],int &sum) \\n    {\\n        vis[row][col]=1;   \\n        //int sum=0;\\n        queue<pair<int,int>>q; \\n        q.push({row,col});  \\n         sum+=grid[row][col];\\n        int n=grid.size(),m=grid[0].size(); \\n        while(!q.empty()) \\n        {\\n            int row=q.front().first; \\n            int col=q.front().second; \\n            q.pop();  \\n           \\n                   for(int i=0;i<4;i++){\\n                    int nrow=delrow[i]+row;\\n                    int ncol=delcol[i]+col; \\n                    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]!=0 && !vis[nrow][ncol]) \\n                    {\\n                        vis[nrow][ncol]=1; \\n                        sum+=grid[nrow][ncol]; \\n                        q.push({nrow,ncol});\\n                    }\\n                \\n            }\\n        } \\n     // return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) { \\n        if(grid.size()==1 && grid[0][0]==0 && grid[0].size()==1) \\n        return 0;\\n        int n=grid.size(),m=grid[0].size(); \\n        vector<vector<int>>vis(n,vector<int>(m,0)); \\n        int maxi=0,sum=0; \\n        int delrow[]={-1,0,1,0}; \\n         int delcol[]={0,1,0,-1};\\n        for(int row=0;row<n;row++) \\n        {\\n            for(int col=0;col<m;col++) \\n            {  \\n                if(!vis[row][col] && grid[row][col]!=0) \\n                {\\n                  bfs(row,col,vis,grid,delrow,delcol,sum);\\n                  maxi=max(sum,maxi); \\n                  sum=0;\\n                }\\n\\n            }\\n        }  \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>grid,int delrow[],int delcol[],int &sum) \\n    {\\n        vis[row][col]=1;   \\n        //int sum=0;\\n        queue<pair<int,int>>q; \\n        q.push({row,col});  \\n         sum+=grid[row][col];\\n        int n=grid.size(),m=grid[0].size(); \\n        while(!q.empty()) \\n        {\\n            int row=q.front().first; \\n            int col=q.front().second; \\n            q.pop();  \\n           \\n                   for(int i=0;i<4;i++){\\n                    int nrow=delrow[i]+row;\\n                    int ncol=delcol[i]+col; \\n                    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]!=0 && !vis[nrow][ncol]) \\n                    {\\n                        vis[nrow][ncol]=1; \\n                        sum+=grid[nrow][ncol]; \\n                        q.push({nrow,ncol});\\n                    }\\n                \\n            }\\n        } \\n     // return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) { \\n        if(grid.size()==1 && grid[0][0]==0 && grid[0].size()==1) \\n        return 0;\\n        int n=grid.size(),m=grid[0].size(); \\n        vector<vector<int>>vis(n,vector<int>(m,0)); \\n        int maxi=0,sum=0; \\n        int delrow[]={-1,0,1,0}; \\n         int delcol[]={0,1,0,-1};\\n        for(int row=0;row<n;row++) \\n        {\\n            for(int col=0;col<m;col++) \\n            {  \\n                if(!vis[row][col] && grid[row][col]!=0) \\n                {\\n                  bfs(row,col,vis,grid,delrow,delcol,sum);\\n                  maxi=max(sum,maxi); \\n                  sum=0;\\n                }\\n\\n            }\\n        }  \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544967,
                "title": "dfs-c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dim = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int dfs(vector<vector<int>>& grid,int r,int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0)\\n            return 0;\\n        int ans = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto a : dim){\\n            ans += dfs(grid,r + a[0],c + a[1]);\\n        }\\n        return ans;   \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i = 0;i < r;i++){\\n            for(int j = 0;j < c;j++){\\n                ans = max(ans,dfs(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dim = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int dfs(vector<vector<int>>& grid,int r,int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0)\\n            return 0;\\n        int ans = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto a : dim){\\n            ans += dfs(grid,r + a[0],c + a[1]);\\n        }\\n        return ans;   \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i = 0;i < r;i++){\\n            for(int j = 0;j < c;j++){\\n                ans = max(ans,dfs(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516055,
                "title": "2658-maximum-number-of-fish-in-a-grid-java",
                "content": "```\\nclass Solution {\\n    public int dfs(int [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==0)\\n            return 0;\\n        int res=grid[i][j];\\n        grid[i][j]=0;\\n        res+=dfs(grid,i+1,j);\\n        res+=dfs(grid,i,j+1);\\n        res+=dfs(grid,i-1,j);\\n        res+=dfs(grid,i,j-1);\\n        return res;\\n    }\\n    \\n    public int findMaxFish(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++)\\n        { \\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                  ans=Math.max(ans,dfs(grid,i,j));  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int dfs(int [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==0)\\n            return 0;\\n        int res=grid[i][j];\\n        grid[i][j]=0;\\n        res+=dfs(grid,i+1,j);\\n        res+=dfs(grid,i,j+1);\\n        res+=dfs(grid,i-1,j);\\n        res+=dfs(grid,i,j-1);\\n        return res;\\n    }\\n    \\n    public int findMaxFish(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++)\\n        { \\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                  ans=Math.max(ans,dfs(grid,i,j));  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488243,
                "title": "c-bfs-dfs-both-approaches",
                "content": "## DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& csum){\\n        if (vis[i][j] || grid[i][j]==0)return;\\n        vis[i][j]=1;\\n        csum+= grid[i][j];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        for (int it=0; it<4; it++){\\n            int nr= dx[it]+i;\\n            int nc= dy[it]+j;\\n            if (nr>=0 && nc>=0 && nr<grid.size() && nc<grid[0].size())dfs(grid,vis,nr,nc,csum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int csum=0;\\n                    dfs(grid,vis,i,j,csum);\\n                    ans= max(ans,csum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## BFS\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& curr){\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        curr+= grid[i][j];\\n        vis[i][j]=1;\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,-1,1};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int it=0; it<4; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nc>=0 && nc<grid[0].size() && nr>=0 && nr<grid.size() && !vis[nr][nc] && grid[nr][nc]>0){\\n                    q.push({nr,nc});\\n                    curr+= grid[nr][nc];\\n                    vis[nr][nc]=1;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int curr=0;\\n                    bfs(grid,vis,i,j,curr);\\n                    ans= max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& csum){\\n        if (vis[i][j] || grid[i][j]==0)return;\\n        vis[i][j]=1;\\n        csum+= grid[i][j];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        for (int it=0; it<4; it++){\\n            int nr= dx[it]+i;\\n            int nc= dy[it]+j;\\n            if (nr>=0 && nc>=0 && nr<grid.size() && nc<grid[0].size())dfs(grid,vis,nr,nc,csum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int csum=0;\\n                    dfs(grid,vis,i,j,csum);\\n                    ans= max(ans,csum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& curr){\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        curr+= grid[i][j];\\n        vis[i][j]=1;\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,-1,1};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int it=0; it<4; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nc>=0 && nc<grid[0].size() && nr>=0 && nr<grid.size() && !vis[nr][nc] && grid[nr][nc]>0){\\n                    q.push({nr,nc});\\n                    curr+= grid[nr][nc];\\n                    vis[nr][nc]=1;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int curr=0;\\n                    bfs(grid,vis,i,j,curr);\\n                    ans= max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485575,
                "title": "god-level-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dirx{1,-1,0,0};\\n    vector<int> diry{0,0,1,-1};\\n    int solve(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& vis,int n,int m){\\n        \\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=true;\\n        int sum=0;\\n        \\n        while(!q.empty()){\\n            auto curr=q.front();\\n            int xx=curr.first;\\n            int yy=curr.second;\\n            sum+=grid[xx][yy];\\n            q.pop();\\n            \\n            for(int i=0;i<4;i++){\\n                int nx=xx+dirx[i];\\n                int ny=yy+diry[i];\\n                \\n                if(ny<0 || ny==m || nx<0 || nx==n || grid[nx][ny]==0 || vis[nx][ny]) continue;\\n                \\n                q.push({nx,ny});\\n                vis[nx][ny]=true;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int res=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 && !vis[i][j]){\\n                    int ans=solve(i,j,grid,vis,n,m);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dirx{1,-1,0,0};\\n    vector<int> diry{0,0,1,-1};\\n    int solve(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& vis,int n,int m){\\n        \\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=true;\\n        int sum=0;\\n        \\n        while(!q.empty()){\\n            auto curr=q.front();\\n            int xx=curr.first;\\n            int yy=curr.second;\\n            sum+=grid[xx][yy];\\n            q.pop();\\n            \\n            for(int i=0;i<4;i++){\\n                int nx=xx+dirx[i];\\n                int ny=yy+diry[i];\\n                \\n                if(ny<0 || ny==m || nx<0 || nx==n || grid[nx][ny]==0 || vis[nx][ny]) continue;\\n                \\n                q.push({nx,ny});\\n                vis[nx][ny]=true;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int res=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 && !vis[i][j]){\\n                    int ans=solve(i,j,grid,vis,n,m);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481241,
                "title": "c-bfs-graphs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(4*n*m)$$\\n\\n- Space complexity:$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!grid[i][j]){\\n                    v[i][j]=1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    int cnt=0;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        cnt+=grid[x][y];\\n                        q.pop();\\n                        int r[4]={-1, 1, 0, 0};\\n                        int c[4]={0, 0, 1, -1};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(valid(row, col, v.size(), v[0].size()) && !v[row][col]){\\n                                v[row][col]=1;\\n                                q.push({row, col});\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!grid[i][j]){\\n                    v[i][j]=1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    int cnt=0;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        cnt+=grid[x][y];\\n                        q.pop();\\n                        int r[4]={-1, 1, 0, 0};\\n                        int c[4]={0, 0, 1, -1};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(valid(row, col, v.size(), v[0].size()) && !v[row][col]){\\n                                v[row][col]=1;\\n                                q.push({row, col});\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471545,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple DFS with node sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We simply traverse whole grid and check if current cell is having value greater than 0 or not. \\n- If it has value greater than 0 we call a DFS function which provides us the sum of current node along with it\\'s adjacent cells in the grid (Four Directionally).\\n- It goes without saying that in our DFS function we must keep an eye upon whether the function call for the current indexes in the grid is out of grid boundaries or not.\\n- Along with this we also need to maintain the visited array inorder to avoid duplicate function calls.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. -->\\n$$O(m*n)$$\\nwhere m is number of rows and n is number of columns in the grid. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\nwhere m is number of rows and n is number of columns in the grid.\\n# Code\\nThe below code is self explanatory.\\n```\\nclass Solution {\\npublic:\\n    // Function to check out of boundary condition\\n    bool isSafe(int i,int j,int m, int n){\\n        if (i<0 or i>=m or j<0 or j>=n) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &g, int i , int j, int m, int n, int &tmp, vector<vector<int>> &vis){\\n        // Check out of Boundary condition\\n        if (!isSafe(i,j,m,n)) return 0;\\n        if (g[i][j]==0) return 0;\\n        // If current cell is already visited return 0.\\n        if (vis[i][j]==1) return 0;\\n\\n        // mark current node as visited\\n        vis[i][j]=1;\\n        \\n        // add the value of current node\\n        tmp+= g[i][j];\\n        \\n        // call DFS for adjancent cells\\n        solve(g,i+1,j,m,n,tmp,vis);\\n        solve(g,i-1,j,m,n,tmp,vis);\\n        solve(g,i,j-1,m,n,tmp,vis);\\n        solve(g,i,j+1,m,n,tmp,vis);\\n        \\n        return tmp;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int ans=0, res=0;\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++){\\n                if (g[i][j]>0) \\n                {   int tmp=0;\\n                    ans=solve(g, i ,j ,m,n, tmp, vis);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check out of boundary condition\\n    bool isSafe(int i,int j,int m, int n){\\n        if (i<0 or i>=m or j<0 or j>=n) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &g, int i , int j, int m, int n, int &tmp, vector<vector<int>> &vis){\\n        // Check out of Boundary condition\\n        if (!isSafe(i,j,m,n)) return 0;\\n        if (g[i][j]==0) return 0;\\n        // If current cell is already visited return 0.\\n        if (vis[i][j]==1) return 0;\\n\\n        // mark current node as visited\\n        vis[i][j]=1;\\n        \\n        // add the value of current node\\n        tmp+= g[i][j];\\n        \\n        // call DFS for adjancent cells\\n        solve(g,i+1,j,m,n,tmp,vis);\\n        solve(g,i-1,j,m,n,tmp,vis);\\n        solve(g,i,j-1,m,n,tmp,vis);\\n        solve(g,i,j+1,m,n,tmp,vis);\\n        \\n        return tmp;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int ans=0, res=0;\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++){\\n                if (g[i][j]>0) \\n                {   int tmp=0;\\n                    ans=solve(g, i ,j ,m,n, tmp, vis);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468895,
                "title": "bfs-java-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int visit[][]=new int[n][m];\\n        int delRow[]={0,0,-1,1};\\n        int delCol[]={1,-1,0,0};\\n        \\n        int ans[]={0};\\n        int max=0;\\n  \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && grid[i][j]!=0){\\n\\n                    bfs(i,j,grid,visit,ans,delRow,delCol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int visit[][]=new int[n][m];\\n        int delRow[]={0,0,-1,1};\\n        int delCol[]={1,-1,0,0};\\n        \\n        int ans[]={0};\\n        int max=0;\\n  \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && grid[i][j]!=0){\\n\\n                    bfs(i,j,grid,visit,ans,delRow,delCol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468240,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/cea41f0c-e7be-4699-951b-5a0c9d475d8f_1682827066.2703393.png)\\n```\\n#define MAX(a,b) (a) > (b) ? (a) : (b)\\n\\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\nvoid dfs(int** grid, int r, int c, int rSize, int cSize, int* cnt) {\\n    if (r < 0 || r >= rSize || c < 0 || c >= cSize || grid[r][c] == 0) return;\\n    (*cnt) += grid[r][c];\\n    grid[r][c] = 0;\\n    for (int i = 0; i < 4; i++) {\\n        dfs(grid, r+dir[i][0], c+dir[i][1], rSize, cSize, cnt);\\n    }\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX(a,b) (a) > (b) ? (a) : (b)\\n\\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\nvoid dfs(int** grid, int r, int c, int rSize, int cSize, int* cnt) {\\n    if (r < 0 || r >= rSize || c < 0 || c >= cSize || grid[r][c] == 0) return;\\n    (*cnt) += grid[r][c];\\n    grid[r][c] = 0;\\n    for (int i = 0; i < 4; i++) {\\n        dfs(grid, r+dir[i][0], c+dir[i][1], rSize, cSize, cnt);\\n    }\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467612,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int vis[][]=new int [n][m];\\n        int delrow[]={0,0,-1,1};\\n        int delcol[]={1,-1,0,0};\\n        int ans[]={0};\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && grid[i][j]!=0){\\n                    bfs(i,j,grid,vis,ans,delrow,delcol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int vis[][]=new int [n][m];\\n        int delrow[]={0,0,-1,1};\\n        int delcol[]={1,-1,0,0};\\n        int ans[]={0};\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && grid[i][j]!=0){\\n                    bfs(i,j,grid,vis,ans,delrow,delcol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467563,
                "title": "java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxFish = 0;\\n        boolean [][]vis = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) { \\n                    maxFish = Math.max(maxFish, dfs(i, j,grid));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n      \\n       \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i<0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){\\n            return 0;\\n        }\\n        int fish = grid[i][j]; \\n        grid[i][j] = 0;\\n        fish += dfs(i-1, j, grid);\\n        fish += dfs(i, j+1, grid);\\n        fish += dfs(i+1, j, grid);\\n        fish += dfs(i, j-1, grid);\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxFish = 0;\\n        boolean [][]vis = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) { \\n                    maxFish = Math.max(maxFish, dfs(i, j,grid));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n      \\n       \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i<0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){\\n            return 0;\\n        }\\n        int fish = grid[i][j]; \\n        grid[i][j] = 0;\\n        fish += dfs(i-1, j, grid);\\n        fish += dfs(i, j+1, grid);\\n        fish += dfs(i+1, j, grid);\\n        fish += dfs(i, j-1, grid);\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467557,
                "title": "easy-to-understand-simple-and-easy-code-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis,int drow[],int dcol[]){\\n        vis[row][col]=1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         int x = 0 ;\\n         for(int i = 0 ; i < 4 ;i ++){\\n             int nrow = row + drow[i];\\n             int ncol = col + dcol[i];\\n             if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && grid[nrow][ncol] != 0 && !vis[nrow][ncol] ){\\n             x = x + grid[nrow][ncol] + f(nrow,ncol,grid,vis,drow,dcol);\\n             }\\n         }\\n         return x;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int drow[] = {0,-1,0,1};\\n        int dcol[] = {-1,0,1,0};\\n        int maxi = 0 ;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ;j < m ; j++){\\n                if(grid[i][j] > 0 ){\\n                int x = grid[i][j];\\n              int maxi1 = x + f(i,j,grid,vis,drow,dcol);\\n              maxi = max(maxi , maxi1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis,int drow[],int dcol[]){\\n        vis[row][col]=1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         int x = 0 ;\\n         for(int i = 0 ; i < 4 ;i ++){\\n             int nrow = row + drow[i];\\n             int ncol = col + dcol[i];\\n             if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && grid[nrow][ncol] != 0 && !vis[nrow][ncol] ){\\n             x = x + grid[nrow][ncol] + f(nrow,ncol,grid,vis,drow,dcol);\\n             }\\n         }\\n         return x;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int drow[] = {0,-1,0,1};\\n        int dcol[] = {-1,0,1,0};\\n        int maxi = 0 ;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ;j < m ; j++){\\n                if(grid[i][j] > 0 ){\\n                int x = grid[i][j];\\n              int maxi1 = x + f(i,j,grid,vis,drow,dcol);\\n              maxi = max(maxi , maxi1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467495,
                "title": "easy-dfs-soln-max-area-of-island",
                "content": "# Intuition\\nThis is similar to [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //x = exchange(a, b) --> x gets assigned with a & a is assiigned with b \\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        return exchange(grid[i][j], 0) + f(i - 1, j, grid) + f(i, j - 1, grid) + f(i + 1, j, grid) + f(i, j + 1, grid);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    maxi = max(maxi, f(i, j, grid));\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //x = exchange(a, b) --> x gets assigned with a & a is assiigned with b \\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        return exchange(grid[i][j], 0) + f(i - 1, j, grid) + f(i, j - 1, grid) + f(i + 1, j, grid) + f(i, j + 1, grid);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    maxi = max(maxi, f(i, j, grid));\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467447,
                "title": "run-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = size(grid),m = size(grid[0]), fish = 0, t = 0;\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        vector<pair<int,int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        function<void(int,int)> dfs = [&](int i,int j){\\n            t += grid[i][j];\\n            vis[i][j] = true;\\n            for(auto&[u,v]: moves){\\n                int x = i + u, y = j + v;\\n                if(isvalid(x,y) && grid[x][y] && !vis[x][y])\\n                    dfs(x,y);\\n            }\\n        };\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] && !vis[i][j]){\\n                    t = 0;\\n                    dfs(i,j);\\n                    fish = max(fish,t);\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = size(grid),m = size(grid[0]), fish = 0, t = 0;\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        vector<pair<int,int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        function<void(int,int)> dfs = [&](int i,int j){\\n            t += grid[i][j];\\n            vis[i][j] = true;\\n            for(auto&[u,v]: moves){\\n                int x = i + u, y = j + v;\\n                if(isvalid(x,y) && grid[x][y] && !vis[x][y])\\n                    dfs(x,y);\\n            }\\n        };\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] && !vis[i][j]){\\n                    t = 0;\\n                    dfs(i,j);\\n                    fish = max(fish,t);\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467349,
                "title": "dfs-c-solution-with-detailed-explanation",
                "content": "\\n# Approach\\nSo, basically this question can be solved using both BFS and DFS. I have solved this using DFS/recursion.\\nFirstly, I have declared a visited matrix with all indices marked -1.\\nNow, its given in question that if grid[i][j]=0 its land otherwise its number of fishes. \\nSo, for 1st recursion call value of grid[i][j] should be >0. In the reursion function first marked the vis[i][j]=0.\\nNow, we have 4 ways(as mentioned in question) in which we can move, so declared two arrays dr and dc with all 4 conditions/ways. We will traverse through grid with conditions.\\nIn this way this will mark all the visited indices as 0 and if the grid is not valid it won\\'t adding the number of fishes to c and return the value of c to main function. So in main function the value is compared with a max variable and the maximum is returened.\\nThank You and hope u understand my solution.\\nOpen for quries.\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int c=0;\\n    void rec(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n        vis[i][j]=0;\\n        \\n        int dr[4]={-1, 0, 1, 0};\\n        int dc[4]={0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            int nr= dr[k]+i;\\n            int nc= dc[k]+j;\\n            \\n            if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]>0 && vis[nr][nc]==-1){\\n                c+=grid[nr][nc];\\n                rec(nr, nc, n, m, grid, vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                 c=0;\\n                if(grid[i][j]>0 && vis[i][j]==-1){\\n                    c+=grid[i][j];\\n                    rec(i, j, n, m, grid, vis);\\n                    maxi= max(maxi, c);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c=0;\\n    void rec(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n        vis[i][j]=0;\\n        \\n        int dr[4]={-1, 0, 1, 0};\\n        int dc[4]={0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            int nr= dr[k]+i;\\n            int nc= dc[k]+j;\\n            \\n            if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]>0 && vis[nr][nc]==-1){\\n                c+=grid[nr][nc];\\n                rec(nr, nc, n, m, grid, vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                 c=0;\\n                if(grid[i][j]>0 && vis[i][j]==-1){\\n                    c+=grid[i][j];\\n                    rec(i, j, n, m, grid, vis);\\n                    maxi= max(maxi, c);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467310,
                "title": "easy-explanation-beginner-friendly",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint fun(int row, int col, vector<vector<int>> &vec)\\n\\t\\t{\\n\\t\\t\\tint n = vec.size();\\n\\t\\t\\tint m = vec[0].size();\\n\\t\\t\\tint score = vec[row][col];\\n\\t\\t\\tvec[row][col] = 0;\\n\\n\\t\\t\\tint rt[] = {0, -1, 0, 1};\\n\\t\\t\\tint ct[] = {-1, 0, 1, 0};\\n\\n\\n\\t\\t\\tfor(int i = 0; i < 4; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint r = row + rt[i];\\n\\t\\t\\t\\tint c = col + ct[i];\\n\\n\\t\\t\\t\\tif(r >= 0 && r < n && c >= 0 && c < m && vec[r][c] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscore = score + fun(r, c, vec);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\n\\n\\n\\t\\tint findMaxFish(vector<vector<int>>& grid) \\n\\t\\t{\\n\\t\\t\\tint score = 0;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tint m = grid[0].size();\\n\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvector<vector<int>> vec = grid;\\n\\t\\t\\t\\t\\tif(grid[i][j] != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscore = max(score, fun(i, j, vec));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint fun(int row, int col, vector<vector<int>> &vec)\\n\\t\\t{\\n\\t\\t\\tint n = vec.size();\\n\\t\\t\\tint m = vec[0].size();\\n\\t\\t\\tint score = vec[row][col];\\n\\t\\t\\tvec[row][col] = 0;\\n\\n\\t\\t\\tint rt[] = {0, -1, 0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3467296,
                "title": "python-bfs-easy-explained",
                "content": "# Intuition\\nIt is same as a standard bfs count problem just the few optimisations are:\\nadding all zeroes to visited as we dont want to vist them (fisherman cant go there)\\nif u already visited another cell while traversing from current cell no need to visit that cell again as it will carry the same value.\\nreturn the max fish caught from a particular cell.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        visited = {(i, j) for i in range(ROWS) for j in range(COLS) if grid[i][j] <= 0}\\n\\n        def catch_fish(i, j):\\n            q = deque()\\n            fish = grid[i][j]\\n            visited.add((i, j))\\n            q.append((i, j))\\n            while q:\\n                curr_row, curr_col = q.popleft()\\n                for dr, dc in directions:\\n                    r, c = curr_row + dr, curr_col + dc\\n                    if (r, c) not in visited and 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] > 0:\\n                        fish += grid[r][c]\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n            return fish\\n\\n        max_fish = 0\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if (i, j) not in visited and grid[i][j] > 0:\\n                    fish_count = catch_fish(i, j)\\n                    max_fish = max(max_fish, fish_count)\\n        return max_fish\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        visited = {(i, j) for i in range(ROWS) for j in range(COLS) if grid[i][j] <= 0}\\n\\n        def catch_fish(i, j):\\n            q = deque()\\n            fish = grid[i][j]\\n            visited.add((i, j))\\n            q.append((i, j))\\n            while q:\\n                curr_row, curr_col = q.popleft()\\n                for dr, dc in directions:\\n                    r, c = curr_row + dr, curr_col + dc\\n                    if (r, c) not in visited and 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] > 0:\\n                        fish += grid[r][c]\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n            return fish\\n\\n        max_fish = 0\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if (i, j) not in visited and grid[i][j] > 0:\\n                    fish_count = catch_fish(i, j)\\n                    max_fish = max(max_fish, fish_count)\\n        return max_fish\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467276,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0 int btts(int i,int j,vector<vector<int>>& grid){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 queue<pair<int,int>>que;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>>vis(n,vector<int>(m,0));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[i][j] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({i,j});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int drow[] = {-1,0,1,0,-1};\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int maxi = INT_MIN;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(!que.empty()){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int row = que.front().first;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int col = que.front().second;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.pop();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum+= grid[row][col];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<4;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int nrow = row+drow[i];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ncol = col+drow[i+1];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({nrow,ncol});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[nrow][ncol] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sum;\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 int findMaxFish(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ans = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<n;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int j=0;j<m;j++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(grid[i][j] > 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 ans = max(ans,btts(i,j,grid));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return ans;\\n\\xA0\\xA0\\xA0 }\\n};\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0 int btts(int i,int j,vector<vector<int>>& grid){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 queue<pair<int,int>>que;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>>vis(n,vector<int>(m,0));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[i][j] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({i,j});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int drow[] = {-1,0,1,0,-1};\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int maxi = INT_MIN;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(!que.empty()){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int row = que.front().first;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int col = que.front().second;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.pop();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum+= grid[row][col];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<4;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int nrow = row+drow[i];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ncol = col+drow[i+1];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({nrow,ncol});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[nrow][ncol] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sum;\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 int findMaxFish(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ans = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<n;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int j=0;j<m;j++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(grid[i][j] > 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 ans = max(ans,btts(i,j,grid));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return ans;\\n\\xA0\\xA0\\xA0 }\\n};\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467210,
                "title": "simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1) return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=-1;\\n        ans+= f(i+1,j, grid)+ f(i-1,j,grid)+ f(i, j-1,grid)+ f(i,j+1, grid);\\n        return ans;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                ans= max(ans, f(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1) return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=-1;\\n        ans+= f(i+1,j, grid)+ f(i-1,j,grid)+ f(i, j-1,grid)+ f(i,j+1, grid);\\n        return ans;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                ans= max(ans, f(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467048,
                "title": "simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee the fish in cell take these and search for neighbour cell and take maximum whenever leaving the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEnter in a cell where grid[row][col]!=-1\\nand search in neighbours cell using bfs whenever leaving that particular cell add this to our fish variable and  put it equal to zero i.e grid[row][col]=0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int dx[4]={1,-1,0,0};\\n     int dy[4]={0,0,1,-1};\\n     int find(int i,int j,vector<vector<int>>& grid,int m,int n)\\n     {\\n         int fish=0;\\n         queue<pair<int,int>> q;\\n         q.push({i,j});\\n         while(!q.empty())\\n         {\\n             int x=q.front().first;\\n             int y=q.front().second;\\n             q.pop();\\n             fish+=grid[x][y];\\n             grid[x][y]=0;\\n             for(int k=0;k<4;k++)\\n             {\\n                 if(x+dx[k] >=0 && x+dx[k] <m && y+dy[k]>=0 && y+dy[k]<n && grid[x+dx[k]][y+dy[k]]!=0)\\n                 {\\n                     q.push({x+dx[k],y+dy[k]});\\n                 }\\n             }\\n             \\n         }\\n         return fish;\\n     }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int fish=find(i,j,grid,m,n);\\n                    ans=max(ans,fish);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int dx[4]={1,-1,0,0};\\n     int dy[4]={0,0,1,-1};\\n     int find(int i,int j,vector<vector<int>>& grid,int m,int n)\\n     {\\n         int fish=0;\\n         queue<pair<int,int>> q;\\n         q.push({i,j});\\n         while(!q.empty())\\n         {\\n             int x=q.front().first;\\n             int y=q.front().second;\\n             q.pop();\\n             fish+=grid[x][y];\\n             grid[x][y]=0;\\n             for(int k=0;k<4;k++)\\n             {\\n                 if(x+dx[k] >=0 && x+dx[k] <m && y+dy[k]>=0 && y+dy[k]<n && grid[x+dx[k]][y+dy[k]]!=0)\\n                 {\\n                     q.push({x+dx[k],y+dy[k]});\\n                 }\\n             }\\n             \\n         }\\n         return fish;\\n     }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int fish=find(i,j,grid,m,n);\\n                    ans=max(ans,fish);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466944,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i,j):\\n            visited.add((i, j))\\n           \\n            self.fish += grid[i][j]\\n            for r,c in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                new_r = r + i\\n                new_c = c + j\\n                if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] != 0:\\n                    dfs(new_r, new_c)\\n                \\n            \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        self.fish = 0\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in visited:\\n                    self.fish = 0\\n                    dfs(i,j)\\n                    ans = max(self.fish, ans)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i,j):\\n            visited.add((i, j))\\n           \\n            self.fish += grid[i][j]\\n            for r,c in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                new_r = r + i\\n                new_c = c + j\\n                if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] != 0:\\n                    dfs(new_r, new_c)\\n                \\n            \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        self.fish = 0\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in visited:\\n                    self.fish = 0\\n                    dfs(i,j)\\n                    ans = max(self.fish, ans)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466898,
                "title": "easy-dfs-solution-o-n-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_max_fish(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n\\n        for i in 0..grid.len() {\\n            for j in 0..grid[0].len() {\\n                if grid[i][j] > 0 {\\n                    ans = ans.max(dfs(&mut grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\nfn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\\n    if i >= grid.len() || j >= grid[0].len() || grid[i][j] == 0 { return 0 };\\n    let val = grid[i][j];\\n    grid[i][j] = 0;\\n\\n    dfs(grid, i + 1, j) +\\n    dfs(grid, i - 1, j) +\\n    dfs(grid, i, j + 1) +\\n    dfs(grid, i, j - 1) + val\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_fish(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n\\n        for i in 0..grid.len() {\\n            for j in 0..grid[0].len() {\\n                if grid[i][j] > 0 {\\n                    ans = ans.max(dfs(&mut grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\nfn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\\n    if i >= grid.len() || j >= grid[0].len() || grid[i][j] == 0 { return 0 };\\n    let val = grid[i][j];\\n    grid[i][j] = 0;\\n\\n    dfs(grid, i + 1, j) +\\n    dfs(grid, i - 1, j) +\\n    dfs(grid, i, j + 1) +\\n    dfs(grid, i, j - 1) + val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466870,
                "title": "c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& g, vector<vector<bool>>& vis){\\n      if(min(r, c) < 0 or r >= g.size() or c >= g[0].size() or vis[r][c] or g[r][c] == 0) return 0;\\n      vis[r][c] = true;\\n      int x = dfs(r + 1, c, g, vis);\\n      int y = dfs(r, c + 1, g, vis);\\n      int z = dfs(r - 1, c, g, vis);\\n      int w = dfs(r, c - 1, g, vis);\\n      return g[r][c] + x + y + z + w;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n      int ans = 0, m = g.size(), n = g[0].size();\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n          if(g[i][j] > 0 and !vis[i][j]) \\n            ans = max(ans, dfs(i, j, g, vis));\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& g, vector<vector<bool>>& vis){\\n      if(min(r, c) < 0 or r >= g.size() or c >= g[0].size() or vis[r][c] or g[r][c] == 0) return 0;\\n      vis[r][c] = true;\\n      int x = dfs(r + 1, c, g, vis);\\n      int y = dfs(r, c + 1, g, vis);\\n      int z = dfs(r - 1, c, g, vis);\\n      int w = dfs(r, c - 1, g, vis);\\n      return g[r][c] + x + y + z + w;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n      int ans = 0, m = g.size(), n = g[0].size();\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n          if(g[i][j] > 0 and !vis[i][j]) \\n            ans = max(ans, dfs(i, j, g, vis));\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466805,
                "title": "why-not-dp",
                "content": "Can\\'t we use dp in this problem (wasted 1 hour)?\\uD83E\\uDD14\\n\\nwhy we can not apply dp here anyone please.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Can\\'t we use dp in this problem (wasted 1 hour)?\\uD83E\\uDD14\\n\\nwhy we can not apply dp here anyone please.",
                "codeTag": "Unknown"
            },
            {
                "id": 3466773,
                "title": "dfs-brute-force-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(mn4^(mn))\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n const int dx[4] = {1, 0, -1, 0};\\n const int dy[4] = {0, 1, 0, -1};\\n\\n int dfs(vector<vector<int>>& grid, int x, int y) {\\n    int ans1 = 0;\\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] <= 0) {\\n        return ans1;\\n    }\\n    ans1 += grid[x][y]; \\n    grid[x][y] = -grid[x][y]; \\n    for (int i = 0; i < 4; i++) { \\n        int nx = x + dx[i], ny = y + dy[i];\\n        ans1 += dfs(grid, nx, ny);\\n    }\\n    return ans1;\\n}\\n int findMaxFish(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    for (int x = 0; x < grid.size(); x++) {\\n        for (int y = 0; y < grid[0].size(); y++) {\\n            if (grid[x][y] > 0) {\\n                ans = max(ans, dfs(grid, x, y));\\n            }\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n const int dx[4] = {1, 0, -1, 0};\\n const int dy[4] = {0, 1, 0, -1};\\n\\n int dfs(vector<vector<int>>& grid, int x, int y) {\\n    int ans1 = 0;\\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] <= 0) {\\n        return ans1;\\n    }\\n    ans1 += grid[x][y]; \\n    grid[x][y] = -grid[x][y]; \\n    for (int i = 0; i < 4; i++) { \\n        int nx = x + dx[i], ny = y + dy[i];\\n        ans1 += dfs(grid, nx, ny);\\n    }\\n    return ans1;\\n}\\n int findMaxFish(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    for (int x = 0; x < grid.size(); x++) {\\n        for (int y = 0; y < grid[0].size(); y++) {\\n            if (grid[x][y] > 0) {\\n                ans = max(ans, dfs(grid, x, y));\\n            }\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466739,
                "title": "easy-clean-best-c-code-dfs",
                "content": "# Code\\n## PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int maxi=0,ans=0;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    void DFS(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(isValid(x,y,m,n) && grid[x][y])\\n                DFS(grid,x,y,m,n);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    DFS(grid,i,j,m,n);\\n                    maxi=max(maxi,ans);\\n                    ans=0;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0,ans=0;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    void DFS(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(isValid(x,y,m,n) && grid[x][y])\\n                DFS(grid,x,y,m,n);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    DFS(grid,i,j,m,n);\\n                    maxi=max(maxi,ans);\\n                    ans=0;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466712,
                "title": "dart-recursive-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    int result = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n      for (int j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] != 0) {\\n          final tempResult = traverseRecurr(grid, i, j);\\n          result = tempResult > result ? tempResult : result;\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n   int traverseRecurr(List<List<int>> grid, i, j) {\\n    if (\\n       i < grid.length \\n    && i >= 0 \\n    && j < grid[i].length \\n    && j >= 0\\n    ) {\\n      if (grid[i][j] == 0) {\\n        return 0;\\n      }\\n      int result = grid[i][j];\\n      grid[i][j] = 0;\\n      result += traverseRecurr(grid, i - 1, j);\\n      result += traverseRecurr(grid, i + 1, j);\\n      result += traverseRecurr(grid, i, j + 1);\\n      result += traverseRecurr(grid, i, j - 1);\\n      return result;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    int result = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n      for (int j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] != 0) {\\n          final tempResult = traverseRecurr(grid, i, j);\\n          result = tempResult > result ? tempResult : result;\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n   int traverseRecurr(List<List<int>> grid, i, j) {\\n    if (\\n       i < grid.length \\n    && i >= 0 \\n    && j < grid[i].length \\n    && j >= 0\\n    ) {\\n      if (grid[i][j] == 0) {\\n        return 0;\\n      }\\n      int result = grid[i][j];\\n      grid[i][j] = 0;\\n      result += traverseRecurr(grid, i - 1, j);\\n      result += traverseRecurr(grid, i + 1, j);\\n      result += traverseRecurr(grid, i, j + 1);\\n      result += traverseRecurr(grid, i, j - 1);\\n      return result;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466700,
                "title": "python-bfs",
                "content": "```python\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def bfs(y, x):\\n            q = deque([(y, x)])\\n            v = set([(y, x)])\\n            m = 0\\n            \\n            while q:\\n                y, x = q.popleft()\\n                m += grid[y][x]\\n\\n                for y, x in ((y, x + 1), (y, x - 1), (y + 1, x), (y - 1, x)):\\n                    if not (0 <= y < h and 0 <= x < w):\\n                        continue\\n                    if grid[y][x] == 0:\\n                        continue\\n                    if (y, x) in v:\\n                        continue\\n                    v.add((y, x))\\n                    q.append((y, x))\\n\\n            return m\\n\\n        m, h, w = 0, len(grid), len(grid[0])\\n\\n        for y in range(h):\\n            for x in range(w):\\n                if grid[y][x] > 0:\\n                    m = max(m, bfs(y, x))\\n\\n        return m\\n```\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def bfs(y, x):\\n            q = deque([(y, x)])\\n            v = set([(y, x)])\\n            m = 0\\n            \\n            while q:\\n                y, x = q.popleft()\\n                m += grid[y][x]\\n\\n                for y, x in ((y, x + 1), (y, x - 1), (y + 1, x), (y - 1, x)):\\n                    if not (0 <= y < h and 0 <= x < w):\\n                        continue\\n                    if grid[y][x] == 0:\\n                        continue\\n                    if (y, x) in v:\\n                        continue\\n                    v.add((y, x))\\n                    q.append((y, x))\\n\\n            return m\\n\\n        m, h, w = 0, len(grid), len(grid[0])\\n\\n        for y in range(h):\\n            for x in range(w):\\n                if grid[y][x] > 0:\\n                    m = max(m, bfs(y, x))\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466687,
                "title": "maximize-sum-of-islands",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y, vector<vector<int>>& grid)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    int bfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        int sum=grid[x][y];\\n        vis[x][y]=1;\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            \\n            int i=p.first;\\n            int j=p.second;\\n                if(isvalid(i+1,j,grid) && grid[i+1][j]!=0 && vis[i+1][j]==0)\\n                {\\n                    vis[i+1][j]=1;\\n                    sum+=grid[i+1][j];\\n                    q.push({i+1,j});\\n                }\\n                if(isvalid(i-1,j,grid) && grid[i-1][j]!=0 && vis[i-1][j]==0)\\n                {\\n                    vis[i-1][j]=1;\\n                    sum+=grid[i-1][j];\\n                    q.push({i-1,j});\\n                }\\n                if(isvalid(i,j+1,grid) && grid[i][j+1]!=0 && vis[i][j+1]==0)\\n                {\\n                    vis[i][j+1]=1;\\n                    sum+=grid[i][j+1];\\n                    q.push({i,j+1});\\n                }\\n                if(isvalid(i,j-1,grid) && grid[i][j-1]!=0 && vis[i][j-1]==0)\\n                {\\n                    vis[i][j-1]=1;\\n                    sum+=grid[i][j-1];\\n                    q.push({i,j-1});\\n                }\\n            //vis[i][j]=1;\\n        }\\n        return sum;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !vis[i][j])\\n                {\\n                    ans=max(ans,bfs(i,j,grid,vis));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y, vector<vector<int>>& grid)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    int bfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        int sum=grid[x][y];\\n        vis[x][y]=1;\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            \\n            int i=p.first;\\n            int j=p.second;\\n                if(isvalid(i+1,j,grid) && grid[i+1][j]!=0 && vis[i+1][j]==0)\\n                {\\n                    vis[i+1][j]=1;\\n                    sum+=grid[i+1][j];\\n                    q.push({i+1,j});\\n                }\\n                if(isvalid(i-1,j,grid) && grid[i-1][j]!=0 && vis[i-1][j]==0)\\n                {\\n                    vis[i-1][j]=1;\\n                    sum+=grid[i-1][j];\\n                    q.push({i-1,j});\\n                }\\n                if(isvalid(i,j+1,grid) && grid[i][j+1]!=0 && vis[i][j+1]==0)\\n                {\\n                    vis[i][j+1]=1;\\n                    sum+=grid[i][j+1];\\n                    q.push({i,j+1});\\n                }\\n                if(isvalid(i,j-1,grid) && grid[i][j-1]!=0 && vis[i][j-1]==0)\\n                {\\n                    vis[i][j-1]=1;\\n                    sum+=grid[i][j-1];\\n                    q.push({i,j-1});\\n                }\\n            //vis[i][j]=1;\\n        }\\n        return sum;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !vis[i][j])\\n                {\\n                    ans=max(ans,bfs(i,j,grid,vis));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466672,
                "title": "easiest-solution-ever",
                "content": "```\\nvoid solve(int i, int j, vector<vector<int>>& g, int &ans, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n            return;\\n        \\n        if(vis[i][j] || (g[i][j]==0))\\n            return;\\n        \\n        vis[i][j] = true;\\n        ans += g[i][j];\\n        \\n        solve(i+1, j, g, ans, vis);\\n        solve(i, j+1, g, ans, vis);\\n        solve(i-1, j, g, ans, vis);\\n        solve(i, j-1, g, ans, vis);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        int mx = 0;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(g[i][j]==0)\\n                    continue;\\n                \\n                if(vis[i][j]==true)\\n                    continue;\\n                \\n                int ans = 0;\\n                solve(i, j, g, ans, vis);\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid solve(int i, int j, vector<vector<int>>& g, int &ans, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n            return;\\n        \\n        if(vis[i][j] || (g[i][j]==0))\\n            return;\\n        \\n        vis[i][j] = true;\\n        ans += g[i][j];\\n        \\n        solve(i+1, j, g, ans, vis);\\n        solve(i, j+1, g, ans, vis);\\n        solve(i-1, j, g, ans, vis);\\n        solve(i, j-1, g, ans, vis);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        int mx = 0;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(g[i][j]==0)\\n                    continue;\\n                \\n                if(vis[i][j]==true)\\n                    continue;\\n                \\n                int ans = 0;\\n                solve(i, j, g, ans, vis);\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466647,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>> &grid,int i,int j,int &temp,vector<vector<int>>&vis){\\n        if(i<0||i>=n||j<0||j>=m) return;\\n        vis[i][j] = 1;\\n        temp += grid[i][j];\\n        int a[] = {1,0,-1,0};\\n        int b[] = {0,1,0,-1};\\n        for(int x=0;x<4;x++){\\n            if(i+a[x]>=0 && i+a[x]<n && j+b[x]>=0 && j+b[x]<m && !vis[i+a[x]][j+b[x]] && grid[i+a[x]][j+b[x]]){\\n                dfs(grid,i+a[x],j+b[x],temp,vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    int temp=0;\\n                    dfs(grid,i,j,temp,vis);\\n                    if(ans<temp) ans = temp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>> &grid,int i,int j,int &temp,vector<vector<int>>&vis){\\n        if(i<0||i>=n||j<0||j>=m) return;\\n        vis[i][j] = 1;\\n        temp += grid[i][j];\\n        int a[] = {1,0,-1,0};\\n        int b[] = {0,1,0,-1};\\n        for(int x=0;x<4;x++){\\n            if(i+a[x]>=0 && i+a[x]<n && j+b[x]>=0 && j+b[x]<m && !vis[i+a[x]][j+b[x]] && grid[i+a[x]][j+b[x]]){\\n                dfs(grid,i+a[x],j+b[x],temp,vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    int temp=0;\\n                    dfs(grid,i,j,temp,vis);\\n                    if(ans<temp) ans = temp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097424,
                "title": "easy-c-solution-dfs",
                "content": "\\n```\\n#define max(a, b) (a > b ? a : b)\\n\\nvoid helper (int i, int j, int m, int n, int *sum, int *ans, int** grid) {\\n    *ans = max (*ans, *sum);\\n\\n    if (i < 0 || j < 0 || i >= m || j >= n || !grid[i][j])\\n        return;\\n\\n    *sum += grid[i][j];\\n    grid[i][j] = 0;\\n\\n    if (i + 1 < m) helper (i + 1, j, m, n, sum, ans, grid);\\n    if (i - 1 >= 0) helper (i - 1, j, m, n, sum, ans, grid);\\n    if (j + 1 < n) helper (i, j + 1, m, n, sum, ans, grid);\\n    if (j - 1 >= 0) helper (i, j - 1, m, n, sum, ans, grid);\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define max(a, b) (a > b ? a : b)\\n\\nvoid helper (int i, int j, int m, int n, int *sum, int *ans, int** grid) {\\n    *ans = max (*ans, *sum);\\n\\n    if (i < 0 || j < 0 || i >= m || j >= n || !grid[i][j])\\n        return;\\n\\n    *sum += grid[i][j];\\n    grid[i][j] = 0;\\n\\n    if (i + 1 < m) helper (i + 1, j, m, n, sum, ans, grid);\\n    if (i - 1 >= 0) helper (i - 1, j, m, n, sum, ans, grid);\\n    if (j + 1 < n) helper (i, j + 1, m, n, sum, ans, grid);\\n    if (j - 1 >= 0) helper (i, j - 1, m, n, sum, ans, grid);\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097360,
                "title": "simple-bfs-solution-easy-to-understand",
                "content": "# Intuition\\n\\nIn solving the question we just use the simple bfs algo.\\nRead the code you will understand it.\\n\\n# Approach\\nwe make queue which keep the a pair of elements first the value of the grid value and other values are the row and column respectively.\\nThen check that if  nrow and ncol are not going outside the grid and not visited and the grid is having a fish.\\nthen finding the max. from the possible value.\\nand at last return it maximum value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxi=0;\\n    void bfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis, int delrow[],int delcol[],int &sum){\\n        \\n        vis[row][col]=1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({grid[row][col],{row,col}});\\n        while(!q.empty()){\\n            int n=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            sum+=n;\\n            for(int i=0; i<4; i++){\\n            int nrow=x+delrow[i];\\n            int ncol=y+delcol[i];\\n     if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol]>0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                q.push({grid[nrow][ncol],{nrow,ncol}});\\n            }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int delrow[]={-1,0,1,0};\\n        int delcol[]={0,-1,0,1};\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n\\n                if(grid[i][j]>0 && vis[i][j]==0){\\n                    int sum=0;\\n                    bfs(i,j,grid,vis,delrow,delcol,sum);\\n\\n                    maxi=max(maxi,sum);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxi=0;\\n    void bfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis, int delrow[],int delcol[],int &sum){\\n        \\n        vis[row][col]=1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({grid[row][col],{row,col}});\\n        while(!q.empty()){\\n            int n=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            sum+=n;\\n            for(int i=0; i<4; i++){\\n            int nrow=x+delrow[i];\\n            int ncol=y+delcol[i];\\n     if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol]>0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                q.push({grid[nrow][ncol],{nrow,ncol}});\\n            }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int delrow[]={-1,0,1,0};\\n        int delcol[]={0,-1,0,1};\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n\\n                if(grid[i][j]>0 && vis[i][j]==0){\\n                    int sum=0;\\n                    bfs(i,j,grid,vis,delrow,delcol,sum);\\n\\n                    maxi=max(maxi,sum);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090243,
                "title": "c-easy-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nrow = row + prerow[i];\\n            int ncol = col + precol[i];\\n            if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && visited[nrow][ncol] == 0 && grid[nrow][ncol] > 0)\\n            {\\n                res += dfs(grid, visited, nrow, ncol);\\n            }\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector <int>> visited(grid.size(), vector <int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, dfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nrow = row + prerow[i];\\n            int ncol = col + precol[i];\\n            if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && visited[nrow][ncol] == 0 && grid[nrow][ncol] > 0)\\n            {\\n                res += dfs(grid, visited, nrow, ncol);\\n            }\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector <int>> visited(grid.size(), vector <int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, dfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090209,
                "title": "c-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n\\n        while(q.empty() == false)\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + prerow[i];\\n                int ncol = col + precol[i];\\n\\n                if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && grid[nrow][ncol] > 0 && visited[nrow][ncol] == 0){\\n                    q.push({nrow, ncol});\\n                    res += grid[nrow][ncol];\\n                    visited[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n         \\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, bfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n\\n        while(q.empty() == false)\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + prerow[i];\\n                int ncol = col + precol[i];\\n\\n                if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && grid[nrow][ncol] > 0 && visited[nrow][ncol] == 0){\\n                    q.push({nrow, ncol});\\n                    res += grid[nrow][ncol];\\n                    visited[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n         \\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, bfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084103,
                "title": "python-easy-dfs-connected-components",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def helper(self, grid,i,j):\\n        s=grid[i][j]\\n        grid[i][j]=0\\n        x=[1,0,0,-1]\\n        y=[0,1,-1,0]\\n        for k in range(4):\\n            q=i+x[k]\\n            w=j+y[k]\\n            if q>=0 and w>=0 and q<=len(grid)-1 and  w<=len(grid[0])-1 and grid[q][w]!=0:\\n                s+=self.helper(grid,q,w)\\n        return s\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ma=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]>0:\\n                    ma=max(ma,self.helper(grid,i,j))\\n        return ma\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, grid,i,j):\\n        s=grid[i][j]\\n        grid[i][j]=0\\n        x=[1,0,0,-1]\\n        y=[0,1,-1,0]\\n        for k in range(4):\\n            q=i+x[k]\\n            w=j+y[k]\\n            if q>=0 and w>=0 and q<=len(grid)-1 and  w<=len(grid[0])-1 and grid[q][w]!=0:\\n                s+=self.helper(grid,q,w)\\n        return s\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ma=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]>0:\\n                    ma=max(ma,self.helper(grid,i,j))\\n        return ma\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083953,
                "title": "java-standard-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStandard DFS, Visited Array\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n^2)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int currMax=0;\\n        int[] curr=new int[1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && !(grid[i][j]==0)){\\n                    curr[0]=0;\\n                    dfs(i,j,grid,vis,curr);\\n                    currMax=Math.max(currMax,curr[0]);\\n                }\\n            }\\n        }\\n        return currMax;\\n    }\\n    private void dfs(int i, int j, int[][] grid,boolean[][] vis, int[] curr){\\n        int m = grid.length, n = grid[0].length;\\n        if(i<0 || j<0 || i>m-1 || j>n-1 || grid[i][j]==0 || vis[i][j]) return;\\n        vis[i][j]=true;\\n        curr[0]+=grid[i][j];\\n        dfs(i+1,j,grid,vis,curr);\\n        dfs(i-1,j,grid,vis,curr);\\n        dfs(i,j+1,grid,vis,curr);\\n        dfs(i,j-1,grid,vis,curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int currMax=0;\\n        int[] curr=new int[1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && !(grid[i][j]==0)){\\n                    curr[0]=0;\\n                    dfs(i,j,grid,vis,curr);\\n                    currMax=Math.max(currMax,curr[0]);\\n                }\\n            }\\n        }\\n        return currMax;\\n    }\\n    private void dfs(int i, int j, int[][] grid,boolean[][] vis, int[] curr){\\n        int m = grid.length, n = grid[0].length;\\n        if(i<0 || j<0 || i>m-1 || j>n-1 || grid[i][j]==0 || vis[i][j]) return;\\n        vis[i][j]=true;\\n        curr[0]+=grid[i][j];\\n        dfs(i+1,j,grid,vis,curr);\\n        dfs(i-1,j,grid,vis,curr);\\n        dfs(i,j+1,grid,vis,curr);\\n        dfs(i,j-1,grid,vis,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077158,
                "title": "simple-dfs-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        ans=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=set()\\n        def dfs(r,c):\\n            if r<0 or c<0 or r==m or c==n or (r,c) in vis or grid[r][c]==0: return 0\\n            vis.add((r,c))\\n            return grid[r][c]+dfs(r-1,c)+dfs(r,c-1)+dfs(r+1,c)+dfs(r,c+1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans=max(ans,dfs(i,j))     \\n\\n        return ans        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        ans=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=set()\\n        def dfs(r,c):\\n            if r<0 or c<0 or r==m or c==n or (r,c) in vis or grid[r][c]==0: return 0\\n            vis.add((r,c))\\n            return grid[r][c]+dfs(r-1,c)+dfs(r,c-1)+dfs(r+1,c)+dfs(r,c+1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans=max(ans,dfs(i,j))     \\n\\n        return ans        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072146,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # directions for moving up, down, left, right\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        # DFS function\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or (i, j) in visited:\\n                return 0\\n            visited.add((i, j))\\n            fish = grid[i][j]\\n            for dx, dy in directions:\\n                fish += dfs(i + dx, j + dy, visited)\\n            return fish\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:  # if it\\'s a water cell\\n                    max_fish = max(max_fish, dfs(i, j, set()))\\n        \\n        return max_fish\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # directions for moving up, down, left, right\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        # DFS function\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or (i, j) in visited:\\n                return 0\\n            visited.add((i, j))\\n            fish = grid[i][j]\\n            for dx, dy in directions:\\n                fish += dfs(i + dx, j + dy, visited)\\n            return fish\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:  # if it\\'s a water cell\\n                    max_fish = max(max_fish, dfs(i, j, set()))\\n        \\n        return max_fish\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062067,
                "title": "java-simple-dfs",
                "content": "class Solution {\\n\\n    int dirs1[]=new int[]{-1,0,1,0};\\n    int dirs2[]=new int[]{0,1,0,-1};\\n    \\n    int max = 0;\\n    int mn =0;\\n    int nn=0;\\n    \\n    public int dfs(int i,int j,int[][] grid,boolean vis[][]){\\n        if(i<0 || j<0 || i>= mn || j>= nn || vis[i][j] || grid[i][j]==0){\\n            return 0;\\n        }\\n        \\n        vis[i][j]=true;\\n        int neighborSum = 0;\\n        for(int k=0;k<4;k++){\\n            int r = i + dirs1[k];\\n            int c = j + dirs2[k];\\n            neighborSum += dfs(r,c,grid,vis);\\n        }\\n        return grid[i][j] + neighborSum;\\n        \\n    }\\n    public int findMaxFish(int[][] grid) {\\n        mn= grid.length;\\n        nn=grid[0].length;\\n        \\n        \\n        for(int i=0;i<mn;i++){\\n            for(int j=0;j<nn;j++){\\n                if(grid[i][j]!=0){\\n                    int size = dfs(i,j,grid,new boolean[mn][nn]);\\n                    max = Math.max(size,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int dirs1[]=new int[]{-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 4059104,
                "title": "dfs-implementation-both-in-c-and-java",
                "content": "# Code\\n```java []\\nclass Solution {\\n    void solve(int r, int c, int[][] grid, int[][] vis, int[] sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\\n        sum[0] += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == 0 && grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int maxi = 0;\\n        int[][] vis = new int[n][m];\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && vis[i][j] == 0) {\\n                    int[] sum = new int[1];\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = Math.max(maxi, sum[0]);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void solve(int r, int c, vector<vector<int>> &grid, vector<vector<int>> &vis, int &sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        sum += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int maxi = 0;\\n        vector<vector<int>> vis(n, vector<int> (m));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 and !vis[i][j]) {\\n                    int sum = 0;\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = max(maxi, sum);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    void solve(int r, int c, int[][] grid, int[][] vis, int[] sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\\n        sum[0] += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == 0 && grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int maxi = 0;\\n        int[][] vis = new int[n][m];\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && vis[i][j] == 0) {\\n                    int[] sum = new int[1];\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = Math.max(maxi, sum[0]);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051736,
                "title": "template-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        simple dfs should suffice\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        self.max_fish = 0\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1, j), (i,j-1), (i,j+1)]\\n        \\n        def dfs(i, j, dfs_visited):\\n            self.count+=grid[i][j]\\n            dfs_visited.add((i,j))\\n            self.max_fish = max(self.max_fish, self.count)\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] != 0 and (x, y) not in dfs_visited:\\n                    dfs(x, y, dfs_visited)\\n\\n        self.visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in self.visited:\\n                    dfs_visited = set()\\n                    self.count = 0\\n                    dfs(i, j, dfs_visited)\\n                    self.visited = self.visited.union(dfs_visited)\\n\\n        return self.max_fish\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        simple dfs should suffice\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        self.max_fish = 0\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1, j), (i,j-1), (i,j+1)]\\n        \\n        def dfs(i, j, dfs_visited):\\n            self.count+=grid[i][j]\\n            dfs_visited.add((i,j))\\n            self.max_fish = max(self.max_fish, self.count)\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] != 0 and (x, y) not in dfs_visited:\\n                    dfs(x, y, dfs_visited)\\n\\n        self.visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in self.visited:\\n                    dfs_visited = set()\\n                    self.count = 0\\n                    dfs(i, j, dfs_visited)\\n                    self.visited = self.visited.union(dfs_visited)\\n\\n        return self.max_fish\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041516,
                "title": "c-bfs-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i,int j,int n,int m){\\n      return i>-1 && i<n && j>-1 && j<m;\\n    }\\n    void Bfs(int i,int j,int &count,vector<vector<int>>& grid){\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int row[4]={-1,1,0,0};\\n      int col[4]={0,0,-1,1};\\n      queue<pair<int,int>>q;\\n      q.push({i,j});\\n      while(!q.empty()){\\n        i=q.front().first;\\n        j=q.front().second;\\n        q.pop();\\n        for(int k=0;k<4;k++){\\n          if(valid(i+row[k],j+col[k],n,m) && grid[i+row[k]][j+col[k]]>0){\\n            q.push({i+row[k],j+col[k]});\\n            count+=grid[i+row[k]][j+col[k]];\\n            grid[i+row[k]][j+col[k]]=0;\\n          }\\n        }\\n      }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          int count=0;\\n           if(grid[i][j]>0){\\n              count+=grid[i][j];\\n              grid[i][j]=0;\\n              Bfs(i,j,count,grid);\\n              ans=max(ans,count);\\n\\n           }\\n        }\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i,int j,int n,int m){\\n      return i>-1 && i<n && j>-1 && j<m;\\n    }\\n    void Bfs(int i,int j,int &count,vector<vector<int>>& grid){\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int row[4]={-1,1,0,0};\\n      int col[4]={0,0,-1,1};\\n      queue<pair<int,int>>q;\\n      q.push({i,j});\\n      while(!q.empty()){\\n        i=q.front().first;\\n        j=q.front().second;\\n        q.pop();\\n        for(int k=0;k<4;k++){\\n          if(valid(i+row[k],j+col[k],n,m) && grid[i+row[k]][j+col[k]]>0){\\n            q.push({i+row[k],j+col[k]});\\n            count+=grid[i+row[k]][j+col[k]];\\n            grid[i+row[k]][j+col[k]]=0;\\n          }\\n        }\\n      }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          int count=0;\\n           if(grid[i][j]>0){\\n              count+=grid[i][j];\\n              grid[i][j]=0;\\n              Bfs(i,j,count,grid);\\n              ans=max(ans,count);\\n\\n           }\\n        }\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023609,
                "title": "c-easy-dfs-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid){\\n        // base case that makes the curr cell invalid, if visited, or if it \\n        //is land cell we return 0 (no fish caught);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(row<0 || row>=m || col<0 || col>=n || vis[row][col] || \\n        grid[row][col]==0)\\n        return 0;\\n\\n        //otherwise we mark it as visited and proceed\\n        vis[row][col] = 1;\\n        \\n        int res = 0;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            res +=dfs(nrow,ncol,vis,grid);\\n        } \\n\\n        return res + grid[row][col];\\n    }\\npublic:\\n    vector<int> delrow{-1,0,1,0};\\n    vector<int> delcol{0,1,0,-1};\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m,vector<int>(n,0)); //visited vector\\n\\n        //a fisherman can start at any water cell therefore we call dfs for \\n        //every water body and find sum of all cells and maximize it\\n        int maxi = -1e9;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if it is an unvisited water body\\n                if(grid[i][j]>0 && !vis[i][j]){\\n                    int val = dfs(i,j,vis,grid);\\n                    cout<<val<<endl;\\n                    maxi = max(maxi,val);\\n                }\\n            }\\n        }\\n        return max(maxi,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid){\\n        // base case that makes the curr cell invalid, if visited, or if it \\n        //is land cell we return 0 (no fish caught);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(row<0 || row>=m || col<0 || col>=n || vis[row][col] || \\n        grid[row][col]==0)\\n        return 0;\\n\\n        //otherwise we mark it as visited and proceed\\n        vis[row][col] = 1;\\n        \\n        int res = 0;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            res +=dfs(nrow,ncol,vis,grid);\\n        } \\n\\n        return res + grid[row][col];\\n    }\\npublic:\\n    vector<int> delrow{-1,0,1,0};\\n    vector<int> delcol{0,1,0,-1};\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m,vector<int>(n,0)); //visited vector\\n\\n        //a fisherman can start at any water cell therefore we call dfs for \\n        //every water body and find sum of all cells and maximize it\\n        int maxi = -1e9;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if it is an unvisited water body\\n                if(grid[i][j]>0 && !vis[i][j]){\\n                    int val = dfs(i,j,vis,grid);\\n                    cout<<val<<endl;\\n                    maxi = max(maxi,val);\\n                }\\n            }\\n        }\\n        return max(maxi,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4004210,
                "title": "c-solution-by-floodfill-algorithm",
                "content": "# Intuition\\nUse floodfill algorithm\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int iCount = 0;\\n    void floodfill(vector<vector<int>>& grid, int i, int j)\\n    {\\n        iCount+=grid[i][j];\\n        grid[i][j] = 0;\\n        if(i-1>=0 && grid[i-1][j] >0) floodfill(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] >0) floodfill(grid, i+1, j);\\n        if(j-1>=0 && grid[i][j-1] >0) floodfill(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] >0) floodfill(grid, i, j+1);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int iMaxCount = 0;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] != 0)\\n                {\\n                    iCount = 0;\\n                    floodfill(grid, i, j);\\n                    if(iCount > iMaxCount) iMaxCount = iCount;\\n\\n                }\\n            }\\n        }\\n\\n        return iMaxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int iCount = 0;\\n    void floodfill(vector<vector<int>>& grid, int i, int j)\\n    {\\n        iCount+=grid[i][j];\\n        grid[i][j] = 0;\\n        if(i-1>=0 && grid[i-1][j] >0) floodfill(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] >0) floodfill(grid, i+1, j);\\n        if(j-1>=0 && grid[i][j-1] >0) floodfill(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] >0) floodfill(grid, i, j+1);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int iMaxCount = 0;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] != 0)\\n                {\\n                    iCount = 0;\\n                    floodfill(grid, i, j);\\n                    if(iCount > iMaxCount) iMaxCount = iCount;\\n\\n                }\\n            }\\n        }\\n\\n        return iMaxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999782,
                "title": "a-c-solution",
                "content": "\\n# Code\\n```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit) {\\n    if(row < 0 || row >= rLimit || col < 0 || col >= cLimit || !grid[row][col]) return 0;\\n    int ret = grid[row][col];\\n    grid[row][col] = 0;\\n\\n    ret += traverse(grid, row + 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row - 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row, col + 1, rLimit, cLimit);\\n    ret += traverse(grid, row, col - 1, rLimit, cLimit);\\n\\n    return ret;\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit) {\\n    if(row < 0 || row >= rLimit || col < 0 || col >= cLimit || !grid[row][col]) return 0;\\n    int ret = grid[row][col];\\n    grid[row][col] = 0;\\n\\n    ret += traverse(grid, row + 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row - 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row, col + 1, rLimit, cLimit);\\n    ret += traverse(grid, row, col - 1, rLimit, cLimit);\\n\\n    return ret;\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994399,
                "title": "3-liner-dfs-performance-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(m$$ x $$n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int dfs(int[][] grid, int i, int j) {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[i].length || grid[i][j] < 1) return 0;\\n        grid[i][j] -= 20;\\n        return 20 + grid[i][j] + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) if(grid[i][j] > 0) max = Math.max(max, dfs(grid, i, j));\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(int[][] grid, int i, int j) {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[i].length || grid[i][j] < 1) return 0;\\n        grid[i][j] -= 20;\\n        return 20 + grid[i][j] + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) if(grid[i][j] > 0) max = Math.max(max, dfs(grid, i, j));\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984753,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    var max = -1;\\n    var curMax = 0;\\n    final rows = grid.length;\\n    final cols = grid[0].length;\\n\\n    int dfs(int i, int j) {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        final curValue = grid[i][j];\\n        grid[i][j] = 0;\\n        return curValue + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\\n    }\\n\\n    for (int i = 0; i < rows; i++) {\\n        for (int j = 0; j < cols; j++) {\\n            if (grid[i][j] != 0) {\\n                curMax = dfs(i, j);\\n            }\\n            if (curMax > max) {\\n                max = curMax;\\n            }\\n        }\\n    }\\n\\n    return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    var max = -1;\\n    var curMax = 0;\\n    final rows = grid.length;\\n    final cols = grid[0].length;\\n\\n    int dfs(int i, int j) {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        final curValue = grid[i][j];\\n        grid[i][j] = 0;\\n        return curValue + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\\n    }\\n\\n    for (int i = 0; i < rows; i++) {\\n        for (int j = 0; j < cols; j++) {\\n            if (grid[i][j] != 0) {\\n                curMax = dfs(i, j);\\n            }\\n            if (curMax > max) {\\n                max = curMax;\\n            }\\n        }\\n    }\\n\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982530,
                "title": "java-100",
                "content": "# Approach\\nWhen we find a water cell, we recurse through it and its water cell neighbors. For each cell, we accumulate the value and then set it to 0 so that it will not be counted again. We store and return the max value.\\n\\n# Complexity\\n- Time complexity : O(m*n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int [][] g;\\n\\n    public int findMaxFish(int[][] grid)\\n    {\\n        g = grid;\\n        int max = 0;\\n\\n        for(int i=0, l=grid.length, b=grid[0].length; i<l; i++)\\n            for(int j=0; j<b; j++)\\n                if(g[i][j]!=0)\\n                    max = Math.max(max,get(i,j));\\n\\n        return max;\\n    }\\n\\n    private int get(int x, int y)\\n    {\\n        if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0)\\n            return 0;\\n        \\n        int c = g[x][y];\\n        g[x][y] = 0;\\n        \\n        return c + get(x+1,y) + get(x,y+1) + get(x-1,y) + get(x,y-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\n    int [][] g;\\n\\n    public int findMaxFish(int[][] grid)\\n    {\\n        g = grid;\\n        int max = 0;\\n\\n        for(int i=0, l=grid.length, b=grid[0].length; i<l; i++)\\n            for(int j=0; j<b; j++)\\n                if(g[i][j]!=0)\\n                    max = Math.max(max,get(i,j));\\n\\n        return max;\\n    }\\n\\n    private int get(int x, int y)\\n    {\\n        if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0)\\n            return 0;\\n        \\n        int c = g[x][y];\\n        g[x][y] = 0;\\n        \\n        return c + get(x+1,y) + get(x,y+1) + get(x-1,y) + get(x,y-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981408,
                "title": "very-easy-dfs-to-beat-92-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res=0\\n        def dfs(i,j):\\n            if grid[i][j]==0:\\n                return 0\\n            temp=grid[i][j]\\n            grid[i][j]=0\\n\\n            next_move=[(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n            for next_row, next_col in next_move:\\n                if next_row >=0 and next_row <len(grid) and next_col>=0 and next_col < len(grid[0])\\\\\\n                and grid[next_row][next_col] !=0:\\n                    temp+=dfs(next_row, next_col)\\n                else:\\n                    continue\\n            return temp\\n\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]!=0:\\n                    res=max(res, dfs(i,j))\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res=0\\n        def dfs(i,j):\\n            if grid[i][j]==0:\\n                return 0\\n            temp=grid[i][j]\\n            grid[i][j]=0\\n\\n            next_move=[(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n            for next_row, next_col in next_move:\\n                if next_row >=0 and next_row <len(grid) and next_col>=0 and next_col < len(grid[0])\\\\\\n                and grid[next_row][next_col] !=0:\\n                    temp+=dfs(next_row, next_col)\\n                else:\\n                    continue\\n            return temp\\n\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]!=0:\\n                    res=max(res, dfs(i,j))\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976375,
                "title": "using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i, j):\\n\\n            if i<0 or j<0 or i>m-1 or j>n-1 or grid[i][j] == 0:\\n                return 0\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n            return val + dfs(i-1,j) + dfs(i,j-1) + dfs(i,j+1) + dfs(i+1,j)\\n\\n        m, n = len(grid),len(grid[0])\\n        s = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    s = max(s, dfs(i,j))\\n                    print(\"S is \",s)\\n        return s\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i, j):\\n\\n            if i<0 or j<0 or i>m-1 or j>n-1 or grid[i][j] == 0:\\n                return 0\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n            return val + dfs(i-1,j) + dfs(i,j-1) + dfs(i,j+1) + dfs(i+1,j)\\n\\n        m, n = len(grid),len(grid[0])\\n        s = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    s = max(s, dfs(i,j))\\n                    print(\"S is \",s)\\n        return s\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971940,
                "title": "similar-to-max-area-of-island-bfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private:\\nvoid bfs(int row,int col, vector<vector<int>>&vis,vector<vector<int>>& grid,int &a)\\n{\\n    vis[row][col]=1;\\n    queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int r=q.front().first;\\n        int c=q.front().second;\\n        q.pop();\\n        for(int delrow=-1;delrow<=1;delrow++)\\n        {\\n            for(int delcol=-1;delcol<=1;delcol++)\\n            {\\n                if(abs(delrow)!=abs(delcol))\\n                {\\n                    int nrow=r+delrow;\\n                    int ncol=c+delcol;\\n                    if(nrow>=0&&nrow<grid.size()&&ncol>=0&&ncol<grid[0].size()&&!vis[nrow][ncol]&&grid[nrow][ncol]>0)\\n                    {\\n                        a+=grid[nrow][ncol];\\n                        vis[nrow][ncol]=1;\\n                        q.push({nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid[i][j]!=0)\\n                {\\n                    int a=grid[i][j];\\n                    bfs(i,j,vis,grid,a);\\n                    count=max(a,count);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    private:\\nvoid bfs(int row,int col, vector<vector<int>>&vis,vector<vector<int>>& grid,int &a)\\n{\\n    vis[row][col]=1;\\n    queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int r=q.front().first;\\n        int c=q.front().second;\\n        q.pop();\\n        for(int delrow=-1;delrow<=1;delrow++)\\n        {\\n            for(int delcol=-1;delcol<=1;delcol++)\\n            {\\n                if(abs(delrow)!=abs(delcol))\\n                {\\n                    int nrow=r+delrow;\\n                    int ncol=c+delcol;\\n                    if(nrow>=0&&nrow<grid.size()&&ncol>=0&&ncol<grid[0].size()&&!vis[nrow][ncol]&&grid[nrow][ncol]>0)\\n                    {\\n                        a+=grid[nrow][ncol];\\n                        vis[nrow][ncol]=1;\\n                        q.push({nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid[i][j]!=0)\\n                {\\n                    int a=grid[i][j];\\n                    bfs(i,j,vis,grid,a);\\n                    count=max(a,count);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970807,
                "title": "cpp-easy-implementation-fast-and-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:``O( M * N )``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        vector<int> r={1,0,-1,0};\\n        vector<int> c={0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int row=x+r[k];\\n                int col=y+c[k];\\n                if(row>=0 && row<m && col>=0 && col<n && grid[row][col]!=0){\\n                    ans+=grid[row][col];\\n                    grid[row][col]=0;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n= grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0){\\n                    int temp=bfs(grid,i,j,m,n);\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        vector<int> r={1,0,-1,0};\\n        vector<int> c={0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int row=x+r[k];\\n                int col=y+c[k];\\n                if(row>=0 && row<m && col>=0 && col<n && grid[row][col]!=0){\\n                    ans+=grid[row][col];\\n                    grid[row][col]=0;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n= grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0){\\n                    int temp=bfs(grid,i,j,m,n);\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969630,
                "title": "jave-dfs-easy-and-straightforward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nClassic DFS solution\\n\\nMain function:\\n- traverse through all grids\\n- update ```maxFish``` when some grids returns a larger number from dfs search\\n\\nIn DFS function:\\n- check conditions: visited? upper lower bounds? water or land? etc\\n- evaluate grid if condition is fulfilled, then mark as visited = true;\\n- update the returned value (fish in this case)\\n- evaluate adjacent grids, check if there\\'s a possible move. Do this recursively to check all possible moves.\\n- move to adj grids and update returning value (fish)\\n- If back tracking is necessary, mark as false;\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n- Because we have $$N^2$$ for main function (iterates m*n times), and N (iterates m*n times) for helper dfs function\\n- So, the time complexity is $$O(m^2*n^2)$$. If m and n are roughly equal (i.e., the grid is close to square), then the time complexity could be described as $$O(N^4)$$ where N is the side length of the grid.  \\n\\n- Space complexity: $$O(m*n)$$\\n- The grid itself occupies $$O(m\\xD7n)$$ space, but we don\\'t count this since it\\'s given as input. The visited array occupies $$O(m\\xD7n)$$ space. The recursive DFS can potentially go as deep as m\\xD7n in the worst case, so the call stack could occupy $$O(m\\xD7n)$$ space. \\n- Combining the above, the total space complexity is $$O(m\\xD7n)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int [][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int findMaxFish(int[][] grid) { \\n        // DFS to find spot with maxfish && maxFish > 0\\n        int m = grid.length, n = grid[0].length; // m >= 1; n <= 10;\\n        int maxFish = 0;\\n        int fish = 0;\\n        // use two for-loops to traverse through all grids\\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++){\\n                fish = dfs(i,j,grid,new boolean [m][n]); // don\\'t use visited[i][j] here because \\n                maxFish = Math.max(fish,maxFish); //update if newly collected fish is more\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited){\\n        int m = grid.length, n = grid[0].length;\\n        //check all conditions: visited ? water? reach bound m? n?\\n        if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] <= 0) {\\n            return 0;\\n        }\\n        // update visited\\n        visited[r][c] = true;\\n\\n        //if passed, update new fish num\\n        int fish = grid[r][c];\\n        grid[r][c] = 0; // set land mark to 0 to avoid double counting\\n\\n        // keep updating fish if adj routes are possible\\n        for(int[] dir : directions){\\n            int adjrow = r + dir[0];\\n            int adjcol = c + dir[1];\\n            fish += dfs(adjrow,adjcol,grid,visited);\\n        }\\n        \\n        //update if backtrack\\n        visited[r][c] = false;\\n\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```maxFish```\n```\\nclass Solution {\\n    \\n    int [][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int findMaxFish(int[][] grid) { \\n        // DFS to find spot with maxfish && maxFish > 0\\n        int m = grid.length, n = grid[0].length; // m >= 1; n <= 10;\\n        int maxFish = 0;\\n        int fish = 0;\\n        // use two for-loops to traverse through all grids\\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++){\\n                fish = dfs(i,j,grid,new boolean [m][n]); // don\\'t use visited[i][j] here because \\n                maxFish = Math.max(fish,maxFish); //update if newly collected fish is more\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited){\\n        int m = grid.length, n = grid[0].length;\\n        //check all conditions: visited ? water? reach bound m? n?\\n        if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] <= 0) {\\n            return 0;\\n        }\\n        // update visited\\n        visited[r][c] = true;\\n\\n        //if passed, update new fish num\\n        int fish = grid[r][c];\\n        grid[r][c] = 0; // set land mark to 0 to avoid double counting\\n\\n        // keep updating fish if adj routes are possible\\n        for(int[] dir : directions){\\n            int adjrow = r + dir[0];\\n            int adjcol = c + dir[1];\\n            fish += dfs(adjrow,adjcol,grid,visited);\\n        }\\n        \\n        //update if backtrack\\n        visited[r][c] = false;\\n\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963099,
                "title": "golang-dfs-solution",
                "content": "# Code\\n```go\\nfunc findMaxFish(grid [][]int) int {\\n\\tmf := 0\\n\\tfor i := range grid {\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tfish := dfs(grid, i, j)\\n\\t\\t\\tif fish > mf {\\n\\t\\t\\t\\tmf = fish\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mf\\n}\\n\\nfunc dfs(grid [][]int, i, j int) int {\\n\\tif i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) {\\n\\t\\treturn 0\\n\\t}\\n\\tif grid[i][j] == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfish := grid[i][j]\\n\\tgrid[i][j] = 0\\n\\tfish += dfs(grid, i-1, j)\\n\\tfish += dfs(grid, i+1, j)\\n\\tfish += dfs(grid, i, j-1)\\n\\tfish += dfs(grid, i, j+1)\\n\\treturn fish\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc findMaxFish(grid [][]int) int {\\n\\tmf := 0\\n\\tfor i := range grid {\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tfish := dfs(grid, i, j)\\n\\t\\t\\tif fish > mf {\\n\\t\\t\\t\\tmf = fish\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mf\\n}\\n\\nfunc dfs(grid [][]int, i, j int) int {\\n\\tif i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) {\\n\\t\\treturn 0\\n\\t}\\n\\tif grid[i][j] == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfish := grid[i][j]\\n\\tgrid[i][j] = 0\\n\\tfish += dfs(grid, i-1, j)\\n\\tfish += dfs(grid, i+1, j)\\n\\tfish += dfs(grid, i, j-1)\\n\\tfish += dfs(grid, i, j+1)\\n\\treturn fish\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957420,
                "title": "c-u-c-t-nh-s-l-ng-c-c-th-c-u-nhi-u-nh-t-theo-4-h-ng",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\t\\tpublic static int[] dx = { 1, -1, 0, 0 };\\n\\t\\tpublic static int[] dy = { 0, 0, 1, -1 }; \\n\\t\\tpublic static int MAXFISH = 0;\\n\\n    public int findMaxFish(int[][] matrix) {\\n        \\tint rows = matrix.length;\\n\\t\\t\\t\\t\\tint col = matrix[0].length;\\n\\t\\t\\t\\t\\tint maxFish = 0;\\n\\t\\t\\t\\t\\tboolean[][] visited = new boolean[rows][col];\\n\\n\\t\\t\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (matrix[i][j] > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint fishByCell = bfs(i, j, matrix, matrix[i][j], visited);\\n\\t\\t\\t\\t\\t\\t\\t\\tmaxFish = Math.max(maxFish, fishByCell);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn maxFish;\\n    }\\n\\n public static int bfs(int x, int y, int[][] matrix, int fish, boolean[][] visited) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tint col = matrix[0].length;\\n\\t\\tint maxFish = fish;\\n\\t\\tvisited[x][y] = true;\\n\\t\\tQueue<Cellss> queue = new LinkedList<Cellss>();\\n\\t\\tqueue.add(new Cellss(x, y));\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tCellss curenCell = queue.poll();\\n\\t\\t\\tint cureentX = curenCell.x;\\n\\t\\t\\tint cureentY = curenCell.y;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) { \\n\\t\\t\\t\\tint nextX = cureentX + dx[i];\\n\\t\\t\\t\\tint nextY = cureentY + dy[i]; \\n\\t\\t\\t\\tif (nextX < rows && nextX >= 0 && nextY < col && nextY >= 0\\n\\t\\t\\t\\t\\t\\t&& matrix[nextX][nextY] > 0 && !visited[nextX][nextY]) {\\n\\t\\t\\t\\t\\tmaxFish = maxFish + matrix[nextX][nextY];\\n\\n\\t\\t\\t\\t\\tqueue.add(new Cellss(nextX, nextY));\\n\\t\\t\\t\\t\\tvisited[nextX][nextY] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxFish;\\n\\t}\\n}\\n\\n\\nclass Cellss {\\n\\tint x;\\n\\tint y;\\n\\n\\tpublic Cellss(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic static int[] dx = { 1, -1, 0, 0 };\\n\\t\\tpublic static int[] dy = { 0, 0, 1, -1 }; \\n\\t\\tpublic static int MAXFISH = 0;\\n\\n    public int findMaxFish(int[][] matrix) {\\n        \\tint rows = matrix.length;\\n\\t\\t\\t\\t\\tint col = matrix[0].length;\\n\\t\\t\\t\\t\\tint maxFish = 0;\\n\\t\\t\\t\\t\\tboolean[][] visited = new boolean[rows][col];\\n\\n\\t\\t\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (matrix[i][j] > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint fishByCell = bfs(i, j, matrix, matrix[i][j], visited);\\n\\t\\t\\t\\t\\t\\t\\t\\tmaxFish = Math.max(maxFish, fishByCell);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn maxFish;\\n    }\\n\\n public static int bfs(int x, int y, int[][] matrix, int fish, boolean[][] visited) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tint col = matrix[0].length;\\n\\t\\tint maxFish = fish;\\n\\t\\tvisited[x][y] = true;\\n\\t\\tQueue<Cellss> queue = new LinkedList<Cellss>();\\n\\t\\tqueue.add(new Cellss(x, y));\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tCellss curenCell = queue.poll();\\n\\t\\t\\tint cureentX = curenCell.x;\\n\\t\\t\\tint cureentY = curenCell.y;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) { \\n\\t\\t\\t\\tint nextX = cureentX + dx[i];\\n\\t\\t\\t\\tint nextY = cureentY + dy[i]; \\n\\t\\t\\t\\tif (nextX < rows && nextX >= 0 && nextY < col && nextY >= 0\\n\\t\\t\\t\\t\\t\\t&& matrix[nextX][nextY] > 0 && !visited[nextX][nextY]) {\\n\\t\\t\\t\\t\\tmaxFish = maxFish + matrix[nextX][nextY];\\n\\n\\t\\t\\t\\t\\tqueue.add(new Cellss(nextX, nextY));\\n\\t\\t\\t\\t\\tvisited[nextX][nextY] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxFish;\\n\\t}\\n}\\n\\n\\nclass Cellss {\\n\\tint x;\\n\\tint y;\\n\\n\\tpublic Cellss(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929438,
                "title": "c-simple-dfs-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    int m;\\n    int n;\\n    void dfs(vector<vector<int>>&grid, int x, int y, int&curr)\\n    {\\n        curr+=grid[x][y];\\n        grid[x][y]=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx = x+dir[k][0];\\n            int ny = y+dir[k][1];\\n            if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)\\n            {\\n                dfs(grid, nx, ny, curr);\\n            }\\n        }\\n        return ;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    int curr = 0;\\n                    dfs(grid, i, j, curr);\\n                    ans=max(ans, curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    int m;\\n    int n;\\n    void dfs(vector<vector<int>>&grid, int x, int y, int&curr)\\n    {\\n        curr+=grid[x][y];\\n        grid[x][y]=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx = x+dir[k][0];\\n            int ny = y+dir[k][1];\\n            if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)\\n            {\\n                dfs(grid, nx, ny, curr);\\n            }\\n        }\\n        return ;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    int curr = 0;\\n                    dfs(grid, i, j, curr);\\n                    ans=max(ans, curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924427,
                "title": "simplest-depth-first-search-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->Check each cell\\n->if the cell has non-zero value\\n->run iterative function to collect all connected non-zero value\\n->as each cell changes to zero\\n->compare with other cell values to save the maximum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getfish(self,grid,i,j):\\n        if grid[i][j]==0: return 0\\n        fish=grid[i][j]\\n        grid[i][j]=0\\n\\n        if i+1<len(grid):fish+=self.getfish(grid,i+1,j)\\n        if i-1>=0:fish+=self.getfish(grid,i-1,j)\\n        if j+1<len(grid[0]):fish+=self.getfish(grid,i,j+1)\\n        if j-1>=0:fish+=self.getfish(grid,i,j-1)\\n  \\n        return fish\\n\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        out = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]>0:\\n                    out = max(out,self.getfish(grid,i,j))\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getfish(self,grid,i,j):\\n        if grid[i][j]==0: return 0\\n        fish=grid[i][j]\\n        grid[i][j]=0\\n\\n        if i+1<len(grid):fish+=self.getfish(grid,i+1,j)\\n        if i-1>=0:fish+=self.getfish(grid,i-1,j)\\n        if j+1<len(grid[0]):fish+=self.getfish(grid,i,j+1)\\n        if j-1>=0:fish+=self.getfish(grid,i,j-1)\\n  \\n        return fish\\n\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        out = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]>0:\\n                    out = max(out,self.getfish(grid,i,j))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922330,
                "title": "easy-cpp-solution-beats-98-of-online-submission",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint delrow[4]={-1,0,1,0};\\nint delcol[4]={0,1,0,-1};\\nvoid dfs(vector<vector<int>>& g,int i,int j,int& cnt){\\ncnt=cnt+g[i][j];\\n//vis[i][j]=1;\\nint n=g.size();\\nint m=g[0].size();\\ng[i][j]=0;\\nfor(int k=0;k<4;k++){\\n    int nrow=i+delrow[k];\\n    int ncol=j+delcol[k];\\n    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && g[nrow][ncol]!=0){\\n        dfs(g,nrow,ncol,cnt);\\n    }\\n}\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\nfor(int i=0;i<n;i++){\\n    for(int j=0;j<m;j++){\\nif(grid[i][j]!=0){\\n    int cnt=0;\\n   // vector<vector<int>> vis(n,vector<int>(m,0));\\ndfs(grid,i,j,cnt);\\nmaxi=max(maxi,cnt);\\n}\\n    }\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint delrow[4]={-1,0,1,0};\\nint delcol[4]={0,1,0,-1};\\nvoid dfs(vector<vector<int>>& g,int i,int j,int& cnt){\\ncnt=cnt+g[i][j];\\n//vis[i][j]=1;\\nint n=g.size();\\nint m=g[0].size();\\ng[i][j]=0;\\nfor(int k=0;k<4;k++){\\n    int nrow=i+delrow[k];\\n    int ncol=j+delcol[k];\\n    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && g[nrow][ncol]!=0){\\n        dfs(g,nrow,ncol,cnt);\\n    }\\n}\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\nfor(int i=0;i<n;i++){\\n    for(int j=0;j<m;j++){\\nif(grid[i][j]!=0){\\n    int cnt=0;\\n   // vector<vector<int>> vis(n,vector<int>(m,0));\\ndfs(grid,i,j,cnt);\\nmaxi=max(maxi,cnt);\\n}\\n    }\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917556,
                "title": "clean-bfs-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c]>0:\\n                    queue = [(r,c)]\\n                    count = 0\\n                    while queue:\\n                        row,col = queue.pop()\\n                        if grid[row][col]==0:continue\\n                        count+=grid[row][col]\\n                        grid[row][col] = 0\\n                        for m_r,m_c in directions:\\n                            new_r,new_c = row+m_r,col+m_c\\n                            if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] !=0:\\n                                queue.append((new_r, new_c))\\n                    ans = max(ans,count)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c]>0:\\n                    queue = [(r,c)]\\n                    count = 0\\n                    while queue:\\n                        row,col = queue.pop()\\n                        if grid[row][col]==0:continue\\n                        count+=grid[row][col]\\n                        grid[row][col] = 0\\n                        for m_r,m_c in directions:\\n                            new_r,new_c = row+m_r,col+m_c\\n                            if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] !=0:\\n                                queue.append((new_r, new_c))\\n                    ans = max(ans,count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916100,
                "title": "easy-python-solution-by-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n        m,n = len(grid), len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        curfishes = [0]\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] > 0:\\n                    curfishes[0] += grid[i][j]\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n        maxFishes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 0 and grid[i][j] > 0:\\n                    curfishes[0] = 0\\n                    dfs(i,j)\\n                    maxFishes = max(maxFishes, curfishes[0])\\n        return maxFishes\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n        m,n = len(grid), len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        curfishes = [0]\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] > 0:\\n                    curfishes[0] += grid[i][j]\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n        maxFishes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 0 and grid[i][j] > 0:\\n                    curfishes[0] = 0\\n                    dfs(i,j)\\n                    maxFishes = max(maxFishes, curfishes[0])\\n        return maxFishes\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915836,
                "title": "easy-intuitive-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != 0) {\\n                    int maxFish = dfs(grid, i, j);\\n                    max = Math.max(max, maxFish);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int dfs(int[][] grid, int r, int c) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) {\\n            return 0;\\n        }\\n       \\n        int curr = grid[r][c];\\n        grid[r][c] = 0;\\n        int u = dfs(grid, r - 1, c);  // Up\\n        int d = dfs(grid, r + 1, c);  // Down\\n        int ri = dfs(grid, r, c + 1); // Right\\n        int l = dfs(grid, r, c - 1);  // Left\\n        return curr + l + ri + u + d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != 0) {\\n                    int maxFish = dfs(grid, i, j);\\n                    max = Math.max(max, maxFish);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int dfs(int[][] grid, int r, int c) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) {\\n            return 0;\\n        }\\n       \\n        int curr = grid[r][c];\\n        grid[r][c] = 0;\\n        int u = dfs(grid, r - 1, c);  // Up\\n        int d = dfs(grid, r + 1, c);  // Down\\n        int ri = dfs(grid, r, c + 1); // Right\\n        int l = dfs(grid, r, c - 1);  // Left\\n        return curr + l + ri + u + d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908818,
                "title": "javascript-dfs-o-n-2",
                "content": "```\\nvar findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905885,
                "title": "cpp-easy-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCall a BFS from each water cell we encounter and then find the max from all the function calls.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCall a BFS from each water cell we encounter and then find the max from all the function calls.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<pair<int,int>>vct={{0,1},{0,-1},{1,0},{-1,0}};\\nint bfs(int row,int col,vector<vector<int>>& grid)\\n{\\n    int res=0;\\n     std::vector<std::vector<bool>>track(grid.size(),std::vector<bool>(grid[0].size(),false));\\n     track[row][col]=true;\\n    std::queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int newrow=q.front().first;\\n        int newcol=q.front().second;\\n        res+=grid[q.front().first][q.front().second];\\n        q.pop();\\n        for(int i=0;i<vct.size();i++)\\n        {\\n            if((newrow+vct[i].first)>=0 && (newrow+vct[i].first)<grid.size() && (newcol+vct[i].second)>=0 && (newcol+vct[i].second)<grid[0].size() && grid[newrow+vct[i].first][newcol+vct[i].second]>0 && track[newrow+vct[i].first][newcol+vct[i].second]==false)\\n            {\\n                track[newrow+vct[i].first][newcol+vct[i].second]=true;\\n                q.push({newrow+vct[i].first,newcol+vct[i].second});\\n            }\\n        }\\n    }\\n    return res;\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                   \\n                    int subans=bfs(i,j,grid);\\n                    ans=max(ans,subans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<pair<int,int>>vct={{0,1},{0,-1},{1,0},{-1,0}};\\nint bfs(int row,int col,vector<vector<int>>& grid)\\n{\\n    int res=0;\\n     std::vector<std::vector<bool>>track(grid.size(),std::vector<bool>(grid[0].size(),false));\\n     track[row][col]=true;\\n    std::queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int newrow=q.front().first;\\n        int newcol=q.front().second;\\n        res+=grid[q.front().first][q.front().second];\\n        q.pop();\\n        for(int i=0;i<vct.size();i++)\\n        {\\n            if((newrow+vct[i].first)>=0 && (newrow+vct[i].first)<grid.size() && (newcol+vct[i].second)>=0 && (newcol+vct[i].second)<grid[0].size() && grid[newrow+vct[i].first][newcol+vct[i].second]>0 && track[newrow+vct[i].first][newcol+vct[i].second]==false)\\n            {\\n                track[newrow+vct[i].first][newcol+vct[i].second]=true;\\n                q.push({newrow+vct[i].first,newcol+vct[i].second});\\n            }\\n        }\\n    }\\n    return res;\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                   \\n                    int subans=bfs(i,j,grid);\\n                    ans=max(ans,subans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896630,
                "title": "c-clean-code-too-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:long long int a=0,s=0;\\n    void t(int i,int j,vector<vector<int>>& g)\\n    {\\n         if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==0) return;\\n         s+=g[i][j];\\n         g[i][j]=0;\\n\\n         t(i+1,j,g);\\n         t(i-1,j,g);\\n         t(i,j+1,g);\\n         t(i,j-1,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        for(int i=0;i<g.size();i++)\\n         for(int j=0;j<g[0].size();j++)\\n          if(g[i][j]>0)\\n            {t(i,j,g);\\n            a=max(a,s);\\n            s=0;\\n            }\\n\\n       return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:long long int a=0,s=0;\\n    void t(int i,int j,vector<vector<int>>& g)\\n    {\\n         if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==0) return;\\n         s+=g[i][j];\\n         g[i][j]=0;\\n\\n         t(i+1,j,g);\\n         t(i-1,j,g);\\n         t(i,j+1,g);\\n         t(i,j-1,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        for(int i=0;i<g.size();i++)\\n         for(int j=0;j<g[0].size();j++)\\n          if(g[i][j]>0)\\n            {t(i,j,g);\\n            a=max(a,s);\\n            s=0;\\n            }\\n\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868878,
                "title": "dfs-c",
                "content": "# Intuition\\nDo a DFS a find the maximum count\\n\\n# Complexity\\n- Time complexity:\\nO{m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        bool[,] visited = new bool[m,n];\\n        int maxFishes = 0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !visited[i,j])\\n                {\\n                    maxFishes = Math.Max(maxFishes,DFS(grid,i,j,visited));\\n                }\\n            }\\n        }\\n        return maxFishes;\\n    }\\n\\n    private int DFS(int[][] grid,int i,int j, bool[,] visited)\\n    {\\n\\n        int[] c = new int[]{1,0,-1,0};\\n        int[] r = new int[]{0,-1,0,1};\\n        int sum = grid[i][j];\\n        visited[i,j] = true;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int row = i+r[k];\\n            int col = j+c[k];\\n            if(isAllowed(row,col,grid.Length,grid[0].Length) && !visited[row,col] && grid[row][col]!=0)\\n            {\\n                sum = sum + DFS(grid,row,col,visited);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private bool isAllowed(int i,int j,int m,int n)\\n    {\\n        if(i>=0 && i< m && j>=0 && j<n)\\n            return true;\\n\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        bool[,] visited = new bool[m,n];\\n        int maxFishes = 0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !visited[i,j])\\n                {\\n                    maxFishes = Math.Max(maxFishes,DFS(grid,i,j,visited));\\n                }\\n            }\\n        }\\n        return maxFishes;\\n    }\\n\\n    private int DFS(int[][] grid,int i,int j, bool[,] visited)\\n    {\\n\\n        int[] c = new int[]{1,0,-1,0};\\n        int[] r = new int[]{0,-1,0,1};\\n        int sum = grid[i][j];\\n        visited[i,j] = true;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int row = i+r[k];\\n            int col = j+c[k];\\n            if(isAllowed(row,col,grid.Length,grid[0].Length) && !visited[row,col] && grid[row][col]!=0)\\n            {\\n                sum = sum + DFS(grid,row,col,visited);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private bool isAllowed(int i,int j,int m,int n)\\n    {\\n        if(i>=0 && i< m && j>=0 && j<n)\\n            return true;\\n\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863959,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        maxx = 0\\n\\n        def helper(x,y):\\n            if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]) or not grid[x][y]:\\n                return 0\\n            \\n            current = grid[x][y]\\n            grid[x][y] = 0\\n\\n            return current + helper(x-1,y) + helper(x+1,y) + helper(x,y-1) + helper(x,y+1)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    maxx = max(helper(i,j), maxx)\\n        \\n        return maxx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        maxx = 0\\n\\n        def helper(x,y):\\n            if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]) or not grid[x][y]:\\n                return 0\\n            \\n            current = grid[x][y]\\n            grid[x][y] = 0\\n\\n            return current + helper(x-1,y) + helper(x+1,y) + helper(x,y-1) + helper(x,y+1)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    maxx = max(helper(i,j), maxx)\\n        \\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849817,
                "title": "python-3-with-dfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        n, m = len(grid), len(grid[0])\\n\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m:\\n                return 0\\n            \\n            if grid[i][j] == 0:\\n                return 0\\n\\n            fish, grid[i][j] = grid[i][j], 0\\n\\n            fish += dfs(i + 1, j)\\n            fish += dfs(i - 1, j)\\n            fish += dfs(i, j + 1)\\n            fish += dfs(i, j - 1)\\n            return fish\\n\\n            \\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        n, m = len(grid), len(grid[0])\\n\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m:\\n                return 0\\n            \\n            if grid[i][j] == 0:\\n                return 0\\n\\n            fish, grid[i][j] = grid[i][j], 0\\n\\n            fish += dfs(i + 1, j)\\n            fish += dfs(i - 1, j)\\n            fish += dfs(i, j + 1)\\n            fish += dfs(i, j - 1)\\n            return fish\\n\\n            \\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848447,
                "title": "beats-100-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->DFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int r, int c){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0)\\n        return 0;\\n        int x = grid[r][c];\\n        grid[r][c] = 0;\\n\\n        return x+dfs(grid,r-1,c)+dfs(grid,r+1,c)+dfs(grid,r,c-1)+dfs(grid,r,c+1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int fish = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] != 0){\\n                    fish = Math.max(fish,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(int[][] grid, int r, int c){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0)\\n        return 0;\\n        int x = grid[r][c];\\n        grid[r][c] = 0;\\n\\n        return x+dfs(grid,r-1,c)+dfs(grid,r+1,c)+dfs(grid,r,c-1)+dfs(grid,r,c+1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int fish = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] != 0){\\n                    fish = Math.max(fish,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848212,
                "title": "python-dfs-beats-98-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to calculate total number of fishes from each group of fishes\\n\\nSo, apply dfs in each group and mark it as visited to avoid going to it again\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nCall dfs at every point mark the elements visited in visited array. Recursively call for all its adjacent nodes and return the total \\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```class Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        visited = [[False for i in range(n)] for j in range(m)]\\n\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            visited[i][j] = True\\n            res = grid[i][j]\\n\\n            dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            for x, y in dir:\\n                if isSafe(i+x, j+y) and grid[i + x][j + y] != 0 and visited[i + x][j + y] == False:\\n                    res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and visited[i][j] == False:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nSpace Optimized (marking value to 0 on grid after visiting it)\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) (Not including recursion stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            \\n            if not isSafe(i, j) or grid[i][j] == 0:\\n                return 0\\n\\n            res = grid[i][j]\\n            grid[i][j] = 0\\n\\n\\n            for x, y in dir:\\n                res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        visited = [[False for i in range(n)] for j in range(m)]\\n\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            visited[i][j] = True\\n            res = grid[i][j]\\n\\n            dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            for x, y in dir:\\n                if isSafe(i+x, j+y) and grid[i + x][j + y] != 0 and visited[i + x][j + y] == False:\\n                    res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and visited[i][j] == False:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            \\n            if not isSafe(i, j) or grid[i][j] == 0:\\n                return 0\\n\\n            res = grid[i][j]\\n            grid[i][j] = 0\\n\\n\\n            for x, y in dir:\\n                res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839217,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 ){\\n                    max=Math.max(max,helper(grid,i,j,n,m));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int helper(int[][] grid,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(grid[i][j]==0)return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=0;\\n        return ans+helper(grid,i+1,j,n,m)+helper(grid,i,j-1,n,m)+helper(grid,i-1,j,n,m)+helper(grid,i,j+1,n,m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 ){\\n                    max=Math.max(max,helper(grid,i,j,n,m));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int helper(int[][] grid,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(grid[i][j]==0)return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=0;\\n        return ans+helper(grid,i+1,j,n,m)+helper(grid,i,j-1,n,m)+helper(grid,i-1,j,n,m)+helper(grid,i,j+1,n,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832115,
                "title": "c-simple-beginner-friendly-solution-ll-bfs-dfs-union-find",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int mx=0,i=0,j=0,p=0,m=grid.size(),n=grid[0].size(),f=0,r=0,c=0,s=0,a=0,k=0;\\n        queue<int>q;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]>0)\\n                {\\n                    a=0;\\n                    q.push(i*n+j);\\n                    while(q.size()>0)\\n                    {\\n                        s=q.size();\\n                        for(k=0;k<s;k++)\\n                        {\\n                            f=q.front();\\n                            r=f/n,c=f%n;\\n                            if(grid[r][c]>0)\\n                            {\\n                                a+=grid[r][c];\\n                                grid[r][c]=0;\\n                                if(r>0) q.push(f-n);\\n                                if(r<m-1) q.push(f+n);\\n                                if(c>0) q.push(f-1);\\n                                if(c<n-1) q.push(f+1);\\n                            }\\n                            q.pop();\\n                        }\\n                    }\\n                    mx=max(a,mx);\\n                }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int mx=0,i=0,j=0,p=0,m=grid.size(),n=grid[0].size(),f=0,r=0,c=0,s=0,a=0,k=0;\\n        queue<int>q;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]>0)\\n                {\\n                    a=0;\\n                    q.push(i*n+j);\\n                    while(q.size()>0)\\n                    {\\n                        s=q.size();\\n                        for(k=0;k<s;k++)\\n                        {\\n                            f=q.front();\\n                            r=f/n,c=f%n;\\n                            if(grid[r][c]>0)\\n                            {\\n                                a+=grid[r][c];\\n                                grid[r][c]=0;\\n                                if(r>0) q.push(f-n);\\n                                if(r<m-1) q.push(f+n);\\n                                if(c>0) q.push(f-1);\\n                                if(c<n-1) q.push(f+1);\\n                            }\\n                            q.pop();\\n                        }\\n                    }\\n                    mx=max(a,mx);\\n                }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827389,
                "title": "bfs-from-land",
                "content": "# Intuition\\n\\nWe can do DFS from each land, but BFS seems interesting here.\\n\\n# Approach\\n\\nCollect all land first. And do BFS for each land. Collecting profit.\\n\\n# Complexity\\n- Time complexity:\\n`O(rows * cols)`\\n\\n- Space complexity:\\n`O(rows * cols)`\\n\\n# Code\\n```\\ntype Pair struct {r, c int}\\n\\nfunc findMaxFish(grid [][]int) int {\\n    // collect all land points\\n    rows, cols := len(grid), len(grid[0])\\n\\n    landArr := []Pair{}\\n\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            // land\\n            if grid[r][c] != 0 {\\n                landArr = append(landArr, Pair{r, c})\\n            }\\n        }\\n    }\\n\\n    profit := 0\\n\\n    if len(landArr) == 0 {\\n       return profit \\n    }\\n\\n    checkNei := func(r, c int, visited [][]bool) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] > 0 && !visited[r][c]\\n    }\\n\\n    for _, land := range landArr {\\n\\n        newProfit := 0\\n        // start \\n        q := []Pair{land}\\n\\n        visited := make([][]bool, rows)\\n\\n        for r := 0; r < rows; r++ {\\n            visited[r] = make([]bool, cols)\\n        }\\n\\n        for len(q) > 0 {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if visited[cur.r][cur.c] {continue}\\n\\n            newProfit += grid[cur.r][cur.c]\\n            \\n            visited[cur.r][cur.c] = true\\n\\n            if checkNei(cur.r + 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r + 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r - 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r - 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r, cur.c + 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c + 1})\\n            }\\n\\n            if checkNei(cur.r, cur.c - 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c - 1})\\n            }\\n        }\\n\\n        if newProfit > profit {\\n            profit = newProfit\\n        }\\n    }\\n\\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Pair struct {r, c int}\\n\\nfunc findMaxFish(grid [][]int) int {\\n    // collect all land points\\n    rows, cols := len(grid), len(grid[0])\\n\\n    landArr := []Pair{}\\n\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            // land\\n            if grid[r][c] != 0 {\\n                landArr = append(landArr, Pair{r, c})\\n            }\\n        }\\n    }\\n\\n    profit := 0\\n\\n    if len(landArr) == 0 {\\n       return profit \\n    }\\n\\n    checkNei := func(r, c int, visited [][]bool) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] > 0 && !visited[r][c]\\n    }\\n\\n    for _, land := range landArr {\\n\\n        newProfit := 0\\n        // start \\n        q := []Pair{land}\\n\\n        visited := make([][]bool, rows)\\n\\n        for r := 0; r < rows; r++ {\\n            visited[r] = make([]bool, cols)\\n        }\\n\\n        for len(q) > 0 {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if visited[cur.r][cur.c] {continue}\\n\\n            newProfit += grid[cur.r][cur.c]\\n            \\n            visited[cur.r][cur.c] = true\\n\\n            if checkNei(cur.r + 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r + 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r - 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r - 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r, cur.c + 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c + 1})\\n            }\\n\\n            if checkNei(cur.r, cur.c - 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c - 1})\\n            }\\n        }\\n\\n        if newProfit > profit {\\n            profit = newProfit\\n        }\\n    }\\n\\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824188,
                "title": "easy-dfs-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int count;\\n    public int findMaxFish(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n      \\n       int ans=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               count=0;\\n               if(mat[i][j]!=0){\\n                   dfs( mat,i,j);\\n                   ans=Math.max(count,ans);\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n\\n\\n    public void dfs(int[][] mat,int i,int j){\\n        if(i<0||j<0||i>=mat.length||j>=mat[0].length||mat[i][j]==0)return;\\n        count+=mat[i][j];\\n        mat[i][j]=0;\\n        dfs(mat,i+1,j);\\n        dfs(mat,i-1,j);\\n        dfs(mat,i,j+1);\\n        dfs(mat,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int findMaxFish(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n      \\n       int ans=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               count=0;\\n               if(mat[i][j]!=0){\\n                   dfs( mat,i,j);\\n                   ans=Math.max(count,ans);\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n\\n\\n    public void dfs(int[][] mat,int i,int j){\\n        if(i<0||j<0||i>=mat.length||j>=mat[0].length||mat[i][j]==0)return;\\n        count+=mat[i][j];\\n        mat[i][j]=0;\\n        dfs(mat,i+1,j);\\n        dfs(mat,i-1,j);\\n        dfs(mat,i,j+1);\\n        dfs(mat,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817700,
                "title": "dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n       boolean [][] visited = new boolean[m][n];\\n       int ans = 0;\\n       for(int i = 0;i<m ; i++){\\n           for(int j = 0; j<n; j++){\\n               if(grid[i][j]!= 0 && !visited[i][j])\\n               ans = Math.max(ans,dfs(grid,visited,i,j,m,n));\\n           }\\n       }\\n       return ans;\\n    }\\n    public int dfs(int[][] grid, boolean [][] visited,int i,int j,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>= n || grid[i][j]== 0|| visited[i][j])\\n        return 0;\\n        visited[i][j] = true;\\n        int fish = grid[i][j];\\n        return fish + dfs(grid,visited,i+1,j,m,n) +\\n                dfs(grid,visited,i,j+1,m,n) +\\n                dfs(grid,visited,i-1,j,m,n) +\\n                dfs(grid,visited,i,j-1,m,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n       boolean [][] visited = new boolean[m][n];\\n       int ans = 0;\\n       for(int i = 0;i<m ; i++){\\n           for(int j = 0; j<n; j++){\\n               if(grid[i][j]!= 0 && !visited[i][j])\\n               ans = Math.max(ans,dfs(grid,visited,i,j,m,n));\\n           }\\n       }\\n       return ans;\\n    }\\n    public int dfs(int[][] grid, boolean [][] visited,int i,int j,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>= n || grid[i][j]== 0|| visited[i][j])\\n        return 0;\\n        visited[i][j] = true;\\n        int fish = grid[i][j];\\n        return fish + dfs(grid,visited,i+1,j,m,n) +\\n                dfs(grid,visited,i,j+1,m,n) +\\n                dfs(grid,visited,i-1,j,m,n) +\\n                dfs(grid,visited,i,j-1,m,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812217,
                "title": "python-solution-dfs-explained",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\t    # visited keeps track of all the cells visited\\n        visited = set()\\n\\t\\t\\n\\t\\t#initialize rows and columns variables\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # DFS function\\n        def backtrack(i, j):\\n\\t\\t    # Check if out of bounds\\n            if i < 0 or j < 0 or i == rows or j == cols:\\n                return 0\\n            else:\\n\\t\\t\\t    # If land the fish caught will be 0\\n                if grid[i][j] == 0:\\n                    return 0\\n\\t\\t\\t\\t# If already visited don\\'t take the path\\n                if (i, j) in visited:\\n                    return 0\\n                \\n\\t\\t\\t\\t# Add the cell to visited\\n                visited.add((i, j))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Find out the total number of fish that can be caught by performing DFS recursively\\n                return grid[i][j] + backtrack(i, j + 1) + backtrack(i, j - 1) + backtrack(i+1, j) + backtrack(i-1,j)\\n            \\n            \\n        res = 0\\n            \\n        \\n\\t\\t# Iterate over every cell of the grid\\n        for i in range(rows):\\n            for j in range(cols):\\n\\t\\t\\t   # If the grid is not land and it has been not visited so far, perform DFS on it and get the total sum as current value\\n                if (i, j) not in visited and grid[i][j] != 0:\\n                    current_value = backtrack(i, j)\\n\\t\\t\\t\\t\\t# If this path gives best result update the result variable\\n                    res = max(current_value, res)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\t    # visited keeps track of all the cells visited\\n        visited = set()\\n\\t\\t\\n\\t\\t#initialize rows and columns variables\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # DFS function\\n        def backtrack(i, j):\\n\\t\\t    # Check if out of bounds\\n            if i < 0 or j < 0 or i == rows or j == cols:\\n                return 0\\n            else:\\n\\t\\t\\t    # If land the fish caught will be 0\\n                if grid[i][j] == 0:\\n                    return 0\\n\\t\\t\\t\\t# If already visited don\\'t take the path\\n                if (i, j) in visited:\\n                    return 0\\n                \\n\\t\\t\\t\\t# Add the cell to visited\\n                visited.add((i, j))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Find out the total number of fish that can be caught by performing DFS recursively\\n                return grid[i][j] + backtrack(i, j + 1) + backtrack(i, j - 1) + backtrack(i+1, j) + backtrack(i-1,j)\\n            \\n            \\n        res = 0\\n            \\n        \\n\\t\\t# Iterate over every cell of the grid\\n        for i in range(rows):\\n            for j in range(cols):\\n\\t\\t\\t   # If the grid is not land and it has been not visited so far, perform DFS on it and get the total sum as current value\\n                if (i, j) not in visited and grid[i][j] != 0:\\n                    current_value = backtrack(i, j)\\n\\t\\t\\t\\t\\t# If this path gives best result update the result variable\\n                    res = max(current_value, res)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800687,
                "title": "simplest-solution-dfs-brute-force",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$stack->O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int r,int c,vector<vector<int>>&grid,int &sum)\\n   {   int n=grid.size(),m=grid[0].size();\\n       \\n       sum +=grid[r][c];\\n       grid[r][c]=0;\\n\\n       if(r+1<n and grid[r+1][c]!=0)\\n       {\\n         dfs(r+1,c,grid,sum);\\n       }\\n       if(c+1<m and grid[r][c+1] !=0)\\n       {\\n           dfs(r,c+1,grid,sum);\\n       }\\n       if(r-1>=0 and grid[r-1][c] !=0)\\n       {\\n           dfs(r-1,c,grid,sum);\\n       }\\n\\n       if(c-1>=0 and grid[r][c-1] !=0)\\n       {\\n          dfs(r,c-1,grid,sum);\\n       }        \\n   }\\n\\n\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int fish=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>0){\\n                    int sum=0;\\n                    dfs(i,j,grid,sum);\\n                    fish=max(fish,sum);\\n                }\\n            }\\n        }\\n    return fish;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int r,int c,vector<vector<int>>&grid,int &sum)\\n   {   int n=grid.size(),m=grid[0].size();\\n       \\n       sum +=grid[r][c];\\n       grid[r][c]=0;\\n\\n       if(r+1<n and grid[r+1][c]!=0)\\n       {\\n         dfs(r+1,c,grid,sum);\\n       }\\n       if(c+1<m and grid[r][c+1] !=0)\\n       {\\n           dfs(r,c+1,grid,sum);\\n       }\\n       if(r-1>=0 and grid[r-1][c] !=0)\\n       {\\n           dfs(r-1,c,grid,sum);\\n       }\\n\\n       if(c-1>=0 and grid[r][c-1] !=0)\\n       {\\n          dfs(r,c-1,grid,sum);\\n       }        \\n   }\\n\\n\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int fish=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>0){\\n                    int sum=0;\\n                    dfs(i,j,grid,sum);\\n                    fish=max(fish,sum);\\n                }\\n            }\\n        }\\n    return fish;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797461,
                "title": "union-find-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int r,c;\\n    vector<int>parents;\\n\\n    bool isValid(int x, int y, vector<vector<int>>&grid){\\n        if((x>=0 && x<r) && (y>=0 && y<c) && grid[x][y])\\n            return true;\\n        return false;\\n    }\\n\\n    int getAbsoluteParent(int n){\\n        if(n!=parents[n])\\n            parents[n] = getAbsoluteParent(parents[n]);\\n        \\n        return parents[n];\\n    }\\n\\n    void unify(int x, int y){\\n        int px = getAbsoluteParent(x);\\n        int py = getAbsoluteParent(y);\\n\\n        if(px!=py)\\n            parents[px] = py;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        vector<pair<int,int>>dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        vector<int>totalFishes(r*c,0);\\n        parents = vector<int>(r*c);\\n        \\n        for(int i=0;i<r*c;i++)\\n            parents[i] = i;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(!grid[i][j])\\n                    continue;\\n\\n                for(int k=0;k<4;k++){\\n                    int ni = i + dirs[k].first;\\n                    int nj = j + dirs[k].second;\\n                    if(isValid(ni,nj,grid)){\\n                        unify(ni*c+nj,i*c+j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n\\n                if(grid[i][j]){\\n                    int cur_parent = getAbsoluteParent(i*c+j);\\n                    totalFishes[cur_parent] += grid[i][j];\\n                    ans = max(ans,totalFishes[cur_parent]);\\n                }\\n                    \\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int r,c;\\n    vector<int>parents;\\n\\n    bool isValid(int x, int y, vector<vector<int>>&grid){\\n        if((x>=0 && x<r) && (y>=0 && y<c) && grid[x][y])\\n            return true;\\n        return false;\\n    }\\n\\n    int getAbsoluteParent(int n){\\n        if(n!=parents[n])\\n            parents[n] = getAbsoluteParent(parents[n]);\\n        \\n        return parents[n];\\n    }\\n\\n    void unify(int x, int y){\\n        int px = getAbsoluteParent(x);\\n        int py = getAbsoluteParent(y);\\n\\n        if(px!=py)\\n            parents[px] = py;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        vector<pair<int,int>>dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        vector<int>totalFishes(r*c,0);\\n        parents = vector<int>(r*c);\\n        \\n        for(int i=0;i<r*c;i++)\\n            parents[i] = i;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(!grid[i][j])\\n                    continue;\\n\\n                for(int k=0;k<4;k++){\\n                    int ni = i + dirs[k].first;\\n                    int nj = j + dirs[k].second;\\n                    if(isValid(ni,nj,grid)){\\n                        unify(ni*c+nj,i*c+j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n\\n                if(grid[i][j]){\\n                    int cur_parent = getAbsoluteParent(i*c+j);\\n                    totalFishes[cur_parent] += grid[i][j];\\n                    ans = max(ans,totalFishes[cur_parent]);\\n                }\\n                    \\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780050,
                "title": "100-faster-c-solution-using-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int m , n ;\\n    void dfs( int i , int j , vector<vector<int>>&grid , int &fish )\\n    {\\n        if( i < 0 or j < 0 or i >= m or j >= n ) return ;\\n        \\n        if(grid[i][j]==0) return ;\\n        fish += grid[i][j] ;\\n        grid[i][j] = 0 ;\\n        \\n        dfs( i , j + 1 , grid , fish ) ;\\n        dfs( i , j - 1 , grid , fish ) ;\\n        dfs( i + 1 , j , grid , fish ) ;\\n        dfs( i - 1 , j , grid , fish ) ;\\n        \\n        \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        int ans = 0 ;\\n        for( int i = 0 ; i < m ; i++ )\\n        {\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                if(grid[i][j] != 0 )\\n                {\\n                    int temp = 0 ;\\n                    dfs( i , j , grid , temp ) ;\\n                    ans = max( ans , temp ) ;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m , n ;\\n    void dfs( int i , int j , vector<vector<int>>&grid , int &fish )\\n    {\\n        if( i < 0 or j < 0 or i >= m or j >= n ) return ;\\n        \\n        if(grid[i][j]==0) return ;\\n        fish += grid[i][j] ;\\n        grid[i][j] = 0 ;\\n        \\n        dfs( i , j + 1 , grid , fish ) ;\\n        dfs( i , j - 1 , grid , fish ) ;\\n        dfs( i + 1 , j , grid , fish ) ;\\n        dfs( i - 1 , j , grid , fish ) ;\\n        \\n        \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        int ans = 0 ;\\n        for( int i = 0 ; i < m ; i++ )\\n        {\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                if(grid[i][j] != 0 )\\n                {\\n                    int temp = 0 ;\\n                    dfs( i , j , grid , temp ) ;\\n                    ans = max( ans , temp ) ;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770309,
                "title": "c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] > 0)\\n                    maxFish = max(maxFish, dfs(grid, i, j));\\n        return maxFish;\\n    }\\nprivate:\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() ||\\n            j < 0 || j >= grid[0].size() ||\\n            grid[i][j] == 0)\\n            return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += dfs(grid, i + 1, j);\\n        fish += dfs(grid, i - 1, j);\\n        fish += dfs(grid, i, j + 1);\\n        fish += dfs(grid, i, j - 1);\\n        return fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] > 0)\\n                    maxFish = max(maxFish, dfs(grid, i, j));\\n        return maxFish;\\n    }\\nprivate:\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() ||\\n            j < 0 || j >= grid[0].size() ||\\n            grid[i][j] == 0)\\n            return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += dfs(grid, i + 1, j);\\n        fish += dfs(grid, i - 1, j);\\n        fish += dfs(grid, i, j + 1);\\n        fish += dfs(grid, i, j - 1);\\n        return fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764213,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max = 0;\\n\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) continue;\\n\\n            max = Math.max(max, dfs(grid, i, j));\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nconst dfs = function(grid, r, c) {\\n    if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0;\\n    if(grid[r][c] === 0) return 0;\\n\\n    let fish = grid[r][c];\\n    grid[r][c] = 0;\\n\\n    return fish + dfs(grid, r - 1, c) + dfs(grid, r, c - 1) + dfs(grid, r + 1, c) + dfs(grid, r, c + 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max = 0;\\n\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) continue;\\n\\n            max = Math.max(max, dfs(grid, i, j));\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nconst dfs = function(grid, r, c) {\\n    if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0;\\n    if(grid[r][c] === 0) return 0;\\n\\n    let fish = grid[r][c];\\n    grid[r][c] = 0;\\n\\n    return fish + dfs(grid, r - 1, c) + dfs(grid, r, c - 1) + dfs(grid, r + 1, c) + dfs(grid, r, c + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760200,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum = 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] != 0) {\\n                    int res[] = new int[1];\\n                    catchFish(grid, i, j, res);\\n                    sum = Math.max(sum, res[0]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    private void catchFish(int[][] grid, int i, int j, int[] res) {\\n        if( i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        res[0] += grid[i][j];\\n        grid[i][j] = 0;\\n        catchFish(grid, i, j + 1, res);\\n        catchFish(grid, i, j - 1, res);\\n        catchFish(grid, i + 1, j, res);\\n        catchFish(grid, i - 1, j, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum = 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] != 0) {\\n                    int res[] = new int[1];\\n                    catchFish(grid, i, j, res);\\n                    sum = Math.max(sum, res[0]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    private void catchFish(int[][] grid, int i, int j, int[] res) {\\n        if( i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        res[0] += grid[i][j];\\n        grid[i][j] = 0;\\n        catchFish(grid, i, j + 1, res);\\n        catchFish(grid, i, j - 1, res);\\n        catchFish(grid, i + 1, j, res);\\n        catchFish(grid, i - 1, j, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748345,
                "title": "python-c-numislands-variant-dfs",
                "content": "\\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n:\\n                return 0\\n            if grid[i][j] == 0:\\n                return 0\\n\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n\\n            return val + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int res = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dfs(grid, i, j));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {\\n            return 0; \\n        }\\n\\n        if (grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        return val + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1)+ dfs(grid, i, j - 1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n:\\n                return 0\\n            if grid[i][j] == 0:\\n                return 0\\n\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n\\n            return val + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738696,
                "title": "typescript-solution-easy-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nfunction findMaxFish(grid: number[][]): number {\\n    const rows: number = grid.length;\\n    const columns: number = grid[0].length;\\n    let maxResult: number = 0;\\n    let visited: boolean[][] = grid.map(row=> row.map(column=>false));\\n    \\n    function dfs(row: number, column: number): number {\\n        if (row < 0 || row >= rows || column < 0 || column >= columns)\\n            return 0;\\n        if (visited[row][column])\\n            return 0;\\n        \\n        visited[row][column] = true;\\n        if (grid[row][column] == 0)\\n            return 0;\\n\\n        let result: number = grid[row][column];\\n        result += dfs(row-1, column);\\n        result += dfs(row+1, column);\\n        result += dfs(row, column-1);\\n        result += dfs(row, column+1);\\n        return result;\\n    }\\n\\n    for(let i=0; i<rows; i++) {\\n        for(let j=0; j<columns; j++) {\\n            if(grid[i][j] == 0)\\n                continue;\\n            const count: number = dfs(i, j);\\n            maxResult = Math.max(maxResult, count);\\n        }\\n    }\\n    return maxResult;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findMaxFish(grid: number[][]): number {\\n    const rows: number = grid.length;\\n    const columns: number = grid[0].length;\\n    let maxResult: number = 0;\\n    let visited: boolean[][] = grid.map(row=> row.map(column=>false));\\n    \\n    function dfs(row: number, column: number): number {\\n        if (row < 0 || row >= rows || column < 0 || column >= columns)\\n            return 0;\\n        if (visited[row][column])\\n            return 0;\\n        \\n        visited[row][column] = true;\\n        if (grid[row][column] == 0)\\n            return 0;\\n\\n        let result: number = grid[row][column];\\n        result += dfs(row-1, column);\\n        result += dfs(row+1, column);\\n        result += dfs(row, column-1);\\n        result += dfs(row, column+1);\\n        return result;\\n    }\\n\\n    for(let i=0; i<rows; i++) {\\n        for(let j=0; j<columns; j++) {\\n            if(grid[i][j] == 0)\\n                continue;\\n            const count: number = dfs(i, j);\\n            maxResult = Math.max(maxResult, count);\\n        }\\n    }\\n    return maxResult;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731123,
                "title": "easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731122,
                "title": "easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720607,
                "title": "98-beat-simple-dfs-bfs-solution",
                "content": "# DFS Code:\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, vector<pair<int,int>>& dir){\\n        int currFish = grid[x][y];\\n        grid[x][y] = 0;\\n        \\n        for(auto& d: dir){\\n            int nx = x + d.first;\\n            int ny = y + d.second;\\n\\n            if(nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] != 0){\\n                currFish += dfs(grid, nx, ny, dir);\\n            }\\n        }\\n        \\n        return currFish;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0){\\n                    int currFish = dfs(grid, i, j, dir);\\n                    ans = max(ans, currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# BFS Code:\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]!=0){\\n                    q.push({i,j});\\n                    int currFish = 0;\\n                    while(!q.empty()){\\n                        int x = q.front().first;\\n                        int y = q.front().second;\\n                        q.pop();\\n                        currFish += grid[x][y];\\n                        grid[x][y] = 0;\\n\\n                        for(auto& d: dir){\\n                            int nx = x + d.first;\\n                            int ny = y + d.second;\\n\\n                            if(nx>=0 && ny>=0 && nx<grid.size() && ny<grid[0].size() && grid[nx][ny]!=0){\\n                                q.push({nx,ny});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans,currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, vector<pair<int,int>>& dir){\\n        int currFish = grid[x][y];\\n        grid[x][y] = 0;\\n        \\n        for(auto& d: dir){\\n            int nx = x + d.first;\\n            int ny = y + d.second;\\n\\n            if(nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] != 0){\\n                currFish += dfs(grid, nx, ny, dir);\\n            }\\n        }\\n        \\n        return currFish;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0){\\n                    int currFish = dfs(grid, i, j, dir);\\n                    ans = max(ans, currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]!=0){\\n                    q.push({i,j});\\n                    int currFish = 0;\\n                    while(!q.empty()){\\n                        int x = q.front().first;\\n                        int y = q.front().second;\\n                        q.pop();\\n                        currFish += grid[x][y];\\n                        grid[x][y] = 0;\\n\\n                        for(auto& d: dir){\\n                            int nx = x + d.first;\\n                            int ny = y + d.second;\\n\\n                            if(nx>=0 && ny>=0 && nx<grid.size() && ny<grid[0].size() && grid[nx][ny]!=0){\\n                                q.push({nx,ny});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans,currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708698,
                "title": "easy-to-understand-optimised-dfs-without-making-any-visited-array-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$ \\nWorst case if we had to traverse the whole grid\\n\\n- Space complexity:\\n$$O(n*m)$$ \\nSince we will be accessing the grid so that too counts otherwise constant space\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int i, int j, int &count, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return;\\n        }\\n        count+=grid[i][j];\\n        grid[i][j]=0;\\n        dfs(i+1, j, count, grid);\\n        dfs(i, j+1, count, grid);\\n        dfs(i, j-1, count, grid);\\n        dfs(i-1, j, count, grid);\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count=0;\\n                    dfs(i, j, count, grid);\\n                    maxi=max(maxi, count);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, int &count, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return;\\n        }\\n        count+=grid[i][j];\\n        grid[i][j]=0;\\n        dfs(i+1, j, count, grid);\\n        dfs(i, j+1, count, grid);\\n        dfs(i, j-1, count, grid);\\n        dfs(i-1, j, count, grid);\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count=0;\\n                    dfs(i, j, count, grid);\\n                    maxi=max(maxi, count);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696630,
                "title": "python-8-line-and-cpp-exchange-function",
                "content": "\\n```\\nIf you don\\'t want to make the values > 0 to 0.\\n```\\n\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        grid[r][c] *= -1;\\n        return abs(grid[r][c]) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), sum = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    sum = max(sum, dfs(grid,r,c));\\n        return sum;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] < 1:\\n                return 0\\n            grid[r][c] *= -1\\n            return abs(grid[r][c]) + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\\n```\\nIf you want to make the values > 0 to 0 so badly.\\n\\nexchange in C++ 14 in utility header file.\\n\\nint a = 1, b = 2;         | Here exchange changing the value of a to b\\nint ans = exchange(a,b);  | and returning the old value of a.\\ncout << a << \" \" << b << \" \" << ans;\\n\\n        Output:\\n\\n2 2 1\\n   \\n```\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        return exchange(grid[r][c], 0) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    ans = max(ans, dfs(grid,r,c));\\n        return ans;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] == 0:\\n                return 0\\n            grid[r][c], temp = 0, grid[r][c]\\n            return temp + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\\n\\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(mn)\\n```\\n### If the post was helpful, an upvote will be appreciated.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nIf you don\\'t want to make the values > 0 to 0.\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        grid[r][c] *= -1;\\n        return abs(grid[r][c]) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), sum = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    sum = max(sum, dfs(grid,r,c));\\n        return sum;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] < 1:\\n                return 0\\n            grid[r][c] *= -1\\n            return abs(grid[r][c]) + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\n```\\nIf you want to make the values > 0 to 0 so badly.\\n\\nexchange in C++ 14 in utility header file.\\n\\nint a = 1, b = 2;         | Here exchange changing the value of a to b\\nint ans = exchange(a,b);  | and returning the old value of a.\\ncout << a << \" \" << b << \" \" << ans;\\n\\n        Output:\\n\\n2 2 1\\n   \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        return exchange(grid[r][c], 0) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    ans = max(ans, dfs(grid,r,c));\\n        return ans;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] == 0:\\n                return 0\\n            grid[r][c], temp = 0, grid[r][c]\\n            return temp + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(mn)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689962,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int m, n, mx;\\n    vector<int> dx{0, 0, 1, -1};\\n    vector<int> dy{1, -1, 0, 0};\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        m = grid.size(), n = grid[0].size(), mx = 0;\\n        for(int i = 0; i < m; i++)  \\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j])\\n                    mx = max(mx, helper(grid, i, j));\\n\\n        return mx;\\n    }\\n\\n    int helper(vector<vector<int>> &grid, int i, int j)\\n    {\\n        int tmp = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        for(int k = 0; k < dx.size(); k++)\\n        {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y])\\n                tmp += helper(grid, x, y);\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int m, n, mx;\\n    vector<int> dx{0, 0, 1, -1};\\n    vector<int> dy{1, -1, 0, 0};\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        m = grid.size(), n = grid[0].size(), mx = 0;\\n        for(int i = 0; i < m; i++)  \\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j])\\n                    mx = max(mx, helper(grid, i, j));\\n\\n        return mx;\\n    }\\n\\n    int helper(vector<vector<int>> &grid, int i, int j)\\n    {\\n        int tmp = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        for(int k = 0; k < dx.size(); k++)\\n        {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y])\\n                tmp += helper(grid, x, y);\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680690,
                "title": "standard-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int r, int c, int &count){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==0) return ;\\n        count+= grid[r][c];\\n        grid[r][c]=0;\\n        dfs(grid, r-1, c, count);\\n        dfs(grid, r+1, c, count);\\n        dfs(grid, r, c-1, count);\\n        dfs(grid, r, c+1, count);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n  =grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count = 0;\\n                    dfs(grid, i, j, count);\\n                    // grid[i][j] = 0;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int r, int c, int &count){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==0) return ;\\n        count+= grid[r][c];\\n        grid[r][c]=0;\\n        dfs(grid, r-1, c, count);\\n        dfs(grid, r+1, c, count);\\n        dfs(grid, r, c-1, count);\\n        dfs(grid, r, c+1, count);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n  =grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count = 0;\\n                    dfs(grid, i, j, count);\\n                    // grid[i][j] = 0;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677888,
                "title": "done-with-dfs-easy-solution-c",
                "content": "# Approach\\n* First traverse the matrix by 2 for loops and check if any element of matrix is not zero then call dfs function in which we are calculating sum of connected elements.....\\n* Then we make an isvalid function in which we checked that whether the index where we traverse is valid or within the bound or not....\\n* if yes then return true else false.....\\n* Then in dfs function we add elements in sum variable if connected and make that element 0 so that we can\\'t traverse it again and then call dfs recursively if element connected or valid....\\n* conditions in dfs are:-\\n    1. first we check for row+1 and col\\n    2. second we check for row-1 and col\\n    3. third we check for row and col+1\\n    4. last we check for row and col-1\\n* in last we return sum in dfs function.....\\n* at last in findMaxFish function we take the maximum value of sum among all and return the same.........\\n\\n---\\n\\n\\n- [Time complexity: $$O(MN)$$]()\\n\\n---\\n\\n\\n- [Space complexity:$$ O(1)$$]()\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]!=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid, int i, int j, int &sum)\\n    {\\n        sum+=grid[i][j];\\n        grid[i][j]=0;\\n        if(isvalid(grid, i+1, j))\\n        {\\n            dfs(grid, i+1, j, sum);\\n        }\\n        if(isvalid(grid, i-1, j))\\n        {\\n            dfs(grid, i-1, j, sum);\\n        }\\n        if(isvalid(grid, i, j+1))\\n        {\\n            dfs(grid, i, j+1, sum);\\n        }\\n        if(isvalid(grid, i, j-1))\\n        {\\n            dfs(grid, i, j-1, sum);\\n        }\\n        return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio;\\n        cin.tie(0);\\n        int m=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                int sum=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    int x = dfs(grid, i, j, sum);\\n                    m = max(m, x);\\n                }\\n            }\\n        }\\n        return m;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]!=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid, int i, int j, int &sum)\\n    {\\n        sum+=grid[i][j];\\n        grid[i][j]=0;\\n        if(isvalid(grid, i+1, j))\\n        {\\n            dfs(grid, i+1, j, sum);\\n        }\\n        if(isvalid(grid, i-1, j))\\n        {\\n            dfs(grid, i-1, j, sum);\\n        }\\n        if(isvalid(grid, i, j+1))\\n        {\\n            dfs(grid, i, j+1, sum);\\n        }\\n        if(isvalid(grid, i, j-1))\\n        {\\n            dfs(grid, i, j-1, sum);\\n        }\\n        return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio;\\n        cin.tie(0);\\n        int m=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                int sum=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    int x = dfs(grid, i, j, sum);\\n                    m = max(m, x);\\n                }\\n            }\\n        }\\n        return m;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677816,
                "title": "faster-c-dfs-easy-solution",
                "content": "# *Complexity*\\n- *Time & Space Complexity :*\\n```\\nO(mn)\\n```\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col)\\n    {\\n        if(row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size() && grid[row][col] != 0 && visit[row][col] == false)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void dfs_func(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col, int &temp)\\n    {\\n        if(!isValid(grid, visit, row, col))\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            visit[row][col] = true;\\n            temp += grid[row][col];\\n            if(isValid(grid, visit, row+1, col))\\n            {\\n                dfs_func(grid, visit, row+1, col, temp);\\n            }\\n            if(isValid(grid, visit, row-1, col))\\n            {\\n                dfs_func(grid, visit, row-1, col, temp);\\n            }\\n            if(isValid(grid, visit, row, col+1))\\n            {\\n                dfs_func(grid, visit, row, col+1, temp);\\n            }\\n            if(isValid(grid, visit, row, col-1))\\n            {\\n                dfs_func(grid, visit, row, col-1, temp);\\n            }\\n            return;\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int temp = 0, count = 0;\\n        vector<vector<bool>> visit(grid.size(), vector<bool> (grid[0].size(), false));\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] > 0 && visit[i][j] == false)\\n                {\\n                    temp = 0;\\n                    dfs_func(grid, visit, i, j, temp);\\n                    count = max(temp, count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***DO UPVOTE!*** \\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nO(mn)\\n```\n```\\nclass Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col)\\n    {\\n        if(row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size() && grid[row][col] != 0 && visit[row][col] == false)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void dfs_func(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col, int &temp)\\n    {\\n        if(!isValid(grid, visit, row, col))\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            visit[row][col] = true;\\n            temp += grid[row][col];\\n            if(isValid(grid, visit, row+1, col))\\n            {\\n                dfs_func(grid, visit, row+1, col, temp);\\n            }\\n            if(isValid(grid, visit, row-1, col))\\n            {\\n                dfs_func(grid, visit, row-1, col, temp);\\n            }\\n            if(isValid(grid, visit, row, col+1))\\n            {\\n                dfs_func(grid, visit, row, col+1, temp);\\n            }\\n            if(isValid(grid, visit, row, col-1))\\n            {\\n                dfs_func(grid, visit, row, col-1, temp);\\n            }\\n            return;\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int temp = 0, count = 0;\\n        vector<vector<bool>> visit(grid.size(), vector<bool> (grid[0].size(), false));\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] > 0 && visit[i][j] == false)\\n                {\\n                    temp = 0;\\n                    dfs_func(grid, visit, i, j, temp);\\n                    count = max(temp, count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669574,
                "title": "simple-bfs-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int i,int j,int &fishCaught,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n\\n        int newRows[]={-1,0,1,0};\\n        int newCols[]={0,1,0,-1};\\n        q.push({i,j});\\n        visited[i][j]=true;\\n\\n        // bfs to go in 4 direction \\n        while(!q.empty()){\\n\\n            int row = q.front().first;\\n            int col= q.front().second;\\n            q.pop();\\n            // Catching fish \\uD83D\\uDC1F\\uD83D\\uDC20\\uD83E\\uDD88\\uD83D\\uDC21\\n            fishCaught=fishCaught+grid[row][col];\\n\\n            for(int i=0;i<4;i++){\\n                int nRow = newRows[i] + row;\\n                int nCol = newCols[i] + col;\\n\\n                if(nRow>=0 && nRow<grid.size() && nCol>=0 && nCol<grid[0].size() && !visited[nRow][nCol] && grid[nRow][nCol]){\\n                    q.push({nRow,nCol});\\n                    visited[nRow][nCol]=true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int maxFish=0;\\n        int fishCaught=0;\\n        vector<vector<bool>> visited(rows,vector<bool>(cols,false));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                // check if there are any fishes \\n                // if not visited go fishing\\n                if(!visited[i][j] && grid[i][j]>0){\\n\\n                    bfs(i,j,fishCaught,visited,grid);\\n                    // to find max fishes a fisherman can catch\\n                    maxFish=max(fishCaught,maxFish);\\n                    fishCaught=0;\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int i,int j,int &fishCaught,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n\\n        int newRows[]={-1,0,1,0};\\n        int newCols[]={0,1,0,-1};\\n        q.push({i,j});\\n        visited[i][j]=true;\\n\\n        // bfs to go in 4 direction \\n        while(!q.empty()){\\n\\n            int row = q.front().first;\\n            int col= q.front().second;\\n            q.pop();\\n            // Catching fish \\uD83D\\uDC1F\\uD83D\\uDC20\\uD83E\\uDD88\\uD83D\\uDC21\\n            fishCaught=fishCaught+grid[row][col];\\n\\n            for(int i=0;i<4;i++){\\n                int nRow = newRows[i] + row;\\n                int nCol = newCols[i] + col;\\n\\n                if(nRow>=0 && nRow<grid.size() && nCol>=0 && nCol<grid[0].size() && !visited[nRow][nCol] && grid[nRow][nCol]){\\n                    q.push({nRow,nCol});\\n                    visited[nRow][nCol]=true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int maxFish=0;\\n        int fishCaught=0;\\n        vector<vector<bool>> visited(rows,vector<bool>(cols,false));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                // check if there are any fishes \\n                // if not visited go fishing\\n                if(!visited[i][j] && grid[i][j]>0){\\n\\n                    bfs(i,j,fishCaught,visited,grid);\\n                    // to find max fishes a fisherman can catch\\n                    maxFish=max(fishCaught,maxFish);\\n                    fishCaught=0;\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668537,
                "title": "unionfind",
                "content": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind dsu = new UnionFind(grid);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                \\n                for (int[] dir : dirs) {\\n                    int x = i + dir[0], y = j + dir[1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)\\n                        continue;\\n                    dsu.union(i, j, x, y);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m * n; i++) \\n            if (dsu.id[i] == i) ans = Math.max(ans, dsu.sum[i]);\\n\\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] id, sum, rank;\\n    int m, n;\\n\\n    public UnionFind(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        id = new int[m*n];\\n        sum = new int[m*n];\\n        rank = new int[m*n];\\n        for (int i = 0; i < m*n; i++) {\\n            id[i] = i; \\n            rank[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) \\n                sum[i * n + j] = grid[i][j];\\n        }\\n    }\\n\\n    public int find(int x) {\\n        int root = x;\\n        while (id[root] != root)\\n            root = id[root];\\n\\n        return root;\\n    }\\n\\n    public void union(int i, int j, int x, int y) {\\n        int rootX = find(i * n + j), rootY = find(x * n + y);\\n        if (rootX == rootY) return;\\n\\n        if (rank[rootX] >= rank[rootY]) {\\n            rank[rootX] += rank[rootY];\\n            rank[rootY] = 0;\\n            id[rootY] = rootX;\\n            sum[rootX] += sum[rootY];\\n        } else {\\n            rank[rootY] += rank[rootX];\\n            rank[rootX] = 0;\\n            id[rootX] = rootY;\\n            sum[rootY] += sum[rootX];\\n        }\\n \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind dsu = new UnionFind(grid);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                \\n                for (int[] dir : dirs) {\\n                    int x = i + dir[0], y = j + dir[1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)\\n                        continue;\\n                    dsu.union(i, j, x, y);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m * n; i++) \\n            if (dsu.id[i] == i) ans = Math.max(ans, dsu.sum[i]);\\n\\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] id, sum, rank;\\n    int m, n;\\n\\n    public UnionFind(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        id = new int[m*n];\\n        sum = new int[m*n];\\n        rank = new int[m*n];\\n        for (int i = 0; i < m*n; i++) {\\n            id[i] = i; \\n            rank[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) \\n                sum[i * n + j] = grid[i][j];\\n        }\\n    }\\n\\n    public int find(int x) {\\n        int root = x;\\n        while (id[root] != root)\\n            root = id[root];\\n\\n        return root;\\n    }\\n\\n    public void union(int i, int j, int x, int y) {\\n        int rootX = find(i * n + j), rootY = find(x * n + y);\\n        if (rootX == rootY) return;\\n\\n        if (rank[rootX] >= rank[rootY]) {\\n            rank[rootX] += rank[rootY];\\n            rank[rootY] = 0;\\n            id[rootY] = rootX;\\n            sum[rootX] += sum[rootY];\\n        } else {\\n            rank[rootY] += rank[rootX];\\n            rank[rootX] = 0;\\n            id[rootX] = rootY;\\n            sum[rootY] += sum[rootX];\\n        }\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667002,
                "title": "c-easy-solution",
                "content": "##### Solution 1: Depth First Search\\n```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        for(int row = 0; row < grid.GetLength(0); row++) {\\n            for(int col = 0; col < grid[row].Length; col++) {\\n                if(grid[row][col] != 0)\\n                    max_fish = Math.Max(max_fish, DFS(grid, row, col));\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int DFS(int[][] grid, int row, int col) {\\n        if(row < 0 || col < 0 || row >= grid.GetLength(0) || col >= grid[row].Length || grid[row][col] == 0)\\n            return 0;\\n\\n        var fish = grid[row][col];\\n        grid[row][col] = 0;\\n\\n        fish += DFS(grid, row + 1, col);\\n        fish += DFS(grid, row - 1, col);\\n        fish += DFS(grid, row, col + 1);\\n        fish += DFS(grid, row, col - 1);\\n\\n        return fish;\\n    }\\n}\\n```\\n\\n##### Solution 2: Union Find\\n```\\n\\npublic class Solution {\\n    int[] rank;\\n    int[] parent;\\n    \\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        var rowCount = grid.GetLength(0);\\n        var columnCount = grid[0].Length;\\n\\n        rank = new int[rowCount * columnCount];\\n        parent = new int[rowCount * columnCount];\\n        \\n        for(int row =  0; row < rowCount; row++) {\\n            for(int col = 0; col < columnCount; col++) {\\n                var idx = row * columnCount + col;\\n                parent[idx] = idx;\\n                rank[idx] = grid[row][col];\\n                max_fish = Math.Max(max_fish, rank[idx]);\\n            }\\n        }\\n\\n        for (int row = 0; row < rowCount; row++) {\\n            for (int col = 0; col < columnCount; col++) {\\n                if (grid[row][col] != 0) {\\n                    var idx = row * columnCount + col;\\n                    if(row < rowCount - 1 && grid[row + 1][col] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, (row + 1) * columnCount + col));\\n\\n                    if(col < columnCount - 1 && grid[row][col + 1] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, row * columnCount + (col + 1)));\\n                }\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int FindParent(int node) {\\n        if (parent[node] == node)\\n            return parent[node];\\n\\n        parent[node] = FindParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    private int Union(int node1, int node2) {\\n        var parent1 = FindParent(node1);\\n        var parent2 = FindParent(node2);\\n\\n        if(parent1 != parent2) {\\n            if (parent1 < parent2) {\\n                rank[parent1] += rank[parent2];\\n                parent[parent2] = parent1;\\n                return rank[parent1];\\n            }\\n            else {\\n                rank[parent2] += rank[parent1];\\n                parent[parent1] = parent2;\\n                return rank[parent2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        for(int row = 0; row < grid.GetLength(0); row++) {\\n            for(int col = 0; col < grid[row].Length; col++) {\\n                if(grid[row][col] != 0)\\n                    max_fish = Math.Max(max_fish, DFS(grid, row, col));\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int DFS(int[][] grid, int row, int col) {\\n        if(row < 0 || col < 0 || row >= grid.GetLength(0) || col >= grid[row].Length || grid[row][col] == 0)\\n            return 0;\\n\\n        var fish = grid[row][col];\\n        grid[row][col] = 0;\\n\\n        fish += DFS(grid, row + 1, col);\\n        fish += DFS(grid, row - 1, col);\\n        fish += DFS(grid, row, col + 1);\\n        fish += DFS(grid, row, col - 1);\\n\\n        return fish;\\n    }\\n}\\n```\n```\\n\\npublic class Solution {\\n    int[] rank;\\n    int[] parent;\\n    \\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        var rowCount = grid.GetLength(0);\\n        var columnCount = grid[0].Length;\\n\\n        rank = new int[rowCount * columnCount];\\n        parent = new int[rowCount * columnCount];\\n        \\n        for(int row =  0; row < rowCount; row++) {\\n            for(int col = 0; col < columnCount; col++) {\\n                var idx = row * columnCount + col;\\n                parent[idx] = idx;\\n                rank[idx] = grid[row][col];\\n                max_fish = Math.Max(max_fish, rank[idx]);\\n            }\\n        }\\n\\n        for (int row = 0; row < rowCount; row++) {\\n            for (int col = 0; col < columnCount; col++) {\\n                if (grid[row][col] != 0) {\\n                    var idx = row * columnCount + col;\\n                    if(row < rowCount - 1 && grid[row + 1][col] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, (row + 1) * columnCount + col));\\n\\n                    if(col < columnCount - 1 && grid[row][col + 1] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, row * columnCount + (col + 1)));\\n                }\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int FindParent(int node) {\\n        if (parent[node] == node)\\n            return parent[node];\\n\\n        parent[node] = FindParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    private int Union(int node1, int node2) {\\n        var parent1 = FindParent(node1);\\n        var parent2 = FindParent(node2);\\n\\n        if(parent1 != parent2) {\\n            if (parent1 < parent2) {\\n                rank[parent1] += rank[parent2];\\n                parent[parent2] = parent1;\\n                return rank[parent1];\\n            }\\n            else {\\n                rank[parent2] += rank[parent1];\\n                parent[parent1] = parent2;\\n                return rank[parent2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665865,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<int>> &grid,int x,int y,int *curr)\\n    {\\n        if(x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y]==0)\\n        {\\n            return;\\n        }\\n\\n        *curr+=grid[x][y];\\n        grid[x][y]=0;\\n\\n        dfs(grid,x+1,y,curr);\\n        dfs(grid,x-1,y,curr);\\n        dfs(grid,x,y+1,curr);\\n        dfs(grid,x,y-1,curr);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int ans;\\n        ans=0;\\n\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int curr=0;\\n                    dfs(grid,i,j,&curr);\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<int>> &grid,int x,int y,int *curr)\\n    {\\n        if(x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y]==0)\\n        {\\n            return;\\n        }\\n\\n        *curr+=grid[x][y];\\n        grid[x][y]=0;\\n\\n        dfs(grid,x+1,y,curr);\\n        dfs(grid,x-1,y,curr);\\n        dfs(grid,x,y+1,curr);\\n        dfs(grid,x,y-1,curr);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int ans;\\n        ans=0;\\n\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int curr=0;\\n                    dfs(grid,i,j,&curr);\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663430,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r , int c , vector<vector<int>>& grid , vector<vector<int>>& vis , vector<int> delRow , vector<int> delCol , int m , int n , int& sum){\\n        sum += grid[r][c];\\n        vis[r][c] = 1;\\n\\n        for (int i=0 ; i<4 ; i++){\\n            int nr = r + delRow[i];\\n            int nc = c + delCol[i];\\n\\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && grid[nr][nc]>0){\\n                dfs(nr , nc , grid, vis , delRow , delCol , m , n , sum);\\n            }\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=-1e9;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vector<int> delRow = {-1 , 0 , 1 , 0};\\n        vector<int> delCol = {0 , 1 , 0 , -1};\\n\\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                int sum = 0;\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    dfs(i , j , grid , vis , delRow , delCol , m , n , sum);\\n                    maxi = max(maxi , sum);\\n                }\\n            }\\n        }\\n        if (maxi < 0)\\n            return 0;\\n            \\n        return maxi;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r , int c , vector<vector<int>>& grid , vector<vector<int>>& vis , vector<int> delRow , vector<int> delCol , int m , int n , int& sum){\\n        sum += grid[r][c];\\n        vis[r][c] = 1;\\n\\n        for (int i=0 ; i<4 ; i++){\\n            int nr = r + delRow[i];\\n            int nc = c + delCol[i];\\n\\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && grid[nr][nc]>0){\\n                dfs(nr , nc , grid, vis , delRow , delCol , m , n , sum);\\n            }\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=-1e9;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vector<int> delRow = {-1 , 0 , 1 , 0};\\n        vector<int> delCol = {0 , 1 , 0 , -1};\\n\\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                int sum = 0;\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    dfs(i , j , grid , vis , delRow , delCol , m , n , sum);\\n                    maxi = max(maxi , sum);\\n                }\\n            }\\n        }\\n        if (maxi < 0)\\n            return 0;\\n            \\n        return maxi;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662617,
                "title": "recusion-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n   recursion approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  static int sum;\\n    public static void util(int grid[][],int row,int col){\\n\\n        if(row<0 ||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]==0){\\n            return ;\\n        }\\n        sum+=grid[row][col];\\n        grid[row][col]=0;\\n       //checking fishes all four direction of grid\\n        util(grid,row+1,col);\\n        util(grid,row-1,col);\\n        util(grid,row,col+1);\\n        util(grid,row,col-1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int  max=0;\\n       \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    this.sum=0;\\n                    util(grid,i,j);\\n                    max=Math.max(max,this.sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  static int sum;\\n    public static void util(int grid[][],int row,int col){\\n\\n        if(row<0 ||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]==0){\\n            return ;\\n        }\\n        sum+=grid[row][col];\\n        grid[row][col]=0;\\n       //checking fishes all four direction of grid\\n        util(grid,row+1,col);\\n        util(grid,row-1,col);\\n        util(grid,row,col+1);\\n        util(grid,row,col-1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int  max=0;\\n       \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    this.sum=0;\\n                    util(grid,i,j);\\n                    max=Math.max(max,this.sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661397,
                "title": "bfs-dfs-both-java-code",
                "content": "class pair{\\n    int first;\\n    int second;\\n    pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] vis=new int[n][m];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0){\\n                    max=Math.max(bfs(i,j,grid,vis),max);\\n                }\\n            }\\n        }\\n        if(max>=0){\\n             return max;\\n        }\\n        return 0;\\n    }\\n    // public int dfs(int i,int j,int[][] grid,int[][] vis){\\n    //     if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]!=0 && vis[i][j]==0){\\n    //         vis[i][j]=1;\\n    //         return grid[i][j]+dfs(i+1,j,grid,vis)+dfs(i,j+1,grid,vis)+dfs(i-1,j,grid,vis)+dfs(i,j-1,grid,vis);\\n    //     }\\n    //     return 0;\\n    //     }\\n    public int bfs(int i,int j,int[][] grid,int[][]vis){\\n        vis[i][j]=1;\\n        Queue<pair> q=new LinkedList<>();\\n        int sum=grid[i][j];\\n        q.add(new pair(i,j));\\n        int dir[]={0,-1,0,1,0};\\n        while(!q.isEmpty()){\\n            int x=q.peek().first;\\n            int y=q.peek().second;\\n            q.remove();\\n            for(int k=0;k<4;k++){\\n                int nrow=x+dir[k];\\n                int ncol=y+dir[k+1];\\n            if(nrow>=0 && ncol>=0 && nrow<grid.length && ncol<grid[0].length && grid[nrow][ncol]!=0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                sum+=grid[nrow][ncol];\\n                q.add(new pair(nrow,ncol));\\n            }\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] vis=new int[n][m];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0){\\n                    max=Math.max(bfs(i,j,grid,vis),max);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3660334,
                "title": "simulated-c-dsu-dfs",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m*n * m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n + m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<bool>>&visited, vector<vector<int>>&grid)\\n    {\\n        int ans=grid[i][j];\\n        visited[i][j]=true;\\n        if(i+1<grid.size() && !visited[i+1][j] && grid[i+1][j]!=0) ans = ans + dfs(i+1,j,visited,grid);\\n        if(j+1<grid[0].size() && !visited[i][j+1] && grid[i][j+1]!=0) ans = ans + dfs(i,j+1,visited,grid);\\n        if(i-1>=0 && !visited[i-1][j] && grid[i-1][j]!=0) ans = ans + dfs(i-1,j,visited,grid);\\n        if(j-1>=0 && !visited[i][j-1] && grid[i][j-1]!=0) ans = ans + dfs(i,j-1,visited,grid);\\n        return ans;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int ans=0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!=0)\\n                {\\n                    ans=max(ans,dfs(i,j,visited,grid));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(m*n *)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n )$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findparent(int node, vector<pair<int,int>>&parent)\\n    {\\n        if(node==parent[node].first) return node;\\n        return parent[node].first=findparent(parent[node].first,parent);\\n    }\\n    void Union(int u, int v, vector<pair<int,int>>&parent, vector<int>&rank)\\n    {\\n        int pu = findparent(u,parent);\\n        int pv = findparent(v, parent);\\n        if(pu==pv) return;\\n        else if(rank[pu]<rank[pv]) \\n        {\\n            parent[pu].first = pv;\\n            parent[pv].second +=parent[pu].second;\\n        }\\n        else if(rank[pv]<rank[pu]) \\n        {\\n            parent[pv].first =pu;\\n            parent[pu].second +=parent[pv].second;\\n        }\\n        else\\n        {\\n            parent[pv].first=pu;\\n            parent[pu].second +=parent[pv].second;\\n            rank[pu]++;\\n        }\\n    }\\n    bool isvalid(int i, int j, int m, int n)\\n    {\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n         std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int,int>>parent(m*n);\\n        vector<int>rank(m*n,0);\\n        for(int i =0;i<(m*n);i++)\\n        {\\n            int a = i/n;\\n            int b = i%n;\\n            parent[i]={i,grid[a][b]};\\n        }\\n        for(int a=0;a<(m*n);a++)\\n        {\\n            int i  = a/n;\\n            int j = a%n;\\n            if(grid[i][j]!=0)\\n            {\\n                if(isvalid(i+1,j,m,n) && grid[i+1][j]!=0)\\n                {\\n                    int b = (i+1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i-1,j,m,n) && grid[i-1][j]!=0)\\n                {\\n                    int b = (i-1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j+1,m,n) && grid[i][j+1]!=0)\\n                {\\n                    int b = (i)*n+(j+1);\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j-1,m,n) && grid[i][j-1]!=0)\\n                {\\n                    int b = (i)*n+(j-1);\\n                    Union(a,b,parent, rank);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i =0;i<parent.size();i++)\\n        {\\n            ans=max(ans,parent[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<bool>>&visited, vector<vector<int>>&grid)\\n    {\\n        int ans=grid[i][j];\\n        visited[i][j]=true;\\n        if(i+1<grid.size() && !visited[i+1][j] && grid[i+1][j]!=0) ans = ans + dfs(i+1,j,visited,grid);\\n        if(j+1<grid[0].size() && !visited[i][j+1] && grid[i][j+1]!=0) ans = ans + dfs(i,j+1,visited,grid);\\n        if(i-1>=0 && !visited[i-1][j] && grid[i-1][j]!=0) ans = ans + dfs(i-1,j,visited,grid);\\n        if(j-1>=0 && !visited[i][j-1] && grid[i][j-1]!=0) ans = ans + dfs(i,j-1,visited,grid);\\n        return ans;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int ans=0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!=0)\\n                {\\n                    ans=max(ans,dfs(i,j,visited,grid));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findparent(int node, vector<pair<int,int>>&parent)\\n    {\\n        if(node==parent[node].first) return node;\\n        return parent[node].first=findparent(parent[node].first,parent);\\n    }\\n    void Union(int u, int v, vector<pair<int,int>>&parent, vector<int>&rank)\\n    {\\n        int pu = findparent(u,parent);\\n        int pv = findparent(v, parent);\\n        if(pu==pv) return;\\n        else if(rank[pu]<rank[pv]) \\n        {\\n            parent[pu].first = pv;\\n            parent[pv].second +=parent[pu].second;\\n        }\\n        else if(rank[pv]<rank[pu]) \\n        {\\n            parent[pv].first =pu;\\n            parent[pu].second +=parent[pv].second;\\n        }\\n        else\\n        {\\n            parent[pv].first=pu;\\n            parent[pu].second +=parent[pv].second;\\n            rank[pu]++;\\n        }\\n    }\\n    bool isvalid(int i, int j, int m, int n)\\n    {\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n         std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int,int>>parent(m*n);\\n        vector<int>rank(m*n,0);\\n        for(int i =0;i<(m*n);i++)\\n        {\\n            int a = i/n;\\n            int b = i%n;\\n            parent[i]={i,grid[a][b]};\\n        }\\n        for(int a=0;a<(m*n);a++)\\n        {\\n            int i  = a/n;\\n            int j = a%n;\\n            if(grid[i][j]!=0)\\n            {\\n                if(isvalid(i+1,j,m,n) && grid[i+1][j]!=0)\\n                {\\n                    int b = (i+1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i-1,j,m,n) && grid[i-1][j]!=0)\\n                {\\n                    int b = (i-1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j+1,m,n) && grid[i][j+1]!=0)\\n                {\\n                    int b = (i)*n+(j+1);\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j-1,m,n) && grid[i][j-1]!=0)\\n                {\\n                    int b = (i)*n+(j-1);\\n                    Union(a,b,parent, rank);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i =0;i<parent.size();i++)\\n        {\\n            ans=max(ans,parent[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3657185,
                "title": "c-easy-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int bfs(int row,int col,vector<vector<int>>&grid,vector<vector<int>>&visited)\\n    {\\n        int count =0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n        int del_row[]= {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n\\n            int ro = q.front().first;\\n            int cl = q.front().second;\\n\\n            \\n            count +=grid[ro][cl];\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n\\n                int ne_row = ro+del_row[i];\\n                int ne_col = cl+del_col[i];\\n                if(ne_row<m && ne_row>=0 && ne_col <n && ne_col>=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]!=0)\\n                {\\n                    \\n                    visited[ne_row][ne_col]=1;\\n                    q.push({ne_row,ne_col});\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int>fishes;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!= 0)\\n                {\\n\\n                    fishes.push_back(bfs(i,j,grid,visited));\\n                }\\n            }\\n        }\\n\\n        \\n        if(fishes.size()>0)\\n        {\\n            int max_fish=fishes[0];\\n            for(int i=0;i<fishes.size();i++)\\n            {\\n                if(fishes[i]>max_fish)\\n                {\\n                    max_fish= fishes[i];\\n                }\\n            }\\n            return max_fish;\\n        }\\n        return 0;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bfs(int row,int col,vector<vector<int>>&grid,vector<vector<int>>&visited)\\n    {\\n        int count =0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n        int del_row[]= {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n\\n            int ro = q.front().first;\\n            int cl = q.front().second;\\n\\n            \\n            count +=grid[ro][cl];\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n\\n                int ne_row = ro+del_row[i];\\n                int ne_col = cl+del_col[i];\\n                if(ne_row<m && ne_row>=0 && ne_col <n && ne_col>=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]!=0)\\n                {\\n                    \\n                    visited[ne_row][ne_col]=1;\\n                    q.push({ne_row,ne_col});\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int>fishes;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!= 0)\\n                {\\n\\n                    fishes.push_back(bfs(i,j,grid,visited));\\n                }\\n            }\\n        }\\n\\n        \\n        if(fishes.size()>0)\\n        {\\n            int max_fish=fishes[0];\\n            for(int i=0;i<fishes.size();i++)\\n            {\\n                if(fishes[i]>max_fish)\\n                {\\n                    max_fish= fishes[i];\\n                }\\n            }\\n            return max_fish;\\n        }\\n        return 0;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649008,
                "title": "maximum-number-of-fish-in-a-grid-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644249,
                "title": "dfs-approach-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is similar to \"Max Area of Island\" question with oneline variation.\\nhttps://leetcode.com/problems/max-area-of-island/\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// it will store the answer.\\nint ans=0;\\nvoid dfs(int row,int col,int&fish,vector<vector<int>>&visited,vector<vector<int>>&grid)\\n    {\\n\\n        // variation.\\n        fish+= grid[row][col];\\n\\n        visited[row][col]=1;\\n       \\n\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n\\n            if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && !visited[nrow][ncol] &&grid[nrow][ncol])\\n            {               \\n                dfs(nrow,ncol,fish,visited,grid);            \\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j])\\n                {\\n                    int fish=0;\\n                    dfs(i,j,fish,visited,grid);\\n\\n                    // store the max answer.\\n                    ans = max(ans,fish);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// it will store the answer.\\nint ans=0;\\nvoid dfs(int row,int col,int&fish,vector<vector<int>>&visited,vector<vector<int>>&grid)\\n    {\\n\\n        // variation.\\n        fish+= grid[row][col];\\n\\n        visited[row][col]=1;\\n       \\n\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n\\n            if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && !visited[nrow][ncol] &&grid[nrow][ncol])\\n            {               \\n                dfs(nrow,ncol,fish,visited,grid);            \\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j])\\n                {\\n                    int fish=0;\\n                    dfs(i,j,fish,visited,grid);\\n\\n                    // store the max answer.\\n                    ans = max(ans,fish);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636773,
                "title": "golang-dfs-simple",
                "content": "# Code\\n```\\nfunc findMaxFish(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var res int\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if grid[i][j] != 0 {\\n        res = max(res, dfs(grid, i, j))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc dfs(grid [][]int, row, col int) int {\\n  res := grid[row][col]\\n  grid[row][col] = 0\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {0, 1}, {1, 0}}\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] > 0 {\\n      res += dfs(grid, x, y)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc findMaxFish(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var res int\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if grid[i][j] != 0 {\\n        res = max(res, dfs(grid, i, j))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc dfs(grid [][]int, row, col int) int {\\n  res := grid[row][col]\\n  grid[row][col] = 0\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {0, 1}, {1, 0}}\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] > 0 {\\n      res += dfs(grid, x, y)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636025,
                "title": "c-dfs-graph-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &count){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]==0)\\n    return ;\\n    visited[i][j] = 1;\\n    count += grid[i][j];\\n    \\n    dfs(grid, visited, i+1, j, count);\\n    dfs(grid, visited, i-1, j, count);\\n    dfs(grid, visited, i, j+1, count);\\n    dfs(grid, visited, i, j-1, count);\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        vector<vector<int>> visited(n, vector<int> (m, 0));\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n        \\n                int count = 0;\\n                if(!visited[i][j] && grid[i][j]>0)\\n                dfs(grid, visited, i, j, count);\\n                ans = max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &count){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]==0)\\n    return ;\\n    visited[i][j] = 1;\\n    count += grid[i][j];\\n    \\n    dfs(grid, visited, i+1, j, count);\\n    dfs(grid, visited, i-1, j, count);\\n    dfs(grid, visited, i, j+1, count);\\n    dfs(grid, visited, i, j-1, count);\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        vector<vector<int>> visited(n, vector<int> (m, 0));\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n        \\n                int count = 0;\\n                if(!visited[i][j] && grid[i][j]>0)\\n                dfs(grid, visited, i, j, count);\\n                ans = max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635164,
                "title": "java-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int sum;\\n    public int findMaxFish(int[][] grid) {\\n        sum = 0;\\n        int max = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                dfs(grid,i,j);\\n                max = Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){\\n            return;\\n        }\\n         sum = sum + grid[i][j];\\n         grid[i][j]=0;\\n         dfs(grid,i+1,j);\\n         dfs(grid,i-1,j);\\n         dfs(grid,i,j+1);\\n         dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int sum;\\n    public int findMaxFish(int[][] grid) {\\n        sum = 0;\\n        int max = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                dfs(grid,i,j);\\n                max = Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){\\n            return;\\n        }\\n         sum = sum + grid[i][j];\\n         grid[i][j]=0;\\n         dfs(grid,i+1,j);\\n         dfs(grid,i-1,j);\\n         dfs(grid,i,j+1);\\n         dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620887,
                "title": "easy-dfs-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private int dfs(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n\\n        grid[i][j] = 0;\\n\\n        val += dfs(grid, i+1, j);\\n        val += dfs(grid, i, j+1);\\n        val += dfs(grid, i-1, j);\\n        val += dfs(grid, i, j-1);\\n\\n        return val;\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0){\\n                    ans = Math.max(ans,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int dfs(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n\\n        grid[i][j] = 0;\\n\\n        val += dfs(grid, i+1, j);\\n        val += dfs(grid, i, j+1);\\n        val += dfs(grid, i-1, j);\\n        val += dfs(grid, i, j-1);\\n\\n        return val;\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0){\\n                    ans = Math.max(ans,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620603,
                "title": "java-dfs-solution-using-striver-concept-visited-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int sum;\\n    public void dfs(int grid[][],int row,int col,int vis[][]){\\n        sum+=grid[row][col];\\n        vis[row][col]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int r=row+drow[i];\\n            int c=col+dcol[i];\\n\\n            if(r>=0&&r<grid.length&&c>=0&&c<grid[0].length&&grid[r][c]!=0&&vis[r][c]==0){\\n                dfs(grid,r,c,vis);\\n            }\\n        }\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0 && vis[i][j]==0){\\n                   sum=0;  \\n                  dfs(grid,i,j,vis);\\n                  max=Math.max(sum,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int sum;\\n    public void dfs(int grid[][],int row,int col,int vis[][]){\\n        sum+=grid[row][col];\\n        vis[row][col]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int r=row+drow[i];\\n            int c=col+dcol[i];\\n\\n            if(r>=0&&r<grid.length&&c>=0&&c<grid[0].length&&grid[r][c]!=0&&vis[r][c]==0){\\n                dfs(grid,r,c,vis);\\n            }\\n        }\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0 && vis[i][j]==0){\\n                   sum=0;  \\n                  dfs(grid,i,j,vis);\\n                  max=Math.max(sum,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620196,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\ntypedef struct\\n{\\n    int **grid;\\n    int x;\\n    int y;\\n    int **visited;\\n}stGrid;\\n\\nvoid recrusion(stGrid *field,int cur_x, int cur_y, int *cur_greb, int *maxFish)\\n{\\n    if((cur_x < 0 || cur_x >= field->x) || (cur_y < 0 || cur_y >= field->y) || \\n                field->grid[cur_y][cur_x] == 0 || field->visited[cur_y][cur_x])\\n    {\\n        *maxFish = (*cur_greb>*maxFish)?(*cur_greb):(*maxFish);\\n    }\\n    else\\n    {\\n        if(field->visited[cur_y][cur_x] != 1)\\n        {\\n            *cur_greb += field->grid[cur_y][cur_x];\\n        }\\n        field->visited[cur_y][cur_x] = 1;\\n        recrusion(field,cur_x + 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y - 1, cur_greb, maxFish);\\n        recrusion(field,cur_x - 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y + 1, cur_greb, maxFish);\\n    }\\n}\\n\\n\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n\\n    stGrid field;\\n    field.grid = grid;\\n    field.y = gridSize;\\n    field.x = *gridColSize;\\n    field.visited = (int**)calloc(field.y, sizeof(int*)); \\n    for(int i = 0; i < field.y; i++)\\n    {\\n        field.visited[i] = (int*)calloc(field.x, sizeof(int));\\n    }\\n\\n    int maxFish = 0;\\n    int temp_Fish = 0;\\n    for(int row = 0; row < field.y ; row++)\\n    {\\n        for(int col = 0; col < field.x; col++)\\n        {\\n            recrusion(&field, col, row, &temp_Fish, &maxFish);\\n            temp_Fish = 0;\\n        }\\n    }\\n\\n    return maxFish;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\ntypedef struct\\n{\\n    int **grid;\\n    int x;\\n    int y;\\n    int **visited;\\n}stGrid;\\n\\nvoid recrusion(stGrid *field,int cur_x, int cur_y, int *cur_greb, int *maxFish)\\n{\\n    if((cur_x < 0 || cur_x >= field->x) || (cur_y < 0 || cur_y >= field->y) || \\n                field->grid[cur_y][cur_x] == 0 || field->visited[cur_y][cur_x])\\n    {\\n        *maxFish = (*cur_greb>*maxFish)?(*cur_greb):(*maxFish);\\n    }\\n    else\\n    {\\n        if(field->visited[cur_y][cur_x] != 1)\\n        {\\n            *cur_greb += field->grid[cur_y][cur_x];\\n        }\\n        field->visited[cur_y][cur_x] = 1;\\n        recrusion(field,cur_x + 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y - 1, cur_greb, maxFish);\\n        recrusion(field,cur_x - 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y + 1, cur_greb, maxFish);\\n    }\\n}\\n\\n\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n\\n    stGrid field;\\n    field.grid = grid;\\n    field.y = gridSize;\\n    field.x = *gridColSize;\\n    field.visited = (int**)calloc(field.y, sizeof(int*)); \\n    for(int i = 0; i < field.y; i++)\\n    {\\n        field.visited[i] = (int*)calloc(field.x, sizeof(int));\\n    }\\n\\n    int maxFish = 0;\\n    int temp_Fish = 0;\\n    for(int row = 0; row < field.y ; row++)\\n    {\\n        for(int col = 0; col < field.x; col++)\\n        {\\n            recrusion(&field, col, row, &temp_Fish, &maxFish);\\n            temp_Fish = 0;\\n        }\\n    }\\n\\n    return maxFish;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3618242,
                "title": "java-5ms-99-dfs-and-clean-code",
                "content": "# Approach: DFS\\n1. For i =0..n, j = 0..m, if current cell is water, jump on it and try catching the max nr of fish. Keep track of max number of fish\\n2. Catching fish: recursive function that takes, grid, i, j and returns the max number of fish\\n    - if i,j outside the bounds or current cell is land, return 0\\n    - else add current cell to a return answer, set current cell to 0 and try fishing in the 4 directions, adding their values to return answer.\\n    - return the answer for this function call.  \\n3. Method #2 will traverse all linked water calls, catch their fish and marking the cells with 0.\\n4. #1 will then ignore these already fished cells.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    maxFish = Math.max(maxFish, catchFish(grid, i, j));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int catchFish(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += catchFish(grid, i-1, j) + catchFish(grid, i, j+1) + catchFish(grid, i+1, j) + catchFish(grid, i, j-1);\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    maxFish = Math.max(maxFish, catchFish(grid, i, j));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int catchFish(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += catchFish(grid, i-1, j) + catchFish(grid, i, j+1) + catchFish(grid, i+1, j) + catchFish(grid, i, j-1);\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607455,
                "title": "simple-dfs-c",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis){\\n   if(vis[i][j]==1 || grid[i][j]<=0)return 0;\\n   int ans=grid[i][j];\\n   vis[i][j]=1;\\n   if(i>0)ans+=dfs(grid,i-1,j,vis);\\n   if(j>0)ans+=dfs(grid,i,j-1,vis);\\n   if(i<grid.size()-1)ans+=dfs(grid,i+1,j,vis);\\n   if(j<grid[0].size()-1)ans+=dfs(grid,i,j+1,vis);\\n   return ans;\\n   }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=0;\\n        for(int i=0;i<grid.size();i++){\\n            vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n            for(int j=0;j<grid[0].size();j++){\\n            if(grid[i][j]>0 ){\\n            maxi=max(maxi,dfs(grid,i,j,vis));\\n           // cout<<maxi<<\" \"<<i<<\" \"<<j<<\"\\\\n\";\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis){\\n   if(vis[i][j]==1 || grid[i][j]<=0)return 0;\\n   int ans=grid[i][j];\\n   vis[i][j]=1;\\n   if(i>0)ans+=dfs(grid,i-1,j,vis);\\n   if(j>0)ans+=dfs(grid,i,j-1,vis);\\n   if(i<grid.size()-1)ans+=dfs(grid,i+1,j,vis);\\n   if(j<grid[0].size()-1)ans+=dfs(grid,i,j+1,vis);\\n   return ans;\\n   }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=0;\\n        for(int i=0;i<grid.size();i++){\\n            vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n            for(int j=0;j<grid[0].size();j++){\\n            if(grid[i][j]>0 ){\\n            maxi=max(maxi,dfs(grid,i,j,vis));\\n           // cout<<maxi<<\" \"<<i<<\" \"<<j<<\"\\\\n\";\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3602081,
                "title": "most-intuitive-c-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int di[4] = {1, -1, 0, 0}, dj[4] = {0, 0, 1, -1};\\n    \\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid[0].size() &&\\n               grid[i][j] != 0;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid) {\\n        int res = grid[i][j];\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) res += dfs(r, c, grid);\\n        }\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int cnt = dfs(i, j, grid);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int di[4] = {1, -1, 0, 0}, dj[4] = {0, 0, 1, -1};\\n    \\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid[0].size() &&\\n               grid[i][j] != 0;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid) {\\n        int res = grid[i][j];\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) res += dfs(r, c, grid);\\n        }\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int cnt = dfs(i, j, grid);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593140,
                "title": "java-solution-simple-dfs-99-fast",
                "content": "# Approach\\n**DFS** through every non-zero cell, and add up all the numbers found on the way. Also, mark all the cells as 0, so they won\\'t be parsed again.\\nEvery DFS dive will get back a number, that will be the maximum number of fishes caught starting from current cell, as well as from any cell that was visited.No need to do it again from every cell.\\nBiggest number returned among all dfs dives will be the answer.\\n\\n# Complexity\\nLet rows and columns be denoted by ```row```, ```col```\\n- Time complexity:\\nAt worst case parsing of every cell in the grid:$$O(row*col)$$\\n**Total: $$O(row * col)$$**\\n\\n- Space complexity:\\nExcluding input: **$$O(1)$$**\\nIncluding input: **$$O(row * col)$$**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int row = grid.length,col = grid[0].length;\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j] == 0) continue;\\n                int count = dfs(grid,i,j,row,col);\\n                max = Math.max(max,count);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    int dfs(int[][] arr,int i,int j,int row,int col){\\n        if(i<0 || j<0 || i>=row || j>=col) return 0;\\n        if(arr[i][j] == 0) return 0;\\n        int count = arr[i][j];\\n        arr[i][j] = 0;\\n\\n        count+=dfs(arr,i+1,j,row,col);\\n        count+=dfs(arr,i,j+1,row,col);\\n        count+=dfs(arr,i-1,j,row,col);\\n        count+=dfs(arr,i,j-1,row,col);\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```row```\n```col```\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int row = grid.length,col = grid[0].length;\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j] == 0) continue;\\n                int count = dfs(grid,i,j,row,col);\\n                max = Math.max(max,count);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    int dfs(int[][] arr,int i,int j,int row,int col){\\n        if(i<0 || j<0 || i>=row || j>=col) return 0;\\n        if(arr[i][j] == 0) return 0;\\n        int count = arr[i][j];\\n        arr[i][j] = 0;\\n\\n        count+=dfs(arr,i+1,j,row,col);\\n        count+=dfs(arr,i,j+1,row,col);\\n        count+=dfs(arr,i-1,j,row,col);\\n        count+=dfs(arr,i,j-1,row,col);\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877160,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877329,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1878212,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877308,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877396,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877159,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877341,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1921099,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1894798,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877371,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877160,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877329,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1878212,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877308,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877396,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877159,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877341,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1921099,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1894798,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877371,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            }
        ]
    }
]