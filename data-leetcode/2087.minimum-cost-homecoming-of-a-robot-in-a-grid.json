[
    {
        "title": "Minimum Cost Homecoming of a Robot in a Grid",
        "question_content": "There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol).\nThe robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n.\n\n\tIf the robot moves up or down into a cell whose row is r, then this move costs rowCosts[r].\n\tIf the robot moves left or right into a cell whose column is c, then this move costs colCosts[c].\n\nReturn the minimum total cost for this robot to return home.\n&nbsp;\nExample 1:\n\nInput: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\nOutput: 18\nExplanation: One optimal path is that:\nStarting from (1, 0)\n-> It goes down to (2, 0). This move costs rowCosts[2] = 3.\n-> It goes right to (2, 1). This move costs colCosts[1] = 2.\n-> It goes right to (2, 2). This move costs colCosts[2] = 6.\n-> It goes right to (2, 3). This move costs colCosts[3] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18\nExample 2:\n\nInput: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\nOutput: 0\nExplanation: The robot is already at its home. Since no moves occur, the total cost is 0.\n\n&nbsp;\nConstraints:\n\n\tm == rowCosts.length\n\tn == colCosts.length\n\t1 <= m, n <= 105\n\t0 <= rowCosts[r], colCosts[c] <= 104\n\tstartPos.length == 2\n\thomePos.length == 2\n\t0 <= startrow, homerow < m\n\t0 <= startcol, homecol < n",
        "solutions": [
            {
                "id": 1598941,
                "title": "java-c-python-all-shortest-paths-have-the-same-cost",
                "content": "# **Intuition**\\nIt\\'s a brain-teaser,\\nall shortest paths have the same cost.\\n\\n# **Prove**\\nWe have `0 <= rowCosts[r], colCosts[c] <= 10^4`,\\nthat means we don\\'t go duplicated path.\\n\\nFrom the view of row index, the best path will be go directly from start x to home x\\nFrom the view of col index, the best path will be go directly from start y to home y\\n\\n# **Explanation**\\nFirstly move rows, from `startPos[0]` to `homePos[0]`.\\nSecondly move cols, from `startPos[1]` to `homePos[1]`.\\nSum up the cost for every step.\\n<br>\\n\\n# **Complexity**\\nTime `O(n+m)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int res = 0, i = startPos[0], j = startPos[1], x = homePos[0], y = homePos[1];\\n        while (i != x) {\\n            i += (x - i) / Math.abs(x - i);\\n            res += rowCosts[i];\\n        }\\n        while (j != y) {\\n            j += (y - j) / Math.abs(y - j);\\n            res += colCosts[j];\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int res = 0, i = startPos[0], j = startPos[1], x = homePos[0], y = homePos[1];\\n        while (i != x) {\\n            i += (x - i) / abs(x - i);\\n            res += rowCosts[i];\\n        }\\n        while (j != y) {\\n            j += (y - j) / abs(y - j);\\n            res += colCosts[j];\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        res, [i, j], [x, y] = 0, startPos, homePos\\n        while i != x:\\n            i += cmp(x, i)\\n            res += rowCosts[i]\\n        while j != y:\\n            j += cmp(y, j)\\n            res += colCosts[j]\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int res = 0, i = startPos[0], j = startPos[1], x = homePos[0], y = homePos[1];\\n        while (i != x) {\\n            i += (x - i) / Math.abs(x - i);\\n            res += rowCosts[i];\\n        }\\n        while (j != y) {\\n            j += (y - j) / Math.abs(y - j);\\n            res += colCosts[j];\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int res = 0, i = startPos[0], j = startPos[1], x = homePos[0], y = homePos[1];\\n        while (i != x) {\\n            i += (x - i) / abs(x - i);\\n            res += rowCosts[i];\\n        }\\n        while (j != y) {\\n            j += (y - j) / abs(y - j);\\n            res += colCosts[j];\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        res, [i, j], [x, y] = 0, startPos, homePos\\n        while i != x:\\n            i += cmp(x, i)\\n            res += rowCosts[i]\\n        while j != y:\\n            j += cmp(y, j)\\n            res += colCosts[j]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1598900,
                "title": "c-python-simple-solution-w-explanation-count-costs-for-each-row-column-from-end-to-start",
                "content": "\\u2714\\uFE0F ***Solution (Count costs from end cell to start cell for rows & columns)***\\n\\nThe solution relies on the observation that we must cross each row and each column between given positions to get from the `startPos` to the `homePos`. So, we will always incur cost of each row and column between home and start positions atleast once. \\n\\nIt must also be observed that it\\'s always best to travel through rows and column in the direction of start to end position and never beneficial to go in the opposite direction since we would then incur costs twice with no benefits. That is, we must **traverse the shortest path from start to end**.\\n\\nIn the below solution, we are travelling from end to start just to avoid extra condition (as we incur cost of rows & columns of ending cell but not of the start cell).\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        for(int i = homePos[0]; i != startPos[0]; i += i > startPos[0] ? -1 : 1)  // move row-wise from end to start\\n            ans += rowCosts[i];\\n        for(int i = homePos[1]; i != startPos[1]; i += i > startPos[1] ? -1 : 1)  // move col-wise from end to start\\n            ans += colCosts[i];\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        ans, i, j = 0, homePos[0], homePos[1]\\n        while i != startPos[0]:\\n            ans += rowCosts[i]\\n            i += -1 if i > startPos[0] else 1\\n        while j != startPos[1]:\\n            ans += colCosts[j]\\n            j += -1 if j > startPos[1] else 1\\n        return ans\\n```\\n\\n***Time Complexity :*** `O(M+N)`, in the worst case start and end position lie on the corners of grid and we need to traverse `M` rows and `N` columns to reach the end.\\n***Space Complexity :*** `O(1)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        for(int i = homePos[0]; i != startPos[0]; i += i > startPos[0] ? -1 : 1)  // move row-wise from end to start\\n            ans += rowCosts[i];\\n        for(int i = homePos[1]; i != startPos[1]; i += i > startPos[1] ? -1 : 1)  // move col-wise from end to start\\n            ans += colCosts[i];\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        ans, i, j = 0, homePos[0], homePos[1]\\n        while i != startPos[0]:\\n            ans += rowCosts[i]\\n            i += -1 if i > startPos[0] else 1\\n        while j != startPos[1]:\\n            ans += colCosts[j]\\n            j += -1 if j > startPos[1] else 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599378,
                "title": "one-liner",
                "content": "Did not get the point of this question. The robot cannot avoid going through rows and cols between it and home.\\n\\n#### One-liner\\n**C++**\\n```cpp\\nint minCost(vector<int>& s, vector<int>& h, vector<int>& r, vector<int>& c) {\\n    return accumulate(begin(r) + min(s[0], h[0]), begin(r) + max(s[0], h[0]) + 1, -r[s[0]]) +\\n        accumulate(begin(c) + min(s[1], h[1]), begin(c) + max(s[1], h[1]) + 1, -c[s[1]]);\\n}\\n```\\n\\n#### Verbose\\n**C++**\\n```cpp\\nint minCost(vector<int>& s, vector<int>& h, vector<int>& rowCosts, vector<int>& colCosts) {\\n    int res = 0, dr = s[0] < h[0] ? 1 : -1, dc = s[1] < h[1] ? 1 : -1;\\n    for (int r = s[0]; r != h[0]; r += dr)\\n        res += rowCosts[r + dr];\\n    for (int c = s[1]; c != h[1]; c += dc)\\n        res += colCosts[c + dc];\\n    return res;\\n}   \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minCost(vector<int>& s, vector<int>& h, vector<int>& r, vector<int>& c) {\\n    return accumulate(begin(r) + min(s[0], h[0]), begin(r) + max(s[0], h[0]) + 1, -r[s[0]]) +\\n        accumulate(begin(c) + min(s[1], h[1]), begin(c) + max(s[1], h[1]) + 1, -c[s[1]]);\\n}\\n```\n```cpp\\nint minCost(vector<int>& s, vector<int>& h, vector<int>& rowCosts, vector<int>& colCosts) {\\n    int res = 0, dr = s[0] < h[0] ? 1 : -1, dc = s[1] < h[1] ? 1 : -1;\\n    for (int r = s[0]; r != h[0]; r += dr)\\n        res += rowCosts[r + dr];\\n    for (int c = s[1]; c != h[1]; c += dc)\\n        res += colCosts[c + dc];\\n    return res;\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600159,
                "title": "c-easy-and-simple-solution",
                "content": "If we observe carefully, then we can find that **we must cross each row and each column between given positions to get from the startPos to the homePos**.  And, it will also be better, if we travel from start to end position and not in the reverse. This says, add all the values from [start+1 to end] for rows as well as for columns.\\n\\n**Time Complexity : O(n+m)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowPos, vector<int>& colPos) {\\n        int x1 = startPos[0];\\n        int x2 = homePos[0];\\n        int y1 = startPos[1];\\n        int y2 = homePos[1];\\n        int ans = 0;\\n\\n        if (x1 == x2 && y1 == y2) return 0; // when start and home at same position\\n\\n        if (x1 < x2) {\\n            for (int i = x1 + 1; i <= x2 ; i++)\\n                ans += rowPos[i];\\n        }\\n        else {\\n            for (int i = x2; i <= x1 - 1; i++)\\n                ans += rowPos[i];\\n        }\\n\\n        if (y1 < y2) {\\n            for (int i = y1 + 1; i <= y2 ; i++)\\n                ans += colPos[i];\\n        }\\n        else {\\n            for (int i = y2; i <= y1 - 1; i++)\\n                ans += colPos[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowPos, vector<int>& colPos) {\\n        int x1 = startPos[0];\\n        int x2 = homePos[0];\\n        int y1 = startPos[1];\\n        int y2 = homePos[1];\\n        int ans = 0;\\n\\n        if (x1 == x2 && y1 == y2) return 0; // when start and home at same position\\n\\n        if (x1 < x2) {\\n            for (int i = x1 + 1; i <= x2 ; i++)\\n                ans += rowPos[i];\\n        }\\n        else {\\n            for (int i = x2; i <= x1 - 1; i++)\\n                ans += rowPos[i];\\n        }\\n\\n        if (y1 < y2) {\\n            for (int i = y1 + 1; i <= y2 ; i++)\\n                ans += colPos[i];\\n        }\\n        else {\\n            for (int i = y2; i <= y1 - 1; i++)\\n                ans += colPos[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598837,
                "title": "python-greedy-clean-o-1-space",
                "content": "Explanation:\\n\\nLet\\'s say the starting position is (0,10) and the ending position is (5,15)\\n\\n* You must walk from row 0 to row 5 at some point.\\n* You must walk from col 5 to col 15 at some point.\\n\\nThe key observation is... The order of moves doesn\\'t matter because the cost is the same given a row/col. Our column position will not effect how much it costs to go to row+1/row-1 and vice versa. Since no costs are negative (in the constraints), it will always be optimal to greedily move to our target.\\n\\nTherefore just sum the rowCost[0:5] and colCost[5:15], both inclusive and subtract the starting position cost.\\n\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        def getRange(left, right, array):\\n            if left > right:\\n                right, left = left, right\\n            return sum((array[i] for i in range(left,right+1)))\\n        \\n        totalRowCost = getRange(startPos[0], homePos[0], rowCosts)\\n        totalColCost = getRange(startPos[1], homePos[1], colCosts)\\n        \\n        #Don\\'t pay for the position you start out on\\n        return totalRowCost + totalColCost - rowCosts[startPos[0]] - colCosts[startPos[1]]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        def getRange(left, right, array):\\n            if left > right:\\n                right, left = left, right\\n            return sum((array[i] for i in range(left,right+1)))\\n        \\n        totalRowCost = getRange(startPos[0], homePos[0], rowCosts)\\n        totalColCost = getRange(startPos[1], homePos[1], colCosts)\\n        \\n        #Don\\'t pay for the position you start out on\\n        return totalRowCost + totalColCost - rowCosts[startPos[0]] - colCosts[startPos[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598879,
                "title": "java-simple-straight-solution-o-1-space",
                "content": "**Intution:** Catch here is that you have been given four direction to travel but u have to travel in only two direction and that is in the direction of home because if u go in opposite direction then u have to surely come back again on that cell to reach home and that will make u add the cost of that cell twice and hence increasing the cost.\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int total = 0;\\n        \\n        // if home is to the down of start move, down till there\\n        if(homePos[0]>startPos[0]){\\n            int i = startPos[0]+1;\\n            while(i<=homePos[0]){\\n                total += rowCosts[i]; // adding cost while moving corresponding to the cell\\n                i++;\\n            }\\n        }\\n        \\n        // else if home is up from the start, move up till there\\n        else if(homePos[0]<startPos[0]){\\n            int i = startPos[0]-1;\\n            while(i>=homePos[0]){\\n                total += rowCosts[i]; // adding cost while moving corresponding to the cell\\n                i--;\\n            }\\n        }\\n        \\n        // if home is right to the start, move right till there\\n        if(homePos[1]>startPos[1]){\\n            int i = startPos[1]+1;\\n            while(i<=homePos[1]){\\n                total += colCosts[i];  // adding cost while moving corresponding to the cell\\n                i++;\\n            }\\n        }\\n        \\n        // else if home is left to the start, move left till there\\n        else if(homePos[1]<startPos[1]){\\n            int i = startPos[1]-1;\\n            while(i>=homePos[1]){\\n                total += colCosts[i];  // adding cost while moving corresponding to the cell\\n                i--;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int total = 0;\\n        \\n        // if home is to the down of start move, down till there\\n        if(homePos[0]>startPos[0]){\\n            int i = startPos[0]+1;\\n            while(i<=homePos[0]){\\n                total += rowCosts[i]; // adding cost while moving corresponding to the cell\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2295539,
                "title": "easy-to-code",
                "content": "```\\nclass Solution {\\n\\tpublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n\\t\\tint sum = 0;\\n\\t\\twhile (startPos[0] != homePos[0]) {\\n\\t\\t\\tif (startPos[0] < homePos[0]) {\\n\\t\\t\\t\\tsum += rowCosts[++startPos[0]];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum += rowCosts[--startPos[0]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (startPos[1] != homePos[1]) {\\n\\t\\t\\tif (startPos[1] < homePos[1]) {\\n\\t\\t\\t\\tsum += colCosts[++startPos[1]];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum += colCosts[--startPos[1]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n\\t\\tint sum = 0;\\n\\t\\twhile (startPos[0] != homePos[0]) {\\n\\t\\t\\tif (startPos[0] < homePos[0]) {\\n\\t\\t\\t\\tsum += rowCosts[++startPos[0]];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum += rowCosts[--startPos[0]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (startPos[1] != homePos[1]) {\\n\\t\\t\\tif (startPos[1] < homePos[1]) {\\n\\t\\t\\t\\tsum += colCosts[++startPos[1]];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum += colCosts[--startPos[1]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598883,
                "title": "c-just-reach-that-cell",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        if(startPos[0] == homePos[0] and startPos[1] == homePos[1]) return 0;\\n        int cnt = 0;\\n        int x = startPos[0];\\n        int x2 = homePos[0];\\n        int y = startPos[1];\\n        int y2 = homePos[1];\\n        \\n        if(x > x2)\\n        {\\n            while(x!=x2)\\n                x--, cnt+=rowCosts[x];\\n        }\\n        else\\n        {\\n            while(x!=x2)\\n            x++, cnt+=rowCosts[x];\\n        }\\n        \\n        if(y > y2)\\n        {\\n            while(y!=y2)\\n                y--, cnt+=colCosts[y];\\n        }\\n        else\\n        {\\n            while(y!=y2)\\n            y++, cnt+=colCosts[y];\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        if(startPos[0] == homePos[0] and startPos[1] == homePos[1]) return 0;\\n        int cnt = 0;\\n        int x = startPos[0];\\n        int x2 = homePos[0];\\n        int y = startPos[1];\\n        int y2 = homePos[1];\\n        \\n        if(x > x2)\\n        {\\n            while(x!=x2)\\n                x--, cnt+=rowCosts[x];\\n        }\\n        else\\n        {\\n            while(x!=x2)\\n            x++, cnt+=rowCosts[x];\\n        }\\n        \\n        if(y > y2)\\n        {\\n            while(y!=y2)\\n                y--, cnt+=colCosts[y];\\n        }\\n        else\\n        {\\n            while(y!=y2)\\n            y++, cnt+=colCosts[y];\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598850,
                "title": "java-easy-solution-o-m-n-with-explanation",
                "content": "Find how many rows and columns the robot needs to go to reach to its home. \\nAt first, both start and home coordinates are included. Then start coordinates need to be excluded from the final result.\\n\\nTime complexity: O(m+n) - the robot needs to walk the entire rows and columns in the worst case\\nSpace complexity: O(1)\\n\\n```\\npublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        if (startPos[0] == homePos[0] && startPos[1] == homePos[1])\\n            return 0;\\n        \\n        int minRow = Math.min(startPos[0], homePos[0]);\\n        int maxRow = Math.max(startPos[0], homePos[0]);\\n        \\n        int minCol = Math.min(startPos[1], homePos[1]);\\n        int maxCol = Math.max(startPos[1], homePos[1]);\\n        \\n        int res = 0;\\n        \\n        for (int i = minRow; i <= maxRow; i++) {\\n            res += rowCosts[i];\\n        }\\n        \\n        for (int i = minCol; i <= maxCol; i++) {\\n            res += colCosts[i];\\n        }\\n        \\n        res = res - rowCosts[startPos[0]] - colCosts[startPos[1]];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        if (startPos[0] == homePos[0] && startPos[1] == homePos[1])\\n            return 0;\\n        \\n        int minRow = Math.min(startPos[0], homePos[0]);\\n        int maxRow = Math.max(startPos[0], homePos[0]);\\n        \\n        int minCol = Math.min(startPos[1], homePos[1]);\\n        int maxCol = Math.max(startPos[1], homePos[1]);\\n        \\n        int res = 0;\\n        \\n        for (int i = minRow; i <= maxRow; i++) {\\n            res += rowCosts[i];\\n        }\\n        \\n        for (int i = minCol; i <= maxCol; i++) {\\n            res += colCosts[i];\\n        }\\n        \\n        res = res - rowCosts[startPos[0]] - colCosts[startPos[1]];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1880810,
                "title": "c-simple-self-explained-code-tc-o-n-m-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans=0;\\n        if(startPos[0]>homePos[0]){\\n            for(int i=startPos[0]-1;i>=homePos[0];--i) ans+=rowCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[0]+1;i<=homePos[0];++i) ans+=rowCosts[i];\\n        }\\n        if(startPos[1]>homePos[1]){\\n            for(int i=startPos[1]-1;i>=homePos[1];--i) ans+=colCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[1]+1;i<=homePos[1];++i) ans+=colCosts[i];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans=0;\\n        if(startPos[0]>homePos[0]){\\n            for(int i=startPos[0]-1;i>=homePos[0];--i) ans+=rowCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[0]+1;i<=homePos[0];++i) ans+=rowCosts[i];\\n        }\\n        if(startPos[1]>homePos[1]){\\n            for(int i=startPos[1]-1;i>=homePos[1];--i) ans+=colCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[1]+1;i<=homePos[1];++i) ans+=colCosts[i];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1598878,
                "title": "very-simple-c-no-need-to-use-fancy-algorithms",
                "content": "I initially got trick by using BFS. In fact, just do addition for all costs\\n\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        \\n        if(startPos[0] < homePos[0]){\\n            for(int i=startPos[0]+1; i<=homePos[0]; ++i)\\n                cost += rowCosts[i];\\n        }\\n        else if(startPos[0] > homePos[0]){\\n            for(int i=startPos[0]-1; i>=homePos[0]; --i)\\n                cost += rowCosts[i];            \\n        }\\n\\n        if(startPos[1] < homePos[1]){\\n            for(int i=startPos[1]+1; i<=homePos[1]; ++i)\\n                cost += colCosts[i];\\n        }\\n        else if(startPos[1] > homePos[1]){\\n            for(int i=startPos[1]-1; i>=homePos[1]; --i)\\n                cost += colCosts[i];            \\n        }\\n        return cost;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        \\n        if(startPos[0] < homePos[0]){\\n            for(int i=startPos[0]+1; i<=homePos[0]; ++i)\\n                cost += rowCosts[i];\\n        }\\n        else if(startPos[0] > homePos[0]){\\n            for(int i=startPos[0]-1; i>=homePos[0]; --i)\\n                cost += rowCosts[i];            \\n        }\\n\\n        if(startPos[1] < homePos[1]){\\n            for(int i=startPos[1]+1; i<=homePos[1]; ++i)\\n                cost += colCosts[i];\\n        }\\n        else if(startPos[1] > homePos[1]){\\n            for(int i=startPos[1]-1; i>=homePos[1]; --i)\\n                cost += colCosts[i];            \\n        }\\n        return cost;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598847,
                "title": "c-with-explanation-very-simple",
                "content": "**Idea:-**\\n1. We just have to calculate cost to move between homePos[0]  and startPos[0] rows. and homePos[1] and startPos[1] columns.\\n\\nBelow is the code.\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rc, vector<int>& cc) {\\n        int ans=0;\\n        if(homePos[0]>=startPos[0])\\n            for(int i=startPos[0]+1;i<=homePos[0];i++)\\n            ans+=rc[i];\\n        else\\n            for(int i=startPos[0]-1;i>=homePos[0];i--)\\n            ans+=rc[i];\\n        if(homePos[1]>=startPos[1])\\n          for(int i=startPos[1]+1;i<=homePos[1];i++)\\n            ans+=cc[i];\\n        else\\n           for(int i=startPos[1]-1;i>=homePos[1];i--)\\n            ans+=cc[i];\\n        return ans;  \\n    }\\n};\\n```\\nDo **UPVOTE** is it helps:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rc, vector<int>& cc) {\\n        int ans=0;\\n        if(homePos[0]>=startPos[0])\\n            for(int i=startPos[0]+1;i<=homePos[0];i++)\\n            ans+=rc[i];\\n        else\\n            for(int i=startPos[0]-1;i>=homePos[0];i--)\\n            ans+=rc[i];\\n        if(homePos[1]>=startPos[1])\\n          for(int i=startPos[1]+1;i<=homePos[1];i++)\\n            ans+=cc[i];\\n        else\\n           for(int i=startPos[1]-1;i>=homePos[1];i--)\\n            ans+=cc[i];\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605782,
                "title": "java-easy-the-first-hint-made-my-day",
                "content": "\\nHint 1 : \\nIrrespective of what path the robot takes, it will have to traverse all the rows between startRow and homeRow and all the columns between startCol and homeCol.\\n    \\n```\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int cost = 0;\\n        \\n        for(int i=Math.min(startPos[0],homePos[0]); i<=Math.max(startPos[0],homePos[0]); i++)\\n            cost += rowCosts[i];\\n        \\n        for(int j=Math.min(startPos[1],homePos[1]); j<=Math.max(startPos[1],homePos[1]); j++)\\n            cost += colCosts[j];\\n\\n        return cost - rowCosts[ startPos[0] ] - colCosts[ startPos[1] ];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int cost = 0;\\n        \\n        for(int i=Math.min(startPos[0],homePos[0]); i<=Math.max(startPos[0],homePos[0]); i++)\\n            cost += rowCosts[i];\\n        \\n        for(int j=Math.min(startPos[1],homePos[1]); j<=Math.max(startPos[1],homePos[1]); j++)\\n            cost += colCosts[j];\\n\\n        return cost - rowCosts[ startPos[0] ] - colCosts[ startPos[1] ];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603267,
                "title": "python-simple-solution-count-cost",
                "content": "all shortest paths have the same cost. check[](http://) this for proof :- [https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/discuss/1598941/JavaC%2B%2BPython-All-shortest-paths-have-the-same-cost](http://)\\nso just travse and reach home and keep adding cost .\\n```\\n\\t\\ti=startPos[0]\\n        j=homePos[0]\\n        \\n        cost=0  \\n        if i<j:    #moving donwn if home if below \\n            while i!=j:\\n                i+= 1\\n                cost+=rowCosts[i]\\n        elif i>j:   #else moving up if home if above \\n            while i!=j:\\n                i-=1\\n                cost+=rowCosts[i]\\n            \\n        k=startPos[1]\\n        j=homePos[1]\\n        \\n        if k<j:      #moving right if home if it is in right side \\n            while k!=j:\\n                k+= 1\\n                cost+=colCosts[k]\\n        elif k>j:     #moving left if home is in left side\\n            while k!=j:\\n                k-=1\\n                cost+=colCosts[k]\\n        return cost\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\t\\ti=startPos[0]\\n        j=homePos[0]\\n        \\n        cost=0  \\n        if i<j:    #moving donwn if home if below \\n            while i!=j:\\n                i+= 1\\n                cost+=rowCosts[i]\\n        elif i>j:   #else moving up if home if above \\n            while i!=j:\\n                i-=1\\n                cost+=rowCosts[i]\\n            \\n        k=startPos[1]\\n        j=homePos[1]\\n        \\n        if k<j:      #moving right if home if it is in right side \\n            while k!=j:\\n                k+= 1\\n                cost+=colCosts[k]\\n        elif k>j:     #moving left if home is in left side\\n            while k!=j:\\n                k-=1\\n                cost+=colCosts[k]\\n        return cost\\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598918,
                "title": "greedy-approach-well-coded-and-explained-95-faster",
                "content": "## IDEA : \\n In this Question directly we can find the cost for rows and column from source to target and add in last. \\n*  From going starting rows to target rows we have to add cost of the up or down path. \\n\\n*  Similarly, for going from starting column to target column we have to add all the costs of coming column in path either towards left or right,\\n\\n**Implementation:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        src_x,src_y = startPos[0],startPos[1]\\n        end_x,end_y = homePos[0], homePos[1]\\n        \\n        if src_x < end_x:\\n            rc = sum(rowCosts[src_x+1:end_x+1])\\n        elif src_x > end_x:\\n            rc = sum(rowCosts[end_x:src_x])\\n        else:\\n            rc=0\\n        \\n        if src_y < end_y:\\n            cc = sum(colCosts[src_y+1:end_y+1])\\n        elif src_y > end_y:\\n            cc = sum(colCosts[end_y:src_y])\\n        else:\\n            cc=0\\n        \\n        return cc+rc\\n\\n### Thanks and  Upvote if you like the Idea!!\\u270C",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA : \\n In this Question directly we can find the cost for rows and column from source to target and add in last. \\n*  From going starting rows to target rows we have to add cost of the up or down path. \\n\\n*  Similarly, for going from starting column to target column we have to add all the costs of coming column in path either towards left or right,\\n\\n**Implementation:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        src_x,src_y = startPos[0],startPos[1]\\n        end_x,end_y = homePos[0], homePos[1]\\n        \\n        if src_x < end_x:\\n            rc = sum(rowCosts[src_x+1:end_x+1])\\n        elif src_x > end_x:\\n            rc = sum(rowCosts[end_x:src_x])\\n        else:\\n            rc=0\\n        \\n        if src_y < end_y:\\n            cc = sum(colCosts[src_y+1:end_y+1])\\n        elif src_y > end_y:\\n            cc = sum(colCosts[end_y:src_y])\\n        else:\\n            cc=0\\n        \\n        return cc+rc\\n\\n### Thanks and  Upvote if you like the Idea!!\\u270C",
                "codeTag": "Java"
            },
            {
                "id": 3891583,
                "title": "easy-solution-in-python-with-detailed-explanation-beats-95-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the question asks about the minimum cost, You just have to go straight to the Home without any extra moves, by directly changing the position of Robot to required Row and Column accordingly. Do refer to the Hint if you don\\'t understand what I mean.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach was to simply traverse through the rows and columns between the Start and Home locations and add the cost of corresponding rows and columns to the `cost` variable.\\n- When the Robot starts at a lower indexed row than the Home, We have to add the cost of the indexes starting from the index of Start\\'s next row, since the Robot is moving to that particular index, including the index of Home\\'s row.\\n- On the contrary, if the Robot starts at a higher indexed row than the Home,We have to add the cost of the indexes starting from the index of the Home to the index of the row, which is just above the Start. The point of this is that the Robot will start to move to the row just above the Home and continue moving upto Home\\'s row. So we are adding the costs of this, just in the Reverse way.\\n- The logic is pretty much same for the Columns.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        i,j=startPos\\n        a,b=homePos\\n        cost=0\\n        if i<a:\\n            for k in range(i,a):\\n                cost+=rowCosts[k+1]\\n        else:\\n            for m in range(a,i):\\n                cost+=rowCosts[m]\\n        if j<b:\\n            for l in range(j,b):\\n                cost+=colCosts[l+1]\\n        else:\\n            for n in range(b,j):\\n                cost+=colCosts[n]\\n            \\n        return cost\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        i,j=startPos\\n        a,b=homePos\\n        cost=0\\n        if i<a:\\n            for k in range(i,a):\\n                cost+=rowCosts[k+1]\\n        else:\\n            for m in range(a,i):\\n                cost+=rowCosts[m]\\n        if j<b:\\n            for l in range(j,b):\\n                cost+=colCosts[l+1]\\n        else:\\n            for n in range(b,j):\\n                cost+=colCosts[n]\\n            \\n        return cost\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745762,
                "title": "c-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& start, vector<int>& end, vector<int>& costR, vector<int>& costC) {\\n        int ans = 0;\\n        int i = start[0], j = start[1];\\n        int x = end[0], y = end[1];\\n        int changeI = i < x ? 1 : -1;\\n        int changeJ = j < y ? 1 : -1;\\n\\n        while(i != x) {\\n            i += changeI;\\n            ans += costR[i];\\n        }\\n\\n        while(j != y) {\\n            j += changeJ;\\n            ans += costC[j];\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& start, vector<int>& end, vector<int>& costR, vector<int>& costC) {\\n        int ans = 0;\\n        int i = start[0], j = start[1];\\n        int x = end[0], y = end[1];\\n        int changeI = i < x ? 1 : -1;\\n        int changeJ = j < y ? 1 : -1;\\n\\n        while(i != x) {\\n            i += changeI;\\n            ans += costR[i];\\n        }\\n\\n        while(j != y) {\\n            j += changeJ;\\n            ans += costC[j];\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691011,
                "title": "java-linear-solution-with-greedy-approach",
                "content": "# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   \\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int sr = startPos[0];\\n        int sc = startPos[1];\\n        int hr = homePos[0];\\n        int hc = homePos[1];\\n        int cost = 0;\\n        while(sr!=hr){\\n          if(sr<hr) cost+=rowCosts[++sr];\\n          else cost+=rowCosts[--sr];\\n        }\\n        while(sc!=hc){\\n          if(sc<hc) cost+=colCosts[++sc];\\n          else cost+=colCosts[--sc];\\n        }\\n        return cost;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n   \\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int sr = startPos[0];\\n        int sc = startPos[1];\\n        int hr = homePos[0];\\n        int hc = homePos[1];\\n        int cost = 0;\\n        while(sr!=hr){\\n          if(sr<hr) cost+=rowCosts[++sr];\\n          else cost+=rowCosts[--sr];\\n        }\\n        while(sc!=hc){\\n          if(sc<hc) cost+=colCosts[++sc];\\n          else cost+=colCosts[--sc];\\n        }\\n        return cost;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259360,
                "title": "time-o-n-m-space-p-1-c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& a, vector<int>& b, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(a[0]<b[0]){\\n            while(a[0]<b[0]){\\n                a[0]++;\\n                ans += rowCosts[a[0]];\\n            }\\n        }else if(a[0]>b[0]){\\n            while(a[0]>b[0]){\\n                a[0]--;\\n                ans += rowCosts[a[0]];\\n            }\\n        }\\n        if(a[1]<b[1]){\\n            while(a[1]<b[1]){\\n                a[1]++;\\n                ans += colCosts[a[1]];\\n            }\\n        }else if(a[1]>b[1]){\\n            while(a[1]>b[1]){\\n                a[1]--;\\n                ans += colCosts[a[1]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& a, vector<int>& b, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(a[0]<b[0]){\\n            while(a[0]<b[0]){\\n                a[0]++;\\n                ans += rowCosts[a[0]];\\n            }\\n        }else if(a[0]>b[0]){\\n            while(a[0]>b[0]){\\n                a[0]--;\\n                ans += rowCosts[a[0]];\\n            }\\n        }\\n        if(a[1]<b[1]){\\n            while(a[1]<b[1]){\\n                a[1]++;\\n                ans += colCosts[a[1]];\\n            }\\n        }else if(a[1]>b[1]){\\n            while(a[1]>b[1]){\\n                a[1]--;\\n                ans += colCosts[a[1]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439081,
                "title": "c-easy-few-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& h, vector<int>& r, vector<int>& c) {\\n        int n=r.size(),m=c.size(),t=0;\\n        for(int i=min(s[0],h[0])+1;i<max(s[0],h[0]);i++)t+=r[i];\\n        for(int i=min(s[1],h[1])+1;i<max(s[1],h[1]);i++)t+=c[i];\\n        if(s[0]!=h[0])t+=r[h[0]];\\n        if(s[1]!=h[1])t+=c[h[1]];\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& h, vector<int>& r, vector<int>& c) {\\n        int n=r.size(),m=c.size(),t=0;\\n        for(int i=min(s[0],h[0])+1;i<max(s[0],h[0]);i++)t+=r[i];\\n        for(int i=min(s[1],h[1])+1;i<max(s[1],h[1]);i++)t+=c[i];\\n        if(s[0]!=h[0])t+=r[h[0]];\\n        if(s[1]!=h[1])t+=c[h[1]];\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048805,
                "title": "javascript-solution",
                "content": "```\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let totCosts = 0;\\n\\n    let rowDir = startPos[0] <= homePos[0] ? 1 : -1;\\n    let colDir = startPos[1] <= homePos[1] ? 1 : -1;\\n    \\n    let row = startPos[0];\\n\\n    while (row != homePos[0]) {\\n        row += rowDir;\\n        totCosts += rowCosts[row];\\n    }\\n\\n    let col = startPos[1];\\n\\n    while (col != homePos[1]) {\\n        col += colDir;\\n        totCosts += colCosts[col];\\n    }\\n\\n    return totCosts;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let totCosts = 0;\\n\\n    let rowDir = startPos[0] <= homePos[0] ? 1 : -1;\\n    let colDir = startPos[1] <= homePos[1] ? 1 : -1;\\n    \\n    let row = startPos[0];\\n\\n    while (row != homePos[0]) {\\n        row += rowDir;\\n        totCosts += rowCosts[row];\\n    }\\n\\n    let col = startPos[1];\\n\\n    while (col != homePos[1]) {\\n        col += colDir;\\n        totCosts += colCosts[col];\\n    }\\n\\n    return totCosts;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796828,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1b580667-7e22-4d1d-ba0c-7bb9cde20d12_1645724927.951826.png)\\n\\n\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        \"\"\" O(N+M)T O(1)S \"\"\"\\n        [y0, y1], [x0, x1] = sorted([startPos[0], homePos[0]]), sorted([startPos[1], homePos[1]])\\n        return sum(rowCosts[y0:y1 + 1]) + sum(colCosts[x0:x1 + 1]) - rowCosts[startPos[0]] - colCosts[startPos[1]]",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1b580667-7e22-4d1d-ba0c-7bb9cde20d12_1645724927.951826.png)\\n\\n\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        \"\"\" O(N+M)T O(1)S \"\"\"\\n        [y0, y1], [x0, x1] = sorted([startPos[0], homePos[0]]), sorted([startPos[1], homePos[1]])\\n        return sum(rowCosts[y0:y1 + 1]) + sum(colCosts[x0:x1 + 1]) - rowCosts[startPos[0]] - colCosts[startPos[1]]",
                "codeTag": "Python3"
            },
            {
                "id": 1602827,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& row, vector<int>& col) {\\n        \\n      /*\\n      To move from start to end , Cost will be same for all the paths becouse\\n      Robot will cross the required rows and columns always\\n      */\\n      \\n     int cost=0;\\n      \\n  for(int i=min(startPos[0],homePos[0]);i<=max(startPos[0],homePos[0]);i++)\\n    cost+=row[i];\\n  \\n   for(int i=min(startPos[1],homePos[1]);i<=max(startPos[1],homePos[1]);i++)\\n    cost+=col[i];\\n       \\n    cost=cost-row[startPos[0]]-col[startPos[1]]; //subtracting the cost of start pos\\n  \\n      return cost;\\n      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& row, vector<int>& col) {\\n        \\n      /*\\n      To move from start to end , Cost will be same for all the paths becouse\\n      Robot will cross the required rows and columns always\\n      */\\n      \\n     int cost=0;\\n      \\n  for(int i=min(startPos[0],homePos[0]);i<=max(startPos[0],homePos[0]);i++)\\n    cost+=row[i];\\n  \\n   for(int i=min(startPos[1],homePos[1]);i<=max(startPos[1],homePos[1]);i++)\\n    cost+=col[i];\\n       \\n    cost=cost-row[startPos[0]]-col[startPos[1]]; //subtracting the cost of start pos\\n  \\n      return cost;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601275,
                "title": "easy-c-sollution",
                "content": "int minCost(vector<int>& start, vector<int>& home, vector<int>& row, vector<int>& col) {\\n        int a=start[0];\\n        int b=start[1];\\n        int c=home[0];\\n        int d=home[1];\\n       int ans=0;\\n        for(int i=a+1;i<=c;i++)\\n            ans+=row[i];\\n         for(int i=b+1;i<=d;i++)\\n            ans+=col[i];\\n           for(int i=a-1;i>=c;i--)\\n            ans+=row[i];\\n         for(int i=b-1;i>=d;i--)\\n            ans+=col[i];\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int minCost(vector<int>& start, vector<int>& home, vector<int>& row, vector<int>& col) {\\n        int a=start[0];\\n        int b=start[1];\\n        int c=home[0];\\n        int d=home[1];\\n       int ans=0;\\n        for(int i=a+1;i<=c;i++)\\n            ans+=row[i];\\n         for(int i=b+1;i<=d;i++)\\n            ans+=col[i];\\n           for(int i=a-1;i>=c;i--)\\n            ans+=row[i];\\n         for(int i=b-1;i>=d;i--)\\n            ans+=col[i];\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1600374,
                "title": "c-easy-solution-in-o-m-n-with-explanation",
                "content": "**First we are trying to reach the required row and then the required column and while doing so we are adding the cost of the changing the rows and column.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        if(startPos==homePos)   return 0;   //if we are already at the destination\\n        int rcost=0,ccost=0;\\n        if(homePos[0]-startPos[0]>0) //we need to move downwards\\n            for(int i=startPos[0]+1;i<=homePos[0];i++)\\n                rcost+=rowCosts[i];\\n\\t\\t\\t\\t\\n        else if(homePos[0]-startPos[0]<0)            //we need to move upwards\\n            for(int i=startPos[0]-1;i>=homePos[0];i--)\\n                rcost+=rowCosts[i];\\n\\t\\t\\t\\t\\n        if(homePos[1]-startPos[1]>0)            //we need to move right\\n            for(int i=startPos[1]+1;i<=homePos[1];i++)\\n                ccost+=colCosts[i];\\n\\t\\t\\t\\t\\n        else if(homePos[1]-startPos[1]<0)        //we need to move left\\n            for(int i=startPos[1]-1;i>=homePos[1];i--)\\n                ccost+=colCosts[i];\\n\\t\\t\\t\\t\\n        return rcost+ccost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        if(startPos==homePos)   return 0;   //if we are already at the destination\\n        int rcost=0,ccost=0;\\n        if(homePos[0]-startPos[0]>0) //we need to move downwards\\n            for(int i=startPos[0]+1;i<=homePos[0];i++)\\n                rcost+=rowCosts[i];\\n\\t\\t\\t\\t\\n        else if(homePos[0]-startPos[0]<0)            //we need to move upwards\\n            for(int i=startPos[0]-1;i>=homePos[0];i--)\\n                rcost+=rowCosts[i];\\n\\t\\t\\t\\t\\n        if(homePos[1]-startPos[1]>0)            //we need to move right\\n            for(int i=startPos[1]+1;i<=homePos[1];i++)\\n                ccost+=colCosts[i];\\n\\t\\t\\t\\t\\n        else if(homePos[1]-startPos[1]<0)        //we need to move left\\n            for(int i=startPos[1]-1;i>=homePos[1];i--)\\n                ccost+=colCosts[i];\\n\\t\\t\\t\\t\\n        return rcost+ccost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599086,
                "title": "java-o-1-space-solution-full-elaborated-explanation-with-code",
                "content": "The first note is All shortest path with have the same cost.\\n\\nSo simply you need to find the sum of all rows from the source-row to the destination-row\\nThen find the sum of all columns from the source-column to the destination-column\\n\\nJava Code:\\n\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int n = rowCosts.length;\\n        int m = colCosts.length;\\n        \\n        int cost = 0;\\n        for(int i=Math.min(startPos[0], homePos[0]);i<=Math.max(startPos[0], homePos[0]);i++){\\n            cost += rowCosts[i];\\n        }\\n        \\n        for(int i=Math.min(startPos[1], homePos[1]);i<=Math.max(startPos[1], homePos[1]);i++){\\n            cost += colCosts[i];\\n        }\\n        \\n        cost -= (rowCosts[startPos[0]] + colCosts[startPos[1]]);\\n        \\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int n = rowCosts.length;\\n        int m = colCosts.length;\\n        \\n        int cost = 0;\\n        for(int i=Math.min(startPos[0], homePos[0]);i<=Math.max(startPos[0], homePos[0]);i++){\\n            cost += rowCosts[i];\\n        }\\n        \\n        for(int i=Math.min(startPos[1], homePos[1]);i<=Math.max(startPos[1], homePos[1]);i++){\\n            cost += colCosts[i];\\n        }\\n        \\n        cost -= (rowCosts[startPos[0]] + colCosts[startPos[1]]);\\n        \\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598950,
                "title": "java-bfs-solution",
                "content": "```\\n\\tpublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        \\n        boolean down = false;\\n        boolean right = false;\\n        \\n        if(startPos[0] <= homePos[0]){\\n            down = true;\\n        }\\n        if(startPos[1] <= homePos[1]){\\n            right = true;\\n        }\\n        Queue<int[]> queue = new LinkedList();\\n        queue.add(new int[]{startPos[0], startPos[1], 0});\\n        int dr[] = {1, -1};\\n        int dc[] = {-1, 1};\\n        while(!queue.isEmpty()){\\n            int node[] = queue.poll();\\n            int row = node[0];\\n            int col = node[1];\\n            int currCost = node[2];\\n            if(row == homePos[0] && col == homePos[1]){\\n               return currCost;\\n            }\\n            \\n            if(down && row < rowCosts.length-1 && row < homePos[0]){\\n                row+= dr[0];\\n                currCost += rowCosts[row];\\n                \\n            }else if(down == false && row >0 && row > homePos[0] ){\\n                row+= dr[1];\\n               currCost += rowCosts[row];\\n\\n            }\\n            if(right && col < colCosts.length-1 && col < homePos[1]){\\n                col+= dc[1];\\n                currCost += colCosts[col];\\n\\n                \\n            }else if(right == false && col > 0 && col > homePos[1]){\\n                col+=dc[0];\\n                 currCost += colCosts[col];\\n\\n            }\\n\\n            if(row >= 0 && col >= 0 && col< colCosts.length && row < rowCosts.length){\\n                queue.add(new int[]{row, col, currCost});\\n            }\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tpublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        \\n        boolean down = false;\\n        boolean right = false;\\n        \\n        if(startPos[0] <= homePos[0]){\\n            down = true;\\n        }\\n        if(startPos[1] <= homePos[1]){\\n            right = true;\\n        }\\n        Queue<int[]> queue = new LinkedList();\\n        queue.add(new int[]{startPos[0], startPos[1], 0});\\n        int dr[] = {1, -1};\\n        int dc[] = {-1, 1};\\n        while(!queue.isEmpty()){\\n            int node[] = queue.poll();\\n            int row = node[0];\\n            int col = node[1];\\n            int currCost = node[2];\\n            if(row == homePos[0] && col == homePos[1]){\\n               return currCost;\\n            }\\n            \\n            if(down && row < rowCosts.length-1 && row < homePos[0]){\\n                row+= dr[0];\\n                currCost += rowCosts[row];\\n                \\n            }else if(down == false && row >0 && row > homePos[0] ){\\n                row+= dr[1];\\n               currCost += rowCosts[row];\\n\\n            }\\n            if(right && col < colCosts.length-1 && col < homePos[1]){\\n                col+= dc[1];\\n                currCost += colCosts[col];\\n\\n                \\n            }else if(right == false && col > 0 && col > homePos[1]){\\n                col+=dc[0];\\n                 currCost += colCosts[col];\\n\\n            }\\n\\n            if(row >= 0 && col >= 0 && col< colCosts.length && row < rowCosts.length){\\n                queue.add(new int[]{row, col, currCost});\\n            }\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1598842,
                "title": "java-solution-simply-sum-the-cost-from-rows-difference-and-column-difference",
                "content": "The key idea here is to recogise that minimum cost will be along the path of least distance i.e |yHome - yPos| + |xHome  - xPos|\\nwe will need to traverse these rows and cols in any path we take.\\nSince all cost is positive, we must take this route.\\nSimply sum the cost for rows and cols to get the final answer instead of using Dijkstra which will time out (I know it becasue I wasted ~20 min on it)\\n\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int rowCost = 0;\\n        int colCost = 0;\\n        \\n        if (startPos[0] < homePos[0]) {\\n            for(int i = startPos[0] + 1; i <= homePos[0]; i++) {\\n                rowCost += rowCosts[i];\\n            }\\n        } else if (startPos[0] > homePos[0]) {\\n            for(int i = startPos[0] - 1; i >= homePos[0]; i--) {\\n                rowCost += rowCosts[i];\\n            }\\n        }\\n        \\n        if (startPos[1] < homePos[1]) {\\n            for(int i = startPos[1] + 1; i <= homePos[1]; i++) {\\n                colCost += colCosts[i];\\n            }\\n        } else if (startPos[1] > homePos[1]) {\\n            for(int i = startPos[1] - 1; i >= homePos[1]; i--) {\\n                colCost += colCosts[i];\\n            }\\n        }\\n        \\n        return rowCost + colCost;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int rowCost = 0;\\n        int colCost = 0;\\n        \\n        if (startPos[0] < homePos[0]) {\\n            for(int i = startPos[0] + 1; i <= homePos[0]; i++) {\\n                rowCost += rowCosts[i];\\n            }\\n        } else if (startPos[0] > homePos[0]) {\\n            for(int i = startPos[0] - 1; i >= homePos[0]; i--) {\\n                rowCost += rowCosts[i];\\n            }\\n        }\\n        \\n        if (startPos[1] < homePos[1]) {\\n            for(int i = startPos[1] + 1; i <= homePos[1]; i++) {\\n                colCost += colCosts[i];\\n            }\\n        } else if (startPos[1] > homePos[1]) {\\n            for(int i = startPos[1] - 1; i >= homePos[1]; i--) {\\n                colCost += colCosts[i];\\n            }\\n        }\\n        \\n        return rowCost + colCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966251,
                "title": "c-code-simple-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObserving that all paths will be having the same cost as all the rows and columns coming between the start and end point will be visited once.\\nThe sum of costs of these rows and columns gives you the desired answer.\\n\\n# Complexity\\n- Time complexity: O(n + m)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& endPos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(startPos[0] <= endPos[0])\\n        {\\n            for(int i = startPos[0] + 1; i <= endPos[0]; ++i)\\n            {\\n                ans += rowCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[0] - 1; i >= endPos[0]; --i)\\n            {\\n                ans += rowCosts[i];\\n            }\\n        }\\n        if(startPos[1] <= endPos[1])\\n        {\\n            for(int i = startPos[1] + 1; i <= endPos[1]; ++i)\\n            {\\n                ans += colCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[1] - 1; i >= endPos[1]; --i)\\n            {\\n                ans += colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& endPos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(startPos[0] <= endPos[0])\\n        {\\n            for(int i = startPos[0] + 1; i <= endPos[0]; ++i)\\n            {\\n                ans += rowCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[0] - 1; i >= endPos[0]; --i)\\n            {\\n                ans += rowCosts[i];\\n            }\\n        }\\n        if(startPos[1] <= endPos[1])\\n        {\\n            for(int i = startPos[1] + 1; i <= endPos[1]; ++i)\\n            {\\n                ans += colCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[1] - 1; i >= endPos[1]; --i)\\n            {\\n                ans += colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748523,
                "title": "python-3-greedy-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity $$O(M + N)$$\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        sx, sy = startPos\\n        hx, hy = homePos\\n        return sum(rowCosts[min(sx, hx): max(sx, hx) + 1]) + \\\\\\n               sum(colCosts[min(sy, hy): max(sy, hy) + 1]) - \\\\\\n               rowCosts[sx] - colCosts[sy]\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        sx, sy = startPos\\n        hx, hy = homePos\\n        return sum(rowCosts[min(sx, hx): max(sx, hx) + 1]) + \\\\\\n               sum(colCosts[min(sy, hy): max(sy, hy) + 1]) - \\\\\\n               rowCosts[sx] - colCosts[sy]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612447,
                "title": "one-liner-beats-98-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, sp: List[int], hp: List[int], rc: List[int], cc: List[int]) -> int:\\n        return (sum(cc[hp[1]:sp[1]]) if  hp[1]<sp[1] else sum(cc[sp[1]+1:hp[1]+1])) + (sum(rc[hp[0]:sp[0]])  if hp[0]<sp[0] else sum(rc[sp[0]+1:hp[0]+1]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, sp: List[int], hp: List[int], rc: List[int], cc: List[int]) -> int:\\n        return (sum(cc[hp[1]:sp[1]]) if  hp[1]<sp[1] else sum(cc[sp[1]+1:hp[1]+1])) + (sum(rc[hp[0]:sp[0]])  if hp[0]<sp[0] else sum(rc[sp[0]+1:hp[0]+1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479980,
                "title": "simple-and-easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        long long ct=0;\\n        long long x1 = startPos[0],y1=startPos[1],x2=homePos[0],y2=homePos[1];\\n        while(x1<x2) ct+=rowCosts[++x1];\\n        while(x1>x2) ct+=rowCosts[--x1];\\n        while(y1<y2) ct+=colCosts[++y1];\\n        while(y1>y2) ct+=colCosts[--y1];\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        long long ct=0;\\n        long long x1 = startPos[0],y1=startPos[1],x2=homePos[0],y2=homePos[1];\\n        while(x1<x2) ct+=rowCosts[++x1];\\n        while(x1>x2) ct+=rowCosts[--x1];\\n        while(y1<y2) ct+=colCosts[++y1];\\n        while(y1>y2) ct+=colCosts[--y1];\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389701,
                "title": "c-easy-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int minRow = min(startPos[0],homePos[0]);\\n        int maxRow = max(startPos[0],homePos[0]);\\n        int minCol = min(startPos[1],homePos[1]);\\n        int maxCol = max(startPos[1],homePos[1]);\\n        int cost=0;\\n        for (int i=minRow;i<=maxRow;i++) {\\n            cost += rowCosts[i];\\n        }\\n        cost -= rowCosts[startPos[0]];\\n        for (int i=minCol;i<=maxCol;i++) {\\n            cost += colCosts[i];\\n        }\\n        cost -= colCosts[startPos[1]];\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int minRow = min(startPos[0],homePos[0]);\\n        int maxRow = max(startPos[0],homePos[0]);\\n        int minCol = min(startPos[1],homePos[1]);\\n        int maxCol = max(startPos[1],homePos[1]);\\n        int cost=0;\\n        for (int i=minRow;i<=maxRow;i++) {\\n            cost += rowCosts[i];\\n        }\\n        cost -= rowCosts[startPos[0]];\\n        for (int i=minCol;i<=maxCol;i++) {\\n            cost += colCosts[i];\\n        }\\n        cost -= colCosts[startPos[1]];\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369770,
                "title": "minimum-cost-of-a-robot-in-a-grid-c-explained-solution-100-faster",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite simple and just needs simple observation. The problem is very direct if you understand that the best possible way of reaching a cell is by traversing through **Manhatten distance i.e |starti - endi| + |startj - endj|**. Now there are multiple ways of reaching home from start cause there are multiple **manhatten paths**. The observation here is that the **cost of all these paths is actually same and is also the minimum cost to reach home**. Manhatten Paths do not **re-traverse a cell**. So you only have to sum up the values from startrow to homerow and from startcol to homecol and that\\'s all !!. Implementation goes below : \\n\\n# Complexity\\n- Time complexity: **O(N+M)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        ios_base::sync_with_stdio(0);\\n        int ans = 0;\\n        if(startPos[0] <= homePos[0]){\\n            for(int i = startPos[0] + 1; i <= homePos[0]; i++){\\n                ans += rowCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = startPos[0] - 1; i >= homePos[0]; i--){\\n                ans += rowCosts[i];\\n            }\\n        }\\n        if(startPos[1] <= homePos[1]){\\n            for(int i = startPos[1] + 1; i <= homePos[1]; i++){\\n                ans += colCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = startPos[1] - 1; i >= homePos[1]; i--){\\n                ans += colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Screenshot from 2023-04-02 13-41-00.png](https://assets.leetcode.com/users/images/df75afa1-3c81-4770-999c-903e244d4491_1680423725.0393858.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        ios_base::sync_with_stdio(0);\\n        int ans = 0;\\n        if(startPos[0] <= homePos[0]){\\n            for(int i = startPos[0] + 1; i <= homePos[0]; i++){\\n                ans += rowCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = startPos[0] - 1; i >= homePos[0]; i--){\\n                ans += rowCosts[i];\\n            }\\n        }\\n        if(startPos[1] <= homePos[1]){\\n            for(int i = startPos[1] + 1; i <= homePos[1]; i++){\\n                ans += colCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = startPos[1] - 1; i >= homePos[1]; i--){\\n                ans += colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661249,
                "title": "each-shortest-path-have-same-cost-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int cnt=0;\\n        if(startPos[0]<homePos[0])\\n        {\\n            while(startPos[0]<homePos[0])\\n            {\\n                cnt+=rowCosts[++startPos[0]];\\n            }\\n        }\\n        else if(startPos[0]>homePos[0])\\n        {\\n            while(homePos[0]<startPos[0])\\n            {\\n                cnt+=rowCosts[--startPos[0]];\\n            }\\n        }\\n        if(startPos[1]<homePos[1])\\n        {\\n            while(startPos[1]<homePos[1])\\n            {\\n                cnt+=colCosts[++startPos[1]];\\n            }\\n        }\\n        else if(startPos[1]>homePos[1])\\n        {\\n            while(homePos[1]<startPos[1])\\n            {\\n                cnt+=colCosts[--startPos[1]];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int cnt=0;\\n        if(startPos[0]<homePos[0])\\n        {\\n            while(startPos[0]<homePos[0])\\n            {\\n                cnt+=rowCosts[++startPos[0]];\\n            }\\n        }\\n        else if(startPos[0]>homePos[0])\\n        {\\n            while(homePos[0]<startPos[0])\\n            {\\n                cnt+=rowCosts[--startPos[0]];\\n            }\\n        }\\n        if(startPos[1]<homePos[1])\\n        {\\n            while(startPos[1]<homePos[1])\\n            {\\n                cnt+=colCosts[++startPos[1]];\\n            }\\n        }\\n        else if(startPos[1]>homePos[1])\\n        {\\n            while(homePos[1]<startPos[1])\\n            {\\n                cnt+=colCosts[--startPos[1]];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522803,
                "title": "c-easy",
                "content": "1. No need to use any kind of graph traversal techniques of greedy or DP\\n2. If we need from one start position to home position then we will always need to traverse through the rows and cols in between no matter what path we choose, since the cost is not cell wise but row wise and column wise.\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int res = 0;\\n        if(homePos[0] >= startPos[0])\\n        {\\n            for(int i = startPos[0]+1; i <= homePos[0]; i++)\\n            {\\n                res += rowCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[0]-1; i >= homePos[0]; i--)\\n            {\\n                res += rowCosts[i];\\n            }\\n        }\\n        \\n        if(homePos[1] >= startPos[1])\\n        {\\n            for(int i = startPos[1]+1; i <= homePos[1]; i++)\\n            {\\n                res += colCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[1]-1; i >= homePos[1]; i--)\\n            {\\n                res += colCosts[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int res = 0;\\n        if(homePos[0] >= startPos[0])\\n        {\\n            for(int i = startPos[0]+1; i <= homePos[0]; i++)\\n            {\\n                res += rowCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[0]-1; i >= homePos[0]; i--)\\n            {\\n                res += rowCosts[i];\\n            }\\n        }\\n        \\n        if(homePos[1] >= startPos[1])\\n        {\\n            for(int i = startPos[1]+1; i <= homePos[1]; i++)\\n            {\\n                res += colCosts[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = startPos[1]-1; i >= homePos[1]; i--)\\n            {\\n                res += colCosts[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480565,
                "title": "75-tc-and-67-sc-easy-python-solution",
                "content": "```\\ndef minCost(self, startPos: List[int], homePos: List[int], rowC: List[int], colC: List[int]) -> int:\\n\\tm, n = len(rowC), len(colC)\\n\\ti1, j1 = startPos\\n\\ti2, j2 = homePos\\n\\tans = 0\\n\\tif(i1 <= i2):\\n\\t\\tfor i in range(i1+1, i2+1):\\n\\t\\t\\tans += rowC[i]\\n\\telse:\\n\\t\\tfor i in range(i1-1, i2-1, -1):\\n\\t\\t\\tans += rowC[i]\\n\\tif(j1 <= j2):\\n\\t\\tfor j in range(j1+1, j2+1):\\n\\t\\t\\tans += colC[j]\\n\\telse:\\n\\t\\tfor j in range(j1-1, j2-1, -1):\\n\\t\\t\\tans += colC[j]\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef minCost(self, startPos: List[int], homePos: List[int], rowC: List[int], colC: List[int]) -> int:\\n\\tm, n = len(rowC), len(colC)\\n\\ti1, j1 = startPos\\n\\ti2, j2 = homePos\\n\\tans = 0\\n\\tif(i1 <= i2):\\n\\t\\tfor i in range(i1+1, i2+1):\\n\\t\\t\\tans += rowC[i]\\n\\telse:\\n\\t\\tfor i in range(i1-1, i2-1, -1):\\n\\t\\t\\tans += rowC[i]\\n\\tif(j1 <= j2):\\n\\t\\tfor j in range(j1+1, j2+1):\\n\\t\\t\\tans += colC[j]\\n\\telse:\\n\\t\\tfor j in range(j1-1, j2-1, -1):\\n\\t\\t\\tans += colC[j]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2363470,
                "title": "c-understandable-linear-time-o-n-constant-space-o-1",
                "content": "This question is similar to other problem based on calculation of path Cost & can be solve using DP || Memoization but due to high constrain those concept will not be applied\\n\\nInitially i try to solve this problem using Dijkstra Algo but it gives TLE, i commented it out you can it out\\n\\nNow approch to solve this problem :- \\n\\nAs cost of moving to any row from any cell of current cell is always same irespective of anything we have to reach the destination so we will have to that many rows & column \\n\\nstep :-1\\n\\ninitialise a int variable res=0;\\n\\nstep 2:- \\nint i=startPos[0]+1\\n\\nTraversed the rowCosts array from startPos[0]+1 to homePos[0] i.e\\nif homePos[0] >=startPos[0] than we will increment the i,\\nif homePos[0] <startPos[0] => we need to go upward so will decrement i\\n\\nstep 3:- \\n\\nwe will do similar job for column now\\n\\nstep 4:-\\n\\nfinaly return res;\\n\\nit will be clear from code ,plz go through it..\\n\\n```\\n#define schema pair<int,pair<int,int>>\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts)\\n\\t{\\n\\t\\n\\t\\n\\t    int res=0;\\n\\t\\t\\n\\t\\t//This loops runs to cover the gap in rows considering target position is below the start position\\n\\t\\t\\n        for(int i=startPos[0]+1;i<=homePos[0];i++)\\n        {\\n            res+=rowCosts[i];\\n        }\\n        \\n\\t\\t//This loops runs to cover the gap in columns  considering target position is right to the start position\\n\\t\\t\\n        for(int i=startPos[1]+1;i<=homePos[1];i++)\\n        {\\n            res+=colCosts[i];\\n        }\\n        \\n\\t\\t//This loops runs to cover the gap in rows considering target position is above the start position\\n\\t\\t\\n        for(int i=startPos[0]-1;i>=homePos[0];i--)\\n        {\\n            res+=rowCosts[i];\\n        }\\n        \\n\\t\\t\\n\\t\\t//This loops runs to cover the gap in rows considering target position is left the start position\\n\\t\\t\\n        for(int i=startPos[1]-1;i>=homePos[1];i--)\\n        {\\n            res+=colCosts[i];\\n        }\\n        \\n        return res;\\n\\t\\n\\t\\n//         int m=rowCosts.size();\\n//         int n=colCosts.size();\\n//         vector<vector<int>> dist(m,vector<int>(n,INT_MAX));\\n//         dist[startPos[0]][startPos[1]]=0;\\n//         priority_queue<schema,vector<schema>,greater<schema>> q;\\n//         q.push({0,{startPos[0],startPos[1]}});\\n//         while(!q.empty())\\n//         {\\n//             auto temp=q.top();\\n//             q.pop();\\n            \\n//             int i=temp.second.first,j=temp.second.second;\\n//             int cost_so_far=temp.first;\\n            \\n//             // if(cost_so_far>dist[i][j])\\n//             // {\\n//             //     continue;\\n//             // }\\n            \\n//             if(i-1>=0)\\n//             {\\n//                 if(dist[i-1][j]>cost_so_far+rowCosts[i-1])\\n//                 {\\n//                     dist[i-1][j]=cost_so_far+rowCosts[i-1];\\n//                     q.push({dist[i-1][j],{i-1,j}});\\n//                 }\\n//             }\\n            \\n//             if(i+1<m)\\n//             {\\n//                 if(dist[i+1][j]>cost_so_far+rowCosts[i+1])\\n//                 {\\n//                     dist[i+1][j]=cost_so_far+rowCosts[i+1];\\n//                     q.push({dist[i+1][j],{i+1,j}});\\n//                 }\\n//             }\\n            \\n//             if(j-1>=0)\\n//             {\\n//                 if(dist[i][j-1]>cost_so_far+colCosts[j-1])\\n//                 {\\n//                     dist[i][j-1]=cost_so_far+colCosts[j-1];\\n//                     q.push({dist[i][j-1],{i,j-1}});\\n//                 }\\n//             }\\n            \\n//             if(j+1<n)\\n//             {\\n//                 if(dist[i][j+1]>cost_so_far+colCosts[j+1])\\n//                 {\\n//                     dist[i][j+1]=cost_so_far+colCosts[j+1];\\n//                     q.push({dist[i][j+1],{i,j+1}});\\n//                 }\\n//             }\\n//         }\\n        \\n// //         for(auto dis:dist)\\n// //         {\\n// //             for(auto x:dis)\\n// //             {\\n// //                 cout<<x<<\" \";\\n// //             }\\n            \\n// //             cout<<endl;\\n// //         }\\n        \\n//         return dist[homePos[0]][homePos[1]];\\n    }\\n};\\n```\\n\\n**Upvote += \"HelpFul\" ? 1 : 0 ;**\\n**if any suggestion drop it here :)**\\n**thanks & reagrd**\\n**AKS**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define schema pair<int,pair<int,int>>\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts)\\n\\t{\\n\\t\\n\\t\\n\\t    int res=0;\\n\\t\\t\\n\\t\\t//This loops runs to cover the gap in rows considering target position is below the start position\\n\\t\\t\\n        for(int i=startPos[0]+1;i<=homePos[0];i++)\\n        {\\n            res+=rowCosts[i];\\n        }\\n        \\n\\t\\t//This loops runs to cover the gap in columns  considering target position is right to the start position\\n\\t\\t\\n        for(int i=startPos[1]+1;i<=homePos[1];i++)\\n        {\\n            res+=colCosts[i];\\n        }\\n        \\n\\t\\t//This loops runs to cover the gap in rows considering target position is above the start position\\n\\t\\t\\n        for(int i=startPos[0]-1;i>=homePos[0];i--)\\n        {\\n            res+=rowCosts[i];\\n        }\\n        \\n\\t\\t\\n\\t\\t//This loops runs to cover the gap in rows considering target position is left the start position\\n\\t\\t\\n        for(int i=startPos[1]-1;i>=homePos[1];i--)\\n        {\\n            res+=colCosts[i];\\n        }\\n        \\n        return res;\\n\\t\\n\\t\\n//         int m=rowCosts.size();\\n//         int n=colCosts.size();\\n//         vector<vector<int>> dist(m,vector<int>(n,INT_MAX));\\n//         dist[startPos[0]][startPos[1]]=0;\\n//         priority_queue<schema,vector<schema>,greater<schema>> q;\\n//         q.push({0,{startPos[0],startPos[1]}});\\n//         while(!q.empty())\\n//         {\\n//             auto temp=q.top();\\n//             q.pop();\\n            \\n//             int i=temp.second.first,j=temp.second.second;\\n//             int cost_so_far=temp.first;\\n            \\n//             // if(cost_so_far>dist[i][j])\\n//             // {\\n//             //     continue;\\n//             // }\\n            \\n//             if(i-1>=0)\\n//             {\\n//                 if(dist[i-1][j]>cost_so_far+rowCosts[i-1])\\n//                 {\\n//                     dist[i-1][j]=cost_so_far+rowCosts[i-1];\\n//                     q.push({dist[i-1][j],{i-1,j}});\\n//                 }\\n//             }\\n            \\n//             if(i+1<m)\\n//             {\\n//                 if(dist[i+1][j]>cost_so_far+rowCosts[i+1])\\n//                 {\\n//                     dist[i+1][j]=cost_so_far+rowCosts[i+1];\\n//                     q.push({dist[i+1][j],{i+1,j}});\\n//                 }\\n//             }\\n            \\n//             if(j-1>=0)\\n//             {\\n//                 if(dist[i][j-1]>cost_so_far+colCosts[j-1])\\n//                 {\\n//                     dist[i][j-1]=cost_so_far+colCosts[j-1];\\n//                     q.push({dist[i][j-1],{i,j-1}});\\n//                 }\\n//             }\\n            \\n//             if(j+1<n)\\n//             {\\n//                 if(dist[i][j+1]>cost_so_far+colCosts[j+1])\\n//                 {\\n//                     dist[i][j+1]=cost_so_far+colCosts[j+1];\\n//                     q.push({dist[i][j+1],{i,j+1}});\\n//                 }\\n//             }\\n//         }\\n        \\n// //         for(auto dis:dist)\\n// //         {\\n// //             for(auto x:dis)\\n// //             {\\n// //                 cout<<x<<\" \";\\n// //             }\\n            \\n// //             cout<<endl;\\n// //         }\\n        \\n//         return dist[homePos[0]][homePos[1]];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2286125,
                "title": "simple-python-solution-just-go-in-one-direction",
                "content": "Basic idea:\\n===========\\n1.  All shortest path have the same cost.\\n\\tAll that is needed is just to sum the row / col costs from start -> home.\\n\\n\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        if startPos[0] < homePos[0]:\\n            for i in range(startPos[0]+1, homePos[0]+1):\\n                cost += rowCosts[i]\\n        elif startPos[0] > homePos[0]:\\n            for i in reversed(range(homePos[0], startPos[0])):\\n                cost += rowCosts[i]\\n                \\n        if startPos[1] < homePos[1]:\\n            for i in range(startPos[1]+1, homePos[1]+1):\\n                cost += colCosts[i]\\n        elif startPos[1] > homePos[1]:\\n            for i in reversed(range(homePos[1], startPos[1])):\\n                cost += colCosts[i]\\n            \\n        return cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        if startPos[0] < homePos[0]:\\n            for i in range(startPos[0]+1, homePos[0]+1):\\n                cost += rowCosts[i]\\n        elif startPos[0] > homePos[0]:\\n            for i in reversed(range(homePos[0], startPos[0])):\\n                cost += rowCosts[i]\\n                \\n        if startPos[1] < homePos[1]:\\n            for i in range(startPos[1]+1, homePos[1]+1):\\n                cost += colCosts[i]\\n        elif startPos[1] > homePos[1]:\\n            for i in reversed(range(homePos[1], startPos[1])):\\n                cost += colCosts[i]\\n            \\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243063,
                "title": "c-easy-short-and-simple",
                "content": "**APPROACH :**\\n* No matter which path we chose we have to pay the same, So just need to calculate the total cost of rows + columns.\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& h, vector<int>& r, vector<int>& c) {\\n        int ans = 0;\\n\\t\\t// if defference is positive or negative\\n        int a = h[0]>s[0]?1:-1;\\n        int b = h[1]>s[1]?1:-1;\\n        \\n\\t\\t// Total cost of rows\\n        if(s[0] != h[0]){\\n            for(int i=s[0]+a; i != h[0]+a; i+=a)\\n            ans += r[i];    \\n        }\\n        \\n\\t\\t// Total cost of columns\\n        if(s[1] != h[1]){\\n            for(int i=s[1]+b; i != h[1]+b; i+=b)\\n            ans += c[i];    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you find it helpful \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& h, vector<int>& r, vector<int>& c) {\\n        int ans = 0;\\n\\t\\t// if defference is positive or negative\\n        int a = h[0]>s[0]?1:-1;\\n        int b = h[1]>s[1]?1:-1;\\n        \\n\\t\\t// Total cost of rows\\n        if(s[0] != h[0]){\\n            for(int i=s[0]+a; i != h[0]+a; i+=a)\\n            ans += r[i];    \\n        }\\n        \\n\\t\\t// Total cost of columns\\n        if(s[1] != h[1]){\\n            for(int i=s[1]+b; i != h[1]+b; i+=b)\\n            ans += c[i];    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236245,
                "title": "c-simple-concise-crystal-clear-greedy",
                "content": "```\\n// This is Straightforward Question becuase you need to travel at least one time the incoming rows and column in path.\\n// So why you need to complicate the path just traverse staright and to homePos Row and homePos column and you will get the ans...\\n// This Question would have become really tough when negative values also possible in the row and column vectors because that negative values could have decresed the results...but here its simple and concise.\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(startPos[0] < homePos[0])\\n        {\\n            for(int i = startPos[0]+1 ; i <=homePos[0] ; i++)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(startPos[0] > homePos[0])\\n        {\\n            for(int i = startPos[0]-1 ; i >=homePos[0] ; i--)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(startPos[1] < homePos[1])\\n        {\\n            for(int i = startPos[1]+1 ; i <=homePos[1] ; i++)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n         if(startPos[1] > homePos[1])\\n        {\\n            for(int i = startPos[1]-1 ; i >=homePos[1] ; i--)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote the Solution..**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n// This is Straightforward Question becuase you need to travel at least one time the incoming rows and column in path.\\n// So why you need to complicate the path just traverse staright and to homePos Row and homePos column and you will get the ans...\\n// This Question would have become really tough when negative values also possible in the row and column vectors because that negative values could have decresed the results...but here its simple and concise.\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(startPos[0] < homePos[0])\\n        {\\n            for(int i = startPos[0]+1 ; i <=homePos[0] ; i++)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(startPos[0] > homePos[0])\\n        {\\n            for(int i = startPos[0]-1 ; i >=homePos[0] ; i--)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(startPos[1] < homePos[1])\\n        {\\n            for(int i = startPos[1]+1 ; i <=homePos[1] ; i++)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n         if(startPos[1] > homePos[1])\\n        {\\n            for(int i = startPos[1]-1 ; i >=homePos[1] ; i--)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146937,
                "title": "c-easy-solution-row-and-column-traversing",
                "content": "```\\nint sum = 0;\\n        while(startPos[0] < homePos[0])\\n        {\\n            int num = startPos[0] + 1;\\n            sum = sum + rowCosts[num];\\n            startPos[0]++;\\n        }\\n        while(startPos[0] > homePos[0])\\n        {\\n            int num = startPos[0] - 1;\\n            sum = sum + rowCosts[num];\\n            startPos[0]--;\\n        }\\n        while(startPos[1] > homePos[1])\\n        {\\n            int num = startPos[1] - 1;\\n            sum = sum + colCosts[num];\\n            startPos[1]--;\\n        }\\n        while(startPos[1] < homePos[1])\\n        {\\n            int num = startPos[1] + 1;\\n            sum = sum + colCosts[num];\\n            startPos[1]++;\\n        }\\n        return sum;\\n```",
                "solutionTags": [
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nint sum = 0;\\n        while(startPos[0] < homePos[0])\\n        {\\n            int num = startPos[0] + 1;\\n            sum = sum + rowCosts[num];\\n            startPos[0]++;\\n        }\\n        while(startPos[0] > homePos[0])\\n        {\\n            int num = startPos[0] - 1;\\n            sum = sum + rowCosts[num];\\n            startPos[0]--;\\n        }\\n        while(startPos[1] > homePos[1])\\n        {\\n            int num = startPos[1] - 1;\\n            sum = sum + colCosts[num];\\n            startPos[1]--;\\n        }\\n        while(startPos[1] < homePos[1])\\n        {\\n            int num = startPos[1] + 1;\\n            sum = sum + colCosts[num];\\n            startPos[1]++;\\n        }\\n        return sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129641,
                "title": "c-start-thinking-as-quarter-easy-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tif(startPos[0]<homePos[0]){\\n\\t\\t\\t\\t\\tfor(int i=startPos[0]+1; i<=homePos[0]; i++){\\n\\t\\t\\t\\t\\t\\tres += rowCosts[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tfor(int i=startPos[0]-1; i>=homePos[0]; i--){\\n\\t\\t\\t\\t\\t\\tres += rowCosts[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(startPos[1]<homePos[1]){\\n\\t\\t\\t\\t\\tfor(int i=startPos[1]+1; i<=homePos[1]; i++){\\n\\t\\t\\t\\t\\t\\tres += colCosts[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tfor(int i=startPos[1]-1; i>=homePos[1]; i--){\\n\\t\\t\\t\\t\\t\\tres += colCosts[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tif(startPos[0]<homePos[0]){\\n\\t\\t\\t\\t\\tfor(int i=startPos[0]+1; i<=homePos[0]; i++){\\n\\t\\t\\t\\t\\t\\tres += rowCosts[i];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2044131,
                "title": "c-observation-easy",
                "content": "**Observation :**\\n \\n    1. Here every cell don\\'t have it\\'s own cost instead we are given rows and columns costs. This indirectly means that, path doesn\\'t matter as long as we are reaching home[destination].\\n    \\n    2. Here home can be anywhere in the matrix... \\n        For eg : Sample Test home is on right side frome source, so it doesn\\'t mean it always on the right side...\\n        It can be anywhere\\n        \\n        so we can\\'t bound ourselves to only go right, down side...\\n        \\n    Approach : It\\'s pretty straightforward to get the minimum cost, we just need to reach the home..\\n    We just need to calculate the how many rows and columns we need to reach home...\\n    \\n    Here we using min and max function because if \\n    \\n    source ---> destination is like this means starPos occur before homePos then we simply can go startPos to homePos\\n    \\n    but what if destination <---- source is like this means startPos occur after homePos then, we simply need to go destination to source as on left side index is smaller and on right side index is bigger...\\n**Code :**\\n```\\nclass Solution {\\npublic:  \\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        for(int i = min(startPos[0], homePos[0]); i <= max(startPos[0], homePos[0]); i++) \\n\\t\\t\\tcost += rowCosts[i];\\n        for(int j = min(startPos[1], homePos[1]); j <= max(startPos[1], homePos[1]); j++) \\n\\t\\t\\tcost += colCosts[j];\\n        return cost - rowCosts[startPos[0]] - colCosts[startPos[1]]; // subtracting cost of initial position...\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:  \\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        for(int i = min(startPos[0], homePos[0]); i <= max(startPos[0], homePos[0]); i++) \\n\\t\\t\\tcost += rowCosts[i];\\n        for(int j = min(startPos[1], homePos[1]); j <= max(startPos[1], homePos[1]); j++) \\n\\t\\t\\tcost += colCosts[j];\\n        return cost - rowCosts[startPos[0]] - colCosts[startPos[1]]; // subtracting cost of initial position...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969592,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        rowSum = sum(rowCosts[min(startPos[0], homePos[0]):max(homePos[0], startPos[0]) + 1])\\n        colSum = sum(colCosts[min(startPos[1], homePos[1]):max(homePos[1], startPos[1]) + 1])\\n        if rowSum > 0:\\n            rowSum -= rowCosts[startPos[0]]\\n        if colSum > 0:\\n            colSum -= colCosts[startPos[1]]\\n    \\n        \\n        return rowSum + colSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        rowSum = sum(rowCosts[min(startPos[0], homePos[0]):max(homePos[0], startPos[0]) + 1])\\n        colSum = sum(colCosts[min(startPos[1], homePos[1]):max(homePos[1], startPos[1]) + 1])\\n        if rowSum > 0:\\n            rowSum -= rowCosts[startPos[0]]\\n        if colSum > 0:\\n            colSum -= colCosts[startPos[1]]\\n    \\n        \\n        return rowSum + colSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853862,
                "title": "easy-to-understand-maths-no-dfs-no-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& start, vector<int>& home, vector<int>& rc, vector<int>& cc) {\\n        int ans=0;\\n        int c=(home[0]>start[0])?1:-1;\\n        for(int i=start[0]; i!=home[0]; i+=c){\\n            ans+=rc[i+c];\\n        }\\n        c=(home[1]>start[1])?1:-1;\\n        for(int i=start[1]; i!=home[1]; i+=c){\\n            ans+=cc[i+c];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& start, vector<int>& home, vector<int>& rc, vector<int>& cc) {\\n        int ans=0;\\n        int c=(home[0]>start[0])?1:-1;\\n        for(int i=start[0]; i!=home[0]; i+=c){\\n            ans+=rc[i+c];\\n        }\\n        c=(home[1]>start[1])?1:-1;\\n        for(int i=start[1]; i!=home[1]; i+=c){\\n            ans+=cc[i+c];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778837,
                "title": "c-mathematical-o-n",
                "content": "Not a DP problem, Just a simple mathematics.\\n>Hint: Cost for each row or col is same throughout.\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& row, vector<int>& col) {\\n        int r=row.size(),c=col.size();\\n        int res=0,k;\\n        //row\\n        if(startPos[0] < homePos[0]) k=1;\\n        else k=-1;\\n        for(int i=startPos[0]; i!=homePos[0]; i+=k) res+=row[i+k];\\n        //col\\n        if(startPos[1] < homePos[1]) k=1;\\n        else k=-1;\\n        for(int i=startPos[1]; i!=homePos[1]; i+=k) res+=col[i+k];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& row, vector<int>& col) {\\n        int r=row.size(),c=col.size();\\n        int res=0,k;\\n        //row\\n        if(startPos[0] < homePos[0]) k=1;\\n        else k=-1;\\n        for(int i=startPos[0]; i!=homePos[0]; i+=k) res+=row[i+k];\\n        //col\\n        if(startPos[1] < homePos[1]) k=1;\\n        else k=-1;\\n        for(int i=startPos[1]; i!=homePos[1]; i+=k) res+=col[i+k];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772037,
                "title": "python-one-liner",
                "content": "I initially started out with Dijkstra, but got TLE. The complexity of Dijkstra is O(E\\\\*logV) which comes out to be 4\\\\*m\\\\*n * log(m\\\\*n). So, yep Dikstra fails. I should have checked this time complexity before implementation.\\n\\nSo, the actual tricck in the problem is to traverse all rows and all columns between start and end. This is very easy to do in python.\\n\\nAlso note that we are adding left to right and right to left both as one of them would be 0.\\n\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:        \\n        (x, y) = startPos\\n        (lx, ly) = homePos\\n        return sum(rowCosts[x+1:lx+1]) + sum(colCosts[y+1:ly+1]) + sum(rowCosts[lx:x]) + sum(colCosts[ly:y])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:        \\n        (x, y) = startPos\\n        (lx, ly) = homePos\\n        return sum(rowCosts[x+1:lx+1]) + sum(colCosts[y+1:ly+1]) + sum(rowCosts[lx:x]) + sum(colCosts[ly:y])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742282,
                "title": "greedy-approach-very-easy-to-understand-c",
                "content": "class Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& row, vector<int>& col) {\\n        \\n        int i=startPos[0];\\n        int j=startPos[1];\\n        int u=homePos[0];\\n        int v=homePos[1];\\n        \\n        int cost = 0;\\n        while (i != u) {\\n            if (i < u) cost += row[++i];\\n            if (u < i) cost += row[--i];\\n        }\\n        while (j != v) {\\n            if (j < v) cost += col[++j];\\n            if (v < j) cost += col[--j];\\n        }\\n        return cost;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& row, vector<int>& col) {\\n        \\n        int i=startPos[0];\\n        int j=startPos[1];\\n        int u=homePos[0];\\n        int v=homePos[1];\\n        \\n        int cost = 0;\\n        while (i != u) {\\n            if (i < u) cost += row[++i];\\n            if (u < i) cost += row[--i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1695689,
                "title": "2-line-smple-python-solution-beat-99-91",
                "content": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        [x, y], [a, b] = startPos, homePos\\n        return sum(rowCosts[min(x, a): max(x, a) + 1]) + sum(colCosts[min(y, b): max(y, b) + 1]) - rowCosts[x] - colCosts[y]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        [x, y], [a, b] = startPos, homePos\\n        return sum(rowCosts[min(x, a): max(x, a) + 1]) + sum(colCosts[min(y, b): max(y, b) + 1]) - rowCosts[x] - colCosts[y]",
                "codeTag": "Java"
            },
            {
                "id": 1622342,
                "title": "how-many-people-directly-jumped-into-dijkstra-lol",
                "content": "Dijkstra will LTE. \\n Just array traverse, will beat 99%\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n   \\n        // It\\'s a little annoying here.\\n        int rowStart = homePos[0] > startPos[0] ? startPos[0] + 1 : homePos[0];\\n        int rowEnd = homePos[0] > startPos[0] ? homePos[0] : startPos[0] - 1;\\n        \\n        int colStart = homePos[1] > startPos[1] ? startPos[1] + 1 : homePos[1];\\n        int colEnd = homePos[1] > startPos[1] ? homePos[1] : startPos[1] - 1;\\n    \\n        int res = 0;\\n        for (int i = rowStart; i <= rowEnd; i++) {\\n            res += rowCosts[i];\\n        }\\n        \\n         for (int i = colStart; i <= colEnd; i++) {\\n            res += colCosts[i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n   \\n        // It\\'s a little annoying here.\\n        int rowStart = homePos[0] > startPos[0] ? startPos[0] + 1 : homePos[0];\\n        int rowEnd = homePos[0] > startPos[0] ? homePos[0] : startPos[0] - 1;\\n        \\n        int colStart = homePos[1] > startPos[1] ? startPos[1] + 1 : homePos[1];\\n        int colEnd = homePos[1] > startPos[1] ? homePos[1] : startPos[1] - 1;\\n    \\n        int res = 0;\\n        for (int i = rowStart; i <= rowEnd; i++) {\\n            res += rowCosts[i];\\n        }\\n        \\n         for (int i = colStart; i <= colEnd; i++) {\\n            res += colCosts[i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607550,
                "title": "c-difficulty-of-this-question-is-just-a-bluff",
                "content": "The shortest path is the cheapest path\\n```\\n\\tint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ret = 0;\\n        while(startPos[0]<homePos[0])\\n            ret += rowCosts[++startPos[0]];\\n        while(startPos[0]>homePos[0])\\n            ret += rowCosts[--startPos[0]];\\n        while(startPos[1]<homePos[1])\\n            ret += colCosts[++startPos[1]];\\n        while(startPos[1]>homePos[1])\\n            ret += colCosts[--startPos[1]];\\n        return ret;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ret = 0;\\n        while(startPos[0]<homePos[0])\\n            ret += rowCosts[++startPos[0]];\\n        while(startPos[0]>homePos[0])\\n            ret += rowCosts[--startPos[0]];\\n        while(startPos[1]<homePos[1])\\n            ret += colCosts[++startPos[1]];\\n        while(startPos[1]>homePos[1])\\n            ret += colCosts[--startPos[1]];\\n        return ret;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605831,
                "title": "simple-and-easy-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int r1 = min(startPos[0],homePos[0]);\\n        int r2 = max(startPos[0],homePos[0]);\\n        \\n        int c1 = min(startPos[1],homePos[1]);\\n        int c2 = max(startPos[1],homePos[1]);\\n        \\n        int cost = 0;\\n        //HOME IS IN THE RIGHT SIDE\\n        if(startPos[0] == r1) for(int i=r1+1; i<=r2; i++) cost += rowCosts[i];\\n        if(startPos[1] == c1) for(int i=c1+1; i<=c2; i++) cost += colCosts[i];\\n        \\n        //HOME IS THE LEFT SIDE AND ROBOT IS IN THE RIGHT SIDE\\n        if(homePos[0] == r1) for(int i=r1; i<=r2-1; i++) cost += rowCosts[i];\\n        if(homePos[1] == c1) for(int i=c1; i<=c2-1; i++) cost += colCosts[i];\\n        \\n        return cost;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int r1 = min(startPos[0],homePos[0]);\\n        int r2 = max(startPos[0],homePos[0]);\\n        \\n        int c1 = min(startPos[1],homePos[1]);\\n        int c2 = max(startPos[1],homePos[1]);\\n        \\n        int cost = 0;\\n        //HOME IS IN THE RIGHT SIDE\\n        if(startPos[0] == r1) for(int i=r1+1; i<=r2; i++) cost += rowCosts[i];\\n        if(startPos[1] == c1) for(int i=c1+1; i<=c2; i++) cost += colCosts[i];\\n        \\n        //HOME IS THE LEFT SIDE AND ROBOT IS IN THE RIGHT SIDE\\n        if(homePos[0] == r1) for(int i=r1; i<=r2-1; i++) cost += rowCosts[i];\\n        if(homePos[1] == c1) for(int i=c1; i<=c2-1; i++) cost += colCosts[i];\\n        \\n        return cost;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1605602,
                "title": "go-golang",
                "content": "```\\nfunc minCost(startPos []int, homePos []int, rowCosts []int, colCosts []int) int {\\n\\tcolChangeCost, rowChangeCost := 0, 0\\n\\tstartCol, finishCol := startPos[1], homePos[1]\\n\\tstartRow, finishRow := startPos[0], homePos[0]\\n\\n\\tfor col := startCol; col != finishCol; {\\n\\t\\tif startCol < finishCol {\\n\\t\\t\\tcol++\\n\\t\\t} else {\\n\\t\\t\\tcol--\\n\\t\\t}\\n\\n\\t\\tcolChangeCost += colCosts[col]\\n\\t}\\n\\n\\tfor row := startRow; row != finishRow; {\\n\\t\\tif startRow < finishRow {\\n\\t\\t\\trow++\\n\\t\\t} else {\\n\\t\\t\\trow--\\n\\t\\t}\\n\\n\\t\\trowChangeCost += rowCosts[row]\\n\\t}\\n\\n\\treturn colChangeCost + rowChangeCost\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minCost(startPos []int, homePos []int, rowCosts []int, colCosts []int) int {\\n\\tcolChangeCost, rowChangeCost := 0, 0\\n\\tstartCol, finishCol := startPos[1], homePos[1]\\n\\tstartRow, finishRow := startPos[0], homePos[0]\\n\\n\\tfor col := startCol; col != finishCol; {\\n\\t\\tif startCol < finishCol {\\n\\t\\t\\tcol++\\n\\t\\t} else {\\n\\t\\t\\tcol--\\n\\t\\t}\\n\\n\\t\\tcolChangeCost += colCosts[col]\\n\\t}\\n\\n\\tfor row := startRow; row != finishRow; {\\n\\t\\tif startRow < finishRow {\\n\\t\\t\\trow++\\n\\t\\t} else {\\n\\t\\t\\trow--\\n\\t\\t}\\n\\n\\t\\trowChangeCost += rowCosts[row]\\n\\t}\\n\\n\\treturn colChangeCost + rowChangeCost\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605161,
                "title": "c-easy-solution-100-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(startPos[1]>homePos[1])\\n        {\\n            for(int i=startPos[1]-1;i>=homePos[1];i--)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else if(startPos[1]<homePos[1])\\n        {\\n            for(int i=startPos[1]+1;i<=homePos[1];i++)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        if(startPos[0]>homePos[0])\\n        {\\n            for(int i=startPos[0]-1;i>=homePos[0];i--)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else if(startPos[0]<homePos[0])\\n        {\\n            for(int i=startPos[0]+1;i<=homePos[0];i++)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        if(startPos[1]>homePos[1])\\n        {\\n            for(int i=startPos[1]-1;i>=homePos[1];i--)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else if(startPos[1]<homePos[1])\\n        {\\n            for(int i=startPos[1]+1;i<=homePos[1];i++)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        if(startPos[0]>homePos[0])\\n        {\\n            for(int i=startPos[0]-1;i>=homePos[0];i--)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else if(startPos[0]<homePos[0])\\n        {\\n            for(int i=startPos[0]+1;i<=homePos[0];i++)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604280,
                "title": "linear-solution-95-speed",
                "content": "![image](https://assets.leetcode.com/users/images/35bf4c13-9247-4a41-9d04-acacfe27a780_1638278678.2671573.png)\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        if startPos[0] < homePos[0]:\\n            cost += sum(rowCosts[r] for r in range(startPos[0] + 1,\\n                                                   homePos[0] + 1))\\n        elif startPos[0] > homePos[0]:\\n            cost += sum(rowCosts[r] for r in range(startPos[0] - 1,\\n                                                   homePos[0] - 1, -1))\\n        if startPos[1] < homePos[1]:\\n            cost += sum(colCosts[c] for c in range(startPos[1] + 1,\\n                                                   homePos[1] + 1))\\n        elif startPos[1] > homePos[1]:\\n            cost += sum(colCosts[c] for c in range(startPos[1] - 1,\\n                                                   homePos[1] - 1, -1))\\n        return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        if startPos[0] < homePos[0]:\\n            cost += sum(rowCosts[r] for r in range(startPos[0] + 1,\\n                                                   homePos[0] + 1))\\n        elif startPos[0] > homePos[0]:\\n            cost += sum(rowCosts[r] for r in range(startPos[0] - 1,\\n                                                   homePos[0] - 1, -1))\\n        if startPos[1] < homePos[1]:\\n            cost += sum(colCosts[c] for c in range(startPos[1] + 1,\\n                                                   homePos[1] + 1))\\n        elif startPos[1] > homePos[1]:\\n            cost += sum(colCosts[c] for c in range(startPos[1] - 1,\\n                                                   homePos[1] - 1, -1))\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602978,
                "title": "python-one-liner-o-m-n-explained-faster-than-100",
                "content": "* There may be multiple shortest paths, but no matter how you choose, the total cost is the same. \\n* Therefore, one of the feasible solutions is to first move to the target row in a straight line, and then move to the target column in a straight line.\\n* Just note that the start pos should not be added to the total cost.\\n```\\nclass Solution(object):\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n\\t\\treturn sum(rowCosts[min(startPos[0], homePos[0]): max(startPos[0], homePos[0]) + 1]) - rowCosts[startPos[0]] + sum(colCosts[min(startPos[1], homePos[1]): max(startPos[1], homePos[1]) + 1]) - colCosts[startPos[1]]\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n\\t\\treturn sum(rowCosts[min(startPos[0], homePos[0]): max(startPos[0], homePos[0]) + 1]) - rowCosts[startPos[0]] + sum(colCosts[min(startPos[1], homePos[1]): max(startPos[1], homePos[1]) + 1]) - colCosts[startPos[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602713,
                "title": "c-152ms-100-iterative",
                "content": "\\nRuntime: 152 ms, faster than 100.00% of C++ online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\nMemory Usage: 150 MB, less than 25.00% of C++ online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\n```\\nclass Solution {\\npublic:\\n  int minCost(vector<int>& sP, vector<int>& hP, vector<int>& rC, vector<int>& cC) {\\n    int def = 0;\\n    if     (sP[1] < hP[1]) for(int i = sP[1] + 1; i <= hP[1]  ;i++) def += cC[i];\\n    else if(sP[1] > hP[1]) for(int i = sP[1] - 1; i >= hP[1]  ;i--) def += cC[i];    \\n    \\n    if     (sP[0] < hP[0]) for(int i = sP[0] + 1; i <= hP[0]  ;i++) def += rC[i];\\n    else if(sP[0] > hP[0]) for(int i = sP[0] - 1; i >= hP[0]  ;i--) def += rC[i];    \\n    \\n    return def;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minCost(vector<int>& sP, vector<int>& hP, vector<int>& rC, vector<int>& cC) {\\n    int def = 0;\\n    if     (sP[1] < hP[1]) for(int i = sP[1] + 1; i <= hP[1]  ;i++) def += cC[i];\\n    else if(sP[1] > hP[1]) for(int i = sP[1] - 1; i >= hP[1]  ;i--) def += cC[i];    \\n    \\n    if     (sP[0] < hP[0]) for(int i = sP[0] + 1; i <= hP[0]  ;i++) def += rC[i];\\n    else if(sP[0] > hP[0]) for(int i = sP[0] - 1; i >= hP[0]  ;i--) def += rC[i];    \\n    \\n    return def;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602413,
                "title": "simple-python-solution-less-than-100-00-faster-than-100-00-with-explanation",
                "content": "\\'\\'\\'\\n\\t******Author : cyberkid05******\\n\\'\\'\\'\\n\\n```\\n# Runtime: 1476 ms, faster than 100.00% of Python3 online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\n# Memory Usage: 28.6 MB, less than 100.00% of Python3 online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\n\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        a, b = startPos[0], startPos[1]\\n        c, d = homePos[0], homePos[1]\\n        ans = 0\\n        while c > a:    # if home is below start then go downwards\\n            ans += rowCosts[a + 1]\\n            a += 1\\n        while c < a:    # if home is above start then go upwards\\n            ans += rowCosts[a - 1]\\n            a -= 1\\n        while d > b:    # if home is right side of start then go rightwards\\n            ans += colCosts[b + 1]\\n            b += 1\\n        while d < b:    # if home is in left side of start then go leftwards\\n            ans += colCosts[b - 1]\\n            b -= 1\\n        return ans\\n```\\n\\n**SMALLER VERSION **\\n\\n```\\nclass Solution:\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        ans = 0\\n        a, b = startPos; c, d = homePos;\\n        while c > a: a += 1; ans += rowCosts[a];\\n        while c < a: a -= 1; ans += rowCosts[a];\\n        while d > b: b += 1; ans += colCosts[b];\\n        while d < b: b -= 1; ans += colCosts[b];\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\n# Runtime: 1476 ms, faster than 100.00% of Python3 online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\n# Memory Usage: 28.6 MB, less than 100.00% of Python3 online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\n\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        a, b = startPos[0], startPos[1]\\n        c, d = homePos[0], homePos[1]\\n        ans = 0\\n        while c > a:    # if home is below start then go downwards\\n            ans += rowCosts[a + 1]\\n            a += 1\\n        while c < a:    # if home is above start then go upwards\\n            ans += rowCosts[a - 1]\\n            a -= 1\\n        while d > b:    # if home is right side of start then go rightwards\\n            ans += colCosts[b + 1]\\n            b += 1\\n        while d < b:    # if home is in left side of start then go leftwards\\n            ans += colCosts[b - 1]\\n            b -= 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        ans = 0\\n        a, b = startPos; c, d = homePos;\\n        while c > a: a += 1; ans += rowCosts[a];\\n        while c < a: a -= 1; ans += rowCosts[a];\\n        while d > b: b += 1; ans += colCosts[b];\\n        while d < b: b -= 1; ans += colCosts[b];\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600808,
                "title": "easy-java-solution-faster-than-100",
                "content": "**Approach :\"**\\n**Since from any source position to the destination all rows between need to be travelled and all columns in between also need to be travelled so just travel based on housepos and robotpos and calculate the cost that is our answer**\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int ans=0;\\n        if(homePos[0]>startPos[0]){\\n            for(int i=startPos[0]+1;i<=homePos[0];i++){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i=startPos[0]-1;i>=homePos[0];i--){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(homePos[1]>startPos[1]){\\n            for(int i=startPos[1]+1;i<=homePos[1];i++){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i=startPos[1]-1;i>=homePos[1];i--){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int ans=0;\\n        if(homePos[0]>startPos[0]){\\n            for(int i=startPos[0]+1;i<=homePos[0];i++){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i=startPos[0]-1;i>=homePos[0];i--){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(homePos[1]>startPos[1]){\\n            for(int i=startPos[1]+1;i<=homePos[1];i++){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i=startPos[1]-1;i>=homePos[1];i--){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600670,
                "title": "c-short-elegant-linear-156ms-solution-explained-100-time-50-space",
                "content": "I have to admit that I pondered solving this problem with a DP approach way too much, despite having noticed the constraints pretty soon and knowing it would never work if both dimensiones were to be considered close to their upper limits.\\n\\nThen it dawned to me just looking at the picture of the first tiny example:\\n![image](https://assets.leetcode.com/users/images/f5dbc811-cd45-49b4-82cb-398f82c984ec_1638094986.080866.png)\\n\\nNo matter what, we will always have to move AT LEAST one step down and  steps right from the starting point, no matter what. And since the costs are never going to be negative, even if moving to upper rows or columns to the left was an option, it would at best cost `0` if not more on top of our mininum cost of just moving directly (in any order of moves) from the starting to the ending point.\\n\\nWith that clarified, the solution becomes actually rather trivial.\\n\\nWe can start declaring five support variables:\\n* `x1`, `y1`, `x2` and `y2` are the coordinates of our starting ending points;\\n* `res` is our total cost, initialised to be the negative cost of our starting point (to simplify computation later).\\n\\nWe will then make sure that we are having both `x1` an `y1` as lower values, again, just to simplify our logic.\\n\\nAll that is left now, is to move from `x1` to `x2` and from `y1` to `y2` (both ending coordinates included) and add the cost of each step accordingly to `res`.\\n\\nOnce done, we will have the cost of the whole path (ignoring the one of the starting point we subtracted initially) and then we can just have to `return` `res` :)\\n\\nThe code (with performance varying wildly with the test cases):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& endPos, vector<int>& rc, vector<int>& cc) {\\n        // support variables\\n        int x1 = startPos[1], x2 = endPos[1], y1 = startPos[0], y2 = endPos[0], res = - cc[x1] - rc[y1];\\n        // making sure we start with the lower value on both axes\\n        if (x1 > x2) swap(x1, x2);\\n        if (y1 > y2) swap(y1, y2);\\n        // increasing the counter\\n        while (x1 <= x2) {\\n            res += cc[x1++];\\n        }\\n        while (y1 <= y2) {\\n            res += rc[y1++];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative take with the same logic, just made more concise for fun:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& endPos, vector<int>& rc, vector<int>& cc) {\\n        // support variables\\n        int x1 = startPos[1], x2 = endPos[1], y1 = startPos[0], y2 = endPos[0], res = - cc[x1] - rc[y1];\\n        // increasing the counter\\n        res += accumulate(begin(cc) + min(x1++, x2++), begin(cc) + max(x1, x2), 0);\\n        res += accumulate(begin(rc) + min(y1++, y2++), begin(rc) + max(y1, y2), 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& endPos, vector<int>& rc, vector<int>& cc) {\\n        // support variables\\n        int x1 = startPos[1], x2 = endPos[1], y1 = startPos[0], y2 = endPos[0], res = - cc[x1] - rc[y1];\\n        // making sure we start with the lower value on both axes\\n        if (x1 > x2) swap(x1, x2);\\n        if (y1 > y2) swap(y1, y2);\\n        // increasing the counter\\n        while (x1 <= x2) {\\n            res += cc[x1++];\\n        }\\n        while (y1 <= y2) {\\n            res += rc[y1++];\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& endPos, vector<int>& rc, vector<int>& cc) {\\n        // support variables\\n        int x1 = startPos[1], x2 = endPos[1], y1 = startPos[0], y2 = endPos[0], res = - cc[x1] - rc[y1];\\n        // increasing the counter\\n        res += accumulate(begin(cc) + min(x1++, x2++), begin(cc) + max(x1, x2), 0);\\n        res += accumulate(begin(rc) + min(y1++, y2++), begin(rc) + max(y1, y2), 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600669,
                "title": "easy-to-understand-best-ever-code-c-greedy",
                "content": "**Intution:** you have to cross  every row and col atleast once , so just add up cost from start to end row and start to end col ,and  after that subtract the cost of start row and column.\\n**C++:**\\n```\\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        int rmin = min(startPos[0],homePos[0]);\\n        int rmax = max(startPos[0],homePos[0]);\\n        int cmin = min(startPos[1],homePos[1]);\\n        int cmax = max(startPos[1],homePos[1]);\\n        \\n        for(int i = rmin;i<=rmax;i++)\\n            ans += rowCosts[i];\\n        for(int i = cmin;i<=cmax;i++)\\n            ans += colCosts[i];\\n        \\n        ans -= rowCosts[startPos[0]];\\n        ans -= colCosts[startPos[1]];\\n        \\n        return ans;\\n    }\\n\\n```\\n**PS**: Upvote if it helps",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        int rmin = min(startPos[0],homePos[0]);\\n        int rmax = max(startPos[0],homePos[0]);\\n        int cmin = min(startPos[1],homePos[1]);\\n        int cmax = max(startPos[1],homePos[1]);\\n        \\n        for(int i = rmin;i<=rmax;i++)\\n            ans += rowCosts[i];\\n        for(int i = cmin;i<=cmax;i++)\\n            ans += colCosts[i];\\n        \\n        ans -= rowCosts[startPos[0]];\\n        ans -= colCosts[startPos[1]];\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600223,
                "title": "java-simple-solution",
                "content": "**Runtime: 1 ms, faster than 100.00% of Java online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\nMemory Usage: 53.8 MB, less than 50.00% of Java online submissions for Minimum Cost Homecoming of a Robot in a Grid.**\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int[] x = new int[]{startPos[0],homePos[0]};\\n        int[] y = new int[]{startPos[1],homePos[1]};\\n        \\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        \\n        int sum = 0;\\n        for(int i = x[0];i<=x[1];i++)sum+=rowCosts[i];\\n        for(int i = y[0];i<=y[1];i++)sum+=colCosts[i];\\n        sum -= (rowCosts[startPos[0]] + colCosts[startPos[1]]);\\n        \\n        return sum;\\n    }\\n}\\n```\\n\\n**Without Sort:\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Minimum Cost Homecoming of a Robot in a Grid.\\nMemory Usage: 53.5 MB, less than 50.00% of Java online submissions for Minimum Cost Homecoming of a Robot in a Grid.**\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int startr = Math.min(startPos[0],homePos[0]);\\n        int endr = Math.max(startPos[0],homePos[0]);\\n        \\n        int startc = Math.min(startPos[1],homePos[1]);\\n        int endc = Math.max(startPos[1],homePos[1]);\\n        \\n        int sum = 0;\\n        for(int i = startr;i<=endr;i++){\\n            sum += rowCosts[i];\\n        }\\n        \\n        for(int i = startc;i<=endc;i++){\\n            sum += colCosts[i];\\n        }\\n        \\n        sum -= rowCosts[startPos[0]] + colCosts[startPos[1]];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int[] x = new int[]{startPos[0],homePos[0]};\\n        int[] y = new int[]{startPos[1],homePos[1]};\\n        \\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        \\n        int sum = 0;\\n        for(int i = x[0];i<=x[1];i++)sum+=rowCosts[i];\\n        for(int i = y[0];i<=y[1];i++)sum+=colCosts[i];\\n        sum -= (rowCosts[startPos[0]] + colCosts[startPos[1]]);\\n        \\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int startr = Math.min(startPos[0],homePos[0]);\\n        int endr = Math.max(startPos[0],homePos[0]);\\n        \\n        int startc = Math.min(startPos[1],homePos[1]);\\n        int endc = Math.max(startPos[1],homePos[1]);\\n        \\n        int sum = 0;\\n        for(int i = startr;i<=endr;i++){\\n            sum += rowCosts[i];\\n        }\\n        \\n        for(int i = startc;i<=endc;i++){\\n            sum += colCosts[i];\\n        }\\n        \\n        sum -= rowCosts[startPos[0]] + colCosts[startPos[1]];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599585,
                "title": "javascript-greedy-104ms",
                "content": "```\\nconst minCost = (startPos, homePos, rowCosts, colCosts) => {\\n    let [sx, sy] = startPos, [hx, hy] = homePos, res = 0;\\n    while (sx < hx) {\\n        sx++;\\n        res += rowCosts[sx];\\n    }\\n    while (sx > hx) {\\n        sx--;\\n        res += rowCosts[sx];\\n    }\\n    while (sy < hy) {\\n        sy++;\\n        res += colCosts[sy];\\n    }\\n    while (sy > hy) {\\n        sy--;\\n        res += colCosts[sy];\\n    }\\n    return res;\\n};\\n```\\nfirst time DP thinking, but Memory Out\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int n = rowCosts.length, m = colCosts.length;\\n        int[][] dp = new int[n][m];\\n        for (int [] a: dp) Arrays.fill(a, Integer.MAX_VALUE);\\n        int sx = startPos[0], sy = startPos[1], hx = homePos[0], hy = homePos[1];\\n        dp[sx][sy] = 0;\\n        for (int i = sx; i < n; i++) {\\n            for (int j = sy; j < m; j++) operate1(dp, i, j, rowCosts, colCosts);\\n            for (int j = m - 1; j >= 0; j--) operate1(dp, i, j, rowCosts, colCosts);\\n        }\\n        for (int i = sx; i >= 0; i--) {\\n            for (int j = sy; j < m; j++) operate1(dp, i, j, rowCosts, colCosts);\\n            for (int j = m - 1; j >= 0; j--) operate1(dp, i, j, rowCosts, colCosts);\\n        }\\n        return dp[hx][hy];\\n    }\\n    \\n    void operate1 (int[][] dp, int i, int j, int[] rowCosts, int[] colCosts) {\\n         int n = rowCosts.length, m = colCosts.length;\\n         if (i - 1 >= 0 && dp[i - 1][j] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + rowCosts[i]);\\n         if (i + 1 < n && dp[i + 1][j] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + rowCosts[i]);\\n         if (j - 1 >= 0 && dp[i][j - 1] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + colCosts[j]);\\n         if (j + 1 < m && dp[i][j + 1] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + colCosts[j]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst minCost = (startPos, homePos, rowCosts, colCosts) => {\\n    let [sx, sy] = startPos, [hx, hy] = homePos, res = 0;\\n    while (sx < hx) {\\n        sx++;\\n        res += rowCosts[sx];\\n    }\\n    while (sx > hx) {\\n        sx--;\\n        res += rowCosts[sx];\\n    }\\n    while (sy < hy) {\\n        sy++;\\n        res += colCosts[sy];\\n    }\\n    while (sy > hy) {\\n        sy--;\\n        res += colCosts[sy];\\n    }\\n    return res;\\n};\\n```\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int n = rowCosts.length, m = colCosts.length;\\n        int[][] dp = new int[n][m];\\n        for (int [] a: dp) Arrays.fill(a, Integer.MAX_VALUE);\\n        int sx = startPos[0], sy = startPos[1], hx = homePos[0], hy = homePos[1];\\n        dp[sx][sy] = 0;\\n        for (int i = sx; i < n; i++) {\\n            for (int j = sy; j < m; j++) operate1(dp, i, j, rowCosts, colCosts);\\n            for (int j = m - 1; j >= 0; j--) operate1(dp, i, j, rowCosts, colCosts);\\n        }\\n        for (int i = sx; i >= 0; i--) {\\n            for (int j = sy; j < m; j++) operate1(dp, i, j, rowCosts, colCosts);\\n            for (int j = m - 1; j >= 0; j--) operate1(dp, i, j, rowCosts, colCosts);\\n        }\\n        return dp[hx][hy];\\n    }\\n    \\n    void operate1 (int[][] dp, int i, int j, int[] rowCosts, int[] colCosts) {\\n         int n = rowCosts.length, m = colCosts.length;\\n         if (i - 1 >= 0 && dp[i - 1][j] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + rowCosts[i]);\\n         if (i + 1 < n && dp[i + 1][j] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + rowCosts[i]);\\n         if (j - 1 >= 0 && dp[i][j - 1] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + colCosts[j]);\\n         if (j + 1 < m && dp[i][j + 1] != Integer.MAX_VALUE) dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + colCosts[j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599216,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& h, vector<int>& rows, vector<int>& cols) {\\n       int ans = 0;\\n        if (h[0]>=s[0]){\\n            \\n            for (int i =s[0]+1; i<=h[0]; i++){\\n                ans+=rows[i];\\n            }\\n        }\\n        else{\\n            \\n            for (int i =s[0]-1; i>=h[0]; i--){\\n                ans+=rows[i];\\n            }\\n        }\\n         if (h[1]>=s[1]){\\n             \\n            for (int i =s[1]+1; i<=h[1]; i++){\\n                ans+=cols[i];\\n            }\\n        }\\n        else{\\n            \\n            for (int i =s[1]-1; i>=h[1]; i--){\\n                ans+=cols[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& h, vector<int>& rows, vector<int>& cols) {\\n       int ans = 0;\\n        if (h[0]>=s[0]){\\n            \\n            for (int i =s[0]+1; i<=h[0]; i++){\\n                ans+=rows[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1598915,
                "title": "easy-c-choose-any-path-answer-is-same-always",
                "content": "If you choose any Path , answer will be same.  \\nI choose simple just go to from given srcX to destX and given srcY to destY.\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int srcX = startPos[0];\\n        int srcY = startPos[1];\\n        \\n        \\n        int desX = homePos[0];\\n        int desY = homePos[1];\\n        \\n        if(srcX==desX and srcY==desY)\\n            return 0;\\n        int total = 0;\\n        if(desY>srcY)\\n        {\\n            while(srcY!=desY)\\n            {\\n                srcY++;\\n                total += colCosts[srcY];\\n            }\\n        }\\n        else\\n        {\\n            while(srcY!=desY)\\n            {\\n                srcY--;\\n                total += colCosts[srcY];\\n            }\\n        }\\n        // cout<<total<<\" \";\\n        if(desX>srcX)\\n        {\\n            while(srcX!=desX)\\n            {\\n                srcX++;\\n                total += rowCosts[srcX];\\n            }\\n        }\\n        else\\n        {\\n            while(srcX!=desX)\\n            {\\n                srcX--;\\n                total += rowCosts[srcX];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int srcX = startPos[0];\\n        int srcY = startPos[1];\\n        \\n        \\n        int desX = homePos[0];\\n        int desY = homePos[1];\\n        \\n        if(srcX==desX and srcY==desY)\\n            return 0;\\n        int total = 0;\\n        if(desY>srcY)\\n        {\\n            while(srcY!=desY)\\n            {\\n                srcY++;\\n                total += colCosts[srcY];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1598893,
                "title": "c-greedy-o-1-space-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& e, vector<int>& r, vector<int>& c) {\\n        long long sum=0;\\n        if(s[0]>e[0])\\n        {\\n            int idx=s[0];\\n            while(idx!=e[0])\\n            {\\n                sum+=r[--idx];\\n            }\\n        }\\n        else if(s[0]<e[0])\\n        {\\n            int idx=s[0];\\n            while(idx!=e[0])\\n            {\\n                sum+=r[++idx];\\n            }\\n        }\\n        \\n        if(s[1]>e[1])\\n        {\\n            int idx=s[1];\\n            while(idx!=e[1])\\n            {\\n                sum+=c[--idx];\\n            }\\n        }\\n        else if(s[1]<e[1])\\n        {\\n            int idx=s[1];\\n            while(idx!=e[1])\\n            {\\n                sum+=c[++idx];\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& s, vector<int>& e, vector<int>& r, vector<int>& c) {\\n        long long sum=0;\\n        if(s[0]>e[0])\\n        {\\n            int idx=s[0];\\n            while(idx!=e[0])\\n            {\\n                sum+=r[--idx];\\n            }\\n        }\\n        else if(s[0]<e[0])\\n        {\\n            int idx=s[0];\\n            while(idx!=e[0])\\n            {\\n                sum+=r[++idx];\\n            }\\n        }\\n        \\n        if(s[1]>e[1])\\n        {\\n            int idx=s[1];\\n            while(idx!=e[1])\\n            {\\n                sum+=c[--idx];\\n            }\\n        }\\n        else if(s[1]<e[1])\\n        {\\n            int idx=s[1];\\n            while(idx!=e[1])\\n            {\\n                sum+=c[++idx];\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598892,
                "title": "c-2087-minimum-cost-homecoming-of-a-robot-in-a-grid",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0, si = startPos[0], sj = startPos[1], hi = homePos[0], hj = homePos[1], begin = 0, end = 0; \\n        if (si != hi) {\\n            if (si < hi) begin = si+1, end = hi; \\n            else if (si > hi) begin = hi, end = si-1; \\n            for (int i = begin; i <= end; ++i) ans += rowCosts[i]; \\n        }\\n        if (sj != hj) {\\n            if (sj < hj) begin = sj+1, end = hj; \\n            else if (sj > hj) begin = hj, end = sj-1; \\n            for (int j = begin; j <= end; ++j) ans += colCosts[j]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0, si = startPos[0], sj = startPos[1], hi = homePos[0], hj = homePos[1], begin = 0, end = 0; \\n        if (si != hi) {\\n            if (si < hi) begin = si+1, end = hi; \\n            else if (si > hi) begin = hi, end = si-1; \\n            for (int i = begin; i <= end; ++i) ans += rowCosts[i]; \\n        }\\n        if (sj != hj) {\\n            if (sj < hj) begin = sj+1, end = hj; \\n            else if (sj > hj) begin = hj, end = sj-1; \\n            for (int j = begin; j <= end; ++j) ans += colCosts[j]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598866,
                "title": "python3-sum-on-path",
                "content": "Downvoters, leave a comment! \\n\\nFor solutions of biweekly 66, please check out this [commit](https://github.com/gaosanyong/leetcode/commit/2efa877859ad8f79f212b8ebde3edf5730d457ad)\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        ans = 0 \\n        if startPos[0] < homePos[0]: ans = sum(rowCosts[startPos[0]+1:homePos[0]+1])\\n        elif startPos[0] > homePos[0]: ans = sum(rowCosts[homePos[0]:startPos[0]])\\n        if startPos[1] < homePos[1]: ans += sum(colCosts[startPos[1]+1:homePos[1]+1])\\n        elif startPos[1] > homePos[1]: ans += sum(colCosts[homePos[1]:startPos[1]])\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        ans = 0 \\n        if startPos[0] < homePos[0]: ans = sum(rowCosts[startPos[0]+1:homePos[0]+1])\\n        elif startPos[0] > homePos[0]: ans = sum(rowCosts[homePos[0]:startPos[0]])\\n        if startPos[1] < homePos[1]: ans += sum(colCosts[startPos[1]+1:homePos[1]+1])\\n        elif startPos[1] > homePos[1]: ans += sum(colCosts[homePos[1]:startPos[1]])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020265,
                "title": "python-video-walkthrough-time-o-n-space-o-1-one-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/tfklTcI6cJk)\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        return (sum(colCosts[startPos[1]+1:homePos[1]+1]) if homePos[1] > startPos[1] else sum(colCosts[homePos[1]:startPos[1]])) + (sum(rowCosts[startPos[0]+1:homePos[0]+1]) if homePos[0] > startPos[0] else sum(rowCosts[homePos[0]:startPos[0]]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        return (sum(colCosts[startPos[1]+1:homePos[1]+1]) if homePos[1] > startPos[1] else sum(colCosts[homePos[1]:startPos[1]])) + (sum(rowCosts[startPos[0]+1:homePos[0]+1]) if homePos[0] > startPos[0] else sum(rowCosts[homePos[0]:startPos[0]]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018216,
                "title": "ever-thought",
                "content": "```\\n  int minCost(vector<int> &startPos, vector<int> &homePos, vector< int > &rowCosts, vector< int > &colCosts)\\n        {\\n            int a = startPos[0];\\n            int b = homePos[0];\\n            int sum = 0;\\n            if (b > a)\\n                for (int i = b; i > a; i--) sum += rowCosts[i];\\n            else\\n                for (int i = b; i < a; i++) sum += rowCosts[i];\\n            a = startPos[1];\\n            b = homePos[1];\\n            if (b > a)\\n                for (int i = b; i > a; i--) sum += colCosts[i];\\n            else\\n                for (int i = b; i < a; i++) sum += colCosts[i];\\n            return sum;\\n        }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  int minCost(vector<int> &startPos, vector<int> &homePos, vector< int > &rowCosts, vector< int > &colCosts)\\n        {\\n            int a = startPos[0];\\n            int b = homePos[0];\\n            int sum = 0;\\n            if (b > a)\\n                for (int i = b; i > a; i--) sum += rowCosts[i];\\n            else\\n                for (int i = b; i < a; i++) sum += rowCosts[i];\\n            a = startPos[1];\\n            b = homePos[1];\\n            if (b > a)\\n                for (int i = b; i > a; i--) sum += colCosts[i];\\n            else\\n                for (int i = b; i < a; i++) sum += colCosts[i];\\n            return sum;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015481,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int i,m,n,ans;\\n        m=rowCosts.size();\\n        n=colCosts.size();\\n        ans=0;\\n\\n        i=startPos[0];\\n        while(i<homePos[0])\\n        {\\n            ans+=rowCosts[i+1];\\n            i++;\\n        }\\n\\n        while(i>homePos[0])\\n        {\\n            ans+=rowCosts[i-1];\\n            i--;\\n        }\\n\\n        i=startPos[1];\\n        while(i<homePos[1])\\n        {\\n            ans+=colCosts[i+1];\\n            i++;\\n        }\\n\\n        while(i>homePos[1])\\n        {\\n            ans+=colCosts[i-1];\\n            i--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int i,m,n,ans;\\n        m=rowCosts.size();\\n        n=colCosts.size();\\n        ans=0;\\n\\n        i=startPos[0];\\n        while(i<homePos[0])\\n        {\\n            ans+=rowCosts[i+1];\\n            i++;\\n        }\\n\\n        while(i>homePos[0])\\n        {\\n            ans+=rowCosts[i-1];\\n            i--;\\n        }\\n\\n        i=startPos[1];\\n        while(i<homePos[1])\\n        {\\n            ans+=colCosts[i+1];\\n            i++;\\n        }\\n\\n        while(i>homePos[1])\\n        {\\n            ans+=colCosts[i-1];\\n            i--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999588,
                "title": "simplest-solution-o-n-time-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust add all the row cost & column cost between robot pos and home pos.\\nAnd at last subtract the row & col cost of robot pos.\\nYou will get your answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int startRow = min(startPos[0],homePos[0]), \\n            endRow = max(startPos[0],homePos[0]),\\n            startCol = min(startPos[1],homePos[1]),\\n            endCol = max(startPos[1],homePos[1]);\\n        \\n        int ans = 0;\\n        //adding row cost\\n        for(int i=startRow;i<=endRow;i++) ans += rowCosts[i];\\n        ans -= rowCosts[startPos[0]];//removing robot row\\n        //adding col cost\\n        for(int i=startCol;i<=endCol;i++) ans += colCosts[i];\\n        ans -= colCosts[startPos[1]];//removing robot col\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int startRow = min(startPos[0],homePos[0]), \\n            endRow = max(startPos[0],homePos[0]),\\n            startCol = min(startPos[1],homePos[1]),\\n            endCol = max(startPos[1],homePos[1]);\\n        \\n        int ans = 0;\\n        //adding row cost\\n        for(int i=startRow;i<=endRow;i++) ans += rowCosts[i];\\n        ans -= rowCosts[startPos[0]];//removing robot row\\n        //adding col cost\\n        for(int i=startCol;i<=endCol;i++) ans += colCosts[i];\\n        ans -= colCosts[startPos[1]];//removing robot col\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999397,
                "title": "greedy-approach-fast-solution-c-code",
                "content": "# Intuition\\nThink Greedily **Always take a move towards the destination**(Home in this question) \\n\\nAs if we take a move in opposite direction in future we have to make an extra move towards the home \\n\\nThis would be false if the cost for a cell is negative which is not the case in this question\\n\\n# Approach\\nWe will check the direction of home in grid and will make a move as per that weather to go up,down or no move for column or to go left,right or no move for row\\n\\n* Always move in direction of Home caculated by this expression in code **int d = x-i;** (line number - 11)\\n* If already in same row/col no need to make a move as it will only increase cost\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        int x = homePos[0];\\n        int y = homePos[1];\\n        int ans = 0;\\n        while(i!=x || j!=y){\\n            if(i!=x){\\n                int d = x-i;\\n                //right moves\\n                if(d<1){\\n                    ans += rowCosts[i-1];\\n                    i--; \\n                }\\n                //left moves\\n                else{\\n                    ans += rowCosts[i+1];\\n                    i++;\\n                }\\n            }\\n            if(j!=y){\\n                int d = y-j;\\n                //right moves\\n                if(d<1){\\n                    ans += colCosts[j-1];\\n                    j--; \\n                }\\n                //left moves\\n                else{\\n                    ans += colCosts[j+1];\\n                    j++;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        int x = homePos[0];\\n        int y = homePos[1];\\n        int ans = 0;\\n        while(i!=x || j!=y){\\n            if(i!=x){\\n                int d = x-i;\\n                //right moves\\n                if(d<1){\\n                    ans += rowCosts[i-1];\\n                    i--; \\n                }\\n                //left moves\\n                else{\\n                    ans += rowCosts[i+1];\\n                    i++;\\n                }\\n            }\\n            if(j!=y){\\n                int d = y-j;\\n                //right moves\\n                if(d<1){\\n                    ans += colCosts[j-1];\\n                    j--; \\n                }\\n                //left moves\\n                else{\\n                    ans += colCosts[j+1];\\n                    j++;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998048,
                "title": "easy-kotlin-solution-runtime-faster-than-100-00-memory-usage-less-than-100-00",
                "content": "![image](https://assets.leetcode.com/users/images/1365d508-60aa-480d-bf27-cbec4bdc3138_1693760354.200806.png)\\n\\n```\\nfun minCost(startPos: IntArray, homePos: IntArray, rowCosts: IntArray, colCosts: IntArray): Int {\\n    var result = 0\\n\\n    // Row cost\\n    if (startPos[0] < homePos[0]) {\\n        for (i in (startPos[0] + 1)..homePos[0]) {\\n            result += rowCosts[i]\\n        }\\n    } else if (startPos[0] > homePos[0]) {\\n        for (i in (startPos[0] - 1) downTo homePos[0]) {\\n            result += rowCosts[i]\\n        }\\n    }\\n\\n    // Column cost\\n    if (startPos[1] < homePos[1]) {\\n        for (i in (startPos[1] + 1)..homePos[1]) {\\n            result += colCosts[i]\\n        }\\n    } else if (startPos[1] > homePos[1]) {\\n        for (i in (startPos[1] - 1) downTo homePos[1]) {\\n            result += colCosts[i]\\n        }\\n    }\\n\\n    return result\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun minCost(startPos: IntArray, homePos: IntArray, rowCosts: IntArray, colCosts: IntArray): Int {\\n    var result = 0\\n\\n    // Row cost\\n    if (startPos[0] < homePos[0]) {\\n        for (i in (startPos[0] + 1)..homePos[0]) {\\n            result += rowCosts[i]\\n        }\\n    } else if (startPos[0] > homePos[0]) {\\n        for (i in (startPos[0] - 1) downTo homePos[0]) {\\n            result += rowCosts[i]\\n        }\\n    }\\n\\n    // Column cost\\n    if (startPos[1] < homePos[1]) {\\n        for (i in (startPos[1] + 1)..homePos[1]) {\\n            result += colCosts[i]\\n        }\\n    } else if (startPos[1] > homePos[1]) {\\n        for (i in (startPos[1] - 1) downTo homePos[1]) {\\n            result += colCosts[i]\\n        }\\n    }\\n\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996771,
                "title": "greedy-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& start, vector<int>& home, vector<int>& rowc, vector<int>& colc) \\n    {\\n        int a=start[0];\\n        int b=start[1];\\n        int x=home[0];\\n        int y=home[1];\\n        int sum=0;\\n        int maxi=INT_MAX;\\n        while(a<x)\\n        {\\n            a++;\\n            sum+=rowc[a];\\n        }\\n        while(a>x)\\n        {\\n            a--;\\n            sum+=rowc[a];\\n        }\\n        while(b<y)\\n        {\\n            b++;\\n            sum+=colc[b];\\n        }\\n        while(b>y)\\n        {\\n            b--;\\n            sum+=colc[b];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& start, vector<int>& home, vector<int>& rowc, vector<int>& colc) \\n    {\\n        int a=start[0];\\n        int b=start[1];\\n        int x=home[0];\\n        int y=home[1];\\n        int sum=0;\\n        int maxi=INT_MAX;\\n        while(a<x)\\n        {\\n            a++;\\n            sum+=rowc[a];\\n        }\\n        while(a>x)\\n        {\\n            a--;\\n            sum+=rowc[a];\\n        }\\n        while(b<y)\\n        {\\n            b++;\\n            sum+=colc[b];\\n        }\\n        while(b>y)\\n        {\\n            b--;\\n            sum+=colc[b];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995313,
                "title": "most-optimized-solution-c-o-row-col-o-1-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        int startRow = startPos[0], startCol = startPos[1], homeRow = homePos[0], homeCol = homePos[1];\\n        while(startRow < homeRow)cost += rowCosts[++startRow];\\n        while(startRow > homeRow)cost += rowCosts[--startRow];\\n        while(startCol < homeCol)cost += colCosts[++startCol];\\n        while(startCol > homeCol)cost += colCosts[--startCol];\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        int startRow = startPos[0], startCol = startPos[1], homeRow = homePos[0], homeCol = homePos[1];\\n        while(startRow < homeRow)cost += rowCosts[++startRow];\\n        while(startRow > homeRow)cost += rowCosts[--startRow];\\n        while(startCol < homeCol)cost += colCosts[++startCol];\\n        while(startCol > homeCol)cost += colCosts[--startCol];\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964087,
                "title": "c-simple-solution-intuitive-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int ans=0;\\n        bool up = startPos[0] >= homePos[0] ? true : false;\\n        bool left = startPos[1] >= homePos[1] ? true : false;\\n\\n        if(up){\\n            for(int i=startPos[0]-1; i>=homePos[0]; i--) ans += rowCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[0]+1; i<=homePos[0]; i++) ans += rowCosts[i];\\n        }\\n\\n        if(left){\\n            for(int i=startPos[1]-1; i>=homePos[1]; i--) ans += colCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[1]+1; i<=homePos[1]; i++) ans += colCosts[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int ans=0;\\n        bool up = startPos[0] >= homePos[0] ? true : false;\\n        bool left = startPos[1] >= homePos[1] ? true : false;\\n\\n        if(up){\\n            for(int i=startPos[0]-1; i>=homePos[0]; i--) ans += rowCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[0]+1; i<=homePos[0]; i++) ans += rowCosts[i];\\n        }\\n\\n        if(left){\\n            for(int i=startPos[1]-1; i>=homePos[1]; i--) ans += colCosts[i];\\n        }\\n        else{\\n            for(int i=startPos[1]+1; i<=homePos[1]; i++) ans += colCosts[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942532,
                "title": "easy-to-understand-solution-python3-73-97",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        distRow, distCol = homePos[0] - startPos[0], homePos[1] - startPos[1]\\n        minirow = min(startPos[0] + distRow, startPos[0])\\n        max_row = max(startPos[0] + distRow, startPos[0])\\n        minicol = min(startPos[1] + distCol, startPos[1])\\n        max_col = max(startPos[1] + distCol, startPos[1])\\n \\n        if distRow > 0:\\n            row_range = sum(rowCosts[minirow + 1:max_row + 1])\\n        elif distRow < 0:\\n            row_range = sum(rowCosts[minirow:max_row])\\n        else:\\n            row_range = 0\\n        if distCol > 0:\\n            col_range = sum(colCosts[minicol + 1:max_col + 1])\\n        elif distCol < 0:\\n            col_range = sum(colCosts[minicol:max_col])\\n        else:\\n            col_range = 0\\n        return row_range + col_range\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        distRow, distCol = homePos[0] - startPos[0], homePos[1] - startPos[1]\\n        minirow = min(startPos[0] + distRow, startPos[0])\\n        max_row = max(startPos[0] + distRow, startPos[0])\\n        minicol = min(startPos[1] + distCol, startPos[1])\\n        max_col = max(startPos[1] + distCol, startPos[1])\\n \\n        if distRow > 0:\\n            row_range = sum(rowCosts[minirow + 1:max_row + 1])\\n        elif distRow < 0:\\n            row_range = sum(rowCosts[minirow:max_row])\\n        else:\\n            row_range = 0\\n        if distCol > 0:\\n            col_range = sum(colCosts[minicol + 1:max_col + 1])\\n        elif distCol < 0:\\n            col_range = sum(colCosts[minicol:max_col])\\n        else:\\n            col_range = 0\\n        return row_range + col_range\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906122,
                "title": "actually-readable-code",
                "content": "# Intuition\\nYou have to observe the constraints are too high for something like Dijkstra\\'s.\\n\\n# Approach\\n**Greedy Approach:** The greedy approach is that you just move towards the goal using the shortest path possible.\\n**Proof:** One might think that we can use backtracking to generate all paths or use graph algorithms. The sole reason something like this came to my mind at first was that we had to minimize the cost. So one might think that going into some direction other than the greedy one could have less cost.\\nBut when you look at any other path you will see that you have to traverse the straight path from starting row to the home row and the starting column to the home column. Every other path you take is some extra steps + this greedy path. So it is best we only do the greedy path.\\n\\n# Complexity\\n- Time complexity:\\nO(Rhome - Rstart + Chome - Cstart)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        x, y = startPos\\n        hx, hy = homePos\\n        while x != hx:\\n            x = x - 1 if hx - x < 0 else x + 1\\n            cost += rowCosts[x]\\n        while y != hy:\\n            y = y - 1 if hy - y < 0 else y + 1\\n            cost += colCosts[y]\\n        return cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        x, y = startPos\\n        hx, hy = homePos\\n        while x != hx:\\n            x = x - 1 if hx - x < 0 else x + 1\\n            cost += rowCosts[x]\\n        while y != hy:\\n            y = y - 1 if hy - y < 0 else y + 1\\n            cost += colCosts[y]\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878613,
                "title": "python-one-line-beats-95-x-simple-maths",
                "content": "as no obstacles, the number of vertical or horizontal moves are fixed and greedily found by the manhattan distance of this 2 point. the 2 point define a sub rectangle , all moves must be made here (or else duplicate and non shortest). Just sum these range of row/col costs, subtract start ones as they arent counted\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        return sum(rowCosts[min(startPos[0],homePos[0]):max(startPos[0],homePos[0])+1]) + sum(colCosts[min(startPos[1],homePos[1]):max(startPos[1],homePos[1])+1]) - rowCosts[startPos[0]] - colCosts[startPos[1]]",
                "solutionTags": [
                    "Math"
                ],
                "code": "as no obstacles, the number of vertical or horizontal moves are fixed and greedily found by the manhattan distance of this 2 point. the 2 point define a sub rectangle , all moves must be made here (or else duplicate and non shortest). Just sum these range of row/col costs, subtract start ones as they arent counted\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        return sum(rowCosts[min(startPos[0],homePos[0]):max(startPos[0],homePos[0])+1]) + sum(colCosts[min(startPos[1],homePos[1]):max(startPos[1],homePos[1])+1]) - rowCosts[startPos[0]] - colCosts[startPos[1]]",
                "codeTag": "Java"
            },
            {
                "id": 3863636,
                "title": "easy-trivial-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int i=startPos[0],j=startPos[1],cost=0;\\n        while(i!=homePos[0]){\\n            if(i<homePos[0])i++;\\n            else i--;\\n            cost+=rowCosts[i];\\n        }\\n        while(j!=homePos[1]){\\n            if(j<homePos[1])j++;\\n            else j--;\\n            cost+=colCosts[j];\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int i=startPos[0],j=startPos[1],cost=0;\\n        while(i!=homePos[0]){\\n            if(i<homePos[0])i++;\\n            else i--;\\n            cost+=rowCosts[i];\\n        }\\n        while(j!=homePos[1]){\\n            if(j<homePos[1])j++;\\n            else j--;\\n            cost+=colCosts[j];\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814699,
                "title": "easy-c-solution-with-intuition-and-approach",
                "content": "# Intuition\\nStarting from (i,j) and moving to (a,b) will require moving to each row between (i and a) and each column between (j and b).\\n\\n# Approach\\nAdding the rowCosts and colCosts accordingly for 4 conditions.\\nAs homePos can lie above and left in the grid of the startPos\\n# Complexity\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minCost(vector<int> &startPos, vector<int> &homePos, vector<int> &rowCosts, vector<int> &colCosts)\\n    {\\n        int a = startPos[0], b = startPos[1];\\n        int m = homePos[0], n = homePos[1];\\n\\n        int cost = 0;\\n\\n        if (a < m)\\n            for (int i = a + 1; i <= m; i++)\\n                cost += rowCosts[i];\\n\\n        else\\n            for (int i = a - 1; i >= m; i--)\\n                cost += rowCosts[i];\\n\\n        if (b < n)\\n            for (int j = b + 1; j <= n; j++)\\n                cost += colCosts[j];\\n\\n        else\\n            for (int j = b - 1; j >= n; j--)\\n                cost += colCosts[j];\\n\\n        return cost;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minCost(vector<int> &startPos, vector<int> &homePos, vector<int> &rowCosts, vector<int> &colCosts)\\n    {\\n        int a = startPos[0], b = startPos[1];\\n        int m = homePos[0], n = homePos[1];\\n\\n        int cost = 0;\\n\\n        if (a < m)\\n            for (int i = a + 1; i <= m; i++)\\n                cost += rowCosts[i];\\n\\n        else\\n            for (int i = a - 1; i >= m; i--)\\n                cost += rowCosts[i];\\n\\n        if (b < n)\\n            for (int j = b + 1; j <= n; j++)\\n                cost += colCosts[j];\\n\\n        else\\n            for (int j = b - 1; j >= n; j--)\\n                cost += colCosts[j];\\n\\n        return cost;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812836,
                "title": "increment-or-decrement-traverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int ans=0;\\n        int i=startPos[0],j=startPos[1],x=homePos[0],y=homePos[1];\\n        int inc=(i<x)?1:-1;\\n        while(i!=homePos[0]){\\n            i+=inc;\\n            ans+=rowCosts[i];\\n        }\\n        inc=(j<y)?1:-1;\\n        while(j!=y)\\n        {\\n            j+=inc;\\n            ans+=colCosts[j];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int ans=0;\\n        int i=startPos[0],j=startPos[1],x=homePos[0],y=homePos[1];\\n        int inc=(i<x)?1:-1;\\n        while(i!=homePos[0]){\\n            i+=inc;\\n            ans+=rowCosts[i];\\n        }\\n        inc=(j<y)?1:-1;\\n        while(j!=y)\\n        {\\n            j+=inc;\\n            ans+=colCosts[j];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747672,
                "title": "js-solution-high-runtime-low-memory",
                "content": "A simple solution that runs in 105ms, but beats 90.5% with memory. If anyone has ideas to make it faster, I\\'m open to suggestions in the comments.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere\\'s really not much problem solving needed here.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply add the row costs and column costs between the bot and home. It doesn\\'t matter what route you take. The most efficient way is the most cost-efficient way \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIdk\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIdk\\n# Code\\n```\\n/**\\n * @param {number[]} startPos\\n * @param {number[]} homePos\\n * @param {number[]} rowCosts\\n * @param {number[]} colCosts\\n * @return {number}\\n */\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    function sumRange(list, a, b) {\\n        let sum = 0;\\n        if (b > a) {\\n            for (let i = a + 1; i <= b; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        } else {\\n            for (let i = b; i <= a - 1; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        }\\n  \\n        return sum;\\n    }   \\n\\n    return sumRange(rowCosts, startPos[0], homePos[0]) + sumRange(colCosts, startPos[1], homePos[1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} startPos\\n * @param {number[]} homePos\\n * @param {number[]} rowCosts\\n * @param {number[]} colCosts\\n * @return {number}\\n */\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    function sumRange(list, a, b) {\\n        let sum = 0;\\n        if (b > a) {\\n            for (let i = a + 1; i <= b; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        } else {\\n            for (let i = b; i <= a - 1; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        }\\n  \\n        return sum;\\n    }   \\n\\n    return sumRange(rowCosts, startPos[0], homePos[0]) + sumRange(colCosts, startPos[1], homePos[1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725606,
                "title": "anyway-cost-will-be-same-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int minCost(vector<int> &s, vector<int> &t, vector< int > &rowCosts, vector< int > &colCosts)\\n        {\\n            int sum = 0;\\n            int row_source = s[0], row_target = t[0];\\n            if (row_source < row_target)\\n            {\\n                for (int i = row_source + 1; i <= row_target; i++)\\n                {\\n                    sum = sum + rowCosts[i];\\n                }\\n            }\\n            else\\n            {\\n                for (int i = row_source - 1; i >= row_target; i--)\\n                {\\n                    sum = sum + rowCosts[i];\\n                }\\n            }\\n\\n            \\n            int col_source = s[1], col_target = t[1];\\n            if (col_source < col_target)\\n            {\\n                for (int i = col_source + 1; i <= col_target; i++)\\n                {\\n                    sum = sum + colCosts[i];\\n                }\\n            }\\n            else\\n            {\\n                for (int i = col_source - 1; i >= col_target; i--)\\n                {\\n                    sum = sum + colCosts[i];\\n                }\\n            }\\n            cout << sum;\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minCost(vector<int> &s, vector<int> &t, vector< int > &rowCosts, vector< int > &colCosts)\\n        {\\n            int sum = 0;\\n            int row_source = s[0], row_target = t[0];\\n            if (row_source < row_target)\\n            {\\n                for (int i = row_source + 1; i <= row_target; i++)\\n                {\\n                    sum = sum + rowCosts[i];\\n                }\\n            }\\n            else\\n            {\\n                for (int i = row_source - 1; i >= row_target; i--)\\n                {\\n                    sum = sum + rowCosts[i];\\n                }\\n            }\\n\\n            \\n            int col_source = s[1], col_target = t[1];\\n            if (col_source < col_target)\\n            {\\n                for (int i = col_source + 1; i <= col_target; i++)\\n                {\\n                    sum = sum + colCosts[i];\\n                }\\n            }\\n            else\\n            {\\n                for (int i = col_source - 1; i >= col_target; i--)\\n                {\\n                    sum = sum + colCosts[i];\\n                }\\n            }\\n            cout << sum;\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3676808,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} startPos\\n * @param {number[]} homePos\\n * @param {number[]} rowCosts\\n * @param {number[]} colCosts\\n * @return {number}\\n */\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let total = 0\\n    let dRow = 1\\n    let dCol = 1\\n    if (homePos[0] < startPos[0]){\\n        dRow = -1\\n    }\\n    if (homePos[1] < startPos[1]){\\n        dCol = -1\\n    }\\n    let currRow = startPos[0]\\n    while (currRow !== homePos[0]){\\n        currRow += dRow\\n        total += rowCosts[currRow]\\n    }\\n    let currCol = startPos[1]\\n    while (currCol !== homePos[1]){\\n        currCol += dCol\\n        total += colCosts[currCol]\\n    }\\n    return total\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} startPos\\n * @param {number[]} homePos\\n * @param {number[]} rowCosts\\n * @param {number[]} colCosts\\n * @return {number}\\n */\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let total = 0\\n    let dRow = 1\\n    let dCol = 1\\n    if (homePos[0] < startPos[0]){\\n        dRow = -1\\n    }\\n    if (homePos[1] < startPos[1]){\\n        dCol = -1\\n    }\\n    let currRow = startPos[0]\\n    while (currRow !== homePos[0]){\\n        currRow += dRow\\n        total += rowCosts[currRow]\\n    }\\n    let currCol = startPos[1]\\n    while (currCol !== homePos[1]){\\n        currCol += dCol\\n        total += colCosts[currCol]\\n    }\\n    return total\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3618174,
                "title": "minimum-cost-for-robot-to-return-home-a-proactive-approach",
                "content": "**Solution**\\n\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        # Extracting variables for better readability\\n        startRow, startCol = startPos\\n        homeRow, homeCol = homePos\\n        \\n        # Calculating the minimum and maximum row/column indices\\n        minRow = min(startRow, homeRow)\\n        maxRow = max(startRow, homeRow)\\n        minCol = min(startCol, homeCol)\\n        maxCol = max(startCol, homeCol)\\n        \\n        # Calculating the cost for row movements\\n        rowMovementCost = sum(rowCosts[minRow : maxRow + 1])\\n        \\n        # Calculating the cost for column movements\\n        colMovementCost = sum(colCosts[minCol : maxCol + 1])\\n        \\n        # Subtracting the cost of the starting position\\n        totalCost = rowMovementCost + colMovementCost - rowCosts[startRow] - colCosts[startCol]\\n        \\n        return totalCost\\n```\\n\\n**Introduction:**\\nIn this article, we will delve into an efficient algorithmic approach to solve the problem of finding the minimum cost for a robot to return home in a grid. We will discuss the logic behind the solution, its effectiveness, the underlying trick, and the time complexity of the algorithm.\\n\\n**Problem Statement:**\\nWe are given an m x n grid, where a robot is initially located at a specific cell and needs to return to its home. The robot can only move up, down, left, or right within the boundaries of the grid. Each movement incurs a cost based on the row or column it traverses. Our goal is to determine the minimum total cost for the robot to reach its home.\\n\\n**Approach**:\\nTo solve this problem, we will employ a straightforward and intuitive approach. The idea is to calculate the total cost by summing the row movement costs and column movement costs, while subtracting the cost of the starting position.\\n\\n1. Extracting Variables:\\n   - We begin by extracting the starting row and column, as well as the home row and column from the provided input.\\n   - This step allows us to use descriptive variable names for improved readability and understanding.\\n\\n2. Calculating Minimum and Maximum Indices:\\n   - We determine the minimum and maximum row and column indices by comparing the starting and home positions.\\n   - These indices help us identify the range of rows and columns that the robot will traverse.\\n\\n3. Calculating Row Movement Cost:\\n   - We sum the row costs within the range of minimum and maximum row indices (inclusive).\\n   - This step provides us with the total cost of moving vertically (up or down) towards the home.\\n\\n4. Calculating Column Movement Cost:\\n   - We sum the column costs within the range of minimum and maximum column indices (inclusive).\\n   - This step provides us with the total cost of moving horizontally (left or right) towards the home.\\n\\n5. Subtracting Starting Position Cost:\\n   - We subtract the cost of the starting position from the total cost.\\n   - This adjustment is necessary since the cost of the starting position is included in both the row and column movement costs.\\n\\n6. Returning the Result:\\n   - We return the calculated total cost, which represents the minimum cost for the robot to return home.\\n\\n**The Trick:**\\nThe key insight in this solution lies in the observation that the minimum cost is obtained by summing the costs of the rows and columns the robot will traverse while subtracting the cost of the starting position. By considering the range between the minimum and maximum indices, we can efficiently calculate the costs for row and column movements.\\n\\n**Time Complexity Analysis:**\\nThe time complexity of this solution is determined by the operations performed during the calculations. Extracting the variables takes constant time, and summing the row and column costs requires traversing their respective ranges. Therefore, the overall time complexity is O(max(m, n)), where m and n represent the dimensions of the grid.\\n\\n**Conclusion:**\\nIn this article, we explored an effective algorithmic approach to solve the problem of finding the minimum cost for a robot to return home in a grid. By summing the costs of row and column movements while considering the starting position cost, we achieved an optimal solution. The simplicity and efficiency of this approach make it a reliable choice for solving similar problems. With a time complexity of O(max(m, n)), this algorithm is well-suited for grids of any size.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        # Extracting variables for better readability\\n        startRow, startCol = startPos\\n        homeRow, homeCol = homePos\\n        \\n        # Calculating the minimum and maximum row/column indices\\n        minRow = min(startRow, homeRow)\\n        maxRow = max(startRow, homeRow)\\n        minCol = min(startCol, homeCol)\\n        maxCol = max(startCol, homeCol)\\n        \\n        # Calculating the cost for row movements\\n        rowMovementCost = sum(rowCosts[minRow : maxRow + 1])\\n        \\n        # Calculating the cost for column movements\\n        colMovementCost = sum(colCosts[minCol : maxCol + 1])\\n        \\n        # Subtracting the cost of the starting position\\n        totalCost = rowMovementCost + colMovementCost - rowCosts[startRow] - colCosts[startCol]\\n        \\n        return totalCost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603760,
                "title": "run-once-on-row-and-col-c-intuitve-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int gaprow = startPos[0] - homePos[0];\\n        int gapcol = startPos[1] - homePos[1];\\n        int dirRow;\\n        int dirCol;\\n        int res = 0;\\n        if(gaprow!=0)\\n            dirRow = gaprow / abs(gaprow);\\n        while(gaprow != 0){\\n            res += rowCosts[startPos[0] - gaprow];\\n            gaprow -= dirRow;\\n        }\\n        if(gapcol!=0)\\n            dirCol = gapcol / abs(gapcol);\\n        while(gapcol != 0){\\n            res += colCosts[startPos[1] - gapcol];\\n            gapcol -= dirCol;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int gaprow = startPos[0] - homePos[0];\\n        int gapcol = startPos[1] - homePos[1];\\n        int dirRow;\\n        int dirCol;\\n        int res = 0;\\n        if(gaprow!=0)\\n            dirRow = gaprow / abs(gaprow);\\n        while(gaprow != 0){\\n            res += rowCosts[startPos[0] - gaprow];\\n            gaprow -= dirRow;\\n        }\\n        if(gapcol!=0)\\n            dirCol = gapcol / abs(gapcol);\\n        while(gapcol != 0){\\n            res += colCosts[startPos[1] - gapcol];\\n            gapcol -= dirCol;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587493,
                "title": "dp-a-problem-which-wasn-t-asked",
                "content": "\\u26A0\\uFE0F WARNING: This is **NOT** the solution of this problem, but a better problem that could have been asked.\\n\\nIn the question the following statement is written:\\n> \\u25CF If the robot moves **up** or **down** into a cell whose row is r, then this move costs rowCosts[r].\\n    \\u25CF If the robot moves **left** or **right** into a cell whose column is c, then this move costs colCosts[c].\\n\\n*Now what would have happend had we changed the above question to the following?:*\\n# $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$ $$\\\\Large\\\\downarrow$$\\n\\n> \\u25CF If the robot moves **LEFT** or **RIGHT** into a cell whose row is r, then this move costs rowCosts[r].\\n    \\u25CF If the robot moves **UP** or **DOWN** into a cell whose column is c, then this move costs colCosts[c].\\n\\nIn this new modified problem, each column does not have a cost to move horizontally but vertically. Similarly each row has a fixed cost for any horizontal movement. This is infinitely better problem since here we have a **choice** to make at each step. Consider the following figure:\\n\\n![kkk.png](https://assets.leetcode.com/users/images/29899d4b-1ab5-411f-b4f6-e1308ecfbb2b_1685660637.1305661.png)\\n\\nHere to reach from A to B  we have two choices. Hence we will apply DP. At each cell we will compare two paths -- directly going one row below or moving laterally in this row and then going one row below.\\n\\nI have given the dynamic programming code of this modified question(with a few assumptions)\\n\\n\\n# Code\\n```\\n\\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n       //assuming that homePos[0]>=startPos[0] && homePos[1]>=startPos[1] for the sake of simplicity.\\n       vector<vector<int>> dp(homePos[0]+1,vector<int>(homePos[1]+1,INT_MAX));\\n       for(int i = 0; i<homePos[1]; i++){\\n           dp[homePos[0]][i]=rowCosts[homePos[0]];\\n       }\\n       dp[homePos[0]][homePos[1]]=0;\\n       for(int i = homePos[0]-1; i>=startPos[0]; i--){\\n           for(int j = startPos[1]; j<=homePos[1]; j++){\\n               for(int K = startPos[1]; K<=homePos[1]; K++){\\n                    if(k==j) dp[i][j] = min(dp[i][j],colCosts[k]+dp[i+1][k]);\\n                    dp[i][j] = min(dp[i][j],rowCosts[i]+colCosts[k]+dp[i+1][k]);\\n               }               \\n           }\\n       }\\n       return dp[startPos[0]][startPos[1]];\\n}\\n\\n\\n```\\n\\nFeel free to discuss this new problem in the comments.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n       //assuming that homePos[0]>=startPos[0] && homePos[1]>=startPos[1] for the sake of simplicity.\\n       vector<vector<int>> dp(homePos[0]+1,vector<int>(homePos[1]+1,INT_MAX));\\n       for(int i = 0; i<homePos[1]; i++){\\n           dp[homePos[0]][i]=rowCosts[homePos[0]];\\n       }\\n       dp[homePos[0]][homePos[1]]=0;\\n       for(int i = homePos[0]-1; i>=startPos[0]; i--){\\n           for(int j = startPos[1]; j<=homePos[1]; j++){\\n               for(int K = startPos[1]; K<=homePos[1]; K++){\\n                    if(k==j) dp[i][j] = min(dp[i][j],colCosts[k]+dp[i+1][k]);\\n                    dp[i][j] = min(dp[i][j],rowCosts[i]+colCosts[k]+dp[i+1][k]);\\n               }               \\n           }\\n       }\\n       return dp[startPos[0]][startPos[1]];\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582193,
                "title": "java-solution-with-explanation-beats-100",
                "content": "# Intuition\\nNo matter where start(sx, sy) and end(ex, ey) is, it always has to travel (ex-sx) rows and (ey-sy) cols. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int sx = startPos[0];\\n        int sy = startPos[1];\\n\\n        int ex = homePos[0];\\n        int ey = homePos[1];\\n\\n        if(sx == ex && sy == ey){\\n            return 0;\\n        }\\n\\n        int total = 0;\\n        if(sx < ex){\\n            for(int i = sx; i < ex;){\\n                i++;\\n                total += rowCosts[i];\\n            }\\n        }else{\\n            for(int i = sx; i > ex;){\\n                i--;\\n                total += rowCosts[i];\\n            }\\n        }\\n        if(sy < ey){\\n            for(int i = sy; i < ey;){\\n                i++;\\n                total += colCosts[i];\\n            }\\n        }else{\\n            for(int i = sy; i > ey;){\\n                i--;\\n                total += colCosts[i];\\n            }\\n        }\\n        \\n        \\n        return total;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int sx = startPos[0];\\n        int sy = startPos[1];\\n\\n        int ex = homePos[0];\\n        int ey = homePos[1];\\n\\n        if(sx == ex && sy == ey){\\n            return 0;\\n        }\\n\\n        int total = 0;\\n        if(sx < ex){\\n            for(int i = sx; i < ex;){\\n                i++;\\n                total += rowCosts[i];\\n            }\\n        }else{\\n            for(int i = sx; i > ex;){\\n                i--;\\n                total += rowCosts[i];\\n            }\\n        }\\n        if(sy < ey){\\n            for(int i = sy; i < ey;){\\n                i++;\\n                total += colCosts[i];\\n            }\\n        }else{\\n            for(int i = sy; i > ey;){\\n                i--;\\n                total += colCosts[i];\\n            }\\n        }\\n        \\n        \\n        return total;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563681,
                "title": "java-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll shortest paths have minumum cost, so we just need to compute the cost of moving |x_home - x_start| rows and |y_home - y_start| columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPick variables `start` and `end` to denote start row/column and end row/column. Since moving right-left is the same as moving left-right, we can compute the cost in either direction.\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int minCost = 0;\\n        int start = 0;\\n        int end = 0;\\n        \\n        //compute row costs\\n        if (startPos[0] < homePos[0]) {\\n            start = startPos[0] + 1;\\n            end = homePos[0] + 1;\\n        } else {\\n            start = homePos[0];\\n            end = startPos[0];\\n        }\\n        for (int i = start; i < end; i++) {\\n            minCost += rowCosts[i];\\n        }\\n\\n        //compute column costs\\n        if (startPos[1] < homePos[1]) {\\n            start = startPos[1] + 1;\\n            end = homePos[1] + 1;\\n        } else {\\n            start = homePos[1];\\n            end = startPos[1];\\n        }\\n        for (int i = start; i < end; i++) {\\n            minCost += colCosts[i];\\n        }\\n\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int minCost = 0;\\n        int start = 0;\\n        int end = 0;\\n        \\n        //compute row costs\\n        if (startPos[0] < homePos[0]) {\\n            start = startPos[0] + 1;\\n            end = homePos[0] + 1;\\n        } else {\\n            start = homePos[0];\\n            end = startPos[0];\\n        }\\n        for (int i = start; i < end; i++) {\\n            minCost += rowCosts[i];\\n        }\\n\\n        //compute column costs\\n        if (startPos[1] < homePos[1]) {\\n            start = startPos[1] + 1;\\n            end = homePos[1] + 1;\\n        } else {\\n            start = homePos[1];\\n            end = startPos[1];\\n        }\\n        for (int i = start; i < end; i++) {\\n            minCost += colCosts[i];\\n        }\\n\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497469,
                "title": "ruby-beats-100",
                "content": "# Code\\n```\\ndef min_cost(start_pos, home_pos, row_costs, col_costs)\\n  rows = [start_pos[0], home_pos[0]].sort\\n  cols = [start_pos[1], home_pos[1]].sort\\n\\n  res = row_costs.slice(rows[0]..rows[1]).sum + col_costs.slice(cols[0]..cols[1]).sum \\n  res - row_costs[start_pos[0]] - col_costs[start_pos[1]]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_cost(start_pos, home_pos, row_costs, col_costs)\\n  rows = [start_pos[0], home_pos[0]].sort\\n  cols = [start_pos[1], home_pos[1]].sort\\n\\n  res = row_costs.slice(rows[0]..rows[1]).sum + col_costs.slice(cols[0]..cols[1]).sum \\n  res - row_costs[start_pos[0]] - col_costs[start_pos[1]]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3426646,
                "title": "greedy-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        startR, startC = startPos\\n        homeR, homeC = homePos\\n        res = 0\\n        if startR <= homeR:\\n            for row in range(startR + 1, homeR + 1):\\n                res += rowCosts[row]\\n        else:\\n            for row in range(homeR, startR):\\n                res += rowCosts[row]\\n        if startC <= homeC:\\n            for col in range(startC + 1, homeC + 1):\\n                res += colCosts[col]\\n        else:\\n            for col in range(homeC, startC):\\n                res += colCosts[col]\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        startR, startC = startPos\\n        homeR, homeC = homePos\\n        res = 0\\n        if startR <= homeR:\\n            for row in range(startR + 1, homeR + 1):\\n                res += rowCosts[row]\\n        else:\\n            for row in range(homeR, startR):\\n                res += rowCosts[row]\\n        if startC <= homeC:\\n            for col in range(startC + 1, homeC + 1):\\n                res += colCosts[col]\\n        else:\\n            for col in range(homeC, startC):\\n                res += colCosts[col]\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414943,
                "title": "c-case-by-case",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        if(startPos[0] < homePos[0])\\n            for(int i = startPos[0] + 1; i <= homePos[0]; i++) cost += rowCosts[i];\\n        \\n        else if(startPos[0] > homePos[0])\\n            for(int i = startPos[0] - 1; i >= homePos[0]; i--) cost += rowCosts[i];\\n\\n        if(startPos[1] < homePos[1])\\n            for(int i = startPos[1] + 1; i <= homePos[1]; i++) cost += colCosts[i];\\n        \\n        else if(startPos[1] > homePos[1])\\n            for(int i = startPos[1] - 1; i >= homePos[1]; i--) cost += colCosts[i];\\n\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0;\\n        if(startPos[0] < homePos[0])\\n            for(int i = startPos[0] + 1; i <= homePos[0]; i++) cost += rowCosts[i];\\n        \\n        else if(startPos[0] > homePos[0])\\n            for(int i = startPos[0] - 1; i >= homePos[0]; i--) cost += rowCosts[i];\\n\\n        if(startPos[1] < homePos[1])\\n            for(int i = startPos[1] + 1; i <= homePos[1]; i++) cost += colCosts[i];\\n        \\n        else if(startPos[1] > homePos[1])\\n            for(int i = startPos[1] - 1; i >= homePos[1]; i--) cost += colCosts[i];\\n\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411642,
                "title": "java-simple-more-readable-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        \\n         int res= 0;\\n        int strRow = startPos[0];\\n        int strCol = startPos[1];\\n        int homeRow = homePos[0];\\n        int homeCol = homePos[1];\\n\\n        while (strRow!=homeRow){\\n            if(strRow<homeRow){\\n                res = res+rowCosts[++strRow];\\n            }else{\\n                res= res+ rowCosts[--strRow];\\n            }\\n        }\\n        while (strCol!=homeCol){\\n            if(strCol<homeCol){\\n                res = res+ colCosts[++strCol];\\n            }else{\\n                res = res + colCosts[--strCol];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        \\n         int res= 0;\\n        int strRow = startPos[0];\\n        int strCol = startPos[1];\\n        int homeRow = homePos[0];\\n        int homeCol = homePos[1];\\n\\n        while (strRow!=homeRow){\\n            if(strRow<homeRow){\\n                res = res+rowCosts[++strRow];\\n            }else{\\n                res= res+ rowCosts[--strRow];\\n            }\\n        }\\n        while (strCol!=homeCol){\\n            if(strCol<homeCol){\\n                res = res+ colCosts[++strCol];\\n            }else{\\n                res = res + colCosts[--strCol];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378952,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int sr=startPos[0];\\n        int sc=startPos[1];\\n        int er=homePos[0];\\n        int ec=homePos[1];\\n        int ans=0;\\n        while(er>sr)\\n        {\\n            sr++;\\n            ans+=rowCosts[sr];\\n        }\\n        while(er<sr)\\n        {\\n            sr--;\\n            ans+=rowCosts[sr];\\n        }\\n        while(ec>sc)\\n        {\\n            sc++;\\n            ans+=colCosts[sc];\\n        }\\n        while(ec<sc)\\n        {\\n            sc--;\\n            ans+=colCosts[sc];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        int sr=startPos[0];\\n        int sc=startPos[1];\\n        int er=homePos[0];\\n        int ec=homePos[1];\\n        int ans=0;\\n        while(er>sr)\\n        {\\n            sr++;\\n            ans+=rowCosts[sr];\\n        }\\n        while(er<sr)\\n        {\\n            sr--;\\n            ans+=rowCosts[sr];\\n        }\\n        while(ec>sc)\\n        {\\n            sc++;\\n            ans+=colCosts[sc];\\n        }\\n        while(ec<sc)\\n        {\\n            sc--;\\n            ans+=colCosts[sc];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375955,
                "title": "c-for-beginner-easy-and-simple-solution-time-o-no-of-steps-required",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& sp, vector<int>& hp, vector<int>& rc, vector<int>& cc) {\\n        //i am going with simple four condition i.e kidhar move krna hai\\n        \\n        int r=hp[0]-sp[0];\\n        int c=hp[1]-sp[1];\\n        if(r==0&&c==0) return 0;\\n\\n        \\n        //upright                        //means row should be decreased and column should be increased\\n        if(r<=0&&c>=0){\\n            int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n            while(cCol!=hp[1]){\\n                ans+=cc[cCol+1];\\n                cCol+=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow-1];\\n                 cRow-=1;\\n             }\\n            return ans;\\n        }\\n        \\n        //upleft             //means row should be decreased and also column should be decreased\\n         if(r<=0&&c<=0){\\n              int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n            while(cCol!=hp[1]){\\n                ans+=cc[cCol-1];\\n                cCol-=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow-1];\\n                 cRow-=1;\\n             }\\n            return ans;\\n         }\\n             \\n        //downleft             //means row should be increased and column should be decreased\\n         if(r>=0&&c<=0){\\n              int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n           while(cCol!=hp[1]){\\n                ans+=cc[cCol-1];\\n                cCol-=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow+1];\\n                 cRow+=1;\\n             }\\n            return ans;\\n         }\\n             \\n        //downright             //means row should be increased and also column should be increased\\n         if(r>=0&&c>=0){\\n              int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n            while(cCol!=hp[1]){\\n                ans+=cc[cCol+1];\\n                cCol+=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow+1];\\n                 cRow+=1;\\n             }\\n            return ans;\\n         }\\n             \\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& sp, vector<int>& hp, vector<int>& rc, vector<int>& cc) {\\n        //i am going with simple four condition i.e kidhar move krna hai\\n        \\n        int r=hp[0]-sp[0];\\n        int c=hp[1]-sp[1];\\n        if(r==0&&c==0) return 0;\\n\\n        \\n        //upright                        //means row should be decreased and column should be increased\\n        if(r<=0&&c>=0){\\n            int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n            while(cCol!=hp[1]){\\n                ans+=cc[cCol+1];\\n                cCol+=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow-1];\\n                 cRow-=1;\\n             }\\n            return ans;\\n        }\\n        \\n        //upleft             //means row should be decreased and also column should be decreased\\n         if(r<=0&&c<=0){\\n              int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n            while(cCol!=hp[1]){\\n                ans+=cc[cCol-1];\\n                cCol-=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow-1];\\n                 cRow-=1;\\n             }\\n            return ans;\\n         }\\n             \\n        //downleft             //means row should be increased and column should be decreased\\n         if(r>=0&&c<=0){\\n              int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n           while(cCol!=hp[1]){\\n                ans+=cc[cCol-1];\\n                cCol-=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow+1];\\n                 cRow+=1;\\n             }\\n            return ans;\\n         }\\n             \\n        //downright             //means row should be increased and also column should be increased\\n         if(r>=0&&c>=0){\\n              int cCol=sp[1];\\n            int cRow=sp[0];\\n            int ans=0;\\n            while(cCol!=hp[1]){\\n                ans+=cc[cCol+1];\\n                cCol+=1;\\n            }\\n             while(cRow!=hp[0]){\\n                 ans+=rc[cRow+1];\\n                 cRow+=1;\\n             }\\n            return ans;\\n         }\\n             \\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374991,
                "title": "greedy-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n         int cost = 0;\\n\\n         int myrow =  startPos[0];\\n         int mycol =  startPos[1];\\n         \\n         int homerow = homePos[0];\\n         int homecol = homePos[1];\\n\\n         //calculating the row cost\\n         int rowcost = 0;\\n         if(homerow < myrow)\\n         {\\n             while(homerow < myrow)\\n             {\\n                 myrow--;\\n                 rowcost = rowcost + rowCosts[myrow];\\n             }\\n         }\\n         else if(homerow > myrow)\\n         {\\n             while(homerow > myrow)\\n             {\\n                 myrow++;\\n                 rowcost = rowcost + rowCosts[myrow];\\n             }\\n         }\\n\\n         //calculating the col costs\\n         int colcost = 0;\\n         \\n         if(homecol < mycol)\\n         {\\n             while(homecol < mycol)\\n             {\\n                 mycol--;\\n                 colcost = colcost + colCosts[mycol];\\n             }\\n         }\\n         else if(homecol > mycol)\\n         {\\n             while(homecol > mycol)\\n             {\\n                 mycol++;\\n                 colcost = colcost + colCosts[mycol];\\n             }\\n         }\\n         int total_cost = rowcost + colcost;\\n         return total_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n         int cost = 0;\\n\\n         int myrow =  startPos[0];\\n         int mycol =  startPos[1];\\n         \\n         int homerow = homePos[0];\\n         int homecol = homePos[1];\\n\\n         //calculating the row cost\\n         int rowcost = 0;\\n         if(homerow < myrow)\\n         {\\n             while(homerow < myrow)\\n             {\\n                 myrow--;\\n                 rowcost = rowcost + rowCosts[myrow];\\n             }\\n         }\\n         else if(homerow > myrow)\\n         {\\n             while(homerow > myrow)\\n             {\\n                 myrow++;\\n                 rowcost = rowcost + rowCosts[myrow];\\n             }\\n         }\\n\\n         //calculating the col costs\\n         int colcost = 0;\\n         \\n         if(homecol < mycol)\\n         {\\n             while(homecol < mycol)\\n             {\\n                 mycol--;\\n                 colcost = colcost + colCosts[mycol];\\n             }\\n         }\\n         else if(homecol > mycol)\\n         {\\n             while(homecol > mycol)\\n             {\\n                 mycol++;\\n                 colcost = colcost + colCosts[mycol];\\n             }\\n         }\\n         int total_cost = rowcost + colcost;\\n         return total_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374371,
                "title": "simple-c-solution",
                "content": "# Intuition\\nIrrespective of what path the robot takes, it will have to traverse all the rows between startRow and homeRow and all the columns between startCol and homeCol. (LeetCode Hint)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        if(startPos==homePos) return 0;\\n        int ans=0;\\n        if(startPos[0]<homePos[0])\\n        {\\n            for(int x=startPos[0]+1; x<=homePos[0]; x++)\\n            {\\n                ans+=rowCosts[x];\\n            }\\n        }\\n        else\\n        {\\n            for(int x=homePos[0]; x<startPos[0]; x++)\\n            {\\n                ans+=rowCosts[x];\\n            }\\n        }\\n        if(startPos[1]<homePos[1])\\n        {\\n            for(int x=startPos[1]+1; x<=homePos[1]; x++)\\n            {\\n                ans+=colCosts[x];\\n            }\\n        }\\n        else\\n        {\\n            for(int x=homePos[1]; x<startPos[1]; x++)\\n            {\\n                ans+=colCosts[x];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) \\n    {\\n        if(startPos==homePos) return 0;\\n        int ans=0;\\n        if(startPos[0]<homePos[0])\\n        {\\n            for(int x=startPos[0]+1; x<=homePos[0]; x++)\\n            {\\n                ans+=rowCosts[x];\\n            }\\n        }\\n        else\\n        {\\n            for(int x=homePos[0]; x<startPos[0]; x++)\\n            {\\n                ans+=rowCosts[x];\\n            }\\n        }\\n        if(startPos[1]<homePos[1])\\n        {\\n            for(int x=startPos[1]+1; x<=homePos[1]; x++)\\n            {\\n                ans+=colCosts[x];\\n            }\\n        }\\n        else\\n        {\\n            for(int x=homePos[1]; x<startPos[1]; x++)\\n            {\\n                ans+=colCosts[x];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362528,
                "title": "really-simple-solution-java",
                "content": "# Intuition\\nJust take the shortest path by first moving to home row and then to home column to get to home cell. There will be multiple shortest paths, however it doesnt matter which shortest path you take since cost adds up to the same amount.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(r+c) where r and c represent rows and columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) since no extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int cost = 0;\\n        int i = startPos[0];\\n         while(i != homePos[0] && i>=0 && i<=rowCosts.length-1) { //traverse rows to get to home row\\n             if(i < homePos[0]) {\\n                 cost = cost+ rowCosts[++i];\\n             } else {\\n                 cost = cost+ rowCosts[--i];\\n             }\\n        }\\n\\n        int j = startPos[1];\\n         while(j != homePos[1] && j>=0 && j<=colCosts.length-1) { //traverse cols on home row to get to home cell\\n             if(j < homePos[1]) {\\n                 cost = cost+ colCosts[++j];\\n             } else {\\n                 cost = cost+colCosts[--j];\\n             }\\n        }\\n        return cost;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int cost = 0;\\n        int i = startPos[0];\\n         while(i != homePos[0] && i>=0 && i<=rowCosts.length-1) { //traverse rows to get to home row\\n             if(i < homePos[0]) {\\n                 cost = cost+ rowCosts[++i];\\n             } else {\\n                 cost = cost+ rowCosts[--i];\\n             }\\n        }\\n\\n        int j = startPos[1];\\n         while(j != homePos[1] && j>=0 && j<=colCosts.length-1) { //traverse cols on home row to get to home cell\\n             if(j < homePos[1]) {\\n                 cost = cost+ colCosts[++j];\\n             } else {\\n                 cost = cost+colCosts[--j];\\n             }\\n        }\\n        return cost;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351482,
                "title": "easy-js-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} startPos\\n * @param {number[]} homePos\\n * @param {number[]} rowCosts\\n * @param {number[]} colCosts\\n * @return {number}\\n */\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let minRow = Math.min(startPos[0], homePos[0]);\\n    let maxRow = Math.max(startPos[0], homePos[0]);\\n\\n    let minCol = Math.min(startPos[1], homePos[1]);\\n    let maxCol = Math.max(startPos[1], homePos[1]);\\n\\n    let sum = 0;\\n\\n    for(let i = minRow; i <= maxRow; i++) {\\n        sum += rowCosts[i];\\n    }\\n\\n    for(let j = minCol; j <= maxCol; j++) {\\n        sum += colCosts[j];\\n    }\\n\\n    return sum - rowCosts[startPos[0]] - colCosts[startPos[1]];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} startPos\\n * @param {number[]} homePos\\n * @param {number[]} rowCosts\\n * @param {number[]} colCosts\\n * @return {number}\\n */\\nvar minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let minRow = Math.min(startPos[0], homePos[0]);\\n    let maxRow = Math.max(startPos[0], homePos[0]);\\n\\n    let minCol = Math.min(startPos[1], homePos[1]);\\n    let maxCol = Math.max(startPos[1], homePos[1]);\\n\\n    let sum = 0;\\n\\n    for(let i = minRow; i <= maxRow; i++) {\\n        sum += rowCosts[i];\\n    }\\n\\n    for(let j = minCol; j <= maxCol; j++) {\\n        sum += colCosts[j];\\n    }\\n\\n    return sum - rowCosts[startPos[0]] - colCosts[startPos[1]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347474,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n\\n        int r = startPos[0];\\n        int c = startPos[1];\\n        int hr = homePos[0];\\n        int hc = homePos[1];\\n        \\n        int ans=0;\\n        if(r>hr)\\n        {\\n            for(int i=r-1;i>=hr;i--)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else if(r<=hr)\\n        {\\n            for(int i=r+1;i<=hr;i++)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(c>hc)\\n        {\\n            for(int i=c-1;i>=hc;i--)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else if(c<=hc)\\n        {\\n            for(int i=c+1;i<=hc;i++)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n\\n        int r = startPos[0];\\n        int c = startPos[1];\\n        int hr = homePos[0];\\n        int hc = homePos[1];\\n        \\n        int ans=0;\\n        if(r>hr)\\n        {\\n            for(int i=r-1;i>=hr;i--)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else if(r<=hr)\\n        {\\n            for(int i=r+1;i<=hr;i++)\\n            {\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        if(c>hc)\\n        {\\n            for(int i=c-1;i>=hc;i--)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else if(c<=hc)\\n        {\\n            for(int i=c+1;i<=hc;i++)\\n            {\\n                ans+=colCosts[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278523,
                "title": "simple-c-greedy-approach",
                "content": "```\\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        \\n        int ans = 0;\\n        int sr = startPos[0];\\n        int sc = startPos[1];\\n        int dr = homePos[0];\\n        int dc = homePos[1];\\n        \\n        if(sr<=dr){\\n            for(int i = sr+1;i<=dr;i++){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = sr-1;i>=dr;i--){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        \\n        if(sc<=dc){\\n            for(int i = sc+1;i<=dc;i++){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = sc-1;i>=dc;i--){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        \\n        int ans = 0;\\n        int sr = startPos[0];\\n        int sc = startPos[1];\\n        int dr = homePos[0];\\n        int dc = homePos[1];\\n        \\n        if(sr<=dr){\\n            for(int i = sr+1;i<=dr;i++){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = sr-1;i>=dr;i--){\\n                ans+=rowCosts[i];\\n            }\\n        }\\n        \\n        if(sc<=dc){\\n            for(int i = sc+1;i<=dc;i++){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        else{\\n            for(int i = sc-1;i>=dc;i--){\\n                ans+=colCosts[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274657,
                "title": "simple-and-easy-understanding-solution-with-comments",
                "content": "Pls upvote if it helped !!\\n\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        \\n        int ans=0;\\n\\t\\t\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        \\n\\t\\t//If home is in some row below the start point.\\n        while(i<homePos[0]){\\n            i+=1;\\n            ans+=rowCosts[i];\\n        }\\n\\t\\t\\n\\t\\t////If home is in some row above the start point.\\n        while(i>homePos[0]){\\n            i-=1;\\n            ans+=rowCosts[i];\\n        }\\n\\t\\t\\n\\t\\t//If home is in some column right to the start point.\\n        while(j<homePos[1]){\\n            j+=1;\\n            ans+=colCosts[j];\\n        }\\n\\t\\t\\n\\t\\t//If home is in some column left to the start point.\\n        while(j>homePos[1]){\\n            j-=1;\\n            ans+=colCosts[j];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        \\n        int ans=0;\\n\\t\\t\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        \\n\\t\\t//If home is in some row below the start point.\\n        while(i<homePos[0]){\\n            i+=1;\\n            ans+=rowCosts[i];\\n        }\\n\\t\\t\\n\\t\\t////If home is in some row above the start point.\\n        while(i>homePos[0]){\\n            i-=1;\\n            ans+=rowCosts[i];\\n        }\\n\\t\\t\\n\\t\\t//If home is in some column right to the start point.\\n        while(j<homePos[1]){\\n            j+=1;\\n            ans+=colCosts[j];\\n        }\\n\\t\\t\\n\\t\\t//If home is in some column left to the start point.\\n        while(j>homePos[1]){\\n            j-=1;\\n            ans+=colCosts[j];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203195,
                "title": "naive-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(m+n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nfunc minCost(startPos []int, homePos []int, rowCosts []int, colCosts []int) int {\\n    growthR := growthSing(startPos[0], homePos[0])\\n    growthC := growthSing(startPos[1], homePos[1])\\n\\n    cost := 0\\n\\n    for i := startPos[0]; i != homePos[0]; {\\n        i += growthR\\n        cost += rowCosts[i]\\n    }\\n\\n\\n    for i := startPos[1]; i != homePos[1]; {\\n        i += growthC\\n        cost += colCosts[i]\\n    }\\n\\n    return cost\\n}\\n\\nfunc  growthSing(a, b int) int {\\n    if a < b {\\n        return 1\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc minCost(startPos []int, homePos []int, rowCosts []int, colCosts []int) int {\\n    growthR := growthSing(startPos[0], homePos[0])\\n    growthC := growthSing(startPos[1], homePos[1])\\n\\n    cost := 0\\n\\n    for i := startPos[0]; i != homePos[0]; {\\n        i += growthR\\n        cost += rowCosts[i]\\n    }\\n\\n\\n    for i := startPos[1]; i != homePos[1]; {\\n        i += growthC\\n        cost += colCosts[i]\\n    }\\n\\n    return cost\\n}\\n\\nfunc  growthSing(a, b int) int {\\n    if a < b {\\n        return 1\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3185966,
                "title": "simple-fast-and-beginner-friendly-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I tried solving it with BFS but I got TLE. Then I realised there is no need of BFS as the cost will be same from any way, because we have to take the same number of rows and columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Calculate the minimum and maximum row and add the cost.\\n2.Do same for column\\n3.Now subtract the cost of starting row and column.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAt max we need to travel from (0,0) to (n,m). So the Time Complexity will be O(n+m).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using only few variables hence Space Complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n = rowCosts.size(), m = colCosts.size();\\n        int miniRow = min(startPos[0],homePos[0]), maxiRow = max(startPos[0],homePos[0]);\\n        int miniCol = min(startPos[1],homePos[1]), maxiCol = max(startPos[1],homePos[1]);\\n        \\n        int cost=0;\\n        for(int i=miniRow; i<=maxiRow; i++){\\n            cost += rowCosts[i];\\n        }\\n        \\n        for(int i=miniCol; i<=maxiCol; i++){\\n            cost += colCosts[i];\\n        }\\n        \\n        cost -= rowCosts[startPos[0]];\\n        cost -= colCosts[startPos[1]];\\n            \\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n = rowCosts.size(), m = colCosts.size();\\n        int miniRow = min(startPos[0],homePos[0]), maxiRow = max(startPos[0],homePos[0]);\\n        int miniCol = min(startPos[1],homePos[1]), maxiCol = max(startPos[1],homePos[1]);\\n        \\n        int cost=0;\\n        for(int i=miniRow; i<=maxiRow; i++){\\n            cost += rowCosts[i];\\n        }\\n        \\n        for(int i=miniCol; i<=maxiCol; i++){\\n            cost += colCosts[i];\\n        }\\n        \\n        cost -= rowCosts[startPos[0]];\\n        cost -= colCosts[startPos[1]];\\n            \\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171872,
                "title": "simple-direct-solution",
                "content": "# Intuition\\nThe robot will always travel same set of rows and columns for minimum cost.\\n\\n# Approach\\njust calculate the cost of the path having minimum number of steps\\n\\n# Complexity\\n- Time complexity:\\nO(n+m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost=0;\\n        int currentRow=startPos[0],currentCol=startPos[1],targetRow=homePos[0],targetCol=homePos[1];\\n        for(int i=min(currentRow,targetRow);i<=max(currentRow,targetRow);i++){\\n            cost=cost+rowCosts[i];\\n        }\\n        for(int i=min(currentCol,targetCol);i<=max(targetCol,currentCol);i++){\\n            cost=cost+colCosts[i];\\n        }\\n        return cost-rowCosts[currentRow]-colCosts[currentCol];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost=0;\\n        int currentRow=startPos[0],currentCol=startPos[1],targetRow=homePos[0],targetCol=homePos[1];\\n        for(int i=min(currentRow,targetRow);i<=max(currentRow,targetRow);i++){\\n            cost=cost+rowCosts[i];\\n        }\\n        for(int i=min(currentCol,targetCol);i<=max(targetCol,currentCol);i++){\\n            cost=cost+colCosts[i];\\n        }\\n        return cost-rowCosts[currentRow]-colCosts[currentCol];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134968,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, \\n                                                             vector<int>& colCosts){\\n\\n        int ans = 0;\\n        // If row value of home is more than row value of start\\n        for(int i=startPos[0]; i<=homePos[0]; i++){ \\n            if(i != startPos[0]){\\n                ans += rowCosts[i];\\n            } \\n        }\\n        // If row value of start is more than row value of home\\n        for(int i=startPos[0]; i>=homePos[0]; i--){\\n            if(i != startPos[0]){\\n                ans += rowCosts[i];\\n            } \\n        }\\n        // If col value of home is more than col value of start\\n        for(int j=startPos[1]; j<=homePos[1]; j++){\\n            if(j != startPos[1]){\\n                ans += colCosts[j];\\n             } \\n        }\\n        // If col value of start is more than col value of home\\n        for(int j=startPos[1]; j>=homePos[1]; j--){\\n            if(j != startPos[1]){\\n                ans += colCosts[j];\\n             } \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, \\n                                                             vector<int>& colCosts){\\n\\n        int ans = 0;\\n        // If row value of home is more than row value of start\\n        for(int i=startPos[0]; i<=homePos[0]; i++){ \\n            if(i != startPos[0]){\\n                ans += rowCosts[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3107769,
                "title": "o-n-m-few-lines-of-code",
                "content": "class Solution {\\npublic:\\n    int minCost(vector<int>& startPos,vector<int>& homePos,vector<int>&rowCosts, vector<int> &colCosts) {\\n        \\n        int sum = 0;\\n        int sr = startPos[0], sc = startPos[1];\\n        int hr = homePos[0], hc = homePos[1];\\n        \\n        for(int i=min(sr,hr)+1; i<max(sr, hr); i++){\\n            \\n            sum += rowCosts[i];\\n            \\n        }\\n        \\n        for(int i=min(sc,hc)+1; i<max(sc, hc); i++){\\n            \\n            sum += colCosts[i];\\n            \\n        }\\n        \\n        \\n        if(sc != hc){\\n            sum += colCosts[hc];\\n        }\\n        \\n        if(hr != sr){\\n            sum += rowCosts[hr];\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minCost(vector<int>& startPos,vector<int>& homePos,vector<int>&rowCosts, vector<int> &colCosts) {\\n        \\n        int sum = 0;\\n        int sr = startPos[0], sc = startPos[1];\\n        int hr = homePos[0], hc = homePos[1];\\n        \\n        for(int i=min(sr,hr)+1; i<max(sr, hr); i++){\\n            \\n            sum += rowCosts[i];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3072670,
                "title": "python-lowerbound-easy-solution",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        r,c = startPos\\n        i,j = homePos\\n        res = 0\\n        if r < i:\\n            res += sum(rowCosts[r+1:i+1])\\n        else:\\n            res += sum(rowCosts[i:r])\\n        if c < j:\\n            res += sum(colCosts[c+1:j+1])\\n        else:\\n            res += sum(colCosts[j:c])\\n        return res\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        r,c = startPos\\n        i,j = homePos\\n        res = 0\\n        if r < i:\\n            res += sum(rowCosts[r+1:i+1])\\n        else:\\n            res += sum(rowCosts[i:r])\\n        if c < j:\\n            res += sum(colCosts[c+1:j+1])\\n        else:\\n            res += sum(colCosts[j:c])\\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070884,
                "title": "simple-java-o-m-n-greedy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(m+n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int res = 0;\\n        for (int i = Math.min(startPos[0], homePos[0]); i <= Math.max(startPos[0], homePos[0]); i++) {\\n            res += rowCosts[i];\\n        }\\n        for (int i = Math.min(startPos[1], homePos[1]); i <= Math.max(startPos[1], homePos[1]); i++) {\\n            res += colCosts[i];\\n        }\\n        res -= rowCosts[startPos[0]] + colCosts[startPos[1]];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int res = 0;\\n        for (int i = Math.min(startPos[0], homePos[0]); i <= Math.max(startPos[0], homePos[0]); i++) {\\n            res += rowCosts[i];\\n        }\\n        for (int i = Math.min(startPos[1], homePos[1]); i <= Math.max(startPos[1], homePos[1]); i++) {\\n            res += colCosts[i];\\n        }\\n        res -= rowCosts[startPos[0]] + colCosts[startPos[1]];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021774,
                "title": "rust-o-n",
                "content": "```\\nimpl Solution {\\n    pub fn min_cost(start_pos: Vec<i32>, home_pos: Vec<i32>, row_costs: Vec<i32>, col_costs: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let (mut cur_row_idx, mut cur_col_idx) = (start_pos[0], start_pos[1]);\\n        let (home_row_idx, home_col_idx) = (home_pos[0], home_pos[1]);\\n        while (cur_row_idx != home_row_idx) {\\n            cur_row_idx += match home_row_idx > cur_row_idx {\\n                true => 1,\\n                _ => -1,\\n            };\\n            res += row_costs[cur_row_idx as usize];\\n        }\\n        while (cur_col_idx != home_col_idx) {\\n            cur_col_idx += match home_col_idx > cur_col_idx {\\n                true => 1,\\n                _ => -1,\\n            };\\n            res += col_costs[cur_col_idx as usize];\\n        }\\n        res\\n    }\\n}\\n\\n```\\n\\nTESTED\\n\\n```\\n  Accepted\\n  69/69 cases passed (19 ms)\\n  Your runtime beats 100 % of rust submissions\\n  Your memory usage beats 100 % of rust submissions (3.4 MB)\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(start_pos: Vec<i32>, home_pos: Vec<i32>, row_costs: Vec<i32>, col_costs: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let (mut cur_row_idx, mut cur_col_idx) = (start_pos[0], start_pos[1]);\\n        let (home_row_idx, home_col_idx) = (home_pos[0], home_pos[1]);\\n        while (cur_row_idx != home_row_idx) {\\n            cur_row_idx += match home_row_idx > cur_row_idx {\\n                true => 1,\\n                _ => -1,\\n            };\\n            res += row_costs[cur_row_idx as usize];\\n        }\\n        while (cur_col_idx != home_col_idx) {\\n            cur_col_idx += match home_col_idx > cur_col_idx {\\n                true => 1,\\n                _ => -1,\\n            };\\n            res += col_costs[cur_col_idx as usize];\\n        }\\n        res\\n    }\\n}\\n\\n```\n```\\n  Accepted\\n  69/69 cases passed (19 ms)\\n  Your runtime beats 100 % of rust submissions\\n  Your memory usage beats 100 % of rust submissions (3.4 MB)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991950,
                "title": "very-simple-solution-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& stP, vector<int>& hoP, vector<int>& rowC, vector<int>& colC){\\n        int stc = stP[1], str = stP[0] ,enc = hoP[1] ,enr = hoP[0];\\n        int ans = 0;\\n        // for col movement\\n        if(stc > enc){\\n            for(int cc = stc-1;cc >= enc;cc--) ans += colC[cc];\\n        }else if(stc < enc){\\n            for(int cc = stc+1;cc<= enc;cc++) ans += colC[cc];\\n        }\\n        // for row movement\\n        if(str > enr){\\n            for(int rr = str-1;rr>=enr;rr--) ans += rowC[rr];\\n        }else if(str < enr){\\n            for(int rr = str+1;rr<=enr;rr++) ans += rowC[rr];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& stP, vector<int>& hoP, vector<int>& rowC, vector<int>& colC){\\n        int stc = stP[1], str = stP[0] ,enc = hoP[1] ,enr = hoP[0];\\n        int ans = 0;\\n        // for col movement\\n        if(stc > enc){\\n            for(int cc = stc-1;cc >= enc;cc--) ans += colC[cc];\\n        }else if(stc < enc){\\n            for(int cc = stc+1;cc<= enc;cc++) ans += colC[cc];\\n        }\\n        // for row movement\\n        if(str > enr){\\n            for(int rr = str-1;rr>=enr;rr--) ans += rowC[rr];\\n        }else if(str < enr){\\n            for(int rr = str+1;rr<=enr;rr++) ans += rowC[rr];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929923,
                "title": "python3-solution-beats-99-47",
                "content": "I started with BFS and it gave me TLE. Completely missed out on the fact that no matter where you move - it doesn\\'t matter (all shortest paths are going to cost the same.)\\n\\nHeart of the problem -> \\n\\nStep-1: Count the cost involved in moving from startPos[0] -> homePos[0]\\nStep-2: Count the cost involved in moving from startPos[1] -> homePos[1]\\n\\nCaveat: Slicing would not be trivial though; consider different cases mentioned in comment.\\n\\n\\n```\\nclass Solution:\\n    \"\"\"\\n        Diff cases:\\n            1) col_Robot < col_Home (Ex1) (Slicing is trivial)\\n            2) col_Robot > col_Home (Swapped case of Ex1) (Slicing is not trivial)\\n            3) row_Robot < row_Home (Ex1)\\n            4) row_Robot > row_Home (Swapped case of Ex1)\\n            5) Same row\\n            6) Same col\\n            \\n        Case 2)\\n        \\n        * * * * * *  1\\n        * * * * * R  2\\n        * * * * * *  3\\n        * * * * * *  4\\n        * * * * * *  5\\n        H * * * * *  6\\n        \\n    \"\"\"\\n    \\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        row_skipping_cost = 0\\n        col_skipping_cost = 0\\n        \\n        if(homePos[0] != startPos[0]):\\n            if(homePos[0] > startPos[0]):\\n                row_skipping_cost = sum(rowCosts[startPos[0] + 1: homePos[0]])\\n            else:\\n                row_skipping_cost = sum(rowCosts[homePos[0] + 1 : startPos[0]])\\n            \\n            row_skipping_cost += rowCosts[homePos[0]]\\n            \\n        if(homePos[1] != startPos[1]):\\n            if(homePos[1] > startPos[1]):\\n                col_skipping_cost = sum(colCosts[startPos[1] + 1: homePos[1]])\\n            else:\\n                col_skipping_cost = sum(colCosts[homePos[1] + 1 : startPos[1]])\\n            \\n            col_skipping_cost += colCosts[homePos[1]]\\n        \\n        return row_skipping_cost + col_skipping_cost\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n        Diff cases:\\n            1) col_Robot < col_Home (Ex1) (Slicing is trivial)\\n            2) col_Robot > col_Home (Swapped case of Ex1) (Slicing is not trivial)\\n            3) row_Robot < row_Home (Ex1)\\n            4) row_Robot > row_Home (Swapped case of Ex1)\\n            5) Same row\\n            6) Same col\\n            \\n        Case 2)\\n        \\n        * * * * * *  1\\n        * * * * * R  2\\n        * * * * * *  3\\n        * * * * * *  4\\n        * * * * * *  5\\n        H * * * * *  6\\n        \\n    \"\"\"\\n    \\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        row_skipping_cost = 0\\n        col_skipping_cost = 0\\n        \\n        if(homePos[0] != startPos[0]):\\n            if(homePos[0] > startPos[0]):\\n                row_skipping_cost = sum(rowCosts[startPos[0] + 1: homePos[0]])\\n            else:\\n                row_skipping_cost = sum(rowCosts[homePos[0] + 1 : startPos[0]])\\n            \\n            row_skipping_cost += rowCosts[homePos[0]]\\n            \\n        if(homePos[1] != startPos[1]):\\n            if(homePos[1] > startPos[1]):\\n                col_skipping_cost = sum(colCosts[startPos[1] + 1: homePos[1]])\\n            else:\\n                col_skipping_cost = sum(colCosts[homePos[1] + 1 : startPos[1]])\\n            \\n            col_skipping_cost += colCosts[homePos[1]]\\n        \\n        return row_skipping_cost + col_skipping_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928016,
                "title": "java-solution-100-fast",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n`m = | startPos[0] - homePos[0] |`\\n`n = | startPos[1] - homePos[1] |`\\n- Time complexity: $$O(m + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int cost = 0;\\n        \\n        if(startPos[0] != homePos[0]) cost += rowCosts[homePos[0]];\\n        if(startPos[1] != homePos[1]) cost += colCosts[homePos[1]];\\n        \\n        int lastR = Math.max(startPos[0], homePos[0]);\\n        int lastC = Math.max(startPos[1], homePos[1]);\\n        \\n        for(int i = 1 + Math.min(startPos[0], homePos[0]); i < lastR; i++){\\n            cost += rowCosts[i];\\n        }\\n        \\n        for(int i = 1 + Math.min(startPos[1], homePos[1]); i < lastC; i++){\\n            cost += colCosts[i];\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int cost = 0;\\n        \\n        if(startPos[0] != homePos[0]) cost += rowCosts[homePos[0]];\\n        if(startPos[1] != homePos[1]) cost += colCosts[homePos[1]];\\n        \\n        int lastR = Math.max(startPos[0], homePos[0]);\\n        int lastC = Math.max(startPos[1], homePos[1]);\\n        \\n        for(int i = 1 + Math.min(startPos[0], homePos[0]); i < lastR; i++){\\n            cost += rowCosts[i];\\n        }\\n        \\n        for(int i = 1 + Math.min(startPos[1], homePos[1]); i < lastC; i++){\\n            cost += colCosts[i];\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876575,
                "title": "fast-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        if(startPos[0] == homePos[0] && startPos[1]== homePos[1]){\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        res = calc(startPos[0], homePos[0], rowCosts,res);\\n        res = calc(startPos[1], homePos[1], colCosts,res);\\n        res = res - rowCosts[startPos[0]] - colCosts[startPos[1]];\\n        return res;\\n    }\\n\\n    private int calc(int homePos, int startPos, int[] rowCol, int res) {\\n        int min = Math.min(startPos, homePos);\\n        int max = Math.max(startPos, homePos);\\n\\n        for (int i = min; i <= max; i++) {\\n            res += rowCol[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        if(startPos[0] == homePos[0] && startPos[1]== homePos[1]){\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        res = calc(startPos[0], homePos[0], rowCosts,res);\\n        res = calc(startPos[1], homePos[1], colCosts,res);\\n        res = res - rowCosts[startPos[0]] - colCosts[startPos[1]];\\n        return res;\\n    }\\n\\n    private int calc(int homePos, int startPos, int[] rowCol, int res) {\\n        int min = Math.min(startPos, homePos);\\n        int max = Math.max(startPos, homePos);\\n\\n        for (int i = min; i <= max; i++) {\\n            res += rowCol[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867885,
                "title": "java-soln-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n     int total_row=0,total_col=0;\\n     int x1= Math.min(startPos[0],homePos[0]);\\n     int y1= Math.min(startPos[1], homePos[1]);\\n     int x2= Math.max(startPos[0], homePos[0]);\\n     int y2= Math.max(startPos[1], homePos[1]);\\n     int total =0;\\n     if(x1==startPos[0]){\\n         for(int i=x1+1;i<=x2; i++){\\n             total+=rowCosts[i];\\n         }\\n     }\\n     else {\\n         for(int i=x1;i<x2; i++){\\n             total+=rowCosts[i];\\n         }\\n     }\\n     if(y1==startPos[1]){\\n         for(int i=y1+1;i<=y2; i++){\\n             total+=colCosts[i];\\n         }\\n     }\\n     else {\\n         for(int i=y1; i<y2; i++){\\n             total+=colCosts[i];\\n         }\\n     }\\n return total;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n     int total_row=0,total_col=0;\\n     int x1= Math.min(startPos[0],homePos[0]);\\n     int y1= Math.min(startPos[1], homePos[1]);\\n     int x2= Math.max(startPos[0], homePos[0]);\\n     int y2= Math.max(startPos[1], homePos[1]);\\n     int total =0;\\n     if(x1==startPos[0]){\\n         for(int i=x1+1;i<=x2; i++){\\n             total+=rowCosts[i];\\n         }\\n     }\\n     else {\\n         for(int i=x1;i<x2; i++){\\n             total+=rowCosts[i];\\n         }\\n     }\\n     if(y1==startPos[1]){\\n         for(int i=y1+1;i<=y2; i++){\\n             total+=colCosts[i];\\n         }\\n     }\\n     else {\\n         for(int i=y1; i<y2; i++){\\n             total+=colCosts[i];\\n         }\\n     }\\n return total;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855740,
                "title": "c-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& S, vector<int>& H, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int res = 0, rinc = H[0] > S[0] ? 1 : -1, cinc = H[1] > S[1] ? 1 : -1;\\n        for(int i = S[0]; i != H[0]; i+= rinc) res += rowCosts[i+rinc];\\n        for(int i = S[1]; i != H[1]; i+= cinc) res += colCosts[i+cinc];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& S, vector<int>& H, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int res = 0, rinc = H[0] > S[0] ? 1 : -1, cinc = H[1] > S[1] ? 1 : -1;\\n        for(int i = S[0]; i != H[0]; i+= rinc) res += rowCosts[i+rinc];\\n        for(int i = S[1]; i != H[1]; i+= cinc) res += colCosts[i+cinc];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805187,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        \\n        // for each of the shortest path, the cost is same, as each of them has to come across the number of rows and columns\\n        // thus, we don\\'t need to search all the paths.\\n        // for example 1, the cost of path showed in explaination is same with (1,0)->(1,1)->(1,2)->(1,3)->(2,3)=18.\\n        \\n        int res =0;\\n        int i=i=startPos[0], j=startPos[1];\\n        while(i != homePos[0]){\\n            i += i>homePos[0]? -1:1;\\n            res +=rowCosts[i];\\n\\n\\n        }\\n        while(j!= homePos[1]){\\n            j += j >homePos[1]? -1:1;\\n            res += colCosts[j];\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        \\n        // for each of the shortest path, the cost is same, as each of them has to come across the number of rows and columns\\n        // thus, we don\\'t need to search all the paths.\\n        // for example 1, the cost of path showed in explaination is same with (1,0)->(1,1)->(1,2)->(1,3)->(2,3)=18.\\n        \\n        int res =0;\\n        int i=i=startPos[0], j=startPos[1];\\n        while(i != homePos[0]){\\n            i += i>homePos[0]? -1:1;\\n            res +=rowCosts[i];\\n\\n\\n        }\\n        while(j!= homePos[1]){\\n            j += j >homePos[1]? -1:1;\\n            res += colCosts[j];\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745729,
                "title": "java-greedy-simple-code",
                "content": "\\tclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        //just be greedy \\n        int x1=startPos[0];\\n        int x2=homePos[0];\\n        \\n        int y1=startPos[1];\\n        int y2=homePos[1];\\n        \\n        int res=0;\\n        while(x1<x2)\\n        {\\n            x1++;\\n            res+=rowCosts[x1];\\n        }\\n        \\n        while(x1>x2)\\n        {\\n            x1--;\\n            res+=rowCosts[x1];\\n        }\\n        \\n        while(y1<y2)\\n        {\\n            y1++;\\n            res+=colCosts[y1];\\n        }\\n        \\n        while(y1>y2)\\n        {\\n            y1--;\\n            res+=colCosts[y1];\\n        }\\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        //just be greedy \\n        int x1=startPos[0];\\n        int x2=homePos[0];\\n        \\n        int y1=startPos[1];\\n        int y2=homePos[1];\\n        \\n        int res=0;\\n        while(x1<x2)\\n        {\\n            x1++;\\n            res+=rowCosts[x1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2743039,
                "title": "easy-to-understand-greedy",
                "content": "it was an very easy problem dont think too much \\nfrom any row one column another column costs same as well as in any column any row to another row costs the same so we dont need see all paths \\nfirst think the brute force then u definatly got it\\n```\\nclass Solution {\\n    public int minCost(int[] start, int[] end, int[] row, int[] col) {\\n        int x=start[0],y=start[1];\\n        int cost=0;\\n        while(x<end[0]){\\n            x++;\\n            cost+=row[x];\\n        }\\n        while(x>end[0]){\\n            x--;\\n            cost+=row[x];\\n        }\\n        while(y<end[1]){\\n            y++;\\n            cost+=col[y];\\n        }\\n        while(y>end[1]){\\n            y--;\\n            cost+=col[y];\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] start, int[] end, int[] row, int[] col) {\\n        int x=start[0],y=start[1];\\n        int cost=0;\\n        while(x<end[0]){\\n            x++;\\n            cost+=row[x];\\n        }\\n        while(x>end[0]){\\n            x--;\\n            cost+=row[x];\\n        }\\n        while(y<end[1]){\\n            y++;\\n            cost+=col[y];\\n        }\\n        while(y>end[1]){\\n            y--;\\n            cost+=col[y];\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731657,
                "title": "c-greedy",
                "content": "```\\n// using Greedy\\n//  You can not find a cheaper traversal way by using DFS DP cause cost span across all columns and rows (not per cell)\\npublic int MinCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n\\tint startRow=startPos[0], startCol=startPos[1], homeRow=homePos[0], homeCol=homePos[1];\\n\\tif(startRow==homeRow && startCol==homeCol) return 0;\\n\\n\\tint cost=0;\\n\\n\\t// try to move top->down verticaly to the same row as home row\\n\\tfor(int i = startRow+1; i<=homeRow; i++) cost+=rowCosts[i];\\n\\n\\t// try to move bottom->up verticaly to the same row as home row\\n\\tfor(int i = startRow-1; i>=homeRow; i--) cost+=rowCosts[i];\\n\\n\\t// try to move left->right to the same column as home column\\n\\tfor(int i=startCol+1; i<=homeCol; i++) cost+=colCosts[i];\\n\\n\\t// try to move left<-right to the same column as home column\\n\\tfor(int i=startCol-1; i>=homeCol; i--) cost+=colCosts[i];\\n\\n\\treturn cost;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// using Greedy\\n//  You can not find a cheaper traversal way by using DFS DP cause cost span across all columns and rows (not per cell)\\npublic int MinCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n\\tint startRow=startPos[0], startCol=startPos[1], homeRow=homePos[0], homeCol=homePos[1];\\n\\tif(startRow==homeRow && startCol==homeCol) return 0;\\n\\n\\tint cost=0;\\n\\n\\t// try to move top->down verticaly to the same row as home row\\n\\tfor(int i = startRow+1; i<=homeRow; i++) cost+=rowCosts[i];\\n\\n\\t// try to move bottom->up verticaly to the same row as home row\\n\\tfor(int i = startRow-1; i>=homeRow; i--) cost+=rowCosts[i];\\n\\n\\t// try to move left->right to the same column as home column\\n\\tfor(int i=startCol+1; i<=homeCol; i++) cost+=colCosts[i];\\n\\n\\t// try to move left<-right to the same column as home column\\n\\tfor(int i=startCol-1; i>=homeCol; i--) cost+=colCosts[i];\\n\\n\\treturn cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724571,
                "title": "recursive-solution-for-better-understanding",
                "content": "\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\nboolean[][] visit=new boolean[rowCosts.length][colCosts.length];\\n        Integer[][] dp=new Integer[rowCosts.length][colCosts.length];\\n        int result = chec(startPos[0],startPos[1],homePos[0],homePos[1],rowCosts,colCosts,visit,dp);\\n       /* for(int i=0;i<rowCosts.length;i++){\\n            for(int j=0;j<colCosts.length;j++){\\n                System.out.print(dp[i][j]+\"  \");\\n            }\\n            System.out.println(\"\");\\n        }*/\\n        \\n        return result;\\n        \\n    }\\n    static int chec(int r,int c,int i,int j,int[] row,int[] col,boolean[][] visit,Integer[][] dp)\\n    {\\n         if(r==i&&c==j)\\n            return 0;\\n        \\n        if(r<0||c<0||r>=row.length||c>=col.length||visit[r][c])\\n            return -1;\\n        if(dp[r][c]!=null)\\n            return dp[r][c];\\n        visit[r][c]=true;\\n        int ans=Integer.MAX_VALUE,up=0,down=0,left=0,right=0;\\n         \\n        if(r>0 && Math.abs(r-i) > Math.abs(r-1-i))\\n        {\\n            up=chec(r-1,c,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,row[r-1]+up);\\n        }\\n          \\n        if(r<i && Math.abs(r-i) > Math.abs(r+1-i))\\n        {\\n            down=chec(r+1,c,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,row[r+1]+down);\\n        }\\n        \\n        if(c >0 && Math.abs(c-j) > Math.abs(c-1-j))\\n        {\\n            left=chec(r,c-1,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,col[c-1]+left);\\n        }\\n        \\n        if(c<j && Math.abs(c-j) > Math.abs(c+1-j))\\n        {\\n            right=chec(r,c+1,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,col[c+1]+right);\\n        }  \\n        visit[r][c]=false;\\n        return dp[r][c]=ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\nboolean[][] visit=new boolean[rowCosts.length][colCosts.length];\\n        Integer[][] dp=new Integer[rowCosts.length][colCosts.length];\\n        int result = chec(startPos[0],startPos[1],homePos[0],homePos[1],rowCosts,colCosts,visit,dp);\\n       /* for(int i=0;i<rowCosts.length;i++){\\n            for(int j=0;j<colCosts.length;j++){\\n                System.out.print(dp[i][j]+\"  \");\\n            }\\n            System.out.println(\"\");\\n        }*/\\n        \\n        return result;\\n        \\n    }\\n    static int chec(int r,int c,int i,int j,int[] row,int[] col,boolean[][] visit,Integer[][] dp)\\n    {\\n         if(r==i&&c==j)\\n            return 0;\\n        \\n        if(r<0||c<0||r>=row.length||c>=col.length||visit[r][c])\\n            return -1;\\n        if(dp[r][c]!=null)\\n            return dp[r][c];\\n        visit[r][c]=true;\\n        int ans=Integer.MAX_VALUE,up=0,down=0,left=0,right=0;\\n         \\n        if(r>0 && Math.abs(r-i) > Math.abs(r-1-i))\\n        {\\n            up=chec(r-1,c,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,row[r-1]+up);\\n        }\\n          \\n        if(r<i && Math.abs(r-i) > Math.abs(r+1-i))\\n        {\\n            down=chec(r+1,c,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,row[r+1]+down);\\n        }\\n        \\n        if(c >0 && Math.abs(c-j) > Math.abs(c-1-j))\\n        {\\n            left=chec(r,c-1,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,col[c-1]+left);\\n        }\\n        \\n        if(c<j && Math.abs(c-j) > Math.abs(c+1-j))\\n        {\\n            right=chec(r,c+1,i,j,row,col,visit,dp);\\n            ans=Math.min(ans,col[c+1]+right);\\n        }  \\n        visit[r][c]=false;\\n        return dp[r][c]=ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724191,
                "title": "c-easy-short",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        for(int i = homePos[0]; i != startPos[0]; i += i > startPos[0] ? -1 : 1) \\n            ans += rowCosts[i];\\n        for(int i = homePos[1]; i != startPos[1]; i += i > startPos[1] ? -1 : 1) \\n            ans += colCosts[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int ans = 0;\\n        for(int i = homePos[0]; i != startPos[0]; i += i > startPos[0] ? -1 : 1) \\n            ans += rowCosts[i];\\n        for(int i = homePos[1]; i != startPos[1]; i += i > startPos[1] ? -1 : 1) \\n            ans += colCosts[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723154,
                "title": "java-all-shortest-paths-have-the-same-cost",
                "content": "```\\nclass Solution {\\n    public int minCostHelper(int i, int j, int p, int q, int[] rowCosts, int[] colCosts, int result){\\n        while(i!=j){\\n            if(i<j)\\n                result += rowCosts[++i]; \\n            else\\n                result += rowCosts[--i];\\n        }\\n        while(p!=q){\\n            if(p<q)\\n                result += colCosts[++p];\\n            else\\n                result += colCosts[--p];\\n        }\\n        return result;\\n    }\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        if(startPos[0]==homePos[0] && startPos[1]==homePos[1]) return 0;\\n        return minCostHelper(startPos[0],homePos[0],startPos[1],homePos[1],rowCosts,colCosts,0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCostHelper(int i, int j, int p, int q, int[] rowCosts, int[] colCosts, int result){\\n        while(i!=j){\\n            if(i<j)\\n                result += rowCosts[++i]; \\n            else\\n                result += rowCosts[--i];\\n        }\\n        while(p!=q){\\n            if(p<q)\\n                result += colCosts[++p];\\n            else\\n                result += colCosts[--p];\\n        }\\n        return result;\\n    }\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        if(startPos[0]==homePos[0] && startPos[1]==homePos[1]) return 0;\\n        return minCostHelper(startPos[0],homePos[0],startPos[1],homePos[1],rowCosts,colCosts,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714476,
                "title": "python-o-n-m-o-1",
                "content": "# Complexity\\n- Time complexity: O(N + M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        row_cost = sum(rowCosts[min(startPos[0], homePos[0]):max(startPos[0], homePos[0]) + 1]) - rowCosts[startPos[0]]\\n        col_cost = sum(colCosts[min(startPos[1], homePos[1]):max(startPos[1], homePos[1]) + 1]) - colCosts[startPos[1]]\\n        return row_cost + col_cost\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        row_cost = sum(rowCosts[min(startPos[0], homePos[0]):max(startPos[0], homePos[0]) + 1]) - rowCosts[startPos[0]]\\n        col_cost = sum(colCosts[min(startPos[1], homePos[1]):max(startPos[1], homePos[1]) + 1]) - colCosts[startPos[1]]\\n        return row_cost + col_cost\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704608,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        res = 0\\n\\n        if startPos[0] > homePos[0]:\\n            for i in range(startPos[0]-1,homePos[0]-1,-1):\\n                res += rowCosts[i]\\n        else:\\n            for i in range(startPos[0]+1,homePos[0]+1):\\n                res += rowCosts[i]\\n\\n        if startPos[1] > homePos[1]:\\n            for i in range(startPos[1]-1,homePos[1]-1,-1):\\n                res += colCosts[i]\\n        else:\\n            for i in range(startPos[1]+1,homePos[1]+1):\\n                res += colCosts[i]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        res = 0\\n\\n        if startPos[0] > homePos[0]:\\n            for i in range(startPos[0]-1,homePos[0]-1,-1):\\n                res += rowCosts[i]\\n        else:\\n            for i in range(startPos[0]+1,homePos[0]+1):\\n                res += rowCosts[i]\\n\\n        if startPos[1] > homePos[1]:\\n            for i in range(startPos[1]-1,homePos[1]-1,-1):\\n                res += colCosts[i]\\n        else:\\n            for i in range(startPos[1]+1,homePos[1]+1):\\n                res += colCosts[i]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696874,
                "title": "c-clean-concise-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& sp, vector<int>& hp, vector<int>& rc, vector<int>& cc) {\\n        int n=rc.size();\\n        int m=cc.size();\\n\\t    int res=0;\\n        for(int i=min(sp[0],hp[0]); i<=max(sp[0],hp[0]); i++){\\n            res += rc[i];\\n        }\\n        for(int i=min(sp[1],hp[1]); i<=max(sp[1],hp[1]); i++){\\n            res += cc[i];\\n        }\\n        return res-rc[sp[0]]-cc[sp[1]];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& sp, vector<int>& hp, vector<int>& rc, vector<int>& cc) {\\n        int n=rc.size();\\n        int m=cc.size();\\n\\t    int res=0;\\n        for(int i=min(sp[0],hp[0]); i<=max(sp[0],hp[0]); i++){\\n            res += rc[i];\\n        }\\n        for(int i=min(sp[1],hp[1]); i<=max(sp[1],hp[1]); i++){\\n            res += cc[i];\\n        }\\n        return res-rc[sp[0]]-cc[sp[1]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687552,
                "title": "c-easy",
                "content": "class Solution {\\npublic:\\n\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int sr = startPos[0];  //start row\\n        int er = homePos[0];   //end row\\n        int sc = startPos[1];  //start column\\n        int ec = homePos[1];   //end column\\n        int ans = 0;\\n        if(sr>er){\\n            for(int i=er;i<sr;i++){\\n                ans+=rowCosts[i] ;\\n            }\\n        }\\n        else if(sr<er){\\n            for(int i=sr+1;i<=er;i++){\\n                ans+=rowCosts[i] ;\\n            }\\n        }\\n        if(sc>ec){\\n            for(int i=sc-1;i>=ec;i--){\\n                ans+=colCosts[i] ;\\n            }\\n        }\\n        else if(sc<ec){\\n            for(int i=sc+1;i<=ec;i++){\\n                ans+=colCosts[i] ;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int sr = startPos[0];  //start row\\n        int er = homePos[0];   //end row\\n        int sc = startPos[1];  //start column\\n        int ec = homePos[1];   //end column\\n        int ans = 0;\\n        if(sr>er){\\n            for(int i=er;i<sr;i++){\\n                ans+=rowCosts[i] ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2682611,
                "title": "bfs-pq-wont-work-greedy-solution",
                "content": "The moment I read the question, the thought of using BFS algorithm with Priority queue (something like Dijkstra\\'s) struck me. But the constraints simply do not allow such implementation.\\n\\nIn the worst case, we\\'ll end up traversing through all cell once, i.e  (10^5 * 10^5 operations).\\n\\nIntuition : The intuition comes by realizing that I do not have to try all possible ways, since unlike other problems related to grid traversal, here the cost associated with each cell is not unique.\\nIf the starting position and the ending position have certain rows between them, we need to pass those rows and the cost of this traversal is going to be same (not dependent on the path).\\nSimilarly for columns, hence we just calculate the bare minimum number of rows and column that we must pass in order to reach the destination.\\n\\nCode (*Shorter code for the above logic is also available, but this implementation is very intuitive to understand*)\\n![image](https://assets.leetcode.com/users/images/31850fe3-6c4d-4715-9189-573034a63866_1665336964.3045743.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "The moment I read the question, the thought of using BFS algorithm with Priority queue (something like Dijkstra\\'s) struck me. But the constraints simply do not allow such implementation.\\n\\nIn the worst case, we\\'ll end up traversing through all cell once, i.e  (10^5 * 10^5 operations).\\n\\nIntuition : The intuition comes by realizing that I do not have to try all possible ways, since unlike other problems related to grid traversal, here the cost associated with each cell is not unique.\\nIf the starting position and the ending position have certain rows between them, we need to pass those rows and the cost of this traversal is going to be same (not dependent on the path).\\nSimilarly for columns, hence we just calculate the bare minimum number of rows and column that we must pass in order to reach the destination.\\n\\nCode (*Shorter code for the above logic is also available, but this implementation is very intuitive to understand*)\\n![image](https://assets.leetcode.com/users/images/31850fe3-6c4d-4715-9189-573034a63866_1665336964.3045743.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2671150,
                "title": "python-solution-faster-90",
                "content": "\\tdef minCost(self, startPos, homePos, rowCosts, colCosts):\\n\\t\\t\\tres, [i, j], [x, y] = 0, startPos, homePos\\n\\t\\t\\twhile i != x:\\n\\t\\t\\t\\ti += cmp(x, i)\\n\\t\\t\\t\\tres += rowCosts[i]\\n\\t\\t\\twhile j != y:\\n\\t\\t\\t\\tj += cmp(y, j)\\n\\t\\t\\t\\tres += colCosts[j]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tdef minCost(self, startPos, homePos, rowCosts, colCosts):\\n\\t\\t\\tres, [i, j], [x, y] = 0, startPos, homePos\\n\\t\\t\\twhile i != x:\\n\\t\\t\\t\\ti += cmp(x, i)\\n\\t\\t\\t\\tres += rowCosts[i]\\n\\t\\t\\twhile j != y:\\n\\t\\t\\t\\tj += cmp(y, j)\\n\\t\\t\\t\\tres += colCosts[j]\\n\\t\\t\\treturn res",
                "codeTag": "Python3"
            },
            {
                "id": 2650619,
                "title": "scala-solution",
                "content": "```\\n  def minCost(startPos: Array[Int], homePos: Array[Int], rowCosts: Array[Int], colCosts: Array[Int]): Int = {\\n    val minRow = if(startPos(0) <= homePos(0)) startPos(0) + 1  else homePos(0)\\n    val maxRow = if(startPos(0) < homePos(0)) homePos(0) else startPos(0) - 1\\n\\n    val minCol = if(startPos(1) <= homePos(1)) startPos(1) + 1  else homePos(1)\\n    val maxCol = if(startPos(1) < homePos(1)) homePos(1) else startPos(1) - 1\\n\\n    (minRow to maxRow).foldLeft(0)((acc, i) =>{ acc + rowCosts(i)}) +\\n    (minCol to maxCol).foldLeft(0)((acc, i) =>{ acc + colCosts(i)})\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def minCost(startPos: Array[Int], homePos: Array[Int], rowCosts: Array[Int], colCosts: Array[Int]): Int = {\\n    val minRow = if(startPos(0) <= homePos(0)) startPos(0) + 1  else homePos(0)\\n    val maxRow = if(startPos(0) < homePos(0)) homePos(0) else startPos(0) - 1\\n\\n    val minCol = if(startPos(1) <= homePos(1)) startPos(1) + 1  else homePos(1)\\n    val maxCol = if(startPos(1) < homePos(1)) homePos(1) else startPos(1) - 1\\n\\n    (minRow to maxRow).foldLeft(0)((acc, i) =>{ acc + rowCosts(i)}) +\\n    (minCol to maxCol).foldLeft(0)((acc, i) =>{ acc + colCosts(i)})\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2638171,
                "title": "clear-explanation-with-comments-and-intuition",
                "content": "class Solution {\\npublic:\\n    // going topDown from [homerow,homecol] to [startrow,startcol]\\n    \\n    // Think for a moment, what do we need here, do we really need to explore all\\n    // ways to reach from start to homePos ?\\n    // Once we get in the same row / same Col as the homePos, won\\'t the result\\n    // always remain same, because the cost is \"incurred only for changing row or \\n    // changing column\"\\n    \\n    // 1. get to the same row/col as the homePos , and then keep adding the costs\\n    \\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        \\n        int m = rowCosts.size();\\n        int n = colCosts.size();\\n        \\n        int ans = 0;\\n        \\n        // int r1 = startPos[0],r2 = homePos[0];\\n        // int c1 = startPos[1],c2 = homePos[1];\\n        \\n//         while(r1 != r2)\\n//         {\\n//             if(r1 < r2)\\n//             {\\n//                 ans+= rowCosts[++r1];\\n//             }\\n//             else if(r1 > r2)\\n//             {\\n//                 ans+= rowCosts[--r1];\\n//             }\\n//         }\\n        \\n//         while(c1 != c2)\\n//         {\\n//             if(c1 < c2)\\n//             {\\n//                 ans+= colCosts[++c1];\\n//             }\\n//             else if(c1 > c2)\\n//             {\\n//                 ans+= colCosts[--c1];\\n//             }\\n//         }\\n        \\n        // There\\'s a clever logic if you don\\'t want to check for r1 < r2 or r1 > r2\\n        // every time\\n        int i = startPos[0],j = startPos[1];\\n        int x = homePos[0],y = homePos[1];\\n        \\n        int totalCost = 0;\\n        // to go from startPos -> (i,j) to homePos -> (x,y)\\n        while(i != x)\\n        {\\n            i+= (x-i)/abs(x-i); // takes care of i++ or i-- accordingly\\n            totalCost+= rowCosts[i];\\n        }\\n        while(j != y)\\n        {\\n            j+= (y-j)/abs(y-j); // takes care of i++ or i-- accordingly\\n            totalCost+= colCosts[j];\\n        }\\n        \\n        return totalCost;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    // going topDown from [homerow,homecol] to [startrow,startcol]\\n    \\n    // Think for a moment, what do we need here, do we really need to explore all\\n    // ways to reach from start to homePos ?\\n    // Once we get in the same row / same Col as the homePos, won\\'t the result\\n    // always remain same, because the cost is \"incurred only for changing row or \\n    // changing column\"\\n    \\n    // 1. get to the same row/col as the homePos , and then keep adding the costs\\n    \\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        \\n        int m = rowCosts.size();\\n        int n = colCosts.size();\\n        \\n        int ans = 0;\\n        \\n        // int r1 = startPos[0],r2 = homePos[0];\\n        // int c1 = startPos[1],c2 = homePos[1];\\n        \\n//         while(r1 != r2)\\n//         {\\n//             if(r1 < r2)\\n//             {\\n//                 ans+= rowCosts[++r1];\\n//             }",
                "codeTag": "Java"
            },
            {
                "id": 2610829,
                "title": "simulation-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int r = startPos[0] - homePos[0], c = startPos[1] - homePos[1], ans = 0;\\n        int i = startPos[0], j = startPos[1], n = rowCosts.size(), m = colCosts.size();\\n        \\n        while(r || c) {\\n            int minR = INT_MAX, minC = INT_MAX, r1 = 0, r2 = 0, c1 = 0, c2 = 0;\\n            if(r < 0 && i < n - 1) minR = rowCosts[i + 1], r1 = 1;\\n            else if(r > 0 && i > 0) minR = rowCosts[i - 1], r2 = 1;\\n            \\n            if(c < 0 && j < m - 1) minC = colCosts[j + 1], c1 = 1;\\n            else if(c > 0 && j > 0) minC = colCosts[j - 1], c2 = 1;\\n            \\n            if(minR < minC) {\\n                r > 0 ? r-- : r++;\\n                r1 ? i++ : i--;\\n                ans += rowCosts[i];\\n            }\\n            else {\\n                c > 0 ? c-- : c++;\\n                c1 ? j++ : j--;\\n                ans += colCosts[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int r = startPos[0] - homePos[0], c = startPos[1] - homePos[1], ans = 0;\\n        int i = startPos[0], j = startPos[1], n = rowCosts.size(), m = colCosts.size();\\n        \\n        while(r || c) {\\n            int minR = INT_MAX, minC = INT_MAX, r1 = 0, r2 = 0, c1 = 0, c2 = 0;\\n            if(r < 0 && i < n - 1) minR = rowCosts[i + 1], r1 = 1;\\n            else if(r > 0 && i > 0) minR = rowCosts[i - 1], r2 = 1;\\n            \\n            if(c < 0 && j < m - 1) minC = colCosts[j + 1], c1 = 1;\\n            else if(c > 0 && j > 0) minC = colCosts[j - 1], c2 = 1;\\n            \\n            if(minR < minC) {\\n                r > 0 ? r-- : r++;\\n                r1 ? i++ : i--;\\n                ans += rowCosts[i];\\n            }\\n            else {\\n                c > 0 ? c-- : c++;\\n                c1 ? j++ : j--;\\n                ans += colCosts[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597202,
                "title": "c-simple-solution",
                "content": "approach : we have get the sum of rows from start to home and sum of column btw start to home to get the solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int x1 = startPos[0];\\n        int y1 = startPos[1];\\n        int x2 = homePos[0];\\n        int y2 = homePos[1];\\n        int res =0;\\n        if(x1 < x2)\\n        {\\n            for(int i= x1;i<x2;i++)\\n            {\\n                res+=rowCosts[i+1];\\n            }\\n        }\\n        else\\n        {\\n            for(int i=x1;i>x2;i--)\\n            {\\n                res+=rowCosts[i-1];\\n            }\\n        }\\n        if(y1 < y2)\\n        {\\n            for(int i=y1;i<y2;i++)\\n            {\\n                res+=colCosts[i+1];\\n            }\\n        }\\n         else\\n        {\\n            for(int i=y1;i>y2;i--)\\n            {\\n                res+=colCosts[i-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int x1 = startPos[0];\\n        int y1 = startPos[1];\\n        int x2 = homePos[0];\\n        int y2 = homePos[1];\\n        int res =0;\\n        if(x1 < x2)\\n        {\\n            for(int i= x1;i<x2;i++)\\n            {\\n                res+=rowCosts[i+1];\\n            }\\n        }\\n        else\\n        {\\n            for(int i=x1;i>x2;i--)\\n            {\\n                res+=rowCosts[i-1];\\n            }\\n        }\\n        if(y1 < y2)\\n        {\\n            for(int i=y1;i<y2;i++)\\n            {\\n                res+=colCosts[i+1];\\n            }\\n        }\\n         else\\n        {\\n            for(int i=y1;i>y2;i--)\\n            {\\n                res+=colCosts[i-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587722,
                "title": "easy-python3-solution",
                "content": "```class Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        starting_x,starting_y=startPos\\n        des_x,des_y=homePos\\n        res=0\\n        while starting_x!=des_x:\\n            starting_x+=1 if starting_x<des_x else -1\\n            res+=rowCosts[starting_x]\\n        while starting_y!=des_y:\\n            starting_y+=1 if starting_y<des_y else -1\\n            res+=colCosts[starting_y]\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        starting_x,starting_y=startPos\\n        des_x,des_y=homePos\\n        res=0\\n        while starting_x!=des_x:\\n            starting_x+=1 if starting_x<des_x else -1\\n            res+=rowCosts[starting_x]\\n        while starting_y!=des_y:\\n            starting_y+=1 if starting_y<des_y else -1\\n            res+=colCosts[starting_y]\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2562837,
                "title": "only-one-possible-path",
                "content": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        ax, ay = startPos\\n        bx, by = homePos\\n        res = 0\\n        for i in range(min(ay, by), max(ay + 1, by + 1)):\\n            res += colCosts[i]\\n        for i in range(min(ax, bx), max(ax + 1, bx + 1)):\\n            res += rowCosts[i]\\n        res -=  rowCosts[ax] + colCosts[ay]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        ax, ay = startPos\\n        bx, by = homePos\\n        res = 0\\n        for i in range(min(ay, by), max(ay + 1, by + 1)):\\n            res += colCosts[i]\\n        for i in range(min(ax, bx), max(ax + 1, bx + 1)):\\n            res += rowCosts[i]\\n        res -=  rowCosts[ax] + colCosts[ay]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530309,
                "title": "java-greedy-approach-general-iteration",
                "content": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int result = 0 ;\\n        \\n        int startRow = Math.min(startPos[0], homePos[0]) ;\\n        int endRow = Math.max(startPos[0], homePos[0]) ;\\n        int startCol = Math.min(startPos[1], homePos[1]) ;\\n        int endCol = Math.max(startPos[1], homePos[1]) ;\\n        \\n        for (int i = startRow; i <= endRow; i++)\\n            result += rowCosts[i] ;\\n        \\n        for (int i = startCol; i <= endCol; i++)\\n            result += colCosts[i] ;\\n        \\n        result -= rowCosts[startPos[0]] ;\\n        result -= colCosts[startPos[1]] ;\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int result = 0 ;\\n        \\n        int startRow = Math.min(startPos[0], homePos[0]) ;\\n        int endRow = Math.max(startPos[0], homePos[0]) ;\\n        int startCol = Math.min(startPos[1], homePos[1]) ;\\n        int endCol = Math.max(startPos[1], homePos[1]) ;\\n        \\n        for (int i = startRow; i <= endRow; i++)\\n            result += rowCosts[i] ;\\n        \\n        for (int i = startCol; i <= endCol; i++)\\n            result += colCosts[i] ;\\n        \\n        result -= rowCosts[startPos[0]] ;\\n        result -= colCosts[startPos[1]] ;\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523434,
                "title": "python-simple-solution-86-faster",
                "content": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        if startPos == homePos:\\n            return cost\\n        else:\\n            while startPos[0]<homePos[0]:\\n                startPos[0]+=1\\n                cost += rowCosts[startPos[0]]\\n            while startPos[1]<homePos[1]:\\n                startPos[1]+=1\\n                cost+= colCosts[startPos[1]]\\n            while startPos[0]>homePos[0]:\\n                startPos[0]-=1\\n                cost+= rowCosts[startPos[0]]\\n            while startPos[1]>homePos[1]:\\n                startPos[1]-=1\\n                cost+= colCosts[startPos[1]]\\n            return cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        cost = 0\\n        if startPos == homePos:\\n            return cost\\n        else:\\n            while startPos[0]<homePos[0]:\\n                startPos[0]+=1\\n                cost += rowCosts[startPos[0]]\\n            while startPos[1]<homePos[1]:\\n                startPos[1]+=1\\n                cost+= colCosts[startPos[1]]\\n            while startPos[0]>homePos[0]:\\n                startPos[0]-=1\\n                cost+= rowCosts[startPos[0]]\\n            while startPos[1]>homePos[1]:\\n                startPos[1]-=1\\n                cost+= colCosts[startPos[1]]\\n            return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515777,
                "title": "python-easy-to-understand",
                "content": "\\t    cost = 0\\n\\n        while startPos[0] != homePos[0]:\\n            if startPos[0] < homePos[0]:\\n                startPos[0] += 1\\n            else:\\n                startPos[0] -= 1\\n            cost += rowCosts[startPos[0]]\\n        \\n        while startPos[1] != homePos[1]:\\n            if startPos[1] < homePos[1]:\\n                startPos[1] += 1\\n            else:\\n                startPos[1] -= 1\\n            cost += colCosts[startPos[1]]\\n       \\n        return cost",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t    cost = 0\\n\\n        while startPos[0] != homePos[0]:\\n            if startPos[0] < homePos[0]:\\n                startPos[0] += 1\\n            else:\\n                startPos[0] -= 1\\n            cost += rowCosts[startPos[0]]\\n        \\n        while startPos[1] != homePos[1]:\\n            if startPos[1] < homePos[1]:\\n                startPos[1] += 1\\n            else:\\n                startPos[1] -= 1\\n            cost += colCosts[startPos[1]]\\n       \\n        return cost",
                "codeTag": "Unknown"
            },
            {
                "id": 2514563,
                "title": "java-clean-bfs-tle",
                "content": "**Code:**\\n\\n    public int minCost(int[] start, int[] home, int[] row, int[] col) {\\n        if(start[0]==home[0] && start[1]==home[1]) return 0;\\n        int res = Integer.MAX_VALUE, m =  row.length, n = col.length;\\n        \\n        int[][] vis = new int[m][n];\\n        for(int[] arr : vis) Arrays.fill(arr, -1);\\n        int[][] dirs = new int[][]{{0, 1},{0, -1},{1, 0},{-1, 0}};\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{start[0], start[1], 0});\\n        vis[start[0]][start[1]] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int[] curr = q.poll();\\n            int i = curr[0], j = curr[1];\\n            for(int[] dir : dirs){\\n                int x = i+dir[0], y = j+dir[1];\\n                if(x<0||y<0||x>=m||y>=n) continue;\\n                \\n                int cost = curr[2] + (dir[0]==0 ? col[y] : row[x]);\\n                if(res<=cost || (vis[x][y]!=-1 && vis[x][y]<=curr[2])) continue;\\n                \\n                vis[x][y] = curr[2];\\n                if(x==home[0] && y==home[1]) res = Math.min(res, cost);\\n                else q.add(new int[]{x, y, cost});\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "**Code:**\\n\\n    public int minCost(int[] start, int[] home, int[] row, int[] col) {\\n        if(start[0]==home[0] && start[1]==home[1]) return 0;\\n        int res = Integer.MAX_VALUE, m =  row.length, n = col.length;\\n        \\n        int[][] vis = new int[m][n];\\n        for(int[] arr : vis) Arrays.fill(arr, -1);\\n        int[][] dirs = new int[][]{{0, 1},{0, -1},{1, 0},{-1, 0}};\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{start[0], start[1], 0});\\n        vis[start[0]][start[1]] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int[] curr = q.poll();\\n            int i = curr[0], j = curr[1];\\n            for(int[] dir : dirs){\\n                int x = i+dir[0], y = j+dir[1];\\n                if(x<0||y<0||x>=m||y>=n) continue;\\n                \\n                int cost = curr[2] + (dir[0]==0 ? col[y] : row[x]);\\n                if(res<=cost || (vis[x][y]!=-1 && vis[x][y]<=curr[2])) continue;\\n                \\n                vis[x][y] = curr[2];\\n                if(x==home[0] && y==home[1]) res = Math.min(res, cost);\\n                else q.add(new int[]{x, y, cost});\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428047,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0 ;\\n        for(int i = startPos[0] ; i < homePos[0] ; i++) cost += rowCosts[i+1] ;\\n        for(int i = startPos[0] ; i > homePos[0] ; i--) cost += rowCosts[i-1] ;\\n        for(int i = startPos[1] ; i < homePos[1] ; i++) cost += colCosts[i+1] ;\\n        for(int i = startPos[1] ; i > homePos[1] ; i--) cost += colCosts[i-1] ;\\n        return cost ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost = 0 ;\\n        for(int i = startPos[0] ; i < homePos[0] ; i++) cost += rowCosts[i+1] ;\\n        for(int i = startPos[0] ; i > homePos[0] ; i--) cost += rowCosts[i-1] ;\\n        for(int i = startPos[1] ; i < homePos[1] ; i++) cost += colCosts[i+1] ;\\n        for(int i = startPos[1] ; i > homePos[1] ; i--) cost += colCosts[i-1] ;\\n        return cost ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391448,
                "title": "c-3-line-code-logic-exp-in-detail",
                "content": "![image](https://assets.leetcode.com/users/images/d25669c0-7bba-48f3-b431-3569deaf1ae4_1659852043.9843717.png)\\n\\n***Intutuion->At first it seems that it will be done by Recursion but after having a look at constraints and analysing\\n a problem littel bit I came to know that it the greedy approach that we have to take. In short we have to take the greedy path or the shortest path (manhattan distance) because if we take a longer path we have to pay some extra as compared to shortest path. (Because it h will have some extra cells). Thus we greedly follow shortest path and sum up the costs.***\\n \\n**n==Manhattan Distance\\n T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minCost(vector<int>& start, vector<int>& home, vector<int>& rcost, vector<int>& ccost) {\\n\\t\\t\\tint r=0,int c=0;;\\n\\t\\t\\tfor(int i=min(start[0],home[0]);i<=max(start[0],home[0]);i++) r+=rcost[i];\\n\\t\\t\\tfor(int i=min(start[1],home[1]);i<=max(start[1],home[1]);i++) c+=ccost[i];\\n\\t\\t\\treturn (r-rcost[start[0]])+(c-ccost[start[1]]);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minCost(vector<int>& start, vector<int>& home, vector<int>& rcost, vector<int>& ccost) {\\n\\t\\t\\tint r=0,int c=0;;\\n\\t\\t\\tfor(int i=min(start[0],home[0]);i<=max(start[0],home[0]);i++) r+=rcost[i];\\n\\t\\t\\tfor(int i=min(start[1],home[1]);i<=max(start[1],home[1]);i++) c+=ccost[i];\\n\\t\\t\\treturn (r-rcost[start[0]])+(c-ccost[start[1]]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2388084,
                "title": "java-easy-to-implement",
                "content": "**Intitution**: Since cost of all the rows like cost for row 0 elements and row 1 elements are same. Same with all the cols. We don\\'t require to find all the paths. Just traverse from starting position to ending and add the cost.\\n\\n```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int m = rowCosts.length;\\n        int n = colCosts.length;\\n        \\n        int cost = 0;\\n        int x = startPos[0];\\n        int y = startPos[1];\\n        int r = homePos[0];\\n        int s = homePos[1];\\n        \\n        if(x < r){\\n            int i = x;\\n            while(i < r){\\n                cost += rowCosts[++i];\\n            }\\n        }\\n        \\n        if(x > r){\\n            int i = x;\\n            while(i > r){\\n                cost += rowCosts[--i];\\n            }\\n        }\\n        if(y < s){\\n            int i = y;\\n            while(i < s){\\n                cost += colCosts[++i];\\n            }\\n        }\\n        if(y > s){\\n            int i = y;\\n            while(i > s){\\n                cost += colCosts[--i];\\n            }\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int m = rowCosts.length;\\n        int n = colCosts.length;\\n        \\n        int cost = 0;\\n        int x = startPos[0];\\n        int y = startPos[1];\\n        int r = homePos[0];\\n        int s = homePos[1];\\n        \\n        if(x < r){\\n            int i = x;\\n            while(i < r){\\n                cost += rowCosts[++i];\\n            }\\n        }\\n        \\n        if(x > r){\\n            int i = x;\\n            while(i > r){\\n                cost += rowCosts[--i];\\n            }\\n        }\\n        if(y < s){\\n            int i = y;\\n            while(i < s){\\n                cost += colCosts[++i];\\n            }\\n        }\\n        if(y > s){\\n            int i = y;\\n            while(i > s){\\n                cost += colCosts[--i];\\n            }\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385079,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        rowStart, colStart, rowEnd, colEnd = startPos + homePos\\n        ans = 0\\n        row = [rowStart, rowEnd]\\n        col = [colStart, colEnd]\\n        ans+=sum(rowCosts[min(row)+1: max(row)])\\n        ans+=sum(colCosts[min(col)+1: max(col)])\\n        ans+=rowCosts[rowEnd] if rowEnd!=rowStart else 0\\n        ans+=colCosts[colEnd] if colEnd!=colStart else 0\\n        return ans\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        rowStart, colStart, rowEnd, colEnd = startPos + homePos\\n        ans = 0\\n        row = [rowStart, rowEnd]\\n        col = [colStart, colEnd]\\n        ans+=sum(rowCosts[min(row)+1: max(row)])\\n        ans+=sum(colCosts[min(col)+1: max(col)])\\n        ans+=rowCosts[rowEnd] if rowEnd!=rowStart else 0\\n        ans+=colCosts[colEnd] if colEnd!=colStart else 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370272,
                "title": "python3",
                "content": "class Solution:\\n\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        total = 0\\n        xStart,yStart = startPos\\n        xEnd,yEnd = homePos\\n        \\n        for i in range(min(xStart,xEnd)+1,max(xStart,xEnd)):\\n            total += rowCosts[i]\\n            \\n        for j in range(min(yStart,yEnd)+1,max(yStart,yEnd)):\\n            total += colCosts[j]\\n        \\n        if xEnd!=xStart:\\n            total+=rowCosts[xEnd]\\n            \\n        if yEnd!=yStart:\\n            total+=colCosts[yEnd]\\n            \\n        return total",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        total = 0\\n        xStart,yStart = startPos\\n        xEnd,yEnd = homePos\\n        \\n        for i in range(min(xStart,xEnd)+1,max(xStart,xEnd)):\\n            total += rowCosts[i]\\n            \\n        for j in range(min(yStart,yEnd)+1,max(yStart,yEnd)):\\n            total += colCosts[j]\\n        \\n        if xEnd!=xStart:\\n            total+=rowCosts[xEnd]\\n            \\n        if yEnd!=yStart:\\n            total+=colCosts[yEnd]\\n            \\n        return total",
                "codeTag": "Java"
            },
            {
                "id": 2364889,
                "title": "c-easy-solution",
                "content": "``` \\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost=0;\\n        int i=startPos[0];\\n        int j=homePos[0];\\n        if(i<j){\\n            for(int k=i+1;k<=j;k++){\\n                cost+=rowCosts[k];\\n            }\\n        }\\n        else if(i>j){\\n            for(int k=i-1;k>=j;k--){\\n                cost+=rowCosts[k];\\n            }\\n        }\\n        int m=startPos[1];\\n        int n=homePos[1];\\n        if(m<n){\\n            for(int k=m+1;k<=n;k++){\\n                cost+=colCosts[k];\\n            }\\n        }\\n        else if(m>n){\\n            for(int k=m-1;k>=n;k--){\\n                cost+=colCosts[k];\\n            }\\n        }\\n        return cost;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "``` \\nint minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost=0;\\n        int i=startPos[0];\\n        int j=homePos[0];\\n        if(i<j){\\n            for(int k=i+1;k<=j;k++){\\n                cost+=rowCosts[k];\\n            }\\n        }\\n        else if(i>j){\\n            for(int k=i-1;k>=j;k--){\\n                cost+=rowCosts[k];\\n            }\\n        }\\n        int m=startPos[1];\\n        int n=homePos[1];\\n        if(m<n){\\n            for(int k=m+1;k<=n;k++){\\n                cost+=colCosts[k];\\n            }\\n        }\\n        else if(m>n){\\n            for(int k=m-1;k>=n;k--){\\n                cost+=colCosts[k];\\n            }\\n        }\\n        return cost;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2356416,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost=0;\\n        while(startPos[0]!=homePos[0]) {\\n            cost+=rowCosts[homePos[0]];\\n            if(homePos[0]>startPos[0]) {\\n                homePos[0]--;\\n            }\\n            else if(homePos[0]<startPos[0]) {\\n                homePos[0]++;\\n            }\\n        }\\n        while(startPos[1]!=homePos[1]) {\\n            cost+=colCosts[homePos[1]];\\n            if(homePos[1]>startPos[1]) {\\n                homePos[1]--;\\n            }\\n            else if(homePos[1]<startPos[1]) {\\n                homePos[1]++;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```\\n***Please upvote if you\\'ve got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int cost=0;\\n        while(startPos[0]!=homePos[0]) {\\n            cost+=rowCosts[homePos[0]];\\n            if(homePos[0]>startPos[0]) {\\n                homePos[0]--;\\n            }\\n            else if(homePos[0]<startPos[0]) {\\n                homePos[0]++;\\n            }\\n        }\\n        while(startPos[1]!=homePos[1]) {\\n            cost+=colCosts[homePos[1]];\\n            if(homePos[1]>startPos[1]) {\\n                homePos[1]--;\\n            }\\n            else if(homePos[1]<startPos[1]) {\\n                homePos[1]++;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340859,
                "title": "python-two-approaches-intutive-simple-notes",
                "content": "```\\n\\n/*\\n    approach based on hints provided - Got accepted\\n    Irrespective of what path the robot takes, \\n    it will have to traverse all the rows between startRow and \\n    homeRow and all the columns between startCol and homeCol.\\n    \\n    Hence, making any other move other than traversing the \\n    required rows and columns will potentially incur more \\n    cost which can be avoided.\\n*/\\n```\\n```\\ndef minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\nrowcost = 0\\ncolcost = 0\\n\\nif homePos[0] > startPos[0]:\\n\\ti = startPos[0]\\n\\twhile i != homePos[0]:\\n\\t\\trowcost+=rowCosts[i+1]\\n\\t\\ti+=1\\nelse:\\n\\ti = startPos[0]\\n\\twhile i != homePos[0]:\\n\\t\\trowcost+=rowCosts[i-1]\\n\\t\\ti-=1\\n\\nif homePos[1] > startPos[1]:\\n\\ti = startPos[1]\\n\\twhile i != homePos[1]:\\n\\t\\tcolcost+=colCosts[i+1]\\n\\t\\ti+=1\\nelse:\\n\\ti = startPos[1]\\n\\twhile i != homePos[1]:\\n\\t\\tcolcost+=colCosts[i-1]\\n\\t\\ti-=1\\nreturn rowcost + colcost\\n```\\n\\nSecond Approach: The below approach is giving MLE unfortunately.\\n\\n```\\n/*\\n    approach:\\n    we can solve the problem using greedy approach\\n    start at the starting point, maintain a min heap\\n    at every iteration, if the cost to reach the neighbor cell\\n    is minimum than the current cost, update the value and add that \\n    neighbor to heap\\n    Answer will be cost[homePos]\\n*/\\n```\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        m, n = len(rowCosts), len(colCosts)\\n        cost = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        cost[startPos[0]][startPos[1]] = 0\\n        heap = []\\n        heapq.heappush(heap, (0, startPos[0], startPos[1]))\\n        \\n        def is_valid(row, col):\\n            if 0 <= row < m and 0 <= col < n:\\n                return True\\n            return False\\n            \\n        while len(heap):\\n            cur_cost, row, col = heapq.heappop(heap)\\n            \\n            if row == homePos[0] and col == homePos[1]:\\n                return cur_cost\\n            \\n            if is_valid(row+1,col) and cur_cost + rowCosts[row+1] < cost[row+1][col]:\\n                cost[row+1][col] = cur_cost + rowCosts[row+1]\\n                heapq.heappush(heap, (cost[row+1][col], row+1, col))\\n                \\n            if is_valid(row-1,col) and cur_cost + rowCosts[row-1] < cost[row-1][col]:\\n                cost[row-1][col] = cur_cost + rowCosts[row-1]\\n                heapq.heappush(heap, (cost[row-1][col], row-1, col))\\n            \\n            if is_valid(row, col+1) and cur_cost + colCosts[col+1] < cost[row][col+1]:\\n                cost[row][col+1] = cur_cost + colCosts[col+1]\\n                heapq.heappush(heap, (cost[row][col+1], row, col+1))\\n            \\n            if is_valid(row, col-1) and cur_cost + colCosts[col-1] < cost[row][col-1]:\\n                cost[row][col-1] = cur_cost + colCosts[col-1]\\n                heapq.heappush(heap, (cost[row][col-1], row, col-1))\\n                \\n        # this return is not reachable though\\n        return cost[homePos[0]][homePos[1]]\\n```\\n    \\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\n/*\\n    approach based on hints provided - Got accepted\\n    Irrespective of what path the robot takes, \\n    it will have to traverse all the rows between startRow and \\n    homeRow and all the columns between startCol and homeCol.\\n    \\n    Hence, making any other move other than traversing the \\n    required rows and columns will potentially incur more \\n    cost which can be avoided.\\n*/\\n```\n```\\ndef minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\nrowcost = 0\\ncolcost = 0\\n\\nif homePos[0] > startPos[0]:\\n\\ti = startPos[0]\\n\\twhile i != homePos[0]:\\n\\t\\trowcost+=rowCosts[i+1]\\n\\t\\ti+=1\\nelse:\\n\\ti = startPos[0]\\n\\twhile i != homePos[0]:\\n\\t\\trowcost+=rowCosts[i-1]\\n\\t\\ti-=1\\n\\nif homePos[1] > startPos[1]:\\n\\ti = startPos[1]\\n\\twhile i != homePos[1]:\\n\\t\\tcolcost+=colCosts[i+1]\\n\\t\\ti+=1\\nelse:\\n\\ti = startPos[1]\\n\\twhile i != homePos[1]:\\n\\t\\tcolcost+=colCosts[i-1]\\n\\t\\ti-=1\\nreturn rowcost + colcost\\n```\n```\\n/*\\n    approach:\\n    we can solve the problem using greedy approach\\n    start at the starting point, maintain a min heap\\n    at every iteration, if the cost to reach the neighbor cell\\n    is minimum than the current cost, update the value and add that \\n    neighbor to heap\\n    Answer will be cost[homePos]\\n*/\\n```\n```\\nimport heapq\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        m, n = len(rowCosts), len(colCosts)\\n        cost = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        cost[startPos[0]][startPos[1]] = 0\\n        heap = []\\n        heapq.heappush(heap, (0, startPos[0], startPos[1]))\\n        \\n        def is_valid(row, col):\\n            if 0 <= row < m and 0 <= col < n:\\n                return True\\n            return False\\n            \\n        while len(heap):\\n            cur_cost, row, col = heapq.heappop(heap)\\n            \\n            if row == homePos[0] and col == homePos[1]:\\n                return cur_cost\\n            \\n            if is_valid(row+1,col) and cur_cost + rowCosts[row+1] < cost[row+1][col]:\\n                cost[row+1][col] = cur_cost + rowCosts[row+1]\\n                heapq.heappush(heap, (cost[row+1][col], row+1, col))\\n                \\n            if is_valid(row-1,col) and cur_cost + rowCosts[row-1] < cost[row-1][col]:\\n                cost[row-1][col] = cur_cost + rowCosts[row-1]\\n                heapq.heappush(heap, (cost[row-1][col], row-1, col))\\n            \\n            if is_valid(row, col+1) and cur_cost + colCosts[col+1] < cost[row][col+1]:\\n                cost[row][col+1] = cur_cost + colCosts[col+1]\\n                heapq.heappush(heap, (cost[row][col+1], row, col+1))\\n            \\n            if is_valid(row, col-1) and cur_cost + colCosts[col-1] < cost[row][col-1]:\\n                cost[row][col-1] = cur_cost + colCosts[col-1]\\n                heapq.heappush(heap, (cost[row][col-1], row, col-1))\\n                \\n        # this return is not reachable though\\n        return cost[homePos[0]][homePos[1]]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1703302,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 1759153,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 2048203,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 1948801,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 1916776,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 1849809,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 1801065,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            },
            {
                "id": 1796661,
                "content": [
                    {
                        "username": "Decap",
                        "content": "I hope I'm not the only one that immediately assumed that this was a DFS problem..."
                    },
                    {
                        "username": "pnkj1402",
                        "content": "No bro I am also victim of the same."
                    },
                    {
                        "username": "sroninio",
                        "content": "Whats the idea of the question?? The costs are not negative, so there is nothing to think about.\\nsum the costs of all the rows/columns u need to pass in the way home.\\nits trivial, what do I miss?"
                    },
                    {
                        "username": "jethalol",
                        "content": "Yes correct this is trivial"
                    },
                    {
                        "username": "layyy",
                        "content": "minimum is very trivial in this problem"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why dijsktra cant be applied here\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "It can be, its just not efficient and there is no reason to do so since any taxicab/manhattan set of steps from start to home is guarenteed to be the same *and* optimal"
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "i had mistakenly solved this by dp grid method, realise it later. but i want to know that why the code in dp grid method is not working correctly "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@lakshya_8279](/lakshya_8279) Think of it like tabulation or bottom up dp, the larger values depend upon previous values of the table. So for DP to work the dependency should be down/right. But in case of a 4 directional movement we cannot apply DP because you cannot define a recurrence relation for it."
                    },
                    {
                        "username": "lakshya_8279",
                        "content": "\\nclass Solution {\\n    vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    bool isvalid(int n,int m,int i,int j,vector<vector<int>>&vis)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0 || vis[i][j]) return false;\\n        return true;\\n    }\\n    long solve(int i,int j,int r,int c,vector<int>& s,vector<int>& h,vector<vector<int>>&vis,vector<vector<int>>&dp)\\n    {\\n        if(i==r and j==c) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int n=s.size(),m=h.size();\\n         vis[i][j]=1;\\n         long ans=INT_MAX;\\n        for(auto x:dir)\\n        {\\n          int nr=i+x[0];\\n          int nc=j+x[1];\\n          if(isvalid(n,m,nr,nc,vis))\\n          {\\n              int cost;\\n              if(nr!=i) cost=s[nr];\\n              else cost=h[nc];\\n              ans=min(ans,cost+solve(nr,nc,r,c,s,h,vis,dp));\\n\\n          }\\n        }\\n         \\n        vis[i][j]=0;\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int n=rowCosts.size();\\n        int m=colCosts.size();\\n        int x1=startPos[0],x2=startPos[1];\\n        int r=homePos[0],c=homePos[1];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n          vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        return solve(x1,x2,r,c,rowCosts,colCosts,vis,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Really don't understand the point of this question. It is just a trivial summation."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Should be an easy. Its more of a \"did you read it and actually think about it, or just start solving it?\" trick question. Clearly several people here actually just started solving it using DFS because they didnt bother to consider what was being asked, and just used a pattern they\\'d memorized. "
                    },
                    {
                        "username": "shivrajhulwan7",
                        "content": "The question is easy. Just don\\'t get confused with minimum total cost.\\nBecause if you see then from any way the cost is same. "
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be an easy problem"
                    }
                ]
            }
        ]
    }
]