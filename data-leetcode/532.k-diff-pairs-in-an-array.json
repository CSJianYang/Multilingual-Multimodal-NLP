[
    {
        "title": "K-diff Pairs in an Array",
        "question_content": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n\n\t0 <= i, j < nums.length\n\ti != j\n\t|nums[i] - nums[j]| == k\n\nNotice that |val| denotes the absolute value of val.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n\nExample 3:\n\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-107 <= nums[i] <= 107\n\t0 <= k <= 107",
        "solutions": [
            {
                "id": 1756874,
                "title": "c-multiple-approaches-maps-two-pointer",
                "content": "Hi , This problem is pretty straightforward . Let me explain the problem first. \\n##### EXPLANATION : \\nThe problem says that we are provided with an array of integers and we have to find out the ***Count of unique pairs*** in the array such that the ***absolute difference of elements of the pair is ==k.***\\nMathematically , find the **count of unique pairs ( nums[i], nums[j] )** such that ,\\n* *0 <= i < j < nums.length*\\n* *|nums[i] - nums[j]| == k*\\n\\n##### SOLUTION : \\nIt is pretty clear that in order to obtain the answer , we have to find all pairs the array which have an absolute difference of \\'k\\' and then eliminate those which are not unique.\\n\\nThere are multiple ways to achieve that. \\n\\n#### 1. USING MAPS : \\nWe are aware of the fact that for a pair to be counted as an answer , **both the elements ( x and x+k ) , need to be in the array**. \\nSo we simply **create a map and store the frequency** of each element in the map. \\nNow we traverse the map and for **each element \\'x\\'** , we **check if \\'x+k\\' exists in the map** . If it does , then it means **a unique pair can be formed** and hence, we **increment the answer**. \\n##### EDGE CASE : \\nThe only edge case is the situation where**k=0**. If k=0 , instead of finding \\'x+k\\' , we **check if the frequency of \\'x\\'>1**. If it is , then we**increment the answer** . \\nElse , we don\\'t **increment the answer , as the frequency of x=1 and hence it can\\'t form a pair with itself**.\\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> a;\\n        for(int i:nums)\\n            a[i]++;\\n        int ans=0;\\n        for(auto x:a)\\n        {\\n            if(k==0)\\n            {    \\n                if(x.second>1)\\n                ans++;\\n            }\\n             else if(a.find(x.first+k)!=a.end())\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : O(N)**\\n**SPACE COMPLEXITY : O(N)**\\n\\n\\n#### 2. USING TWO POINTERS : \\nWe are aware of the fact that for a pair to be counted as an answer , **both the elements ( x and x+k ) , need to be in the array.** \\nIn this approach , **first we sort the array** and maintain 2 pointers. \\n* *1st Pointer --> 1st Element of the Pair*\\n* *2nd Pointer --> 2nd Element of the Pair*\\n\\nWe set the 1st pointer at the 0th index and 2nd pointer at the 1st index. Then , \\n1. Move the 2nd pointer until **2nd pointer - 1st pointer >=k** . \\n2. If the **2nd pointer - 1st pointer ==k** , then **increment the answer and move the 2nd pointer to the next greater element.**   \\n3. Move the **1st pointer to the next greater element**. \\n\\nFollow the above procedure until **the 2nd pointer reaches the end of the array**.\\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,i=0,j=1;\\n        for(i,j;i<nums.size() and j<nums.size();)\\n        {\\n            if(i==j or nums[j]-nums[i]<k)\\n                j++;\\n            else \\n            {\\n                if(nums[j]-nums[i]==k)\\n                {\\n                    ans++;\\n                    j++;\\n                    for(;j<nums.size();j++)\\n                        if(nums[j]!=nums[j-1])\\n                            break;\\n                    if(j==nums.size())\\n                    return ans;\\n                    j--;                  \\n                }\\n                i++;\\n                while(i<j and nums[i]==nums[i-1])\\n                    i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : O(NlogN)**\\n**SPACE COMPLEXITY : O(1)**\\n\\n**NOTE : The 2nd approach doesn\\'t need to deal with the EDGE CASE mentioned in the 1st approach as , in the 2nd approach after finding a pair , we immediately move to the next greater element.**\\n\\nIf you found this post helpful , do upvote. \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> a;\\n        for(int i:nums)\\n            a[i]++;\\n        int ans=0;\\n        for(auto x:a)\\n        {\\n            if(k==0)\\n            {    \\n                if(x.second>1)\\n                ans++;\\n            }\\n             else if(a.find(x.first+k)!=a.end())\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,i=0,j=1;\\n        for(i,j;i<nums.size() and j<nums.size();)\\n        {\\n            if(i==j or nums[j]-nums[i]<k)\\n                j++;\\n            else \\n            {\\n                if(nums[j]-nums[i]==k)\\n                {\\n                    ans++;\\n                    j++;\\n                    for(;j<nums.size();j++)\\n                        if(nums[j]!=nums[j-1])\\n                            break;\\n                    if(j==nums.size())\\n                    return ans;\\n                    j--;                  \\n                }\\n                i++;\\n                while(i<j and nums[i]==nums[i-1])\\n                    i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756967,
                "title": "well-explained-two-easy-solutions",
                "content": "**First Approach : Using HashMap**\\n\\n1. First we will create map for counting frequencies of each element in the array.\\n2. Now we have 2 cases over here as \\n    -->a) if k == 0 it means we need to count frequency of the same element by using map.get(i) method.\\n\\t-->b) we need to take counter approach for every element by adding k everytime and check whether that element is present in map or not.\\n3. Instead of iterating through array, we will iterate through map.keySet() for getting unique elements.\\n\\t\\n\\t\\t// O(n) Time Solution\\n\\t\\n\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\t\\tMap<Integer, Integer> map = new HashMap();\\n\\t\\t\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t\\t\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\t\\t\\t\\t\\tint result = 0;\\n\\t\\t\\t\\t\\tfor (int i : map.keySet())\\n\\t\\t\\t\\t\\t\\tif (k > 0 && map.containsKey(i + k) || k == 0 && map.get(i) > 1)\\n\\t\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n**Second Approach : Using HashSet**\\n\\n1. First sort the array.\\n2. After that, iterating through loop from first element to the last element.\\n3. Using BinarySearch, checked whether (nums[i] + k) is present in the array from index i+1 to n....i.e. if it is present we can take it as for counting approach.\\n\\t\\t\\n\\t\\tArrays.binarySearch(array_name, start_index, end_index, value_for_checking) ==> this method returns index of value which we are searching.\\n\\t\\t\\n4. After that just added minimum element to set for getting unique pairs as we know set contains only unique values.\\n \\n\\t\\t// O(nlogn) Time Solution\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\tSet<Integer> uniquePair = new HashSet();\\n\\t\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\t\\tint n = nums.length;\\n\\n\\t\\t\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t\\t\\t\\tif (Arrays.binarySearch(nums, i + 1, n, nums[i] + k) > 0)\\n\\t\\t\\t\\t\\t\\tuniquePair.add(nums[i]);\\n\\n\\t\\t\\t\\treturn uniquePair.size();\\n\\t\\t\\t}\\n\\t\\t}\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0\\uD83C\\uDF38), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\t\\tMap<Integer, Integer> map = new HashMap();\\n\\t\\t\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t\\t\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\t\\t\\t\\t\\tint result = 0;\\n\\t\\t\\t\\t\\tfor (int i : map.keySet())\\n\\t\\t\\t\\t\\t\\tif (k > 0 && map.containsKey(i + k) || k == 0 && map.get(i) > 1)\\n\\t\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1756933,
                "title": "an-explanation-going-from-o-nlogn-o-n",
                "content": "So, this problem is very similar to a very famous problem `Two Sum` problem. But a slightly different, there we have to only check wether a pair exists or not which has 2 sum equals to the target. But here we have to count those such pairs & only consider the unique one.\\n\\n**Okay, so how we will solve this problem?**\\n\\n>One of the first idea came in mind that first-of all we sort this array. Let\\'s take an example :-\\n\\n**Input:** nums = [3,1,4,1,5], k = 2\\n**Output:** 2\\n\\nFirst we sort this array & it becomes :- [1,1,3,4,5]. After sorting what we will do is, start from the starting place & check the \\'x + k\\' exists on to right place or not!\\n\\n![image](https://assets.leetcode.com/users/images/525d936e-2f0e-435d-a65d-aa1fa0d50ee3_1644372336.409042.png)\\n\\nSo, first we sort the array & then we will look for the binary search. There is a `method in Java library` called **Arrays.binarySearch** & it may be available in `C++ & Python`. In this method we will pass the array [nums], start index [i + 1], end [n] \"size of the array\" & the value which we have to search [x + k]. If we find that we, then we will store minimum value of \\'x\\' into a set. Because we need only the **Unique Pair**.\\n\\nSo, we will get :- **{1,3} & {3,5}** so these are the 2 pairs we will get. \\n\\n***Let\\'s look at the code you will understand more clearly then,***\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums); // sorted the array\\n        Set<Integer> set = new HashSet<>(); // Declare the HashSet to only consider unique one\\'s\\n        int n = nums.length; // length of the array\\n        for(int i = 0; i < nums.length - 1; i++){\\n            // searching for binary index for the no from the i + 1 index to n \\n            // and check if we are getting nums[i] + k, where nums[i] is our \\'x\\'\\n            if(Arrays.binarySearch(nums, i + 1, n, nums[i] + k) > 0){\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n**Time Complexity :-** O(NlogN) + O(N * logN) = O(NlogN) + O(NlogN) = O(2NlogN) = *BigO(NlogN)*\\n\\n<hr>\\n<hr>\\n\\n> **Now, you we will ask**. Can we further improve it\\'s time complexity? **I\\'ll say yes. Using HashMap.**\\n\\nOkay, so considering the same example : nums[3,1,4,1,5]\\n\\nFirst we will build our HashMap. In Map we will keep the no. as a key & value as a count of occurence\\n\\n![image](https://assets.leetcode.com/users/images/16d72c73-6d89-4fcb-8bf0-db63867f5e1c_1644373538.138938.png)\\n\\nNow, there are 2 cases :-\\n1. If k > 0, then in this case we just need to check wether the counter part exists or not. So, if we are iterating \\'x + k\\' in our map, then we can increment our count\\n\\n\\n2. If k == 0, then we just need to check if x is more then 1 or not [x > 1] in our map.\\n\\nBut another thing we need to note that here as we iterate from the array after doing counting. Then we will get \"1\" two times. So, to avoid this instead of iterating over the array, we will iterate over the keyset of this map, which will give us the unique no. i.e. (3,1,4,5).\\n\\nAlright, so now *I hope approach is clear.*\\n\\n**Let\\'s code it:**\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int count = 0;\\n        for(int x : map.keySet()){\\n            if(k > 0 && map.containsKey(x + k) || k == 0 && map.get(x) > 1) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums); // sorted the array\\n        Set<Integer> set = new HashSet<>(); // Declare the HashSet to only consider unique one\\'s\\n        int n = nums.length; // length of the array\\n        for(int i = 0; i < nums.length - 1; i++){\\n            // searching for binary index for the no from the i + 1 index to n \\n            // and check if we are getting nums[i] + k, where nums[i] is our \\'x\\'\\n            if(Arrays.binarySearch(nums, i + 1, n, nums[i] + k) > 0){\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int count = 0;\\n        for(int x : map.keySet()){\\n            if(k > 0 && map.containsKey(x + k) || k == 0 && map.get(x) > 1) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100098,
                "title": "java-o-n-solution-one-hashmap-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || k < 0)   return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i : nums) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (k == 0) {\\n                //count how many elements in the array that appear more than twice.\\n                if (entry.getValue() >= 2) {\\n                    count++;\\n                } \\n            } else {\\n                if (map.containsKey(entry.getKey() + k)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || k < 0)   return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i : nums) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (k == 0) {\\n                //count how many elements in the array that appear more than twice.\\n                if (entry.getValue() >= 2) {\\n                    count++;\\n                } \\n            } else {\\n                if (map.containsKey(entry.getKey() + k)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100135,
                "title": "java-python-easy-understood-solution",
                "content": "# **Explanation**\\nCount the elements with `Counter`\\nIf `k > 0`, for each element `i`, check if `i + k` exist.\\nIf `k == 0`, for each element `i`, check if `count[i] > 1`\\n<br>\\n\\n# **Explanation**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Python**\\n```py\\ndef findPairs(self, nums, k):\\n        res = 0\\n        c = collections.Counter(nums)\\n        for i in c:\\n            if k > 0 and i + k in c or k == 0 and c[i] > 1:\\n                res += 1\\n        return res\\n```\\nwhich equals to:\\n```py\\ndef findPairs(self, nums, k):\\n        c = collections.Counter(nums)\\n        return  sum(k > 0 and i + k in c or k == 0 and c[i] > 1 for i in c)\\n```\\n\\n**Java**\\nBy @blackspinner\\n```java\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        }\\n        int res = 0;\\n        for (int x : cnt.keySet()) {\\n            if ((k > 0 && cnt.containsKey(x + k)) || (k == 0 && cnt.get(x) > 1)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```py\\ndef findPairs(self, nums, k):\\n        res = 0\\n        c = collections.Counter(nums)\\n        for i in c:\\n            if k > 0 and i + k in c or k == 0 and c[i] > 1:\\n                res += 1\\n        return res\\n```\n```py\\ndef findPairs(self, nums, k):\\n        c = collections.Counter(nums)\\n        return  sum(k > 0 and i + k in c or k == 0 and c[i] > 1 for i in c)\\n```\n```java\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        }\\n        int res = 0;\\n        for (int x : cnt.keySet()) {\\n            if ((k > 0 && cnt.containsKey(x + k)) || (k == 0 && cnt.get(x) > 1)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 142648,
                "title": "easy-java-solution-two-hashsets-o-n",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Set<Integer> numbers = new HashSet<>();\\n        Set<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (numbers.contains(n + k)) found.add(n);\\n            if (numbers.contains(n - k)) found.add(n - k);\\n            numbers.add(n);\\n        }\\n        return found.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Set<Integer> numbers = new HashSet<>();\\n        Set<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (numbers.contains(n + k)) found.add(n);\\n            if (numbers.contains(n - k)) found.add(n - k);\\n            numbers.add(n);\\n        }\\n        return found.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100104,
                "title": "two-pointer-approach",
                "content": "The problem is just a variant of 2-sum.\\n**Update:** Fixed a bug that can cause integer subtraction overflow.\\n**Update:** The code runs in `O(n log n)` time, using `O(1)` space.\\n\\n```java\\npublic int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Arrays.sort(nums);\\n    for (int i = 0, j = 0; i < nums.length; i++) {\\n        for (j = Math.max(j, i + 1); j < nums.length && (long) nums[j] - nums[i] < k; j++) ;\\n        if (j < nums.length && (long) nums[j] - nums[i] == k) ans++;\\n        while (i + 1 < nums.length && nums[i] == nums[i + 1]) i++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Arrays.sort(nums);\\n    for (int i = 0, j = 0; i < nums.length; i++) {\\n        for (j = Math.max(j, i + 1); j < nums.length && (long) nums[j] - nums[i] < k; j++) ;\\n        if (j < nums.length && (long) nums[j] - nums[i] == k) ans++;\\n        while (i + 1 < nums.length && nums[i] == nums[i + 1]) i++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100101,
                "title": "c-o-n-time-with-unordered-map",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n```\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    if (k < 0) return 0;\\n    unordered_map<int, int> m;\\n    for (int n : nums) m[n]++;\\n    int cnt = 0;\\n    for (auto p : m) {\\n      if ((!k && p.second > 1)\\n        || (k && m.count(p.first + k))) ++cnt;\\n    }\\n    return cnt;\\n  }\\n};\\n```\\n\\n---\\n\\nUpdate 2022/02/08:\\n\\nBack on 2017/06/06, the constraint of this problem was as follows (You can see the full problem description [here](https://github.com/lzl124631x/LeetCode/commit/8536736d9fb97483cd0875ccb7a7830b30420b24))\\n\\n>Given an array of integers and an integer **k**, ...\\n>**Note:**  \\n>\\n>1.  The pairs (i, j) and (j, i) count as the same pair.\\n>2.  The length of the array won\\'t exceed 10,000.\\n>3.  All the integers in the given input belong to the range: [-1e7, 1e7].\\n\\nIt didn\\'t say that `k >= 0`. That\\'s why I added the `k < 0` guard -- just like what we need to do in real world.\\n\\nNowadays, the constraints on LeetCode are much more detailed and explicit.\\n\\nIf I write the code today:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& A, int k) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        int ans = 0;\\n        for (auto &[n, cnt] : m) {\\n            ans += k ? m.count(n - k) : cnt > 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    if (k < 0) return 0;\\n    unordered_map<int, int> m;\\n    for (int n : nums) m[n]++;\\n    int cnt = 0;\\n    for (auto p : m) {\\n      if ((!k && p.second > 1)\\n        || (k && m.count(p.first + k))) ++cnt;\\n    }\\n    return cnt;\\n  }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& A, int k) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        int ans = 0;\\n        for (auto &[n, cnt] : m) {\\n            ans += k ? m.count(n - k) : cnt > 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100151,
                "title": "c-java-clean-code-with-explanation-set-map",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    /**\\n     * for every number in the array:\\n     *  - if there was a number previously k-diff with it, save the smaller to a set;\\n     *  - and save the value-index to a map;\\n     */\\n    int findPairs(vector<int>& nums, int k) {\\n        if (k < 0) {\\n            return 0;\\n        }\\n        unordered_set<int> starters;\\n        unordered_map<int, int> indices;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (indices.count(nums[i] - k)) {\\n                starters.insert(nums[i] - k);\\n            }\\n            if (indices.count(nums[i] + k)) {\\n                starters.insert(nums[i]);\\n            }\\n\\n            indices[nums[i]] += 1;\\n        }\\n        \\n        return starters.size();\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) { return 0; }\\n\\n        Set<Integer> starters = new HashSet<Integer>();\\n        Set<Integer> uniqs = new HashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (uniqs.contains(nums[i] - k)) starters.add(nums[i] - k);\\n            if (uniqs.contains(nums[i] + k)) starters.add(nums[i]);\\n            uniqs.add(nums[i]);\\n        }\\n\\n        return starters.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n     * for every number in the array:\\n     *  - if there was a number previously k-diff with it, save the smaller to a set;\\n     *  - and save the value-index to a map;\\n     */\\n    int findPairs(vector<int>& nums, int k) {\\n        if (k < 0) {\\n            return 0;\\n        }\\n        unordered_set<int> starters;\\n        unordered_map<int, int> indices;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (indices.count(nums[i] - k)) {\\n                starters.insert(nums[i] - k);\\n            }\\n            if (indices.count(nums[i] + k)) {\\n                starters.insert(nums[i]);\\n            }\\n\\n            indices[nums[i]] += 1;\\n        }\\n        \\n        return starters.size();\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) { return 0; }\\n\\n        Set<Integer> starters = new HashSet<Integer>();\\n        Set<Integer> uniqs = new HashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (uniqs.contains(nums[i] - k)) starters.add(nums[i] - k);\\n            if (uniqs.contains(nums[i] + k)) starters.add(nums[i]);\\n            uniqs.add(nums[i]);\\n        }\\n\\n        return starters.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876197,
                "title": "python-o-n-solution-explained",
                "content": "Let us just use counter and count frequency of each number in our array. We can have two options:\\n\\n1. `k > 0`, it means, that for each unique number `i` we are asking if number `i+k` also in table.\\n2. `k = 0`, it means, that we are looking for pairs of equal numbers, so just check each frequency.\\n\\n**Complexity**: time and space complexity is `O(n)`, because we traverse our array twice: first time to create counter and second to find `res`.\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums, k):\\n        count = Counter(nums)\\n        if k > 0:\\n            res = sum([i + k in count for i in count])\\n        else:\\n            res = sum([count[i] > 1 for i in count])\\n        return res\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums, k):\\n        count = Counter(nums)\\n        if k > 0:\\n            res = sum([i + k in count for i in count])\\n        else:\\n            res = sum([count[i] > 1 for i in count])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100116,
                "title": "1-liner-in-python-o-n-time",
                "content": "```\\n    def findPairs(self, nums, k):\\n       return len(set(nums)&{n+k for n in nums}) if k>0 else sum(v>1 for v in collections.Counter(nums).values()) if k==0 else 0\\n```\\nwhich is equivalent to:\\n```\\n    def findPairs(self, nums, k):\\n        if k>0:\\n            return len(set(nums)&set(n+k for n in nums))\\n        elif k==0:\\n            sum(v>1 for v in collections.Counter(nums).values())\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def findPairs(self, nums, k):\\n       return len(set(nums)&{n+k for n in nums}) if k>0 else sum(v>1 for v in collections.Counter(nums).values()) if k==0 else 0\\n```\n```\\n    def findPairs(self, nums, k):\\n        if k>0:\\n            return len(set(nums)&set(n+k for n in nums))\\n        elif k==0:\\n            sum(v>1 for v in collections.Counter(nums).values())\\n        else:\\n            return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1757434,
                "title": "python-o-n-solution-98-faster-easy-solution-k-diff-pairs-in-an-array",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        cnt=0\\n        c=Counter(nums)\\n        \\n        if k==0:\\n            for key,v in c.items():\\n                if v>1:\\n                    cnt+=1\\n        else:\\n            for key,v in c.items():\\n                if key+k in c:\\n                    cnt+=1\\n        return cnt\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        cnt=0\\n        c=Counter(nums)\\n        \\n        if k==0:\\n            for key,v in c.items():\\n                if v>1:\\n                    cnt+=1\\n        else:\\n            for key,v in c.items():\\n                if key+k in c:\\n                    cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877159,
                "title": "c-super-simple-solution-o-n-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757692,
                "title": "java-easy-to-understand-two-approaches-sorting-hashmap",
                "content": "#### **Method 1:  using sorting and two pointers**\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0, j=1, diff=0, n=nums.length, sum=Integer.MIN_VALUE;\\n        int count=0;\\n        while(j<n && i<n-1){\\n\\t\\t    // ((nums[i]+nums[j])!=sum) -> this will take care of no repetetion\\n\\t\\t\\t//if we found any match, increase i , j by 1\\n            if(nums[j]-nums[i]==k && (nums[i]+nums[j])!=sum){\\n                sum=nums[i]+nums[j];\\n                i++; j++; count++;\\n            }\\n\\t\\t\\t//if diff is smaller than k increase j by 1\\n\\t\\t\\telse if((nums[j]-nums[i])<k){\\n                j++;\\n            }\\n\\t\\t\\t//else case, when diff is greater than k, increase i by 1\\n\\t\\t\\telse{\\n                i++;\\n            }\\n\\t\\t\\t//check if i and j are not same to aoid duplicates\\n            if(i==j) j++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Time Complexity** : O(nlogn) + O(n)\\n**Space Complexity** : O(n)\\n\\n#### **Method 2 : using HashMap**\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n\\t    // corner cases\\n        if(nums==null || nums.length==0 || k<0) return 0;\\n        int count=0;\\n        Map<Integer, Integer> hash=new HashMap<>();\\n\\t\\t//frequency map\\n        for(int i:nums)\\n            hash.put(i, hash.getOrDefault(i, 0)+1);\\n        for(Map.Entry<Integer, Integer> entry:hash.entrySet())\\n\\t\\t    // check if any such pair exist or not\\n\\t\\t\\t//in case of k==0 check whether any number having frequency >=2 or not.\\n            if((hash.containsKey(entry.getKey()+k) && k!=0) || (k==0 && entry.getValue()>1))\\n                count++;\\n        return count;\\n    }\\n}\\n```\\n**Time Complexity** :  O(n)\\n**Space Complexity** : O(n)\\n\\n**Don\\'t forget to upvote, it inspires me a lot, Thank you!**",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0, j=1, diff=0, n=nums.length, sum=Integer.MIN_VALUE;\\n        int count=0;\\n        while(j<n && i<n-1){\\n\\t\\t    // ((nums[i]+nums[j])!=sum) -> this will take care of no repetetion\\n\\t\\t\\t//if we found any match, increase i , j by 1\\n            if(nums[j]-nums[i]==k && (nums[i]+nums[j])!=sum){\\n                sum=nums[i]+nums[j];\\n                i++; j++; count++;\\n            }\\n\\t\\t\\t//if diff is smaller than k increase j by 1\\n\\t\\t\\telse if((nums[j]-nums[i])<k){\\n                j++;\\n            }\\n\\t\\t\\t//else case, when diff is greater than k, increase i by 1\\n\\t\\t\\telse{\\n                i++;\\n            }\\n\\t\\t\\t//check if i and j are not same to aoid duplicates\\n            if(i==j) j++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n\\t    // corner cases\\n        if(nums==null || nums.length==0 || k<0) return 0;\\n        int count=0;\\n        Map<Integer, Integer> hash=new HashMap<>();\\n\\t\\t//frequency map\\n        for(int i:nums)\\n            hash.put(i, hash.getOrDefault(i, 0)+1);\\n        for(Map.Entry<Integer, Integer> entry:hash.entrySet())\\n\\t\\t    // check if any such pair exist or not\\n\\t\\t\\t//in case of k==0 check whether any number having frequency >=2 or not.\\n            if((hash.containsKey(entry.getKey()+k) && k!=0) || (k==0 && entry.getValue()>1))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100109,
                "title": "interesting-java-solution-hashset-only",
                "content": "Put all numbers n in Hashset S1.\\nPut all numbers n+k in HashSet S2.\\nThe number of pairs are the intersection of the two Hashsets. Different conditions apply to k=0 or k<0.\\n\\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        if(k<0) return ans;\\n        \\n        Set<Integer> set1 = new HashSet<Integer> ();\\n        Set<Integer> set2 = new HashSet<Integer> ();\\n        \\n        if(k==0){\\n                for(int n:nums){\\n                    if(!set1.contains(n))\\n                        {set1.add(n);}\\n                    else{\\n                        set1.remove(n);\\n                        if(!set2.contains(n)) ans++;\\n                        set2.add(n);\\n                        }\\n                }\\n        }\\n        else{\\n            for(int n:nums){\\n                set1.add(n);\\n                set2.add(n+k);\\n            }\\n            set1.retainAll(set2);\\n            ans = set1.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        if(k<0) return ans;\\n        \\n        Set<Integer> set1 = new HashSet<Integer> ();\\n        Set<Integer> set2 = new HashSet<Integer> ();\\n        \\n        if(k==0){\\n                for(int n:nums){\\n                    if(!set1.contains(n))\\n                        {set1.add(n);}\\n                    else{\\n                        set1.remove(n);\\n                        if(!set2.contains(n)) ans++;\\n                        set2.add(n);\\n                        }\\n                }\\n        }\\n        else{\\n            for(int n:nums){\\n                set1.add(n);\\n                set2.add(n+k);\\n            }\\n            set1.retainAll(set2);\\n            ans = set1.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757438,
                "title": "c-solution-w-explanation-brute-force-to-optimize-two-approaches",
                "content": "***Brief note about Question-***\\n\\nWe have to  ***return the number of unique k-diff pairs in the array.***\\n\\nK- diff pair (arr[i], arr[j]) is nothing but basically \\n* 0 < i < j < arr.size()\\n* abs(arr[i] - arr[j]) == k\\n______________\\n***Solution - I (Accepted)-***\\n* We try to implement what the question wants to do, like this is the most basic thing we can do.\\n* We traverse from all of the array and find unique pairs where their absoloute difference is k and increment our count.\\n* See commented program for explanation.\\n```\\nTime Complexity --> O(n ^ 2) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\\n\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        int count = 0; // variable to store count\\n        \\n        sort(arr.begin(), arr.end()); // sort the array to find unique pairs\\n        map<pair<int,int>, int> mp; // make a map where key is pair & value if it occurs\\n        \\n        for(int i = 0; i < n - 1; i++) // traverse from the whole array\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                if(abs(arr[j] - arr[i]) == k) // if it follows criteria\\n                {\\n                    // make a pair to find whether it is unique or not\\n                    pair<int,int> p = {arr[i], arr[j]}; \\n                    \\n                     // if this pair not present in the map, then we do the computation\\n                    if(mp.find(p) == mp.end())\\n                    {\\n                        count++; // increment count\\n                        mp[p] = 1; // make its value as 1, saying that now it is present in our map\\n                    }\\n                }\\n            }\\n        }\\n        return count; // and at last return the count\\n    }\\n};\\n```\\n__________________\\n***Solution - II (Accepted)-***\\n* So a question arises can we optimise it.\\n* And answer is yes, but how?\\n* See, *we have to find number of unique pairs such that their absoloute difference is k.*\\n* suppose, **`a - b == k --> a = b + k`**\\n* Can\\'t we store all the values of array into a map and then `for every value we find value + k`.\\n* That\\'s all we have to do.\\n* see commented code for more explanation.\\n```\\nTime Complexity --> O(n) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using unordered map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        unordered_map<int, int> mp; // map to store all values of array\\n        \\n        for(int i = 0; i < n; i++) //store all values of array into map\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int count = 0; // variable to store the unique pairs\\n        \\n        if(k != 0) // if k is not zero\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++) // traverse in all over the map\\n            {\\n                // if value + k is present in map\\n                if(mp.find(it -> first + k) != mp.end())\\n                {\\n                    count++; // increment count\\n                }\\n            }\\n        }\\n        else // see for k = 0, we have to just find all the values greater than 1\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++)\\n            {\\n                if(it -> second > 1)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count; // at last return count\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime Complexity --> O(n ^ 2) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        int count = 0; // variable to store count\\n        \\n        sort(arr.begin(), arr.end()); // sort the array to find unique pairs\\n        map<pair<int,int>, int> mp; // make a map where key is pair & value if it occurs\\n        \\n        for(int i = 0; i < n - 1; i++) // traverse from the whole array\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                if(abs(arr[j] - arr[i]) == k) // if it follows criteria\\n                {\\n                    // make a pair to find whether it is unique or not\\n                    pair<int,int> p = {arr[i], arr[j]}; \\n                    \\n                     // if this pair not present in the map, then we do the computation\\n                    if(mp.find(p) == mp.end())\\n                    {\\n                        count++; // increment count\\n                        mp[p] = 1; // make its value as 1, saying that now it is present in our map\\n                    }\\n                }\\n            }\\n        }\\n        return count; // and at last return the count\\n    }\\n};\\n```\n```\\nTime Complexity --> O(n) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using unordered map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        unordered_map<int, int> mp; // map to store all values of array\\n        \\n        for(int i = 0; i < n; i++) //store all values of array into map\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int count = 0; // variable to store the unique pairs\\n        \\n        if(k != 0) // if k is not zero\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++) // traverse in all over the map\\n            {\\n                // if value + k is present in map\\n                if(mp.find(it -> first + k) != mp.end())\\n                {\\n                    count++; // increment count\\n                }\\n            }\\n        }\\n        else // see for k = 0, we have to just find all the values greater than 1\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++)\\n            {\\n                if(it -> second > 1)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count; // at last return count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324925,
                "title": "readable-simple-python",
                "content": "O(n) Time.\\nO(n) Space.\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t#If k is less than 0, then the result is 0 since we are looking fpr pairs with an ABSOLUTE difference of k.\\n        if k < 0:\\n            return 0\\n        \\n        count = Counter(nums)\\n        pairs = set([])\\n        \\n        for num in count.keys():\\n\\t\\t\\t#Special case: If k == 0, then there needs to be at least two occurences of a particular num in nums \\n\\t\\t\\t#in order for there to be a pair (num, num).\\n            if k == 0:\\n                if count[num] > 1:\\n                    pairs.add((num, num))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#Regular case: k != 0. Simply check if num + k is a member of the array nums.\\n\\t\\t\\t#Insert the pair into the set of pairs (smallerNum, largerNum) so that there are no duplicate pairs.\\n            else:\\n                otherNum = num + k\\n                if otherNum in count:\\n                    pairs.add((num, otherNum) if num <= otherNum else (otherNum, num))\\n                    \\n        return len(pairs)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t#If k is less than 0, then the result is 0 since we are looking fpr pairs with an ABSOLUTE difference of k.\\n        if k < 0:\\n            return 0\\n        \\n        count = Counter(nums)\\n        pairs = set([])\\n        \\n        for num in count.keys():\\n\\t\\t\\t#Special case: If k == 0, then there needs to be at least two occurences of a particular num in nums \\n\\t\\t\\t#in order for there to be a pair (num, num).\\n            if k == 0:\\n                if count[num] > 1:\\n                    pairs.add((num, num))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#Regular case: k != 0. Simply check if num + k is a member of the array nums.\\n\\t\\t\\t#Insert the pair into the set of pairs (smallerNum, largerNum) so that there are no duplicate pairs.\\n            else:\\n                otherNum = num + k\\n                if otherNum in count:\\n                    pairs.add((num, otherNum) if num <= otherNum else (otherNum, num))\\n                    \\n        return len(pairs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100111,
                "title": "o-n-concise-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k < 0) return 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); ++i)\\n           ++m[nums[i]];\\n        int res = 0;\\n        if(k != 0) {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(m.find(it->first+k) != m.end())\\n                   ++res;\\n        } else {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(it->second > 1)\\n                   ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k < 0) return 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); ++i)\\n           ++m[nums[i]];\\n        int res = 0;\\n        if(k != 0) {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(m.find(it->first+k) != m.end())\\n                   ++res;\\n        } else {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(it->second > 1)\\n                   ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399753,
                "title": "python-concise-o-n-solution-using-sets-only-one-pass-through-the-list",
                "content": "Check whether num + k and num - k are already in the set and also make sure the pair is not already counted. Only goes throught the list one time.\\n\\nEdit: after reading other solutions, some memory can be saved by only saving the smallest value between num1 and num2 in pairsSet instead of the sorted tuple.\\n```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        if k < 0: return 0\\n        numsSet, pairsSet = set(), set()\\n        for num1 in nums:\\n            for num2 in [num1 + k, num1 - k]:\\n                if num2 in numsSet:\\n                    pairsSet.add(tuple(sorted([num1, num2])))\\n            numsSet.add(num1)\\n        return len(pairsSet)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        if k < 0: return 0\\n        numsSet, pairsSet = set(), set()\\n        for num1 in nums:\\n            for num2 in [num1 + k, num1 - k]:\\n                if num2 in numsSet:\\n                    pairsSet.add(tuple(sorted([num1, num2])))\\n            numsSet.add(num1)\\n        return len(pairsSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298502,
                "title": "java-6ms-beats-98-simple-2-pointer-approach",
                "content": "This is a pretty standard 2 pointer approach with a unique take away when looking at duplicates. One thing that took me a little bit to wrap my head around was how we can accurately determine what is a valid answer. I also didn\\'t see any posts where they showed this approach so I thought I would share.\\n\\n\\nTo start I think its easier to look at, what IS NOT a valid answer.\\n1. If the left pointer has caught up to our right pointer. This is between two different values so if left == right, this will never be a valid answer.\\n2. If we have previously used this value to accurately determine that two values compute a valid answer.\\n\\t* \\tFor this problem I used a previous variable and set it whenever we find a value where nums[r] - nums[l] == k. This stops any sort of duplicates from happening.\\n3. As mentioned earlier we must also check that nums[r]-nums[l] == k. We use the while loop to get as close as possible for each iteration but we need the final if statement to check accuracy.\\n\\nHope this helps someone!\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(nums == null || nums.length < 1) return 0;\\n        \\n        Arrays.sort(nums);\\n        int l = 0, ans = 0, prev = Integer.MAX_VALUE;\\n        for(int r = 1; r < nums.length; r++) {\\n            while(l < r && nums[r] - nums[l] > k) l++;\\n            \\n            if(l != r && prev != nums[l] && nums[r] - nums[l] == k) {\\n                ans++;\\n                prev = nums[l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(nums == null || nums.length < 1) return 0;\\n        \\n        Arrays.sort(nums);\\n        int l = 0, ans = 0, prev = Integer.MAX_VALUE;\\n        for(int r = 1; r < nums.length; r++) {\\n            while(l < r && nums[r] - nums[l] > k) l++;\\n            \\n            if(l != r && prev != nums[l] && nums[r] - nums[l] == k) {\\n                ans++;\\n                prev = nums[l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287783,
                "title": "java-o-n-hashmap-one-pass-easy-solution",
                "content": "```\\npublic int findPairs(int[] nums, int k) {\\n        int count =0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(!map.containsKey(nums[i])) {\\n                if(map.containsKey(nums[i] + k)) count++;\\n                if(map.containsKey(nums[i] - k)) count++;\\n                map.put(nums[i], 1);\\n            } else if (k == 0) {\\n                   if(map.get(nums[i]) == 1)\\n                      count++;\\n                   map.put(nums[i], map.get(nums[i]) + 1);\\n            }         \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n        int count =0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(!map.containsKey(nums[i])) {\\n                if(map.containsKey(nums[i] + k)) count++;\\n                if(map.containsKey(nums[i] - k)) count++;\\n                map.put(nums[i], 1);\\n            } else if (k == 0) {\\n                   if(map.get(nums[i]) == 1)\\n                      count++;\\n                   map.put(nums[i], map.get(nums[i]) + 1);\\n            }         \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100114,
                "title": "self-explained-ac-java-sliding-window",
                "content": "```\\n public  int findPairs(int[] nums, int k) {\\n\\tif(k<0 || nums.length<=1){\\n\\t    return 0;\\n\\t}\\n\\t\\t \\n         Arrays.sort(nums);\\n         int count = 0;\\n         int left = 0;\\n         int right = 1;\\n         \\n         while(right<nums.length){\\n             int firNum = nums[left];\\n             int secNum = nums[right];\\n             // If less than k, increase the right index\\n             if(secNum-firNum<k){\\n                 right++;\\n             }\\n             // If larger than k, increase the left index\\n             else if(secNum - firNum>k){\\n                 left++;   \\n             }\\n             // If equal, move left and right to next different number\\n             else{\\n                 count++;\\n                 while(left<nums.length && nums[left]==firNum){\\n                     left++;\\n                 }\\n                 while(right<nums.length && nums[right]==secNum){\\n                     right++;\\n                 }\\n                             \\n             }\\n             //left and right should not be the same number\\n             if(right==left){\\n             \\tright++;\\n             }\\n         }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public  int findPairs(int[] nums, int k) {\\n\\tif(k<0 || nums.length<=1){\\n\\t    return 0;\\n\\t}\\n\\t\\t \\n         Arrays.sort(nums);\\n         int count = 0;\\n         int left = 0;\\n         int right = 1;\\n         \\n         while(right<nums.length){\\n             int firNum = nums[left];\\n             int secNum = nums[right];\\n             // If less than k, increase the right index\\n             if(secNum-firNum<k){\\n                 right++;\\n             }\\n             // If larger than k, increase the left index\\n             else if(secNum - firNum>k){\\n                 left++;   \\n             }\\n             // If equal, move left and right to next different number\\n             else{\\n                 count++;\\n                 while(left<nums.length && nums[left]==firNum){\\n                     left++;\\n                 }\\n                 while(right<nums.length && nums[right]==secNum){\\n                     right++;\\n                 }\\n                             \\n             }\\n             //left and right should not be the same number\\n             if(right==left){\\n             \\tright++;\\n             }\\n         }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757594,
                "title": "best-approach-easy-solution-easy-understanding",
                "content": "```\\n//Please upvote,if u like it :)\\nint findPairs(vector<int>& nums, int k){\\n        unordered_map<int,int> mp;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        int ans = 0;\\n        for(auto it:mp){\\n            int findd = it.first + k;\\n            if(mp.find(findd) != mp.end()){\\n                if(findd == it.first && mp[findd] > 1){\\n                    ans++;\\n                }else if(findd != it.first){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n//Please upvote,if u like it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n//Please upvote,if u like it :)\\nint findPairs(vector<int>& nums, int k){\\n        unordered_map<int,int> mp;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        int ans = 0;\\n        for(auto it:mp){\\n            int findd = it.first + k;\\n            if(mp.find(findd) != mp.end()){\\n                if(findd == it.first && mp[findd] > 1){\\n                    ans++;\\n                }else if(findd != it.first){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n//Please upvote,if u like it :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756950,
                "title": "problem-with-description",
                "content": "The question that is being checked for is not the question that is being asked.\\n\\nThe question being checked for seems to be:\\n\\n*Given an array of integers nums and an integer k, return the number of unique pairs that are of the form (nums[i], nums[j]) where*\\n**nums[i] <= nums[j]\\ni != j\\nabs(nums[i] - nums[j]) == k**\\n\\nThe question that is being asked is similar but different:\\n\\n*Given an array of integers nums and an integer k, return the number of unique pairs that are of the form (nums[i], nums[j]) where*\\n**i < j\\nabs(nums[i] - nums[j]) == k**\\n\\nFor all of the examples in the problem description, the two questions give the same answer. Buf for the test case\\n```\\n[0,3,0]\\n3\\n```\\nthe expected solution is 1, while the answer should be 2, given the actual problem description.\\n\\nThe pairs for the actual question are (0, 3) and (3, 0)\\nThe pair for the checked for question is (0, 3)\\n\\nFWIW, here\\'s a quadratic time brute force literal interpretation of the problem description that gets 2.\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        k_diff_pairs = []\\n        for i in range(n):\\n            for j in range(n):\\n                if i < j:\\n                    if abs(nums[i] - nums[j]) == k:\\n                        k_diff_pairs.append((nums[i], nums[j]))\\n        return len(frozenset(k_diff_pairs))\\n```\\nAnd here\\'s an O(n) time solution\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        so_far = dict()\\n        for num in nums:\\n            for x in (num - k, num + k):\\n                if x in so_far:\\n                    if num not in so_far[x]:\\n                        count += 1\\n                        so_far[x].append(num)\\n            if num not in so_far:\\n                so_far[num] = []\\n        return count\\n```\\nPlease consider updating the problem statement and adding the above test case to the examples.\\n\\nNote that the above test example is a simplified version of one of the tests used to check a solution, namely\\n```\\n[1,2,4,4,3,3,0,9,2,3]\\n3\\n```",
                "solutionTags": [],
                "code": "```\\n[0,3,0]\\n3\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        k_diff_pairs = []\\n        for i in range(n):\\n            for j in range(n):\\n                if i < j:\\n                    if abs(nums[i] - nums[j]) == k:\\n                        k_diff_pairs.append((nums[i], nums[j]))\\n        return len(frozenset(k_diff_pairs))\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        so_far = dict()\\n        for num in nums:\\n            for x in (num - k, num + k):\\n                if x in so_far:\\n                    if num not in so_far[x]:\\n                        count += 1\\n                        so_far[x].append(num)\\n            if num not in so_far:\\n                so_far[num] = []\\n        return count\\n```\n```\\n[1,2,4,4,3,3,0,9,2,3]\\n3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876351,
                "title": "c-java-python-counter-o-n-clean-concise",
                "content": "**Idea**\\n- Build `cnt` is a map to map `unique numbers` and `their counts` .\\n- For each `b` in `cnt`: \\n\\t- If `k > 0` and `a = b - k` exists then we count `(a, b)` as a `k-diff pair`.\\n\\t- If `k = 0` and `b` appears at least 2 times then we count`(b, b)` as a `k-diff pair`.\\n\\n**Complexity** \\n- Time & Space: O(N)\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        cnt = Counter(nums)\\n        ans = 0\\n        for b in cnt:\\n            if (k > 0 and b - k in cnt) or (k == 0 and cnt[b] >= 2):\\n                ans += 1\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> cnt;\\n        for (int x : nums)\\n            cnt[x] += 1;\\n        int ans = 0;\\n        for (auto [b, _] : cnt)\\n            if ((k > 0 && cnt.count(b - k)) || (k == 0 && cnt[b] >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> cnt = new HashMap();\\n        for (int x : nums)\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int b : cnt.keySet())\\n            if ((k > 0 && cnt.containsKey(b - k)) || (k == 0 && cnt.get(b) >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        cnt = Counter(nums)\\n        ans = 0\\n        for b in cnt:\\n            if (k > 0 and b - k in cnt) or (k == 0 and cnt[b] >= 2):\\n                ans += 1\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> cnt;\\n        for (int x : nums)\\n            cnt[x] += 1;\\n        int ans = 0;\\n        for (auto [b, _] : cnt)\\n            if ((k > 0 && cnt.count(b - k)) || (k == 0 && cnt[b] >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> cnt = new HashMap();\\n        for (int x : nums)\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int b : cnt.keySet())\\n            if ((k > 0 && cnt.containsKey(b - k)) || (k == 0 && cnt.get(b) >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676154,
                "title": "java-hashmap",
                "content": "```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            if (map.containsKey(i)) {\\n                if (k == 0 && map.get(i) == 1) {\\n                    map.put(i, map.get(i) + 1);\\n                    res++;\\n                }\\n                continue;\\n            }\\n            res += map.getOrDefault(i + k, 0);\\n            res += map.getOrDefault(i - k, 0);\\n            map.put(i, 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            if (map.containsKey(i)) {\\n                if (k == 0 && map.get(i) == 1) {\\n                    map.put(i, map.get(i) + 1);\\n                    res++;\\n                }\\n                continue;\\n            }\\n            res += map.getOrDefault(i + k, 0);\\n            res += map.getOrDefault(i - k, 0);\\n            map.put(i, 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516401,
                "title": "c-o-nlogn-solution-without-hashmap-detail-explanation",
                "content": "Sort and then perform two scans in parallel, maintaining a difference as close to k as possible between the two scan positions. In other words, advance the leading scan when the difference is smaller than k, and advance the lagging scan when the difference is greater. This way we either find a pair or scan through the list and report that no pair exists. Time complexity: O(n log n).\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint fast=1;\\n\\t\\t\\tint slow=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(slow<nums.size() && fast<nums.size()){\\n\\t\\t\\t\\tif(nums[fast]-nums[slow]==k){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\tslow++;\\n\\t\\t\\t\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[fast]-nums[slow]>k){\\n\\t\\t\\t\\t\\tslow++;  \\n\\t\\t\\t\\t\\tif(fast-slow==0){\\n\\t\\t\\t\\t\\t\\tfast++;}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{      \\n\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t}         \\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint fast=1;\\n\\t\\t\\tint slow=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(slow<nums.size() && fast<nums.size()){\\n\\t\\t\\t\\tif(nums[fast]-nums[slow]==k){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\tslow++;\\n\\t\\t\\t\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1682639,
                "title": "multiple-solutions-in-c-with-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we sort the vector to avoid duplicate elements in the set.\\n- Take to loops & if the difference is equal to k, push it to set.\\n- Calculate the set size in the count variable and return it.\\n- **Time complexity:** O(n^2 logn).\\n\\n### Solution 02\\n\\n- Here we sort the values and store the element occurrence in the map.\\n- If k=0, then the difference of 2 same elements will be equal to 0.\\n- If not then we\\u2019ll iterate the map & will find if the ***(k-current element)*** is present in the map.\\nIf present then we\\u2019ll increase count.\\n- Also every time we\\u2019ll remove the current element from map to avoid repeating elements.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0;\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>>res;\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(abs(nums[i]-nums[j])==k)\\n                    res.insert({nums[i], nums[j]});\\n            }\\n        }\\n        count = res.size();\\n        return count;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0, l=0, r=n-1;\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int>mp;\\n        \\n        if(k<0) return 0;\\n        \\n        for(auto x: nums)\\n            mp[x]++;\\n\\n        if(k==0){\\n            for(auto x:mp){\\n                if(x.second>1)\\n                    count++;\\n            }\\n        }\\n        else{\\n            for(auto x:mp){\\n                x.second--;\\n                if(mp.count(x.first-k))\\n                    count++;\\n                x.second++;\\n            }    \\n        }\\n        \\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0;\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>>res;\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(abs(nums[i]-nums[j])==k)\\n                    res.insert({nums[i], nums[j]});\\n            }\\n        }\\n        count = res.size();\\n        return count;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0, l=0, r=n-1;\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int>mp;\\n        \\n        if(k<0) return 0;\\n        \\n        for(auto x: nums)\\n            mp[x]++;\\n\\n        if(k==0){\\n            for(auto x:mp){\\n                if(x.second>1)\\n                    count++;\\n            }\\n        }\\n        else{\\n            for(auto x:mp){\\n                x.second--;\\n                if(mp.count(x.first-k))\\n                    count++;\\n                x.second++;\\n            }    \\n        }\\n        \\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877137,
                "title": "python-3-faster-than-99-77-dictionary",
                "content": "```\\n# Faster than 99.77% of Python3 online submissions\\n# Memory Usage: 15.6 MB, less than 34.48% of Python3 online submissions\\n\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        # return the number of unique pairs\\n        answ=0\\n        # create a dictionary: d[x]==nums.count(x)\\n        d={}\\n        for x in nums:\\n            if x in d: d[x]+=1\\n            else:      d[x]=1\\n        \\n        if k: # k>0\\n            answ=sum(x+k in d for x in d.keys())\\n        else: # k==0\\n            answ=sum(k>1 for k in d.values())\\n                \\n        return answ\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Faster than 99.77% of Python3 online submissions\\n# Memory Usage: 15.6 MB, less than 34.48% of Python3 online submissions\\n\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        # return the number of unique pairs\\n        answ=0\\n        # create a dictionary: d[x]==nums.count(x)\\n        d={}\\n        for x in nums:\\n            if x in d: d[x]+=1\\n            else:      d[x]=1\\n        \\n        if k: # k>0\\n            answ=sum(x+k in d for x in d.keys())\\n        else: # k==0\\n            answ=sum(k>1 for k in d.values())\\n                \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877129,
                "title": "c-simple-soln-hashing-beats-99-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        int ans=0;\\n        if(k==0)\\n        {\\n            for(auto x: m) if(x.second>1) ans++;\\n        }\\n        else\\n        {\\n            for(auto x: m)\\n            {\\n                if(m.count(x.first + k) > 0) ans++; \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        int ans=0;\\n        if(k==0)\\n        {\\n            for(auto x: m) if(x.second>1) ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 876550,
                "title": "beats-99-of-python3-hashmap-no-libraries",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        cnt = 0\\n        for i in nums:\\n            if i not in d:\\n                d[i] = 1\\n            else:\\n                d[i] += 1\\n        \\n        if k == 0:\\n            for i in d.values():\\n                if i > 1:\\n                    cnt += 1\\n        else:\\n            for i in d:\\n                if k + i in d:\\n                    cnt += 1\\n            \\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        cnt = 0\\n        for i in nums:\\n            if i not in d:\\n                d[i] = 1\\n            else:\\n                d[i] += 1\\n        \\n        if k == 0:\\n            for i in d.values():\\n                if i > 1:\\n                    cnt += 1\\n        else:\\n            for i in d:\\n                if k + i in d:\\n                    cnt += 1\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431250,
                "title": "java-hashmap-solution-easy-to-understand",
                "content": "```\\npublic int findPairs(int[] nums, int k) {\\n\\tif(nums == null || nums.length == 0 || k<0) return 0;\\n\\tint count = 0;\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tfor(int num : nums) \\n\\t\\thm.put(num, hm.getOrDefault(num, 0)+1);\\n\\tfor(Map.Entry<Integer, Integer> e : hm.entrySet())\\n\\t\\tif(k==0 && e.getValue()>=2) count++;\\n\\t\\telse if(k!=0 && hm.containsKey(e.getKey()+k)) count++;\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n\\tif(nums == null || nums.length == 0 || k<0) return 0;\\n\\tint count = 0;\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tfor(int num : nums) \\n\\t\\thm.put(num, hm.getOrDefault(num, 0)+1);\\n\\tfor(Map.Entry<Integer, Integer> e : hm.entrySet())\\n\\t\\tif(k==0 && e.getValue()>=2) count++;\\n\\t\\telse if(k!=0 && hm.containsKey(e.getKey()+k)) count++;\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415255,
                "title": "javascript-solution-o-n-beats-92-r-and-100-m-using-map-easy-to-understand",
                "content": "\\t/**\\n\\t * @param {number[]} nums\\n\\t * @param {number} k\\n\\t * @return {number}\\n\\t */\\n\\tvar findPairs = function(nums, k) {\\n\\t\\tif(nums.length === 0 || k < 0) return 0\\n\\t\\tlet myMap = new Map(),\\n\\t\\t\\tcount = 0\\n\\t\\t//Get wordcount\\n\\t\\tfor(num of nums){\\n\\t\\t\\tmyMap.set(num,(myMap.get(num)+1) || 1)\\n\\t\\t}\\n\\t\\t\\n\\t\\t//search solutions\\n\\t\\tmyMap.forEach((value,key) =>{\\n\\t\\t\\tif(k === 0){\\n\\t\\t\\t\\tif(value > 1) count++\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(myMap.has(key+k)) count++\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\treturn count\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\t/**\\n\\t * @param {number[]} nums\\n\\t * @param {number} k\\n\\t * @return {number}\\n\\t */\\n\\tvar findPairs = function(nums, k) {\\n\\t\\tif(nums.length === 0 || k < 0) return 0\\n\\t\\tlet myMap = new Map(),\\n\\t\\t\\tcount = 0\\n\\t\\t//Get wordcount\\n\\t\\tfor(num of nums){\\n\\t\\t\\tmyMap.set(num,(myMap.get(num)+1) || 1)\\n\\t\\t}\\n\\t\\t\\n\\t\\t//search solutions\\n\\t\\tmyMap.forEach((value,key) =>{\\n\\t\\t\\tif(k === 0){\\n\\t\\t\\t\\tif(value > 1) count++\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(myMap.has(key+k)) count++\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\treturn count\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 383278,
                "title": "java-o-n-sets-clean-7-ms",
                "content": "This problem has two main cases - when k == 0 and all others. The idea is - for number n if there is n + k in the array - pair is possible. We add all numbers from array to the set, then check for n + k. For k == 0 we need to count how many unqiue numbers repeated 2+ times. For that I use second set - add number that we met for the second time to that second set, then size of that second set will be the result.\\n\\nO(n) for time - 2 linear scans of the array. O(n) for space - need to store numbers to the set.\\n\\n```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0)\\n            return 0;\\n        int res = 0;\\n        Set<Integer> set = new HashSet();\\n        //if k == 0 we need to count only repeated nums\\n        //for that we need second set that indicats which num we have\\n        //count already\\n        if (k == 0 ) {\\n            Set<Integer> seen = new HashSet();\\n            for (int n : nums) {\\n                //if we met this num before - add it to the second set\\n                if (set.contains(n)) {\\n                    seen.add(n);\\n                } else\\n                    set.add(n);\\n            }\\n            //size of second set will be the resulting num\\n            res = seen.size();\\n        } else {\\n            //for k > 0 we check if n + k is in the set, this means we have a pair\\n            for (int n : nums) {\\n                set.add(n);\\n            }\\n\\n            for (int n : set) {\\n                if (set.contains(n + k))\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0)\\n            return 0;\\n        int res = 0;\\n        Set<Integer> set = new HashSet();\\n        //if k == 0 we need to count only repeated nums\\n        //for that we need second set that indicats which num we have\\n        //count already\\n        if (k == 0 ) {\\n            Set<Integer> seen = new HashSet();\\n            for (int n : nums) {\\n                //if we met this num before - add it to the second set\\n                if (set.contains(n)) {\\n                    seen.add(n);\\n                } else\\n                    set.add(n);\\n            }\\n            //size of second set will be the resulting num\\n            res = seen.size();\\n        } else {\\n            //for k > 0 we check if n + k is in the set, this means we have a pair\\n            for (int n : nums) {\\n                set.add(n);\\n            }\\n\\n            for (int n : set) {\\n                if (set.contains(n + k))\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757306,
                "title": "using-hashmap-java-code-with-explaination",
                "content": "If you find it useful do upvote\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                // the array element and  increament the frequence by 1\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                // keep the frequene of current element as 1\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        int count = 0;\\n        //create key set\\n        Set<Integer> set = map.keySet();\\n        for(int num: set){\\n            //first check\\n            if(k > 0 &&map.containsKey(num + k)){\\n                count++;\\n            }\\n            // second check\\n            if(k==0 && map.get(num) > 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n```\\n\\n**NOTES**\\n[(https://github.com/rizonkumar/LeetCode-Notes/blob/bb59b2137e810d07dd1f91470e31e4842bf70fa4/532.pdf)]",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                // the array element and  increament the frequence by 1\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                // keep the frequene of current element as 1\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        int count = 0;\\n        //create key set\\n        Set<Integer> set = map.keySet();\\n        for(int num: set){\\n            //first check\\n            if(k > 0 &&map.containsKey(num + k)){\\n                count++;\\n            }\\n            // second check\\n            if(k==0 && map.get(num) > 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757225,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<pair<int, int>, int> m;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(abs(nums[i]-nums[j])==k and m.find({nums[j], nums[i]})==m.end())\\n                    m[{nums[i], nums[j]}]++;\\n            }\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<pair<int, int>, int> m;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(abs(nums[i]-nums[j])==k and m.find({nums[j], nums[i]})==m.end())\\n                    m[{nums[i], nums[j]}]++;\\n            }\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519220,
                "title": "c-o-n-one-pass-with-unordered-map",
                "content": "```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        if(k < 0) return 0;\\n        for(int num:nums){\\n            if(k == 0 && mp[num] == 1){\\n                ans++;\\n            }else if(k > 0 && mp[num] == 0){\\n                ans += mp.count(num - k) + mp.count(num + k);\\n            }\\n            mp[num]++;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        if(k < 0) return 0;\\n        for(int num:nums){\\n            if(k == 0 && mp[num] == 1){\\n                ans++;\\n            }else if(k > 0 && mp[num] == 0){\\n                ans += mp.count(num - k) + mp.count(num + k);\\n            }\\n            mp[num]++;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 100157,
                "title": "java-two-pointer-solution-beats-97",
                "content": "The idea is simple. Sort the array first. Then for each number in the array, find if there exists a number satisfy the requirement. Note that ```right = Math.max(right, i + 1)``` can make sure each number in the array is accessed at most twice. So the time complexity is O(nlogn) + O(n) = O(nlogn)\\n```\\npublic int findPairs(int[] nums, int k) {\\n    if (nums.length < 2 || k < 0) {\\n        return 0;\\n    }\\n    int count = 0;\\n    Arrays.sort(nums);\\n    int right = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n            continue;\\n        }\\n            \\n        right = Math.max(right, i + 1);\\n        while (right < nums.length) {\\n            if (nums[right] - k == nums[i]) {\\n                count++;\\n                break;\\n            } else if (nums[right] - k < nums[i]) {\\n                right++;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```right = Math.max(right, i + 1)```\n```\\npublic int findPairs(int[] nums, int k) {\\n    if (nums.length < 2 || k < 0) {\\n        return 0;\\n    }\\n    int count = 0;\\n    Arrays.sort(nums);\\n    int right = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n            continue;\\n        }\\n            \\n        right = Math.max(right, i + 1);\\n        while (right < nums.length) {\\n            if (nums[right] - k == nums[i]) {\\n                count++;\\n                break;\\n            } else if (nums[right] - k < nums[i]) {\\n                right++;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884432,
                "title": "simple-java-o-n-solution-with-explaination",
                "content": "``` \\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res=0;\\n        //storing count of all the elements\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        for(int a:map.keySet()){\\n            if(k!=0){\\n                //we avoid duplicate by looking for the values (i,j) where i is smaller element eg k=4 (1,3) & (3,1) gives same result but when we are processing 1 we are lloking fr val greater than 1 to form the pair and likewise when we are at 3we are looking for val 3 and above to form the pair\\n                int b=a+k;\\n                if(map.containsKey(b)){\\n                    res++;\\n                }\\n            }else{\\n                //processing the key so processing unique values which is occuring twice  and diff of it gives 0\\n                if(map.get(a)>=2)\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res=0;\\n        //storing count of all the elements\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        for(int a:map.keySet()){\\n            if(k!=0){\\n                //we avoid duplicate by looking for the values (i,j) where i is smaller element eg k=4 (1,3) & (3,1) gives same result but when we are processing 1 we are lloking fr val greater than 1 to form the pair and likewise when we are at 3we are looking for val 3 and above to form the pair\\n                int b=a+k;\\n                if(map.containsKey(b)){\\n                    res++;\\n                }\\n            }else{\\n                //processing the key so processing unique values which is occuring twice  and diff of it gives 0\\n                if(map.get(a)>=2)\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 150243,
                "title": "easy-to-understand-2-pointer-sliding-window-approach-in-python-o-1-space-o-nlogn-time",
                "content": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        nums.sort()\\n        \\n        slow = 0\\n        fast = 1\\n        size = len(nums)\\n        \\n        while fast < size:\\n            if nums[fast] - nums[slow] < k: # case 1, diff is less than k\\n                fast += 1\\n            elif nums[fast] - nums[slow] > k: # case 2, diff is greater than k\\n                slow += 1\\n            else: # case 3, diff is equal to k so increment the count!\\n                count += 1\\n                fast += 1\\n                slow += 1\\n                \\n                #Now ignore any duplicates, both slow and fast could be pointing to duplicates\\n                while slow < size-1 and nums[slow] == nums[slow-1]:\\n                    slow += 1\\n                    \\n                while fast < size-1 and nums[fast] == nums[fast-1]:\\n                    fast += 1\\n                    \\n            if fast <= slow: # fast should be atleast one more than slow\\n                fast = slow + (slow - fast) + 1\\n                \\n        return count\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        nums.sort()\\n        \\n        slow = 0\\n        fast = 1\\n        size = len(nums)\\n        \\n        while fast < size:\\n            if nums[fast] - nums[slow] < k: # case 1, diff is less than k\\n                fast += 1\\n            elif nums[fast] - nums[slow] > k: # case 2, diff is greater than k\\n                slow += 1\\n            else: # case 3, diff is equal to k so increment the count!\\n                count += 1\\n                fast += 1\\n                slow += 1\\n                \\n                #Now ignore any duplicates, both slow and fast could be pointing to duplicates\\n                while slow < size-1 and nums[slow] == nums[slow-1]:\\n                    slow += 1\\n                    \\n                while fast < size-1 and nums[fast] == nums[fast-1]:\\n                    fast += 1\\n                    \\n            if fast <= slow: # fast should be atleast one more than slow\\n                fast = slow + (slow - fast) + 1\\n                \\n        return count\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1757242,
                "title": "c-using-map-easy-soln",
                "content": "\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n       \\n        int n = nums.size();\\n        map<int,int>m;        \\n        for(int i = 0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        int sum = 0; \\n        if(k == 0){\\n            for(auto i:m){\\n                if(i.second>1){\\n                    sum++;\\n                }\\n            }\\n        }\\n        else{\\n            for(auto i:m){\\n                if( m.count(i.first + k))\\n               //if(m.find(i.first + k)!=m.end()) \\n                {\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n       \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n       \\n        int n = nums.size();\\n        map<int,int>m;        \\n        for(int i = 0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757048,
                "title": "easy-commented-javascript-hashmap-o-n-solution",
                "content": "```\\nvar findPairs = function (nums, k) {\\n\\tlet map = {}, //Object to store count/frequency of numbers in array\\n\\t\\tcount = 0; //count the desired output/result\\n\\n\\t//loop through the array and store the count/frequency in the object\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t/*if num appears for the 1st time them map[nums[i]] will be undefined\\n\\tand undefined||0 will result in 0 and 0+1 will store 1 as count of that number */\\n\\t\\tmap[nums[i]] = (map[nums[i]] || 0) + 1;\\n\\t}\\n\\n\\t//loop through keys.In this case keys will be unique as they have the frequency of their occurrences\\n\\tObject.keys(map).forEach((key) => {\\n\\t\\t/* Now we need to check if target k is 0 or not \\n\\t\\tbecause in case k is 0 then only possible combination to get \\n\\t\\tdifference 0 will be when same num appear twice i.e \\n\\t\\t1-1=0 ,here 1 count has to be 2 in map to get diff 0\\n\\t\\t*/\\n\\t\\tif (k !== 0) {\\n\\t\\t\\t/* \\n\\t\\t\\tit is given that |a-b|=k\\n\\t\\t\\tso a=k+b i.e secondNum=k+key\\n\\t\\t\\tSince object stores key as string so we have to typecast it to integer\\n\\t\\t\\tand +k is shorthand of parseInt(k)\\n\\t\\t\\tso we can write  parseInt(k)+parseInt(key) as\\n\\t\\t\\t+k + +key (make sure there is space between +/add operator)\\n\\t\\t\\t*/\\n\\t\\t\\tlet secondNum = +k + +key;\\n\\t\\t\\tif (map[secondNum] !== undefined) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t/*So when k is 0 we check is num count is greater or equal\\n\\t\\t\\t to 2 because then only we will get difference of these two as 0\\n\\t\\t\\t */\\n\\t\\t\\tif (map[key] >= 2) count++;\\n\\t\\t}\\n\\t});\\n\\treturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findPairs = function (nums, k) {\\n\\tlet map = {}, //Object to store count/frequency of numbers in array\\n\\t\\tcount = 0; //count the desired output/result\\n\\n\\t//loop through the array and store the count/frequency in the object\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t/*if num appears for the 1st time them map[nums[i]] will be undefined\\n\\tand undefined||0 will result in 0 and 0+1 will store 1 as count of that number */\\n\\t\\tmap[nums[i]] = (map[nums[i]] || 0) + 1;\\n\\t}\\n\\n\\t//loop through keys.In this case keys will be unique as they have the frequency of their occurrences\\n\\tObject.keys(map).forEach((key) => {\\n\\t\\t/* Now we need to check if target k is 0 or not \\n\\t\\tbecause in case k is 0 then only possible combination to get \\n\\t\\tdifference 0 will be when same num appear twice i.e \\n\\t\\t1-1=0 ,here 1 count has to be 2 in map to get diff 0\\n\\t\\t*/\\n\\t\\tif (k !== 0) {\\n\\t\\t\\t/* \\n\\t\\t\\tit is given that |a-b|=k\\n\\t\\t\\tso a=k+b i.e secondNum=k+key\\n\\t\\t\\tSince object stores key as string so we have to typecast it to integer\\n\\t\\t\\tand +k is shorthand of parseInt(k)\\n\\t\\t\\tso we can write  parseInt(k)+parseInt(key) as\\n\\t\\t\\t+k + +key (make sure there is space between +/add operator)\\n\\t\\t\\t*/\\n\\t\\t\\tlet secondNum = +k + +key;\\n\\t\\t\\tif (map[secondNum] !== undefined) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t/*So when k is 0 we check is num count is greater or equal\\n\\t\\t\\t to 2 because then only we will get difference of these two as 0\\n\\t\\t\\t */\\n\\t\\t\\tif (map[key] >= 2) count++;\\n\\t\\t}\\n\\t});\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747173,
                "title": "c-o-n-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> hash;\\n        for(int i=0;i<nums.size();i++) hash[nums[i]]++;\\n        \\n        int count =0; \\n        \\n        for(auto i: hash){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }\\n            \\n             else {\\n                 if (hash.find(i.first - k) != hash.end()) \\n                     count++;\\n             }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> hash;\\n        for(int i=0;i<nums.size();i++) hash[nums[i]]++;\\n        \\n        int count =0; \\n        \\n        for(auto i: hash){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 876993,
                "title": "k-diff-pairs-c-6-liner-solution-with-explanation-o-nlogn-time-o-1-space",
                "content": "<b> Upvote this post, if you liked it. Happy Coding :)</b>\\n\\nApproach : \\n1) Sort the nums array.\\n2) Loop over the nums array using iterator\\n\\ta) maintain the previous value so that we can jump over duplicate values, to make sure that only unique pairs will be counted.\\n\\tb) perform binary search on elements from the next element (current\\'s next element) to last element,  to find the value\\n\\t\\twhich can satisfy the pair cond.\\n3) return count\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int prev_val, count = 0;\\n        sort(nums.begin(), nums.end());\\n        for(auto it = nums.begin(); it != nums.end(); it++) {\\n            if(it != nums.begin() and *it == prev_val) continue;\\n            if(binary_search(it+1, nums.end(), *it + k)) count++;\\n            prev_val = *it;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**I Hope you understood the solution, if you have any doubts regarding the solution or any suggestions to improve the solution,** then feel free to comment down below.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int prev_val, count = 0;\\n        sort(nums.begin(), nums.end());\\n        for(auto it = nums.begin(); it != nums.end(); it++) {\\n            if(it != nums.begin() and *it == prev_val) continue;\\n            if(binary_search(it+1, nums.end(), *it + k)) count++;\\n            prev_val = *it;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876378,
                "title": "c-solution-one-pass-beats-100-two-pointer-approach",
                "content": "Sort the vector.\\nHere 3 cases arise : \\n* **Case - 1 : When nums[j] - nums[i] > k**\\n\\tThe difference between element at j and element at i is greater than required, so to reduce it increment i.\\n* **Case - 2 : When nums[j] - nums[i] < k**\\n\\tThe difference between element at j and element at i is lesser than required, so to increase it increment j.\\n* **Case - 3 : When nums[j] - nums[i] == k**\\n\\t Required pair found. Increment ans, and skip similar elements for both i and j.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans = 0;\\n        int n = nums.size();\\n        int i = 0, j = 1;\\n        while(i<n && j<n){\\n            if(nums[j] - nums[i] == k && i!=j){\\n                while(i+1 < n && nums[i+1] == nums[i])\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j])\\n                    j++;\\n                j++;\\n                ans++;\\n            }\\n            else if(nums[j] - nums[i] > k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans = 0;\\n        int n = nums.size();\\n        int i = 0, j = 1;\\n        while(i<n && j<n){\\n            if(nums[j] - nums[i] == k && i!=j){\\n                while(i+1 < n && nums[i+1] == nums[i])\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j])\\n                    j++;\\n                j++;\\n                ans++;\\n            }\\n            else if(nums[j] - nums[i] > k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100148,
                "title": "simple-java-o-n-with-single-for-loop-single-hashmap",
                "content": "Solved it by One For-loop and One HashMap\\n```\\npublic int findPairs(int[] nums, int k) {\\n    if(k < 0) return 0;\\n    Map<Integer, Boolean> map = new HashMap<Integer, Boolean>();\\n    int ret = 0;\\n    for(int n : nums){\\n        /* if smaller matched value exists */\\n        if(map.containsKey(n-k) && !map.get(n-k)){\\n            map.put(n-k,true);\\n            ret++;\\n        }\\n        /* if larger matched value exists */\\n        if(map.containsKey(n+k) && (!map.containsKey(n) || !map.get(n))){\\n            map.put(n, true);\\n            ret++;\\n        }\\n        /* if current value has not yet been added*/\\n        if(!map.containsKey(n)){\\n            map.put(n, false);\\n        }\\n    }\\n    return ret;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n    if(k < 0) return 0;\\n    Map<Integer, Boolean> map = new HashMap<Integer, Boolean>();\\n    int ret = 0;\\n    for(int n : nums){\\n        /* if smaller matched value exists */\\n        if(map.containsKey(n-k) && !map.get(n-k)){\\n            map.put(n-k,true);\\n            ret++;\\n        }\\n        /* if larger matched value exists */\\n        if(map.containsKey(n+k) && (!map.containsKey(n) || !map.get(n))){\\n            map.put(n, true);\\n            ret++;\\n        }\\n        /* if current value has not yet been added*/\\n        if(!map.containsKey(n)){\\n            map.put(n, false);\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756781,
                "title": "python-o-n-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        \\n        hashNums={}\\n        pairs=set()\\n        \\n        for n in nums: # O(n)\\n            hashNums[n]=hashNums.get(n,0)+1\\n            \\n            if n-k in hashNums:\\n                pairs.add(tuple(set([n,n-k])))\\n            \\n            if n+k in hashNums:\\n                pairs.add(tuple(set([n,n+k])))\\n        \\n        if k==0: # O(n)\\n            ct=0\\n            for n,f in hashNums.items():\\n                ct+=(f>=2)\\n            return ct\\n        \\n        return len(pairs)",
                "solutionTags": [],
                "code": "class Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        \\n        hashNums={}",
                "codeTag": "Java"
            },
            {
                "id": 881899,
                "title": "java-o-n-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int kDiffs = 0;\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        \\n        for (int n: nums) {\\n            int countOfN = counter.getOrDefault(n, 0);\\n            countOfN++;\\n            counter.put(n, countOfN);\\n            \\n            if (k == 0) {\\n                if (countOfN == 2) kDiffs++;\\n            } else if (countOfN == 1) {\\n                if (counter.containsKey(n - k)) kDiffs++;\\n                if (counter.containsKey(n + k)) kDiffs++;           \\n            }\\n        }\\n        \\n        return kDiffs;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int kDiffs = 0;\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        \\n        for (int n: nums) {\\n            int countOfN = counter.getOrDefault(n, 0);\\n            countOfN++;\\n            counter.put(n, countOfN);\\n            \\n            if (k == 0) {\\n                if (countOfN == 2) kDiffs++;\\n            } else if (countOfN == 1) {\\n                if (counter.containsKey(n - k)) kDiffs++;\\n                if (counter.containsKey(n + k)) kDiffs++;           \\n            }\\n        }\\n        \\n        return kDiffs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876356,
                "title": "c-self-explanatory-one-pass-o-n-use-hash-map",
                "content": "```cpp\\nint findPairs(vector<int>& nums, int k) {;\\n    unordered_map<int, int> freq;\\n    int ans = 0;\\n    for (int n : nums) {\\n        if (k == 0) {\\n            if (freq[n] == 1) ++ans; // only count once\\n        } else if (!freq.count(n)) { // only count when the first time n appears\\n            if (freq.count(n - k)) ++ans;\\n            if (freq.count(n + k)) ++ans;\\n        }\\n        ++freq[n];\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findPairs(vector<int>& nums, int k) {;\\n    unordered_map<int, int> freq;\\n    int ans = 0;\\n    for (int n : nums) {\\n        if (k == 0) {\\n            if (freq[n] == 1) ++ans; // only count once\\n        } else if (!freq.count(n)) { // only count when the first time n appears\\n            if (freq.count(n - k)) ++ans;\\n            if (freq.count(n + k)) ++ans;\\n        }\\n        ++freq[n];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876258,
                "title": "python-really-short-and-easy-explained",
                "content": "Let complementary number be a number that is equal to some given number minus k.\\nTo form at least one pair for any given number:\\n  If k is greater than zero, we only care if count of complementary number is bigger than zero.\\n  If k is zero, we only care if count of complementary number (that is the current number itself) is bigger than one.\\n\\nConveniently, both this cases can be expressed with k==0, that will return zero or one.\\n\\n```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n    c = collections.Counter(nums)\\n    return sum(c[n-k] > (k == 0) for n in c)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n    c = collections.Counter(nums)\\n    return sum(c[n-k] > (k == 0) for n in c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 815088,
                "title": "c-4-lines-simple-n-short-no-built-in-utils-data-structures-etc",
                "content": "```\\nint findPairs(int* nums, int numsSize, int k){\\n    char a[200000] = { 0 }, *m = &a[500];\\n    for (int i = 0, c = 0, *n = nums ; i < numsSize || (numsSize = c, 0) ; i++)\\n        for (int j = i, p ; ++j < numsSize ; abs(n[i] - n[j]) == k && !m[p = n[i] + n[j]] ? c += m[p] = 1 : 0);\\n    return numsSize;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findPairs(int* nums, int numsSize, int k){\\n    char a[200000] = { 0 }, *m = &a[500];\\n    for (int i = 0, c = 0, *n = nums ; i < numsSize || (numsSize = c, 0) ; i++)\\n        for (int j = i, p ; ++j < numsSize ; abs(n[i] - n[j]) == k && !m[p = n[i] + n[j]] ? c += m[p] = 1 : 0);\\n    return numsSize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794950,
                "title": "java-o-n-solution-with-comments",
                "content": "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n       int output=0;\\n       HashMap <Integer,Integer> hm = new HashMap<>(); \\n        \\n       //Storing the frequencies in the hashmpap\\n        for(int num: nums)\\n        {\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n        }\\n        \\n        \\n        //Traversing the hashmap\\n        for (Map.Entry <Integer, Integer> entry: hm.entrySet()) \\n        {\\n            int elem = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            \\n            // finding some other element (elem+ other element=k)\\n            if(k>0 && hm.containsKey(elem+k))\\n                output++;\\n            \\n            // The number can be paired with itself. Hence, the value should be >1. We don\\'t care what value as long as the frequency is greater than one as the question says \"k-diff pair\".\\n            else if(k==0 && value >1)\\n                output++;\\n            \\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n       int output=0;\\n       HashMap <Integer,Integer> hm = new HashMap<>(); \\n        \\n       //Storing the frequencies in the hashmpap\\n        for(int num: nums)\\n        {\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 498433,
                "title": "javascript-using-object-as-map",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar findPairs = function(nums, k) {\\n  if (!nums.length || k < 0) return 0;\\n  const map = {};\\n  let counter = 0;\\n  nums.forEach(n => {\\n    map[n] = (map[n] || 0) + 1;\\n  });\\n  Object.keys(map).forEach(key => {\\n    if (k === 0) {\\n      if (map[key] > 1) counter++;\\n    } else if (map[parseInt(key) + k]) {\\n      counter++;\\n    }\\n  });\\n  return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar findPairs = function(nums, k) {\\n  if (!nums.length || k < 0) return 0;\\n  const map = {};\\n  let counter = 0;\\n  nums.forEach(n => {\\n    map[n] = (map[n] || 0) + 1;\\n  });\\n  Object.keys(map).forEach(key => {\\n    if (k === 0) {\\n      if (map[key] > 1) counter++;\\n    } else if (map[parseInt(key) + k]) {\\n      counter++;\\n    }\\n  });\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466050,
                "title": "3-java-solutions-1-hashmap-without-sort-2-hashmap-sort-3-sort-two-points",
                "content": "1. HashMap without sort.\\nWe define a hashMap. The key element denotes the members of the array. The value has 3 types:\\nvalue 1: the key appears once in the array\\nvalue 2: the key appears more than once in the array\\nvalue 0: the key has been used, this value is used to avoid duplicated pairs.\\nWe use a for-loop to initial the hashMap. \\nIf k == 0, we just calculate the number which appears more than once in array.\\nif k != 0,  each number adds k and subtracts k, then using the result to match the map. \\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k<0)return 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],2);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int count = 0;\\n        if(k==0){\\n            for(int i = 0; i<nums.length; i++){\\n                if(map.containsKey(nums[i]) && map.get(nums[i]) > 1){\\n                    count++;\\n                    map.replace(nums[i],0);\\n                }\\n            }\\n            return count;\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i] + k) && map.get(nums[i] + k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            if(map.containsKey(nums[i] - k) && map.get(nums[i] - k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            map.replace(nums[i],0);\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n2. HashMap + Sort\\nThis solution is similar to the first solution. \\nWe firstly sort the array, so we don\\'t need to consider multiple situations(k==0 or k != 0 ; add or subtract). The sort reduces the complexity of this problem.\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0)return 0;\\n        Map<Integer, Boolean> map = new HashMap<>();\\n        int count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i]) && map.get(nums[i])){\\n                count++;\\n                map.replace(nums[i],false);\\n            }\\n            if(!map.containsKey(nums[i] + k)){\\n                map.put(nums[i] + k, true);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n3.Sort + Two Points:\\nThis solution is based on the ordering of the array.\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0) return 0;\\n        Arrays.sort(nums);\\n        int left = 0, right = 1, count = 0;\\n        while(right < nums.length){\\n            if(nums[right] - nums[left] > k){\\n                left++;\\n            }else if(nums[right] - nums[left] < k || right == left){\\n                right++;\\n            }else{\\n                count++;\\n                left++;\\n                right++;\\n                while(right < nums.length && nums[right] == nums[right - 1]) right++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k<0)return 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],2);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int count = 0;\\n        if(k==0){\\n            for(int i = 0; i<nums.length; i++){\\n                if(map.containsKey(nums[i]) && map.get(nums[i]) > 1){\\n                    count++;\\n                    map.replace(nums[i],0);\\n                }\\n            }\\n            return count;\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i] + k) && map.get(nums[i] + k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            if(map.containsKey(nums[i] - k) && map.get(nums[i] - k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            map.replace(nums[i],0);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0)return 0;\\n        Map<Integer, Boolean> map = new HashMap<>();\\n        int count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i]) && map.get(nums[i])){\\n                count++;\\n                map.replace(nums[i],false);\\n            }\\n            if(!map.containsKey(nums[i] + k)){\\n                map.put(nums[i] + k, true);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0) return 0;\\n        Arrays.sort(nums);\\n        int left = 0, right = 1, count = 0;\\n        while(right < nums.length){\\n            if(nums[right] - nums[left] > k){\\n                left++;\\n            }else if(nums[right] - nums[left] < k || right == left){\\n                right++;\\n            }else{\\n                count++;\\n                left++;\\n                right++;\\n                while(right < nums.length && nums[right] == nums[right - 1]) right++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413636,
                "title": "7-lines-o-n-python3-fast-and-clear-and-easy-understand",
                "content": "make a dictory,and then when k>0 and k==0, we add res :\\n```python\\n  def findPairs(self, nums, k):\\n\\t\\tnums.sort()\\n        res , dic= 0 , {}\\n        for i in nums:\\n            dic[i] = dic[i]+1 if i in dic else 1\\n        for i in dic.keys():\\n            if (i+k in dic and k>0) or (k==0 and dic[i]>1):\\n                res += 1\\n        return res \\n```\\n\\nIf this code is not bad , welcome give me a star ,Thanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n  def findPairs(self, nums, k):\\n\\t\\tnums.sort()\\n        res , dic= 0 , {}\\n        for i in nums:\\n            dic[i] = dic[i]+1 if i in dic else 1\\n        for i in dic.keys():\\n            if (i+k in dic and k>0) or (k==0 and dic[i]>1):\\n                res += 1\\n        return res \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 228659,
                "title": "easy-to-understand-python-solution-using-hashmap",
                "content": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        hashmap = {}\\n        count = 0\\n        for num in nums:\\n            # check num + k and num - k present in hashmap\\n            if num not in hashmap:  \\n                if num + k in hashmap:\\n                    count += 1\\n                if num - k in hashmap:\\n                    count += 1\\n                hashmap[num] = 1\\n            else:\\n                # handling k == 0 condition with by restricting occurances to 1\\n                if k == 0 and hashmap[num] == 1:\\n                    count += 1\\n                hashmap[num] += 1\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        hashmap = {}\\n        count = 0\\n        for num in nums:\\n            # check num + k and num - k present in hashmap\\n            if num not in hashmap:  \\n                if num + k in hashmap:\\n                    count += 1\\n                if num - k in hashmap:\\n                    count += 1\\n                hashmap[num] = 1\\n            else:\\n                # handling k == 0 condition with by restricting occurances to 1\\n                if k == 0 and hashmap[num] == 1:\\n                    count += 1\\n                hashmap[num] += 1\\n                \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 100193,
                "title": "simple-idea-o-nlogn-time-o-1-space-java-solution",
                "content": "guess this solution is intuitive.\\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length < 2) return 0;\\n        int res = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\\n            if (helper(nums, i + 1, nums[i] + k)) res++;\\n        }\\n        return res;\\n    }\\n    private boolean helper(int[] nums, int l, int target) {\\n        int r = nums.length - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length < 2) return 0;\\n        int res = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\\n            if (helper(nums, i + 1, nums[i] + k)) res++;\\n        }\\n        return res;\\n    }\\n    private boolean helper(int[] nums, int l, int target) {\\n        int r = nums.length - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292897,
                "title": "532-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, check if k is less than 0, if yes then return 0.\\n2. Create a hash table freq to store the frequency of each number in the array.\\n3. Iterate through the array nums and for each number, update its frequency in the hash table freq.\\n4. Initialize a variable count to 0 to store the count of unique pairs.\\n5. Iterate through the keys in the hash table freq and check for each key if there exists a pair with difference k in the hash table.\\n6. If k is 0, then increment the count only if the frequency of the number is greater than 1.\\n7. If k is not 0, then check if num + k exists in the hash table. If yes, then increment the count.\\n8. Return the count of unique pairs.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if k < 0:\\n            return 0\\n        \\n        # initialize hash table\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        # iterate through array and find pairs\\n        count = 0\\n        for num in freq:\\n            if k == 0:\\n                if freq[num] > 1:\\n                    count += 1\\n            else:\\n                if num + k in freq:\\n                    count += 1\\n        \\n        # return count of unique pairs\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if k < 0:\\n            return 0\\n        \\n        # initialize hash table\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        # iterate through array and find pairs\\n        count = 0\\n        for num in freq:\\n            if k == 0:\\n                if freq[num] > 1:\\n                    count += 1\\n            else:\\n                if num + k in freq:\\n                    count += 1\\n        \\n        # return count of unique pairs\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757899,
                "title": "c-two-pointer-t-nlogn-and-hashmap-t-n",
                "content": "**TWO-POINTER APPROACH T(NLogN)**\\n\\n1. The approach that I used here is similar to two-sum problem.\\n2. In two-sum we select two numbers that sums-up to k, whereas here we have to select two numbers with difference k.\\n3. I have used two pointers i & j, in two-sum the we start i from 0 and j from n-1, but here we\\'ll start i from 0 and j from 1 because at this point the difference will be minimum b/w nums[i] and nums[j].\\n\\n**CODE**\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i=0, j=1, count=0;\\n        while(j<n){\\n            if(i==j) j++;\\n            if(j>n-1) break;\\n            if(nums[i]+k == nums[j]){\\n                count++;\\n                while(j<n and nums[i]+k == nums[j]) j++;\\n            }else if(nums[i]+k < nums[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\n**HASHMAP APPROACH T(N)**\\n\\n**CODE**\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        int c=0;\\n        for(auto i: nums) m[i]++;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(k!=0){\\n                if(m[k+nums[i]]>0){\\n                    c++;\\n                    m[k+nums[i]]=0;\\n                }\\n            }else{\\n                if(m[nums[i]]>1) c++;\\n                m[nums[i]]=0;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i=0, j=1, count=0;\\n        while(j<n){\\n            if(i==j) j++;\\n            if(j>n-1) break;\\n            if(nums[i]+k == nums[j]){\\n                count++;\\n                while(j<n and nums[i]+k == nums[j]) j++;\\n            }else if(nums[i]+k < nums[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        int c=0;\\n        for(auto i: nums) m[i]++;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(k!=0){\\n                if(m[k+nums[i]]>0){\\n                    c++;\\n                    m[k+nums[i]]=0;\\n                }\\n            }else{\\n                if(m[nums[i]]>1) c++;\\n                m[nums[i]]=0;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757179,
                "title": "c-simple-easy-solution-o-n-hashmap",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count =0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++; \\n        for(auto i: mp){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }\\n             else {\\n                 if (mp.find(i.first - k) != mp.end()) \\n                     count++;\\n             }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count =0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++; \\n        for(auto i: mp){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }\\n             else {\\n                 if (mp.find(i.first - k) != mp.end()) \\n                     count++;\\n             }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756867,
                "title": "c-95-fast-and-easy-solution-explained-hashmap",
                "content": "**Welcome to abivilion\\'s solution. Kindly Upvote for supporting this article.**\\n\\n**SOLUTION**\\n**TC - O(n)**\\n**SC - O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int>st;\\n        int count=0;\\n        \\n\\t\\t//storing in map\\n        for(auto &it:nums)\\n            st[it]++;\\n\\n       // if k is 0, then which element FREQUENCY >1 can give 0\\n        if(k==0) \\n        {\\n            for(auto &ko:st) if(ko.second>1) count++;\\n                \\n        }\\n\\n   // if k is any other number then ,difference can currentnum+k is present then the pair can give k as a resultant\\n   // a-b = c\\n   // a= c+b\\n   // b =c-a\\n        else\\n        for(auto &ki:st)\\n        {\\n            if(st.count(ki.first+k)) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int>st;\\n        int count=0;\\n        \\n\\t\\t//storing in map\\n        for(auto &it:nums)\\n            st[it]++;\\n\\n       // if k is 0, then which element FREQUENCY >1 can give 0\\n        if(k==0) \\n        {\\n            for(auto &ko:st) if(ko.second>1) count++;\\n                \\n        }\\n\\n   // if k is any other number then ,difference can currentnum+k is present then the pair can give k as a resultant\\n   // a-b = c\\n   // a= c+b\\n   // b =c-a\\n        else\\n        for(auto &ki:st)\\n        {\\n            if(st.count(ki.first+k)) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003595,
                "title": "python-7-line-super-simple-and-short-solution",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914187,
                "title": "python-faster-than-93",
                "content": "```\\nclass Solution:\\n    def findPairs(self, a: List[int], K: int) -> int:\\n        s = set(a)\\n        if K == 0: return sum(1 for x in s if a.count(x) > 1)\\n        return sum(1 for x in s if x + K in s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, a: List[int], K: int) -> int:\\n        s = set(a)\\n        if K == 0: return sum(1 for x in s if a.count(x) > 1)\\n        return sum(1 for x in s if x + K in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876921,
                "title": "binary-search-solution-java",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {  \\n            int low=i+1;\\n            int high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=low+(high-low)/2;\\n                if(nums[mid]-nums[i]==k)\\n                {count++;\\n                 break;\\n                }else if(nums[mid]-nums[i]>k)\\n                    high=mid-1;\\n                else\\n                    low=mid+1;\\n            }\\n            while(i!=nums.length-1 && nums[i+1]==nums[i])\\n                i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {  \\n            int low=i+1;\\n            int high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=low+(high-low)/2;\\n                if(nums[mid]-nums[i]==k)\\n                {count++;\\n                 break;\\n                }else if(nums[mid]-nums[i]>k)\\n                    high=mid-1;\\n                else\\n                    low=mid+1;\\n            }\\n            while(i!=nums.length-1 && nums[i+1]==nums[i])\\n                i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876438,
                "title": "java-soln-1-pass-o-n-time-and-space",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tHashSet<Integer> duplicateset = new HashSet<>();\\n\\t\\t\\n\\t\\t\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tif (set.contains(n)) {\\n\\t\\t\\t\\tif(k==0 && !duplicateset.contains(n)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tduplicateset.add(n);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else {\\n\\t\\t\\t\\t//check diff of that number exist to find pair. \\n\\t\\t\\t\\t// It will not count (a,b) and (b,a) as 1 set of number is not added to set yet.\\n\\t\\t\\t\\tif(k!=0 && set.contains(n-k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(k!=0 && set.contains(n+k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tset.add(n);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tHashSet<Integer> duplicateset = new HashSet<>();\\n\\t\\t\\n\\t\\t\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tif (set.contains(n)) {\\n\\t\\t\\t\\tif(k==0 && !duplicateset.contains(n)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tduplicateset.add(n);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else {\\n\\t\\t\\t\\t//check diff of that number exist to find pair. \\n\\t\\t\\t\\t// It will not count (a,b) and (b,a) as 1 set of number is not added to set yet.\\n\\t\\t\\t\\tif(k!=0 && set.contains(n-k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(k!=0 && set.contains(n+k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tset.add(n);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830216,
                "title": "easy-js-solution",
                "content": "```\\nvar findPairs = function(nums, k) {\\n    if (k < 0) return 0;   \\n    nums = (k === 0) ? nums : Array.from(new Set(nums));\\n    let m = new Map(), res = 0;\\n    for (let num of nums) {\\n        if (m.get(num+k) === 1) res++;\\n        if (num+k !== num-k && m.get(num-k) === 1) res++;\\n        m.set(num, m.get(num)+1 || 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findPairs = function(nums, k) {\\n    if (k < 0) return 0;   \\n    nums = (k === 0) ? nums : Array.from(new Set(nums));\\n    let m = new Map(), res = 0;\\n    for (let num of nums) {\\n        if (m.get(num+k) === 1) res++;\\n        if (num+k !== num-k && m.get(num-k) === 1) res++;\\n        m.set(num, m.get(num)+1 || 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656980,
                "title": "o-n-very-easy-way-by-using-hashset",
                "content": "\\tfrom typing import List\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tif k < 0:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tsaw = set()\\n\\t\\t\\tpair = set()\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif num + k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num + k, num), max(num + k, num)))\\n\\n\\t\\t\\t\\tif num - k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num - k, num), max(num - k, num)))\\n\\n\\t\\t\\t\\tsaw.add(num)\\n\\n\\t\\t\\treturn len(pair)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tfrom typing import List\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tif k < 0:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tsaw = set()\\n\\t\\t\\tpair = set()\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif num + k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num + k, num), max(num + k, num)))\\n\\n\\t\\t\\t\\tif num - k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num - k, num), max(num - k, num)))\\n\\n\\t\\t\\t\\tsaw.add(num)\\n\\n\\t\\t\\treturn len(pair)\\n",
                "codeTag": "Java"
            },
            {
                "id": 584942,
                "title": "python-two-pointer-o-nlogn",
                "content": "```\\ndef find_pairs(L: List[int], k: int) -> int:\\n    \"\"\"\\n    K-diff Pairs in an Array\\n\\n    time: O(nlogn)\\n    space: O(1)\\n\\n    :param List[int] L:\\n    :param int k:\\n    :return int:\\n    \"\"\"\\n    L.sort()\\n\\n    N = len(L)\\n\\n    i = pairs = 0\\n    j = 1\\n\\n    while j < N:\\n        if j < N - 1 and L[j] == L[j + 1]:\\n            j += 1\\n\\n        elif L[j] == L[i] + k:\\n            pairs += 1\\n            i += 1\\n            j += 1\\n\\n        elif L[j] > L[i] + k:\\n            i += 1\\n\\n        elif L[j] < L[i] + k:\\n            j += 1\\n\\n        j = max(j, i + 1)\\n\\n    return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef find_pairs(L: List[int], k: int) -> int:\\n    \"\"\"\\n    K-diff Pairs in an Array\\n\\n    time: O(nlogn)\\n    space: O(1)\\n\\n    :param List[int] L:\\n    :param int k:\\n    :return int:\\n    \"\"\"\\n    L.sort()\\n\\n    N = len(L)\\n\\n    i = pairs = 0\\n    j = 1\\n\\n    while j < N:\\n        if j < N - 1 and L[j] == L[j + 1]:\\n            j += 1\\n\\n        elif L[j] == L[i] + k:\\n            pairs += 1\\n            i += 1\\n            j += 1\\n\\n        elif L[j] > L[i] + k:\\n            i += 1\\n\\n        elif L[j] < L[i] + k:\\n            j += 1\\n\\n        j = max(j, i + 1)\\n\\n    return pairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 530096,
                "title": "python-reasonably-fast-99-4-short-and-readable-explained-different-options",
                "content": "Let\\'s start with something easy to read:\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        r = 0\\n        if k >= 0:\\n            c = collections.Counter(nums)\\n            for i in c:\\n                if (k==0 and c[i]>1) or (k!=0 and i+k in c):\\n                    r += 1\\n        return r\\n```\\n\\nSo there are 3 things you need to take care of:\\n\\n1. The k value is the *absolute* difference, so it has to be a positive number, otherwise we return 0\\n2. k==0. this is a special case. let\\'s say we have [1,1,1,3,3,3,3,...] the 3x1 will produce 1 pair, 4x3 - another 1. So the logic is every non unique element adds a pair. That is a typical case where collections.Counter can be used.\\n3. for all other numbers - we just need to check for every i if i+k is also present.\\n\\nSo now we are putting it all together.\\n\\nr is the return value set to 0. If k<0, we return it right away - this is the first case.\\nnow we create `c = collections.Counter(nums)` and then as we go through the elements, we check for both cases: where k==0 is i is repeated or if k!=0 (we can use k>0 instead) and i+k is also in c.\\n\\nSo this program works just fine and it looks readable, but if you want to save a couple lines ... If you look at the main loop, it\\'s a combination of a `for` and an `if` and it adds either 1 or nothing. So it could be a good case to use a comprehension instead:\\n\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```\\n\\nThe logic is exactly the same, just different presentation.\\n\\nAnd if for some reason you don\\'t want to use collections,  you can replace it with:\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        #c = collections.Counter(nums)     \\n        c={}\\n        for i in nums:\\n            c[i] = c.get(i, 0) + 1                \\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        r = 0\\n        if k >= 0:\\n            c = collections.Counter(nums)\\n            for i in c:\\n                if (k==0 and c[i]>1) or (k!=0 and i+k in c):\\n                    r += 1\\n        return r\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        #c = collections.Counter(nums)     \\n        c={}\\n        for i in nums:\\n            c[i] = c.get(i, 0) + 1                \\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100186,
                "title": "short-java-solution-but-two-hashsets",
                "content": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> seenNum = new HashSet<>();\\n        Set<String> seenPair = new HashSet<>();\\n        int result = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int prev = nums[i] - k;\\n            if (seenNum.contains(prev) && !seenPair.contains(prev + \",\" + nums[i])) {\\n                result++;\\n                seenPair.add(prev + \",\" + nums[i]);\\n            }\\n            seenNum.add(nums[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> seenNum = new HashSet<>();\\n        Set<String> seenPair = new HashSet<>();\\n        int result = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int prev = nums[i] - k;\\n            if (seenNum.contains(prev) && !seenPair.contains(prev + \",\" + nums[i])) {\\n                result++;\\n                seenPair.add(prev + \",\" + nums[i]);\\n            }\\n            seenNum.add(nums[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329845,
                "title": "java-very-easy-explanation-hashmap",
                "content": "# Intuition\\nVery easy approach to solve the problem with the help of single loop and hashmap\\n\\n# Approach\\n\\n* initiate a Map \\n* enter all elements and its frequency\\n* inside of entry loop of map ,check\\n1. if k==0 , it means any element which is occuring more then twice will always have diff ==0 , ex- 1-1=0 , 15-15 =0 ...\\n2. else if map contains element + k , then pair++  \\n\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int n =nums.length;\\n      HashMap<Integer,Integer> map = new HashMap<>();\\n      for(int i =0;i<n;i++){\\n          if(map.containsKey(nums[i]))\\n          map.put(nums[i],map.get(nums[i])+1);\\n          else\\n          map.put(nums[i],1);\\n      }\\n        int count =0;\\n\\n      for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n        int val = entry.getValue();\\n        int key = entry.getKey();\\n\\n        if(k==0){\\n          if(val>=2)\\n            count++;\\n        }\\n\\n        else if(map.containsKey(key+k))\\n        count++;\\n      }  \\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int n =nums.length;\\n      HashMap<Integer,Integer> map = new HashMap<>();\\n      for(int i =0;i<n;i++){\\n          if(map.containsKey(nums[i]))\\n          map.put(nums[i],map.get(nums[i])+1);\\n          else\\n          map.put(nums[i],1);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1923803,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int c=0;\\n        for(int val:nums )\\n            {\\n                map.put(val,map.getOrDefault(val,0)+1);\\n            \\n            }\\n        for(int i:map.keySet())\\n            {\\n                if((k==0 && map.get(i)>1)||(k>0 && map.containsKey(i+k)))\\n                    c++;\\n            }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int c=0;\\n        for(int val:nums )\\n            {\\n                map.put(val,map.getOrDefault(val,0)+1);\\n            \\n            }\\n        for(int i:map.keySet())\\n            {\\n                if((k==0 && map.get(i)>1)||(k>0 && map.containsKey(i+k)))\\n                    c++;\\n            }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758373,
                "title": "python-3-60ms-o-n-counter-hashmap-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = Counter(nums)\\n        if k > 0:\\n            return sum([i + k in count for i in count])\\n        else:\\n            return sum([count[i] > 1 for i in count])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = Counter(nums)\\n        if k > 0:\\n            return sum([i + k in count for i in count])\\n        else:\\n            return sum([count[i] > 1 for i in count])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758183,
                "title": "java-simple-easy-set-no-sort",
                "content": "Simplified  Clean Coded Solution !\\uD83D\\uDE00\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int pairs = 0, n = nums.length;\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> repeatedElements = new HashSet<>();\\n        \\n        for(int ele : nums){\\n            if(set.contains(ele)) repeatedElements.add(ele);\\n            set.add(ele);\\n        }\\n        \\n        // SPECIAL CASE [K == 0]\\n        if(k == 0) return repeatedElements.size();\\n        \\n        // Traversing the SET not the array.\\n        for(int elementInSet : set)\\n            if(set.contains(elementInSet + k)) pairs++;\\n       \\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int pairs = 0, n = nums.length;\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> repeatedElements = new HashSet<>();\\n        \\n        for(int ele : nums){\\n            if(set.contains(ele)) repeatedElements.add(ele);\\n            set.add(ele);\\n        }\\n        \\n        // SPECIAL CASE [K == 0]\\n        if(k == 0) return repeatedElements.size();\\n        \\n        // Traversing the SET not the array.\\n        for(int elementInSet : set)\\n            if(set.contains(elementInSet + k)) pairs++;\\n       \\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757732,
                "title": "c-python-simple-and-clean-o-n-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757294,
                "title": "c-two-pointers-lower-bound-nlogn",
                "content": "### Using two pointer C++ | nlogn :\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        int n=nums.size();\\n        while(i<n &&j<n){                                      \\n            if(i!=0 && nums[i]==nums[i-1]){i++;continue;}\\n            if(i==j) {j++;continue;}\\n            \\n            int dif=nums[j]-nums[i];\\n            if(dif==k){i++;ans++;}\\n            else if(dif<k) j++;\\n            else i++;\\n        }\\n      return ans;\\n}\\n```\\n\\n### Using Lower Bound C++ | nlogn :\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto it=nums.begin();it!=nums.end();it++){         \\n            if(it!=nums.begin() && *it==*(it-1)) continue; \\n            auto itr=lower_bound(it+1,nums.end(),k+(*it));\\n            if(itr==nums.end()) continue;\\n            if(*itr-*it==k){\\n                ans++;\\n            }\\n        }\\n         return ans;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        int n=nums.size();\\n        while(i<n &&j<n){                                      \\n            if(i!=0 && nums[i]==nums[i-1]){i++;continue;}\\n            if(i==j) {j++;continue;}\\n            \\n            int dif=nums[j]-nums[i];\\n            if(dif==k){i++;ans++;}\\n            else if(dif<k) j++;\\n            else i++;\\n        }\\n      return ans;\\n}\\n```\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto it=nums.begin();it!=nums.end();it++){         \\n            if(it!=nums.begin() && *it==*(it-1)) continue; \\n            auto itr=lower_bound(it+1,nums.end(),k+(*it));\\n            if(itr==nums.end()) continue;\\n            if(*itr-*it==k){\\n                ans++;\\n            }\\n        }\\n         return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757214,
                "title": "java-binary-search-easy-to-understand",
                "content": "Try search for each element because we need to find only unique element so discard those element that have been traversed,\\n```\\nclass Solution \\n{\\n    public int findPairs(int[] nums, int k) \\n    {\\n        int n = nums.length;\\n        int count =0;\\n        Arrays.sort(nums);\\n        if(k==0)\\n        {\\n           int pre = 100000001;\\n           for(int i=0;i<(n-1);i++)\\n           {\\n               if((nums[i]==nums[i+1]) && pre!=nums[i])\\n               {\\n                   count++;\\n               }\\n               pre = nums[i];\\n           }\\n           return count;\\n        }\\n        int pre = 100000001;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre!=nums[i])\\n            {\\n               count = count + search(nums,i,k,n-1);\\n               pre = nums[i]; \\n            }\\n        }  \\n        return count;\\n    }\\n    public int search(int[] nums,int l,int k,int r)\\n    {\\n        int target = nums[l];\\n        int t = (target+k);\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n          \\n            if(nums[mid]==t)\\n            {\\n                return 1;\\n            }\\n            else if(nums[mid]>t)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findPairs(int[] nums, int k) \\n    {\\n        int n = nums.length;\\n        int count =0;\\n        Arrays.sort(nums);\\n        if(k==0)\\n        {\\n           int pre = 100000001;\\n           for(int i=0;i<(n-1);i++)\\n           {\\n               if((nums[i]==nums[i+1]) && pre!=nums[i])\\n               {\\n                   count++;\\n               }\\n               pre = nums[i];\\n           }\\n           return count;\\n        }\\n        int pre = 100000001;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre!=nums[i])\\n            {\\n               count = count + search(nums,i,k,n-1);\\n               pre = nums[i]; \\n            }\\n        }  \\n        return count;\\n    }\\n    public int search(int[] nums,int l,int k,int r)\\n    {\\n        int target = nums[l];\\n        int t = (target+k);\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n          \\n            if(nums[mid]==t)\\n            {\\n                return 1;\\n            }\\n            else if(nums[mid]>t)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756983,
                "title": "c-easy-understood-solution-map",
                "content": "We need to find pair whose differense is k.\\nSo that we can store frequency to map and we will find, whether another key is exist or not whose difference is k.\\nif exist, then we will increment our ans by 1.\\n\\nLet\\'s look at one example.\\n**nums = [1,3,5,1,4], k = 2**\\n\\nNow store frequency to map:\\n1-> 2\\n3-> 1\\n4-> 1\\n5-> 1\\n\\nNow, iterate to map and find key difference of k. If found then increment ans+1.\\n\\nHere, keys two keys found **(1,3), (3,5)** whose difference is 2. So that **ans = 2**;\\n\\nWe need to also take care when k=0 given.\\nSo that I have just decrement value by 1 and increment value by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        map<int,int> mp;\\n        for(auto &x : nums){\\n            mp[x]++;\\n        }\\n        for(auto &x : mp){\\n            x.second--;\\n            if(mp.find(x.first+k) != mp.end() and mp[x.first+k] >= 1)\\n                ans++;\\n            x.second++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        map<int,int> mp;\\n        for(auto &x : nums){\\n            mp[x]++;\\n        }\\n        for(auto &x : mp){\\n            x.second--;\\n            if(mp.find(x.first+k) != mp.end() and mp[x.first+k] >= 1)\\n                ans++;\\n            x.second++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718359,
                "title": "c-two-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n    //      time O(nlgn) space O(1)\\n    //     sort(nums.begin(),nums.end());\\n    //     int n=nums.size();\\n    //     int count=0;\\n    //     for(int i=0;i<n;i++){\\n    //         if(i!=0&&nums[i]==nums[i-1])continue;\\n    //         bool res=binary_search(nums.begin()+i+1,nums.end(),nums[i]+k);\\n    //         if(res){\\n    //             count++;\\n    //         }     \\n    //     }\\n    //     return count;\\n    // }\\n        \\n        //      time O(n) space O(n)\\n        int n=nums.size();\\n        int count=0;\\n        unordered_map<int,int> lookup;\\n        if(k==0){\\n            for(int i=0;i<n;i++){\\n                if(lookup[nums[i]]==1){\\n                    count++;\\n                }    \\n                lookup[nums[i]] =lookup[nums[i]]+1;\\n            }\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(!lookup.count(nums[i])){\\n                    if(lookup.count(nums[i]-k)){\\n                        count++;\\n                    }\\n                    if(lookup.count(nums[i]+k)){\\n                        count++;\\n                    }\\n                    lookup[nums[i]]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n    //      time O(nlgn) space O(1)\\n    //     sort(nums.begin(),nums.end());\\n    //     int n=nums.size();\\n    //     int count=0;\\n    //     for(int i=0;i<n;i++){\\n    //         if(i!=0&&nums[i]==nums[i-1])continue;\\n    //         bool res=binary_search(nums.begin()+i+1,nums.end(),nums[i]+k);\\n    //         if(res){\\n    //             count++;\\n    //         }     \\n    //     }\\n    //     return count;\\n    // }\\n        \\n        //      time O(n) space O(n)\\n        int n=nums.size();\\n        int count=0;\\n        unordered_map<int,int> lookup;\\n        if(k==0){\\n            for(int i=0;i<n;i++){\\n                if(lookup[nums[i]]==1){\\n                    count++;\\n                }    \\n                lookup[nums[i]] =lookup[nums[i]]+1;\\n            }\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(!lookup.count(nums[i])){\\n                    if(lookup.count(nums[i]-k)){\\n                        count++;\\n                    }\\n                    if(lookup.count(nums[i]+k)){\\n                        count++;\\n                    }\\n                    lookup[nums[i]]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625606,
                "title": "100-faster-8-ms-without-using-map-worst-case-o-n-logn-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int slow = 0, fast = 1, ans = 0;\\n        while(slow < nums.size() && fast < nums.size()){\\n            if(nums[fast] - nums[slow] == k){\\n                slow++;\\n                fast++;\\n                ans++;\\n                while(fast < nums.size() && nums[fast] == nums[fast - 1]) fast++;\\n            }\\n            else if(nums[fast] - nums[slow] > k){\\n                slow++;\\n                if(fast - slow == 0) fast++;\\n            }\\n            else fast++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int slow = 0, fast = 1, ans = 0;\\n        while(slow < nums.size() && fast < nums.size()){\\n            if(nums[fast] - nums[slow] == k){\\n                slow++;\\n                fast++;\\n                ans++;\\n                while(fast < nums.size() && nums[fast] == nums[fast - 1]) fast++;\\n            }\\n            else if(nums[fast] - nums[slow] > k){\\n                slow++;\\n                if(fast - slow == 0) fast++;\\n            }\\n            else fast++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621521,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int>mymap;\\n        int count=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            mymap[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:mymap){\\n                if(x.second>1){\\n                    count++;\\n                }\\n            }\\n             return count;\\n        }\\n    \\n        for(auto x:mymap){\\n            if(mymap.count(x.first-k)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int>mymap;\\n        int count=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            mymap[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:mymap){\\n                if(x.second>1){\\n                    count++;\\n                }\\n            }\\n             return count;\\n        }\\n    \\n        for(auto x:mymap){\\n            if(mymap.count(x.first-k)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388185,
                "title": "c-o-n-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        int c=0;\\n        \\n        if(k<0) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:m){\\n                if(x.second>1){\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        for(auto x:m){\\n            if(m.count(x.first-k)){\\n                c++;\\n            }\\n            \\n        }\\n        return c;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        int c=0;\\n        \\n        if(k<0) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:m){\\n                if(x.second>1){\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        for(auto x:m){\\n            if(m.count(x.first-k)){\\n                c++;\\n            }\\n            \\n        }\\n        return c;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338044,
                "title": "c-simple-single-loop-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size();i++){\\n            freq[nums[i]]++;\\n        }\\n        int count=0;\\n        if(k!=0){\\n            for(auto itr:freq){\\n                if(freq.find(itr.first+k)!=freq.end()){\\n                    count++;\\n                }\\n            }\\n        }\\n        else{\\n            for(auto itr: freq){\\n                if(itr.second>1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size();i++){\\n            freq[nums[i]]++;\\n        }\\n        int count=0;\\n        if(k!=0){\\n            for(auto itr:freq){\\n                if(freq.find(itr.first+k)!=freq.end()){\\n                    count++;\\n                }\\n            }\\n        }\\n        else{\\n            for(auto itr: freq){\\n                if(itr.second>1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228679,
                "title": "easy-c-soln-nlogn-one-pointer-with-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    //one pointer with binary search nlogn\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;\\n            int x=nums[i];\\n            int l=i+1,r=nums.size()-1;\\n            while(l<=r){\\n                int m=(l+r)>>1;\\n                if(nums[m]-x==k){\\n                    ans++;\\n                    break;\\n                }\\n                else if(nums[m]-x>k)r=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //one pointer with binary search nlogn\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;\\n            int x=nums[i];\\n            int l=i+1,r=nums.size()-1;\\n            while(l<=r){\\n                int m=(l+r)>>1;\\n                if(nums[m]-x==k){\\n                    ans++;\\n                    break;\\n                }\\n                else if(nums[m]-x>k)r=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980705,
                "title": "python-o-n-96",
                "content": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n  \\n        count = 0\\n    \\n\\n        dic= {}\\n        \\n        for num in nums:\\n            if num not in dic: dic[num] = 1\\n            else: dic[num] += 1\\n        \\n        if k == 0:\\n            for key in dic.keys():\\n                if dic[key] > 1: count += 1\\n        \\n        else:\\n            for key in dic.keys():\\n                if key + k in dic: count += 1\\n        \\n        return count",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n  \\n        count = 0\\n    \\n\\n        dic= {}",
                "codeTag": "Java"
            },
            {
                "id": 876956,
                "title": "java-k-diff-pair-100-2-pointer-well-explained-with-multiple-solution",
                "content": "I have explained basic solution below, but let\\'s start with the best approach, a **2 pointer approach. **\\n\\nWhy 2 pointer? \\nBecause we need to find a pair, Non repeatable and the brute force, basic approach is not time efficient.\\n\\nSince we want only unique pair, answer will do irrespective of order and its easier to calculate diff we know where to find larger number or smaller number when sorted, **we sort the array.**\\n\\nStart both left and right from one side.** Calculate diff **of each right val - left val, \\n\\n1. if value is less than k, we need to increase right pointer to take higher value (sorting helps)\\n2. if value is more than k, we increase left pointer to increase smaller val (of left) and sorting does help.. in  case left==right also, we need to increase right by 1, since obviously we need pairs.\\n3. if value == k, yay!! Increase your count by 1 and move left and right by 1. (let\\'s find another pair)\\n\\t In case of repeated value like, 1 1 2 2 or 1 1 2 for k == 1, we need to keep moving left pointer until we find a different value. (No need to check for right, cause if left is unique, right definitely won\\'t be the prev right value. \\n\\t \\n100%\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        int left = 0, right = 1,count = 0;\\n        \\n        while(right<l && left<l){\\n            if(left==right || nums[right]-nums[left]<k)\\n                right++;\\n            else if(nums[right]-nums[left]==k){\\n                count++;\\n                left++;\\n                right++;\\n                while(left < l && nums[left] == nums[left-1])\\n                    left++;\\n            }\\n            else\\n                left++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n-------\\nBasic brute force approach: Consider all the possibilities of pair difference and return all,\\n19% Fast only\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Set<String> pairs = new HashSet<>();\\n        for(int one = 0;one<nums.length;one++){\\n            for(int two = one+1; two < nums.length;two++){\\n                int first = nums[one], second = nums[two];\\n                if(Math.abs(first-second)==Math.abs(k))\\n                    pairs.add(first>second ? first+\" \"+second : second+\" \"+first);\\n            }\\n        }\\n        return pairs.size();\\n    }\\n}\\n\\nAfter pruning: sort it, then you need only second-first (remove Math.abs and first>Secind condition as always second>first)\\nif sorted you can use 2 pointer approach, if right val-left val ==k, we move both forward, if right val -left val > k, we need to increase left val so it matches k,\\nif right val - left val < k, we need to increase right val so it matches k.\\n25% Fast\\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        Set<String> pairs = new HashSet<>();\\n        int left = 0, right = 1;\\n        int count = 0;\\n        String prevVals = \"\";\\n        while(right<l && left<right){\\n            String currentVals = nums[right]+\" \"+nums[left];\\n            if(prevVals.equals(currentVals)){\\n                left++;right++;\\n                continue;\\n            }\\n            int diff = nums[right]-nums[left];\\n            if(diff==k){\\n                count++;\\n                left++;\\n                right++;\\n                prevVals = currentVals;\\n            }else if(diff>k){\\n                left++;\\n                if(right==left)\\n                    right++;\\n            }\\n            else\\n                right++;\\n        }\\n        return count;\\n    }\\n\\t\\n```\\nThese are also 2 pointer approaches but we add more pruning  in 100% solution, like how and when to left++ and when to do right++. Also it is easy tp understand.\\n**If we need to find a pair, I guess it is prety straighforward and easy with 2 pointer. And if the order does not matter, sorting should help**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        int left = 0, right = 1,count = 0;\\n        \\n        while(right<l && left<l){\\n            if(left==right || nums[right]-nums[left]<k)\\n                right++;\\n            else if(nums[right]-nums[left]==k){\\n                count++;\\n                left++;\\n                right++;\\n                while(left < l && nums[left] == nums[left-1])\\n                    left++;\\n            }\\n            else\\n                left++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        Set<String> pairs = new HashSet<>();\\n        int left = 0, right = 1;\\n        int count = 0;\\n        String prevVals = \"\";\\n        while(right<l && left<right){\\n            String currentVals = nums[right]+\" \"+nums[left];\\n            if(prevVals.equals(currentVals)){\\n                left++;right++;\\n                continue;\\n            }\\n            int diff = nums[right]-nums[left];\\n            if(diff==k){\\n                count++;\\n                left++;\\n                right++;\\n                prevVals = currentVals;\\n            }else if(diff>k){\\n                left++;\\n                if(right==left)\\n                    right++;\\n            }\\n            else\\n                right++;\\n        }\\n        return count;\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876727,
                "title": "java-k-diff-pairs-in-an-array-hashmap",
                "content": "We\\'re using hashmap to store the unique keys of the array, the value is the time those keys appear.\\nWe then loop all the HashMap, and check if the map contains the key = a + k => We have 1 pair.\\nRemember to check if k = 0, it is the number of keys has value > 1\\n\\n```\\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n        int result = 0;\\n        for (int i : nums) {\\n            int count = hashMap.getOrDefault(i, 0);\\n            hashMap.put(i, count + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> i : hashMap.entrySet()) {\\n            if (k == 0) {\\n                if (i.getValue() > 1)\\n                    ++result;\\n            } else {\\n                int a = i.getKey();\\n                if (hashMap.containsKey(a + k)) {\\n                    ++result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n        int result = 0;\\n        for (int i : nums) {\\n            int count = hashMap.getOrDefault(i, 0);\\n            hashMap.put(i, count + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> i : hashMap.entrySet()) {\\n            if (k == 0) {\\n                if (i.getValue() > 1)\\n                    ++result;\\n            } else {\\n                int a = i.getKey();\\n                if (hashMap.containsKey(a + k)) {\\n                    ++result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876608,
                "title": "java-short-and-crisp-hasmap-and-binary-search-with-explanaiton",
                "content": "***Question:***\\nTo return the number of unique k-diff pairs in the array.\\nInput: nums = [3,1,4,1,5], k = 2\\nAnswer: 2. Two pairs (1,3) and (3,5)\\n\\n**Using HashMap:**\\nJust see for an element num, there exists num+k.\\nWe essentially need to store count of number,to not mis-intrepet same number as its pair when k=0.\\n\\n**TimeComplexity:** HashMap put and get operations are O(1) with assumption that key-value pairs are well distributed across the buckets. But in worst case, if we need to add multiple elements to one bucket so it can be O(n) .\\n\\n**Space complexity:** In worst case all elements may be unique,so O(n).\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        //HashMap to store value-count\\n        Map<Integer, Integer> hashmap = new HashMap();\\n\\n\\t\\tint result = 0;\\n        /*\\n        for every number ,\\n        if number is seen for the first time ,then put count=1\\n        else ,increment the count\\n        */\\n        for(int num : nums)\\n            hashmap.computeIfAbsent(num, hashmap.getOrDefault(num, 0) + 1);\\n        //For all the elements in hashmap\\n        for(int i : hashmap.keySet()){\\n            /*\\n            As contistion is given i != j && nums[j]-nums[i]=k,\\n            This make sure that same element is not counted \\n            */\\n\\t\\t\\tif(k==0 && hashmap.get(i) > 1) result++;\\n            else if (hashmap.containsKey(i + k)) result++;\\n\\t\\t}\\n        return result;\\n    }\\n}\\n```\\n\\n**Using Binary-Search:**\\n\\nInstead of using in-built methods of arrays.binarysearch(array,start,end,key), I used a utility function .\\n\\n1.To apply binary search we need to sort array. \\n2.After sorting we need to search for element \"num\" ,if there exists another element \"num+k\".\\n\\nImprovement 1:\\nAs we need unique pair,we dont search if current element is same as before.\\nImprovement 2:\\nAs we sorted array in ascending order, we just need to start our binary search from current_index+1.So searching space considerly reduces.\\nAs we are searching from index+1,this also make sure we are not considering same element when k=0.\\n\\n**Time complexity :** O(n log(n)) for sorting, and for searching in worst case O(log(n)) .As we are doing search operation for n elements, O(n log(n)). Resultant time complexity will be O(n log(n)).\\n\\n**Space complexity:**\\nO(1)[If not considering input array],beacuse we are using fixed number of variables.\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int res=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n\\t\\t//To make sure all pairs are unique\\n            if(i==0||nums[i]!=nums[i-1])\\n                if(search(nums,i,k)) res++;\\n    \\n        return res;\\n    }\\n    private boolean search(int[] nums,int index,int k){\\n        int st=index+1,end=nums.length-1,val=nums[index]+k;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(nums[mid]==val) return true;\\n            else if(nums[mid]>val) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nHope this solution was useful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        //HashMap to store value-count\\n        Map<Integer, Integer> hashmap = new HashMap();\\n\\n\\t\\tint result = 0;\\n        /*\\n        for every number ,\\n        if number is seen for the first time ,then put count=1\\n        else ,increment the count\\n        */\\n        for(int num : nums)\\n            hashmap.computeIfAbsent(num, hashmap.getOrDefault(num, 0) + 1);\\n        //For all the elements in hashmap\\n        for(int i : hashmap.keySet()){\\n            /*\\n            As contistion is given i != j && nums[j]-nums[i]=k,\\n            This make sure that same element is not counted \\n            */\\n\\t\\t\\tif(k==0 && hashmap.get(i) > 1) result++;\\n            else if (hashmap.containsKey(i + k)) result++;\\n\\t\\t}\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int res=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n\\t\\t//To make sure all pairs are unique\\n            if(i==0||nums[i]!=nums[i-1])\\n                if(search(nums,i,k)) res++;\\n    \\n        return res;\\n    }\\n    private boolean search(int[] nums,int index,int k){\\n        int st=index+1,end=nums.length-1,val=nums[index]+k;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(nums[mid]==val) return true;\\n            else if(nums[mid]>val) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876479,
                "title": "c-simple-double-solution-explained-100-time-100-space",
                "content": "While this problem does not seem to be a medium by any stretch of imagination, I think the real trick here is actually to understand that this problem is actually 2 problems:\\n* when `k == 0`, we go hunting for duplicates;\\n* in all the other cases, we go looking for pairs `{a, b}` so that `b - a == k` and we know that `a != b` (otherwise you would have again `k == 0`).\\n\\nNow, for the first case, working with a frequency map and then counting all the elements with frequency `> 1` just works like a charm.\\n\\nThe second case, being a different problem, demands another approach - using a `unordered_set`, for example - populating it and then going through it looking for each element `n` matched by another `k + n` element and increasing the result accordingly.\\n\\nWhatever is the way, in the end we just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int res = 0;\\n        // edge case k == 0, we hunt for duplicates\\n        if (!k) {\\n            unordered_map<int, int> frequencies;\\n            for (int n: nums) frequencies[n]++;\\n            for (auto e: frequencies) if (e.second > 1) res++;\\n        }\\n        // all the other cases\\n        else {\\n            unordered_set<int> seen(begin(nums), end(nums));\\n            for (int n: seen) {\\n                res += seen.find(k + n) != end(seen);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int res = 0;\\n        // edge case k == 0, we hunt for duplicates\\n        if (!k) {\\n            unordered_map<int, int> frequencies;\\n            for (int n: nums) frequencies[n]++;\\n            for (auto e: frequencies) if (e.second > 1) res++;\\n        }\\n        // all the other cases\\n        else {\\n            unordered_set<int> seen(begin(nums), end(nums));\\n            for (int n: seen) {\\n                res += seen.find(k + n) != end(seen);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748774,
                "title": "c-3-approaches-97-faster",
                "content": "```\\n#Approach 1 :  without sorting 98% faster 47% space\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0){return 0;}\\n        unordered_map<int,int> mp;      \\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n       int count = 0;\\n       for(auto x : mp){\\n           int diff = x.first - k;\\n           if(mp.find(diff)!=mp.end()){\\n               if(diff==x.first and x.second>1){\\n                   count++;\\n               }else if(diff!=x.first and x.second>=1){\\n                   count++;\\n               }\\n           }\\n       }\\n        return count;\\n       \\n    }\\n};\\n#Approach 2 : with sorting + map\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],temp));\\n                \\n            }\\n            m[nums[i]]=0; // so we can use temp=nums[i]-k again but from next time nums[i] shouldn\\'t be same so we decreament its count  or make it equal to 0 \\n        }\\n        \\n        return unq.size();\\n     }\\n};\\n\\n// two pointers\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n          sort(nums.begin(),nums.end());\\n         int n =  nums.size();\\n         int count = 0;\\n         int i = 0; int j = 1;\\n         while(i<n and j<n){\\n             if(nums[j] - nums[i] == k){\\n                 i++;\\n                 j++;\\n                 count++;\\n                 // to handle duplicates\\n                 while(j<n and nums[j]==nums[j-1]){\\n                     j++;\\n                 }\\n             }else if(nums[j]-nums[i] > k){\\n                 i++;\\n                 if(j-i==0){\\n                     j++;\\n                 }\\n             }else{\\n                 j++;\\n             }\\n             \\n         }\\n        return count;\\n          \\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#Approach 1 :  without sorting 98% faster 47% space\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0){return 0;}\\n        unordered_map<int,int> mp;      \\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n       int count = 0;\\n       for(auto x : mp){\\n           int diff = x.first - k;\\n           if(mp.find(diff)!=mp.end()){\\n               if(diff==x.first and x.second>1){\\n                   count++;\\n               }else if(diff!=x.first and x.second>=1){\\n                   count++;\\n               }\\n           }\\n       }\\n        return count;\\n       \\n    }\\n};\\n#Approach 2 : with sorting + map\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],temp));\\n                \\n            }\\n            m[nums[i]]=0; // so we can use temp=nums[i]-k again but from next time nums[i] shouldn\\'t be same so we decreament its count  or make it equal to 0 \\n        }\\n        \\n        return unq.size();\\n     }\\n};\\n\\n// two pointers\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n          sort(nums.begin(),nums.end());\\n         int n =  nums.size();\\n         int count = 0;\\n         int i = 0; int j = 1;\\n         while(i<n and j<n){\\n             if(nums[j] - nums[i] == k){\\n                 i++;\\n                 j++;\\n                 count++;\\n                 // to handle duplicates\\n                 while(j<n and nums[j]==nums[j-1]){\\n                     j++;\\n                 }\\n             }else if(nums[j]-nums[i] > k){\\n                 i++;\\n                 if(j-i==0){\\n                     j++;\\n                 }\\n             }else{\\n                 j++;\\n             }\\n             \\n         }\\n        return count;\\n          \\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384530,
                "title": "c-112-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int FindPairs(int[] nums, int k)\\n        {\\n            if (k < 0)\\n            {\\n                return 0;\\n            }\\n            var counts = new Dictionary<int, int>();\\n            foreach (int n in nums)\\n            {\\n                counts[n] = counts.ContainsKey(n) ? counts[n] + 1 : 1;\\n            }\\n            return\\n                k == 0 ?\\n                counts.Count(i => i.Value > 1) :\\n                counts.Count(i => counts.ContainsKey(i.Key + k));\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int FindPairs(int[] nums, int k)\\n        {\\n            if (k < 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 247508,
                "title": "javascript-solution-with-explanation-beats-100",
                "content": "\\n```\\nvar findPairs = function(nums, k) {\\n    let pairCount = 0;\\n    let uniques = new Set(nums);\\n    \\n    // Something can\\'t have a negative difference - diff is an absolute value \\n    if (k < 0) return 0;\\n    \\n    // If k is zero, we are basically finding which elements in nums are duplicates\\n    if (k === 0) return findDuplicates(nums).length;\\n    \\n    // Otherwise we find any values with a diff of k\\n    // Note: you can find this by adding or subtracting by k, no need to do both\\n    uniques.forEach(val => {\\n        if (uniques.has(val+k)) {\\n            pairCount++;\\n        }\\n    })\\n    return pairCount;\\n};\\n\\n// Utility method to find duplicate values in an array and return those values, once for each pair\\nvar findDuplicates = (nums) => {\\n\\tlet result = [];\\n\\tnums.forEach((num, index) => {\\n\\t\\tif (nums.indexOf(num, index + 1) > -1) {\\n            if (result.indexOf(num) === -1) {\\n                result.push(num);\\n            }\\n        }\\n    })\\n    return result;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar findPairs = function(nums, k) {\\n    let pairCount = 0;\\n    let uniques = new Set(nums);\\n    \\n    // Something can\\'t have a negative difference - diff is an absolute value \\n    if (k < 0) return 0;\\n    \\n    // If k is zero, we are basically finding which elements in nums are duplicates\\n    if (k === 0) return findDuplicates(nums).length;\\n    \\n    // Otherwise we find any values with a diff of k\\n    // Note: you can find this by adding or subtracting by k, no need to do both\\n    uniques.forEach(val => {\\n        if (uniques.has(val+k)) {\\n            pairCount++;\\n        }\\n    })\\n    return pairCount;\\n};\\n\\n// Utility method to find duplicate values in an array and return those values, once for each pair\\nvar findDuplicates = (nums) => {\\n\\tlet result = [];\\n\\tnums.forEach((num, index) => {\\n\\t\\tif (nums.indexOf(num, index + 1) > -1) {\\n            if (result.indexOf(num) === -1) {\\n                result.push(num);\\n            }\\n        }\\n    })\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246361,
                "title": "c-clean-easy-to-follow-two-pointers-o-1-space-soln",
                "content": "The input array is sorted & two pointers are maintained; the left pointer is incremented if the diff > k, the right pointer is incremented if the diff < k and both if diff == k. \\n\\n```\\n   int findPairs(vector<int>& nums, int k) {\\n        if (nums.empty() || k < 0) {\\n            return 0;\\n        }\\n        \\n        std::sort(nums.begin(), nums.end());\\n        \\n        int p1 = 0;            // points to first member of the pair\\n        int p2 = p1 + 1;       // points to second member of the pair\\n        int result = 0;\\n\\t\\t\\n        while (p1 < nums.size() && p2 < nums.size()) {\\n            if (p1 == p2) {\\n                p2++;\\n                continue;\\n            }\\n            if (p1 > 0 && nums[p1] == nums[p1-1]) {\\n                // to avoid dupes\\n                p1++;\\n                continue;\\n            }\\n            auto diff = std::abs(nums[p1] - nums[p2]);\\n           \\n\\t\\t   if (diff == k) {\\n                result++;\\n                p1++;\\n                p2++;\\n            } else if (diff < k) {\\n                p2++;\\n            } else {\\n                p1++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int findPairs(vector<int>& nums, int k) {\\n        if (nums.empty() || k < 0) {\\n            return 0;\\n        }\\n        \\n        std::sort(nums.begin(), nums.end());\\n        \\n        int p1 = 0;            // points to first member of the pair\\n        int p2 = p1 + 1;       // points to second member of the pair\\n        int result = 0;\\n\\t\\t\\n        while (p1 < nums.size() && p2 < nums.size()) {\\n            if (p1 == p2) {\\n                p2++;\\n                continue;\\n            }\\n            if (p1 > 0 && nums[p1] == nums[p1-1]) {\\n                // to avoid dupes\\n                p1++;\\n                continue;\\n            }\\n            auto diff = std::abs(nums[p1] - nums[p2]);\\n           \\n\\t\\t   if (diff == k) {\\n                result++;\\n                p1++;\\n                p2++;\\n            } else if (diff < k) {\\n                p2++;\\n            } else {\\n                p1++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144919,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        res = 0\\n        counter = collections.Counter(nums)\\n        for key in counter:\\n            if k != 0:\\n                if key - k in counter:\\n                    res += 1\\n            else:\\n                if counter[key] > 1:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        res = 0\\n        counter = collections.Counter(nums)\\n        for key in counter:\\n            if k != 0:\\n                if key - k in counter:\\n                    res += 1\\n            else:\\n                if counter[key] > 1:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100172,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        count = []\\n        dict = {}\\n        for i in xrange(len(nums)):\\n            if nums[i] in dict:\\n                count.append((dict[nums[i]],nums[i]))\\n            dict[nums[i]+k] = nums[i]\\n        return len(set(count))\\n\\n````",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        count = []\\n        dict = {}\\n        for i in xrange(len(nums)):\\n            if nums[i] in dict:\\n                count.append((dict[nums[i]],nums[i]))\\n            dict[nums[i]+k] = nums[i]\\n        return len(set(count))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592588,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(int x: nums) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if (k == 0) {    \\n                if(x.second > 1) ans++;\\n            }\\n            else if (mp.find(x.first + k) != mp.end()) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(int x: nums) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if (k == 0) {    \\n                if(x.second > 1) ans++;\\n            }\\n            else if (mp.find(x.first + k) != mp.end()) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472579,
                "title": "easiest-way-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0 || nums[i]!=nums[i-1]){\\n                for(int j=i+1;j<nums.length;j++){\\n                    if(Math.abs(nums[i]-nums[j])==k){\\n                        count++;\\n                        break;\\n                     \\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0 || nums[i]!=nums[i-1]){\\n                for(int j=i+1;j<nums.length;j++){\\n                    if(Math.abs(nums[i]-nums[j])==k){\\n                        count++;\\n                        break;\\n                     \\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434673,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        Set<Integer> s = new HashSet<>();\\n\\n        for(int num : nums) {\\n            if(s.contains(num - k) || s.contains(num + k)) {\\n                set.add(new ArrayList<>(Arrays.asList(num, num - k)));\\n            } \\n            s.add(num);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        Set<Integer> s = new HashSet<>();\\n\\n        for(int num : nums) {\\n            if(s.contains(num - k) || s.contains(num + k)) {\\n                set.add(new ArrayList<>(Arrays.asList(num, num - k)));\\n            } \\n            s.add(num);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341162,
                "title": "easy-and-short-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n      unordered_map<int,int> m;\\n        for(auto it: nums)m[it]++;\\n        if(k!=0)\\n        {\\n            for(auto it: m)\\n            {\\n                if(m.find(it.first+k)!=m.end())\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(auto it: m)\\n            {\\n                if(it.second>1)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n      unordered_map<int,int> m;\\n        for(auto it: nums)m[it]++;\\n        if(k!=0)\\n        {\\n            for(auto it: m)\\n            {\\n                if(m.find(it.first+k)!=m.end())\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(auto it: m)\\n            {\\n                if(it.second>1)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270120,
                "title": "easy-c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\n//TC=O(nlogn)\\nclass Solution {\\npublic:\\nint search(vector<int>& nums,int t,int s){\\n    int e=nums.size()-1;\\n    while(s<=e){\\n        int mid=s+(e-s)/2;\\n        if(nums[mid]==t)\\n        return mid;\\n        else if(t>nums[mid])\\n        s=mid+1;\\n        else\\n        e=mid-1;\\n    }\\n    return -1;\\n}\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(search(nums,nums[i]+k,i+1)!=-1)\\n            ans.insert({nums[i],nums[i]+k});\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//TC=O(nlogn)\\nclass Solution {\\npublic:\\nint search(vector<int>& nums,int t,int s){\\n    int e=nums.size()-1;\\n    while(s<=e){\\n        int mid=s+(e-s)/2;\\n        if(nums[mid]==t)\\n        return mid;\\n        else if(t>nums[mid])\\n        s=mid+1;\\n        else\\n        e=mid-1;\\n    }\\n    return -1;\\n}\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(search(nums,nums[i]+k,i+1)!=-1)\\n            ans.insert({nums[i],nums[i]+k});\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270063,
                "title": "easy-c-solution-two-pointer-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0,j=1;\\n        while(j<nums.size()){\\n            int diff=nums[j]-nums[i];\\n            if(diff==k)\\n            {\\n                ans.insert({nums[i],nums[j]});\\n                i++;j++;\\n            }\\n            else if(diff>k)\\n            i++;\\n            else\\n            j++;\\n            if(i==j)\\n            j++;\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0,j=1;\\n        while(j<nums.size()){\\n            int diff=nums[j]-nums[i];\\n            if(diff==k)\\n            {\\n                ans.insert({nums[i],nums[j]});\\n                i++;j++;\\n            }\\n            else if(diff>k)\\n            i++;\\n            else\\n            j++;\\n            if(i==j)\\n            j++;\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736308,
                "title": "easiest-c-approach-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;   //duplicates dont matters;\\n        }\\n        if(k==0)\\n        {\\n            int count=0;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                if(it->second>=2)\\n                {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            int num = it->first;\\n            if(mp.find(num+k)!=mp.end())\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n//nums==  3 1 4 1 5   --- > 1 1 3 4 5\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;   //duplicates dont matters;\\n        }\\n        if(k==0)\\n        {\\n            int count=0;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                if(it->second>=2)\\n                {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            int num = it->first;\\n            if(mp.find(num+k)!=mp.end())\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n//nums==  3 1 4 1 5   --- > 1 1 3 4 5\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664398,
                "title": "easiest-c-approach-using-hashmaps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int>hash;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            hash[nums[i]]++;\\n        }\\n        for(auto it=hash.begin();it!=hash.end();it++){\\n            if(k==0){\\n                if(it->second>=2)\\n                    cnt++;\\n            }          \\n            else if(hash.find(it->first+k)!=hash.end())\\n                cnt++;\\n        }\\n        return cnt;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int>hash;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            hash[nums[i]]++;\\n        }\\n        for(auto it=hash.begin();it!=hash.end();it++){\\n            if(k==0){\\n                if(it->second>=2)\\n                    cnt++;\\n            }          \\n            else if(hash.find(it->first+k)!=hash.end())\\n                cnt++;\\n        }\\n        return cnt;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349814,
                "title": "c-hashmap-two-pointer-very-easy-code-80-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        \\n        vector<int> v;\\n        int sum=0;\\n        for(auto x:m)\\n        {\\n            v.push_back(x.first);// vector v has unique(nums) in sorted order;\\n            if(x.second>1)// counting for k==0\\n                sum++;\\n        }\\n        if(k==0)\\n            return sum;\\n        \\n        int res=0;\\n        int i=0,j=1;\\n        while(j<v.size())\\n        {\\n            if(v[j]-v[i] < k)\\n                j++;\\n            else if(v[j]-v[i] > k)\\n                i++;\\n            else\\n            {\\n                i++;\\n                j++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        \\n        vector<int> v;\\n        int sum=0;\\n        for(auto x:m)\\n        {\\n            v.push_back(x.first);// vector v has unique(nums) in sorted order;\\n            if(x.second>1)// counting for k==0\\n                sum++;\\n        }\\n        if(k==0)\\n            return sum;\\n        \\n        int res=0;\\n        int i=0,j=1;\\n        while(j<v.size())\\n        {\\n            if(v[j]-v[i] < k)\\n                j++;\\n            else if(v[j]-v[i] > k)\\n                i++;\\n            else\\n            {\\n                i++;\\n                j++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957431,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int j = 1;\\n        int ans = 0;\\n        while(j<n){\\n            if(nums[j]-nums[i] <= k){\\n                if (nums[j]-nums[i] == k) ans++;\\n                do {\\n                   j++;\\n               } while(j < n && nums[j] == nums[j-1]);\\n            }\\n           else {\\n               do {\\n                   i++;\\n                   if (i == j) j++;\\n               } while(i < n && nums[i] == nums[i-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int j = 1;\\n        int ans = 0;\\n        while(j<n){\\n            if(nums[j]-nums[i] <= k){\\n                if (nums[j]-nums[i] == k) ans++;\\n                do {\\n                   j++;\\n               } while(j < n && nums[j] == nums[j-1]);\\n            }\\n           else {\\n               do {\\n                   i++;\\n                   if (i == j) j++;\\n               } while(i < n && nums[i] == nums[i-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787795,
                "title": "c-binary-search-12ms-97-o-nlogn-12mb-o-1-88",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int res = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(i-1 >= 0 && nums[i] == nums[i - 1]) continue;\\n            int x = nums[i] <= 0 ? nums[i] + k: abs(nums[i]+k);            \\n            if(binary_search(nums.begin() + i+1, nums.end(), x)) res++;\\n        }\\n        \\n        return res;        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int res = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(i-1 >= 0 && nums[i] == nums[i - 1]) continue;\\n            int x = nums[i] <= 0 ? nums[i] + k: abs(nums[i]+k);            \\n            if(binary_search(nums.begin() + i+1, nums.end(), x)) res++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758819,
                "title": "python-o-n-using-counter",
                "content": "**Thought-Process:** The problem is all about search. Hash table is the first approach that comes in the mind when you see searching.  I took counter because, k can be zero, so you want to know that which element occurs more than once. I just see element + k to avoid repetition by limiting my search in unidirectional. \\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        ans = 0\\n        if k == 0:\\n            for e in c:\\n                if c[e] > 1:\\n                    ans += 1\\n        else:\\n            for e in c:\\n                if e+k in c:\\n                    ans += 1\\n        return ans\\n```\\n\\nNote: I am new in competitve programming. I do mistakes. If you have more insights than me, it would be better if you drop your idea in a comment. You can also ask me a question regarding this code, I would be more than happy to help! Happy coding.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        ans = 0\\n        if k == 0:\\n            for e in c:\\n                if c[e] > 1:\\n                    ans += 1\\n        else:\\n            for e in c:\\n                if e+k in c:\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758777,
                "title": "c-simple-hashmap-solution-o-n",
                "content": "class Solution {\\npublic:\\n*     int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n        }\\n         for(auto it:mp){\\n             if(k==0){\\n                if(it.second>=2){\\n                 cnt++;\\n               }\\n             }\\n             else if(k>0){\\n                 int rem=it.first+k;\\n                 if(mp.find(rem)!=mp.end()){\\n                     cnt++;\\n                 }\\n             }\\n         }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n*     int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758446,
                "title": "python-o-n-solution-faster-than-99-88",
                "content": "\\'\\'\\'\\n\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        if k == 0:\\n            s = set()\\n            res_set = set()\\n            for n in nums:\\n                if n in s and n not in res_set:\\n                    res += 1\\n                    res_set.add(n)\\n                else:\\n                    s.add(n)\\n            return res\\n        \\n        s = set(nums)\\n        for n in s:\\n            if n+k in s:\\n                res+=1\\n        return res\\n    \\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "\\'\\'\\'\\n\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        if k == 0:\\n            s = set()\\n            res_set = set()\\n            for n in nums:\\n                if n in s and n not in res_set:\\n                    res += 1\\n                    res_set.add(n)\\n                else:\\n                    s.add(n)\\n            return res\\n        \\n        s = set(nums)\\n        for n in s:\\n            if n+k in s:\\n                res+=1\\n        return res\\n    \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1758296,
                "title": "c-hashmap-easy-understanding",
                "content": "**C++**\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        //create a map to store the freq of all unique nums\\n        unordered_map<int,int> mp;\\n        for(auto n: nums) mp[n]++;\\n        \\n        int ans=0;\\n        \\n        for(auto N : mp){\\n            //if (k==0), for every N in map, check if count[N] > 1\\n            //if (k!=0), find if N + k,exists or not\\n            if( (k==0 && N.second > 1) ||\\n                (k!=0 && mp.count(N.first + k) > 0)){\\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n**Please Upvote, If you find this solution helpful!**",
                "solutionTags": [],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        //create a map to store the freq of all unique nums\\n        unordered_map<int,int> mp;\\n        for(auto n: nums) mp[n]++;\\n        \\n        int ans=0;\\n        \\n        for(auto N : mp){\\n            //if (k==0), for every N in map, check if count[N] > 1\\n            //if (k!=0), find if N + k,exists or not\\n            if( (k==0 && N.second > 1) ||\\n                (k!=0 && mp.count(N.first + k) > 0)){\\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1758086,
                "title": "easy-c-solution-with-map-and-set",
                "content": "```\\nint findPairs(vector<int>& nums, int k) {\\n        map<int ,int> mp;\\n        set<pair<int, int>> st;\\n        \\n        int size = nums.size();\\n        for(int i=0; i<size; i++){\\n                if(mp.count(nums[i]+k))\\n                    st.insert({nums[i], nums[i]+k});\\n                if(mp.count(nums[i]-k))\\n                     st.insert({nums[i]-k, nums[i]});\\n                mp[nums[i]]++;\\n        }\\n        \\n        return st.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        map<int ,int> mp;\\n        set<pair<int, int>> st;\\n        \\n        int size = nums.size();\\n        for(int i=0; i<size; i++){\\n                if(mp.count(nums[i]+k))\\n                    st.insert({nums[i], nums[i]+k});\\n                if(mp.count(nums[i]-k))\\n                     st.insert({nums[i]-k, nums[i]});\\n                mp[nums[i]]++;\\n        }\\n        \\n        return st.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757876,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int pairsCount = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        for(Integer key: map.keySet()) {\\n            \\n            if(k == 0 && map.get(key) > 1)\\n                pairsCount++;\\n            else if(k > 0 && map.containsKey(key-k))\\n                pairsCount++;\\n        }\\n     \\n        return pairsCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int pairsCount = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        for(Integer key: map.keySet()) {\\n            \\n            if(k == 0 && map.get(key) > 1)\\n                pairsCount++;\\n            else if(k > 0 && map.containsKey(key-k))\\n                pairsCount++;\\n        }\\n     \\n        return pairsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757697,
                "title": "k-diff-pairs-in-an-array-solution-java",
                "content": "class Solution {\\n  public int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      numToIndex.put(nums[i], i);\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      final int target = nums[i] + k;\\n      if (numToIndex.containsKey(target) && numToIndex.get(target) != i) {\\n        ++ans;\\n        numToIndex.remove(target);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      numToIndex.put(nums[i], i);\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      final int target = nums[i] + k;\\n      if (numToIndex.containsKey(target) && numToIndex.get(target) != i) {\\n        ++ans;\\n        numToIndex.remove(target);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1757628,
                "title": "python-explanation-hash-table-counter",
                "content": "The intuition/approach behind this solution involves simple **mathematics**. \\n\\nWe create a hash table of the elements of nums, using the Counter module. If the num of pairs to be sought is zero, we expect atleast an element to occur once, else we search for the same in the list including the element and its immediate k neighbors.\\n\\n```\\nclass Solution(object):  \\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        c=Counter(nums)\\n        pairs=0\\n        if k==0:\\n            for key,value in c.items():\\n                if value>1:\\n                    pairs+=1\\n        else:\\n            for key,value in c.items():\\n                if key+k in c:\\n                    pairs+=1\\n        return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):  \\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        c=Counter(nums)\\n        pairs=0\\n        if k==0:\\n            for key,value in c.items():\\n                if value>1:\\n                    pairs+=1\\n        else:\\n            for key,value in c.items():\\n                if key+k in c:\\n                    pairs+=1\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757348,
                "title": "simple-java-solution-with-explaination",
                "content": "we want to found pairs which follow below equation ->\\na-b=k OR it can be written as a=k+b;\\nIt is also mentioned to not consider duplicate pairs.\\ntake counter to hold answer.\\ntake map to store element as key and frequency as value. why we need frequency we will come back to it later.\\nloop and prepare map with required data.\\nnow if we iterate over map again instead of array we will be iterating only unique elements.\\nnow we need to check if map.containsKey(element+k) as entry. if it is true increase counter.\\nnow there is one special case where k=0. in such case, same element should be present atleast twice, then only we will have pair. so if k==0 check map.get(element)>1\\n```\\npublic int findPairs(int[] nums, int k) {\\n        int c=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x:nums) {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        }\\n        for(int x:map.keySet()) {\\n            Integer val = map.getOrDefault(x+k,0);\\n            if((k==0&&val>1)||(k>0 &&val>0)) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n        int c=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x:nums) {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        }\\n        for(int x:map.keySet()) {\\n            Integer val = map.getOrDefault(x+k,0);\\n            if((k==0&&val>1)||(k>0 &&val>0)) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757274,
                "title": "c-o-n-hashmap-with-explanation",
                "content": "/***Daily Challenge:-09/02/2022.\\nApproach:- We are using Concept of Hashing.\\n-->step1:-Store all the frequency of elements in a Unordered_map.**\\n\\n**Now ,Understand the Concept:-\\n\\n**We are given abs(nums[i]-nums[j])==k\\n=>nums[i]=nums[j]+k ;  In this case we have to find nums[i] as required value\\n\\n**or =>nums[j]=nums[i]+k  ; In this case we have to find nums[j] as required value.\\nSo,in the map if we find any of the requird Value we, will increase our Count.**\\n\\n\\n\\n**-->Step2:-Traverse throughOut the map.\\n   ** -->Drecrement the frequency Count of a paticulat element.(Because it will avoid he case ,when finding element will equal to that element.)**\\n    **-->So, if we find our require element, and if its frquency count >=1,we increase our count. ** ***/\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        \\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        for(auto x:mp)\\n        {\\n                mp[x.first]--;\\n            int flag=x.first+k;\\n            \\n            if(mp.find(flag)!=mp.end())\\n            {\\n                if(mp[flag]>=1)\\n                    count++;\\n            }\\n                \\n            mp[x.first]++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        \\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757271,
                "title": "c-binary-search-and-hashmap-easy-to-understand",
                "content": "**Please upvote if you find helpful:)**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        int c=0, i=0;\\n        if(k==0)\\n        {\\n            for(auto it:mp)\\n                if(it.second>1)\\n                    c++;\\n            return c;\\n        }\\n        sort(nums.begin(), nums.end());\\n        while(i<nums.size())\\n        {\\n            while(i>0 && nums[i]==nums[i-1])\\n                i++;\\n            int find=k+nums[i];\\n            if(binary_search(nums.begin(), nums.end(), find))\\n            {\\n                int index=lower_bound(nums.begin(), nums.end(), find)-nums.begin();\\n                if(index==i)\\n                {\\n                    if(mp[nums[i]]>0)\\n                        c++;\\n                }\\n                else\\n                    c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        int c=0, i=0;\\n        if(k==0)\\n        {\\n            for(auto it:mp)\\n                if(it.second>1)\\n                    c++;\\n            return c;\\n        }\\n        sort(nums.begin(), nums.end());\\n        while(i<nums.size())\\n        {\\n            while(i>0 && nums[i]==nums[i-1])\\n                i++;\\n            int find=k+nums[i];\\n            if(binary_search(nums.begin(), nums.end(), find))\\n            {\\n                int index=lower_bound(nums.begin(), nums.end(), find)-nums.begin();\\n                if(index==i)\\n                {\\n                    if(mp[nums[i]]>0)\\n                        c++;\\n                }\\n                else\\n                    c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757245,
                "title": "c-two-versions-dictionary-and-sorting-with-hashset",
                "content": "This was actually asked to me in an interview in a top product based company as an internal candidate.\\n\\n1. This is an O(n) solution converted to C#, shared by others in Java.\\nLogic is very simple:\\nBuild a dictionary (or map) with unique numbers in the array and store their count.\\nEg. for the  input: `nums = [3,1,4,1,5] and k = 2`\\n3-1, there is only one 3\\n1-2, there are two 1s\\n4-1, there is only one 4\\n5-1, there is only one 5\\n\\n\\tNext loop through each key-value pair in this map and see if there exists a key with current key + k (equivalent to Math.Abs(current key - target key) == k)\\n\\n\\tAlso, there is an edge case, for k==0. If k in the input was 0, then just check if the there were duplicate keys in the dictionary/map. This can be done just by checking the count of current key > 1. In above example, if k was 0, then - whenever we are at the number 1 we can see that there were two occurence of 1 in the array and thus we have a pair.\\n\\n```\\npublic int FindPairsWithDictionary(int[] nums, int k) {\\n        var pairsCount = 0 ;\\n        var map = new Dictionary<int, int>();\\n        foreach(var num in nums)\\n        {\\n            if (!map.ContainsKey(num))\\n            {\\n                map.Add(num, 0);\\n            }\\n            map[num]++;\\n        }\\n        \\n        foreach(var pair in map)\\n        {\\n            if (k > 0 && map.ContainsKey(pair.Key + k)) {\\n                pairsCount ++;\\n            }\\n            // special case\\n            if (k == 0 && pair.Value > 1)\\n            {\\n                pairsCount ++;\\n            }\\n        }\\n        \\n        return pairsCount;\\n    }\\n    \\n```\\n\\n2. This is also a C# version for code shared by other people in the discussion. This one looks very simple, but has the overhead of sorting the array, going over the array multiple times. So, the time complexity is really high.\\n```\\npublic int FindPairsWithSorting(int[] nums, int k) {\\n        var count = 0;\\n        var n = nums.Length;\\n        var result = new HashSet<int>();\\n        Array.Sort(nums);\\n        for (int i=0; i<n-1; i++) {\\n            var firstNumber = nums[i];\\n            for (int j=i+1; j<n; j++) \\n            {\\n                if (nums[j] - firstNumber >  k) {\\n                    break;\\n                }\\n                \\n                if (nums[j] - firstNumber == k)\\n                {\\n                    if (!result.Contains(firstNumber) || !result.Contains(nums[j])) {\\n                        count++;\\n                    }\\n                    result.Add(firstNumber);\\n                    result.Add(nums[j]);                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int FindPairsWithDictionary(int[] nums, int k) {\\n        var pairsCount = 0 ;\\n        var map = new Dictionary<int, int>();\\n        foreach(var num in nums)\\n        {\\n            if (!map.ContainsKey(num))\\n            {\\n                map.Add(num, 0);\\n            }\\n            map[num]++;\\n        }\\n        \\n        foreach(var pair in map)\\n        {\\n            if (k > 0 && map.ContainsKey(pair.Key + k)) {\\n                pairsCount ++;\\n            }\\n            // special case\\n            if (k == 0 && pair.Value > 1)\\n            {\\n                pairsCount ++;\\n            }\\n        }\\n        \\n        return pairsCount;\\n    }\\n    \\n```\n```\\npublic int FindPairsWithSorting(int[] nums, int k) {\\n        var count = 0;\\n        var n = nums.Length;\\n        var result = new HashSet<int>();\\n        Array.Sort(nums);\\n        for (int i=0; i<n-1; i++) {\\n            var firstNumber = nums[i];\\n            for (int j=i+1; j<n; j++) \\n            {\\n                if (nums[j] - firstNumber >  k) {\\n                    break;\\n                }\\n                \\n                if (nums[j] - firstNumber == k)\\n                {\\n                    if (!result.Contains(firstNumber) || !result.Contains(nums[j])) {\\n                        count++;\\n                    }\\n                    result.Add(firstNumber);\\n                    result.Add(nums[j]);                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757151,
                "title": "my-java-code",
                "content": "```\\nclass Solution {\\n     public int findPairs(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i: nums) map.put(i,map.getOrDefault(i,0)+1);\\n        if(k==0) return (int)map.keySet().stream().filter(key->map.get(key)>1).count();\\n        return (int)map.keySet().stream().filter(key->map.containsKey(key+k)).count();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int findPairs(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i: nums) map.put(i,map.getOrDefault(i,0)+1);\\n        if(k==0) return (int)map.keySet().stream().filter(key->map.get(key)>1).count();\\n        return (int)map.keySet().stream().filter(key->map.containsKey(key+k)).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757137,
                "title": "c-solution-8-ms-faster-than-98-two-pointer-approach",
                "content": "```\\nint findPairs(vector<int>& nums, int k) {\\n        \\n        int low= 0, high = 1;\\n        int count = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n  \\n        while(low<nums.size() && high<nums.size())\\n        {\\n            int diff=nums[high]-nums[low];\\n            if(diff==k)\\n            {\\n                count++;\\n                high++;\\n                \\n                //to avoid duplicates\\n                \\n                while(high<nums.size() && nums[high]==nums[high-1])\\n                    high++;        \\n                \\n            }\\n            else if(diff<k)\\n                high++;\\n            else if(diff>k)\\n            {\\n                low++;\\n                if(low==high)\\n                    high++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        \\n        int low= 0, high = 1;\\n        int count = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n  \\n        while(low<nums.size() && high<nums.size())\\n        {\\n            int diff=nums[high]-nums[low];\\n            if(diff==k)\\n            {\\n                count++;\\n                high++;\\n                \\n                //to avoid duplicates\\n                \\n                while(high<nums.size() && nums[high]==nums[high-1])\\n                    high++;        \\n                \\n            }\\n            else if(diff<k)\\n                high++;\\n            else if(diff>k)\\n            {\\n                low++;\\n                if(low==high)\\n                    high++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757047,
                "title": "python3-runtime-58-ms-faster-than-99-40-memory-15-6-mb-less-than-89-25",
                "content": "```\\nclass Solution:\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\tans,check = 0,{}\\n\\t\\tfor i in nums:\\n\\t\\t\\tif i not in check:\\n\\t\\t\\t\\tcheck[i]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcheck[i]+=1\\n\\t\\tif k>0:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif j+k in check.keys():\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\telse:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif check[j]>1:\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\treturn ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\tans,check = 0,{}\\n\\t\\tfor i in nums:\\n\\t\\t\\tif i not in check:\\n\\t\\t\\t\\tcheck[i]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcheck[i]+=1\\n\\t\\tif k>0:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif j+k in check.keys():\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\telse:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif check[j]>1:\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704262,
                "title": "c-java-two-pointers-approach",
                "content": "Space complexity - `O(1)`\\nTime complexity - `O(n*log(n))`\\n\\n##### C++\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x == nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n##### Java\\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(Math.abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x==nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(Math.abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x == nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(Math.abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x==nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(Math.abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688321,
                "title": "tanmay-taneja-c",
                "content": "``` \\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        map <int,int> m;\\n        for(int i=0; i<nums.size(); i++){\\n            m[nums[i]]++;\\n        }\\n        for(auto it: m){\\n            if(k==0){\\n                if(m[it.first]>1){\\n                    ans+=1;\\n                }\\n            }\\n            else if(m.find(it.first + k) != m.end()){\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        map <int,int> m;\\n        for(int i=0; i<nums.size(); i++){\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1476335,
                "title": "python-solution-with-hashmap-a-different-approach",
                "content": "I have used hashmap to track each numbers occurances to check for (num + k) or (num - k) in the hashmap which has occured eariler to make a pair with diff k. The same hashmap can be counted to track if we have already visited a possible comination.\\nThis works fine except for when k == 0, for which i have added a check to allow until a particular number occurs twice, as thats when k is 0, when there are 2 occurances ateast.\\n\\nWorks 80% faster. May not be a great solution, just sharing my idea.\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        hmap = {}\\n        count = 0\\n        for i in range(len(nums)):\\n            \\'\\'\\' check in hmap if k is not zero if we have already visited that pair starting with that\\n                if k == 0 its allowed to add either of the case (+k or -k, ive chose to use nums[i]-k here) \\n                untill its count is 2 as when k == 0, we might need the same number twice.  \\'\\'\\'\\n            \\n            if (k!= 0 and nums[i] not in hmap) or (k == 0 and (nums[i] not in hmap or hmap[nums[i]] <2)): \\n                if nums[i] - k in hmap: count += 1\\n                if k!= 0 and nums[i] + k in hmap: count += 1\\n            # add to hmap for tracking visited or to check previous pair.    \\n            if nums[i] not in hmap: hmap[nums[i]] = 0 \\n            hmap[nums[i]] += 1\\n        return count\\n\\t\\t\\n\\t```\\n\\tTC: O(N)\\n\\tSC : O(N)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        hmap = {}\\n        count = 0\\n        for i in range(len(nums)):\\n            \\'\\'\\' check in hmap if k is not zero if we have already visited that pair starting with that\\n                if k == 0 its allowed to add either of the case (+k or -k, ive chose to use nums[i]-k here) \\n                untill its count is 2 as when k == 0, we might need the same number twice.  \\'\\'\\'\\n            \\n            if (k!= 0 and nums[i] not in hmap) or (k == 0 and (nums[i] not in hmap or hmap[nums[i]] <2)): \\n                if nums[i] - k in hmap: count += 1\\n                if k!= 0 and nums[i] + k in hmap: count += 1\\n            # add to hmap for tracking visited or to check previous pair.    \\n            if nums[i] not in hmap: hmap[nums[i]] = 0 \\n            hmap[nums[i]] += 1\\n        return count\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1453644,
                "title": "java-solution-using-hashmap",
                "content": "# We will count the frequnecy of all the elements in the array and ckeck if arr[i] + k is present in the hashmap. If present we will increment the count.\\n# if k == 0. this means same value exists in the array twice so we check if that values frequency is greater than 2 than we increment the count.\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        if(k < 0)\\n            return 0;\\n        \\n        int len = nums.length;\\n        \\n        if(len < 2)\\n            return 0;\\n        \\n        int count = 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        \\n        \\n        for(int n : map.keySet()) {\\n            if(k == 0) {\\n                if(map.get(n) >= 2) {\\n                    count++;\\n                }\\n            }\\n            else {\\n                if(map.containsKey(n + k))\\n                    count++;\\n            }\\n        }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        if(k < 0)\\n            return 0;\\n        \\n        int len = nums.length;\\n        \\n        if(len < 2)\\n            return 0;\\n        \\n        int count = 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        \\n        \\n        for(int n : map.keySet()) {\\n            if(k == 0) {\\n                if(map.get(n) >= 2) {\\n                    count++;\\n                }\\n            }\\n            else {\\n                if(map.containsKey(n + k))\\n                    count++;\\n            }\\n        }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331507,
                "title": "c-easy-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(i!=j && abs(nums[i]-nums[j])==k){\\n                ans++;\\n                int ele=nums[j];\\n                while(nums[j]==ele)\\n                {\\n                    j++;\\n                    if(j>=nums.size()) return ans;\\n                }\\n            }\\n            else if(abs(nums[i]-nums[j])>k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(i!=j && abs(nums[i]-nums[j])==k){\\n                ans++;\\n                int ele=nums[j];\\n                while(nums[j]==ele)\\n                {\\n                    j++;\\n                    if(j>=nums.size()) return ans;\\n                }\\n            }\\n            else if(abs(nums[i]-nums[j])>k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297766,
                "title": "cpp-solution-beats-100-o-nlogn-two-pointer-approach-proof-attached",
                "content": "Hello World !!.  A two pointer based approach. Code is commented for better understanding. Hope it helps otherwise feel free to comment. \\nThanks.\\nHappy Coding.\\n```\\n     int n=nums.size();\\n\\t \\n\\t // Sort the given vector\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=1;\\n        int c=0;  // hold the final answer\\n        int prev=INT_MIN; // keeps tracks of previous element\\n        while(i<n && j<n){\\n\\t\\t\\n            if(nums[j]-nums[i] == k)\\n            {\\n                c++;\\n                prev=nums[i];  //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\t// if difference between values of both pointers is more than k, then increment j.\\n            else if (j<n && nums[j]-nums[i]<k  ) j++;\\n\\t\\t\\t\\n\\t\\t\\t// else increment i\\n            else{\\n                prev=nums[i]; //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Note this while loop carefully. It makes sure that value of current nums[i] is not equal to the previous one, \\n\\t\\t\\t\\t//because only unique difference pairs should be counted as per problem. So this while loop keep on moving \\n\\t\\t\\t\\t// until either i becomes equal to n or previous value is not equal to current value.\\n            while(i<n && nums[i]==prev  ) i++;\\n\\t\\t\\t\\n\\t\\t\\t// It makes sure that both i and j pointers are not pointing to same value. \\n\\t\\t\\t// This makes sure to pass the corner cases when k is 0.\\n            if(i==j) j++;\\n        }\\n        return c;\\n```\\n![image](https://assets.leetcode.com/users/images/a5baf2a4-409e-4870-bf26-de94d2b4930b_1624697454.0305192.png)\\n",
                "solutionTags": [],
                "code": "```\\n     int n=nums.size();\\n\\t \\n\\t // Sort the given vector\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=1;\\n        int c=0;  // hold the final answer\\n        int prev=INT_MIN; // keeps tracks of previous element\\n        while(i<n && j<n){\\n\\t\\t\\n            if(nums[j]-nums[i] == k)\\n            {\\n                c++;\\n                prev=nums[i];  //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\t// if difference between values of both pointers is more than k, then increment j.\\n            else if (j<n && nums[j]-nums[i]<k  ) j++;\\n\\t\\t\\t\\n\\t\\t\\t// else increment i\\n            else{\\n                prev=nums[i]; //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Note this while loop carefully. It makes sure that value of current nums[i] is not equal to the previous one, \\n\\t\\t\\t\\t//because only unique difference pairs should be counted as per problem. So this while loop keep on moving \\n\\t\\t\\t\\t// until either i becomes equal to n or previous value is not equal to current value.\\n            while(i<n && nums[i]==prev  ) i++;\\n\\t\\t\\t\\n\\t\\t\\t// It makes sure that both i and j pointers are not pointing to same value. \\n\\t\\t\\t// This makes sure to pass the corner cases when k is 0.\\n            if(i==j) j++;\\n        }\\n        return c;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229829,
                "title": "one-pass-two-sets-92-speed",
                "content": "Runtime: 68 ms, faster than 92.38% of Python3 online submissions for K-diff Pairs in an Array.\\nMemory Usage: 17 MB, less than 8.57% of Python3 online submissions for K-diff Pairs in an Array.\\n```\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        previous = {nums[0]}\\n        pairs = set()\\n        for n in nums[1:]:\\n            if n - k in previous:\\n                pairs.add((n - k, n))\\n            if n + k in previous:\\n                pairs.add((n, n + k))\\n            previous.add(n)\\n        return len(pairs)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        previous = {nums[0]}\\n        pairs = set()\\n        for n in nums[1:]:\\n            if n - k in previous:\\n                pairs.add((n - k, n))\\n            if n + k in previous:\\n                pairs.add((n, n + k))\\n            previous.add(n)\\n        return len(pairs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225223,
                "title": "c-simple-easy-solution-two-pointer-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n       int count=0;\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n)\\n        {\\n            if(i!=j && nums[j]-nums[i]==k){\\n                while(i+1 < n && nums[i+1] == nums[i]) // to check for distinct pairs\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j]) //to check for distinct pairs\\n                    j++;\\n                j++;\\n                count++;\\n            }\\n            else if(nums[j]-nums[i]<k) j++;\\n            else i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n       int count=0;\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n)\\n        {\\n            if(i!=j && nums[j]-nums[i]==k){\\n                while(i+1 < n && nums[i+1] == nums[i]) // to check for distinct pairs\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j]) //to check for distinct pairs\\n                    j++;\\n                j++;\\n                count++;\\n            }\\n            else if(nums[j]-nums[i]<k) j++;\\n            else i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208890,
                "title": "python-two-set-approach-time-and-space-o-n-no-sorting",
                "content": "|a-b| = k \\n=> a-b = k or a-b = -k \\n=> a+k = k or a-k = b\\n\\nSo if we have a and k, b could either be a + k or a -k, so just look for them. If found in nums and not already added to seen, ans += 1\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        num_set = set()\\n        ans = 0\\n        for i in nums:\\n            if i+k in num_set:\\n                if (i, i+k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i+k))\\n                    seen.add((i+k, i))\\n            \\n            if i-k in num_set:\\n                if (i, i-k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i-k))\\n                    seen.add((i-k, i))\\n            num_set.add(i)\\n                    \\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        num_set = set()\\n        ans = 0\\n        for i in nums:\\n            if i+k in num_set:\\n                if (i, i+k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i+k))\\n                    seen.add((i+k, i))\\n            \\n            if i-k in num_set:\\n                if (i, i-k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i-k))\\n                    seen.add((i-k, i))\\n            num_set.add(i)\\n                    \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173939,
                "title": "java-2-pointer-4ms-beats-91-t-c-o-nlogn-s-c-o-1",
                "content": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tint len = nums.length, left = 0, right = 1, ans = 0;\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn ans;\\n\\n\\t\\twhile (left < len && right < len) {\\n\\n\\t\\t\\tif (nums[right] - nums[left] > k) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t} else if (nums[right] - nums[left] < k)\\n\\t\\t\\t\\tright++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t\\twhile (left < len && nums[left - 1] == nums[left])\\n\\t\\t\\t\\t\\tleft++;\\n\\n\\t\\t\\t\\tright = left+1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tint len = nums.length, left = 0, right = 1, ans = 0;\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn ans;\\n\\n\\t\\twhile (left < len && right < len) {\\n\\n\\t\\t\\tif (nums[right] - nums[left] > k) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t} else if (nums[right] - nums[left] < k)\\n\\t\\t\\t\\tright++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t\\twhile (left < len && nums[left - 1] == nums[left])\\n\\t\\t\\t\\t\\tleft++;\\n\\n\\t\\t\\t\\tright = left+1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1173901,
                "title": "java-hashset-6ms-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length, ans = 0;\\n\\n\\t\\tif (k == 0) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\t\\tIterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();\\n\\t\\t\\twhile (iterator.hasNext()) {\\n\\t\\t\\t\\tMap.Entry<Integer, Integer> pair = (Map.Entry<Integer, Integer>) iterator.next();\\n\\t\\t\\t\\tint val = pair.getValue();\\n\\t\\t\\t\\tif (val >= 2)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\tset.add(nums[0]);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\n\\t\\t\\tint key1 = k + nums[i], key2 = -k + nums[i];\\n\\t\\t\\tif (set.contains(key1) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tif (set.contains(key2) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length, ans = 0;\\n\\n\\t\\tif (k == 0) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\t\\tIterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();\\n\\t\\t\\twhile (iterator.hasNext()) {\\n\\t\\t\\t\\tMap.Entry<Integer, Integer> pair = (Map.Entry<Integer, Integer>) iterator.next();\\n\\t\\t\\t\\tint val = pair.getValue();\\n\\t\\t\\t\\tif (val >= 2)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\tset.add(nums[0]);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\n\\t\\t\\tint key1 = k + nums[i], key2 = -k + nums[i];\\n\\t\\t\\tif (set.contains(key1) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tif (set.contains(key2) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1162305,
                "title": "c-solution-using-set-and-hashmap-tc-o-nlogn-and-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        \\n        int s = nums.size();\\n        \\n        for(int i=0;i<s;i++)\\n            mp[nums[i]] = i;\\n        \\n      \\n        int res = 0;\\n        \\n        set<pair<int,int>> st;\\n        \\n        for(int i=0;i<s;i++) {\\n            int d = nums[i]-k;\\n            \\n            if(mp.find(d)!=mp.end()  && i!=mp[d])\\n                st.insert({nums[i],d});\\n                \\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        \\n        int s = nums.size();\\n        \\n        for(int i=0;i<s;i++)\\n            mp[nums[i]] = i;\\n        \\n      \\n        int res = 0;\\n        \\n        set<pair<int,int>> st;\\n        \\n        for(int i=0;i<s;i++) {\\n            int d = nums[i]-k;\\n            \\n            if(mp.find(d)!=mp.end()  && i!=mp[d])\\n                st.insert({nums[i],d});\\n                \\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150983,
                "title": "java-hashmap-clean-solution",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] arr, int k) {\\n      Map<Integer,Integer> mp=new HashMap<>();\\n      int pairs=0;\\n      for(int val:arr){\\n        mp.put(val,mp.getOrDefault(val,0)+1);\\n      }\\n      \\n      for(int key:mp.keySet()){\\n        int val=mp.get(key);\\n        \\n        if(k>0 && mp.containsKey(key+k)) pairs++;\\n       else if(k==0 && val>1)            pairs++; //if arr=[1,1] & k=0  than pair will be {1,1}\\n      }\\n      \\n      return pairs;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] arr, int k) {\\n      Map<Integer,Integer> mp=new HashMap<>();\\n      int pairs=0;\\n      for(int val:arr){\\n        mp.put(val,mp.getOrDefault(val,0)+1);\\n      }\\n      \\n      for(int key:mp.keySet()){\\n        int val=mp.get(key);\\n        \\n        if(k>0 && mp.containsKey(key+k)) pairs++;\\n       else if(k==0 && val>1)            pairs++; //if arr=[1,1] & k=0  than pair will be {1,1}\\n      }\\n      \\n      return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090396,
                "title": "3-different-approach-c-clean-code",
                "content": "Method 1: Binary Search\\n\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int p=0;\\n        int ans=0;\\n        while(p<n){\\n            int val=nums[p]+k;\\n            bool f=binary_search(nums.begin()+p+1,nums.end(),val);\\n            if(f)\\n                ans++;\\n            int x=nums[p];\\n            while(p<n&&x==nums[p])p++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nMethod 2 :Hashing\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:mp){\\n            int val=x.first+k;\\n            if(k==0){\\n                if(x.second>1)\\n                ans++;\\n                continue;\\n            }\\n            if(mp.count(val)){\\n                ans++;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\nMethod 3: Two Pointer\\nTime Complexity:  O(nlogn) //beacause of sorting\\nSpace complexity :  O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        if(n==1) return 0;\\n        sort(nums.begin(),nums.end());\\n        int p1=0,p2=1;\\n        int ans=0;\\n        for(int i=0;i<n&&p2<n;i++){\\n            \\n            p2=max(i+1,p2);\\n            while(p2<n&&(nums[p2]-nums[i])<k)p2++;\\n            if(p2<n&&nums[p2]-nums[i]==k)ans++;\\n            \\n            //skipping dublicates as we need unique pair\\n            while(i+1<n&&nums[i]==nums[i+1])i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int p=0;\\n        int ans=0;\\n        while(p<n){\\n            int val=nums[p]+k;\\n            bool f=binary_search(nums.begin()+p+1,nums.end(),val);\\n            if(f)\\n                ans++;\\n            int x=nums[p];\\n            while(p<n&&x==nums[p])p++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 878770,
                "title": "c-one-pass-solution-hashmap",
                "content": "One pass solution. TC 40 ms, beats 98.48% solution.\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (auto n : nums) {\\n            if (mp.find(n) == mp.end() ) {\\n                res += mp.count(n - k);\\n                res += mp.count(n + k);\\n            }\\n            else if (mp[n] == 1 && k == 0) res++; \\n            \\n            mp[n]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (auto n : nums) {\\n            if (mp.find(n) == mp.end() ) {\\n                res += mp.count(n - k);\\n                res += mp.count(n + k);\\n            }\\n            else if (mp[n] == 1 && k == 0) res++; \\n            \\n            mp[n]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877405,
                "title": "two-pointer-o-n-time-complexity-k-diff-pairs-in-an-array",
                "content": "**Explaination :**\\n\\n1. Use some kind of sorting mechanism. To sort the array. Also don\\'t include duplicates in this array.\\n2. Also store the frequency of each element in another Array.\\n3. Use two pointers (ptr1 and ptr2). And move these two according to the difference between the elements.\\n    while(untill ptr2 reaches the end of sorted array)\\n        - If difference == k  : increment ptr1 and ptr2 and sum++\\n        - if difference < k : increment ptr2\\n        - if difference >k : increment ptr1\\n        - Special case - if k==0 and difference == k and freq >1 :  increment ptr1 and ptr2 and sum++ \\n\\n**Approach :**\\n\\n**Contraints hint:**\\nFirstly, to get better understanding of how to proceed, I looked up to the contraints. And as the length of array will be always less than 10^4 . This means, we cannot use O(n^2) . We can use sorting because that would give O(nlogn) complexity, which is fair enough.\\n\\n**Examples hint:**\\nNow if we try some examples. we can think whether we need duplicate? How are duplicated causing any problem? And if we see, for the much part, it is of no use. We can ignore duplicates. Because questions asks to find **unique pairs** only. So if we have two 1s and single 3, like this : arr= [1,1,3] and k = 2;\\nthen (arr[0] , arr[2] ) and (arr[1] , arr[2]) are counted only once. And ans = 1.\\n\\nSimilarly , if arr= [1,1,3,3] and k =2;\\nStill ans = 1;\\n\\nSo, We dont need duplicates here. We can count them once. \\n\\n**Edge cases hint:**\\nOn, further trying out example, **if k= 0,**  then what are the challenges:\\nif k == 0 then the difference has to be 0. But , according to the question, in a k-diff pair : (arr[i] , arr[j]) , **i != j**\\nSo , it must be same integer but at different index in sorted array. Then we can consider it in our mighty Answer!\\nEx : arr= [1,1,2,3,4] and k = 0\\nans = 1 (arr[0] , arr[1])\\n\\nSo here we need to keep in mind the **role of duplicates, when k==0.**\\nAnd , knowing that a value freq is stricly more than 1, and k==0 , we can count it in the answer.\\n\\n*My mighty code:*\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> mp;    //creating map with frequency as its value\\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]+=1;\\n        }\\n        int sum = 0;\\n       map<int,int>::iterator itl;   //ptr1\\n        map<int,int>::iterator itr;   //ptr2\\n        itl= mp.begin(); itr= mp.begin() ;\\n\\t\\t\\n        while(itr!=mp.end()){\\n            int f = itl->first;\\n            int s = itr -> first;\\n            if(s-f <k && s>=f){\\n                itr++;   //increment ptr2 -> increase window width\\n            }else if(s-f > k && s>=f){\\n                itl++;   //increment ptr1 -> decrease window width\\n            }else if(s-f == k){\\n                if((k==0 && itl->second >1 )|| (k>0)){\\n                    sum++;\\n                }\\n                itr++; itl++;  //increment both ptr1 and ptr2 -> sliding the window\\n            }\\n          \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> mp;    //creating map with frequency as its value\\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]+=1;\\n        }\\n        int sum = 0;\\n       map<int,int>::iterator itl;   //ptr1\\n        map<int,int>::iterator itr;   //ptr2\\n        itl= mp.begin(); itr= mp.begin() ;\\n\\t\\t\\n        while(itr!=mp.end()){\\n            int f = itl->first;\\n            int s = itr -> first;\\n            if(s-f <k && s>=f){\\n                itr++;   //increment ptr2 -> increase window width\\n            }else if(s-f > k && s>=f){\\n                itl++;   //increment ptr1 -> decrease window width\\n            }else if(s-f == k){\\n                if((k==0 && itl->second >1 )|| (k>0)){\\n                    sum++;\\n                }\\n                itr++; itl++;  //increment both ptr1 and ptr2 -> sliding the window\\n            }\\n          \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877271,
                "title": "c-super-simple-clear-solution-99-5-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> myMap;\\n        size_t kDiffPairs = 0;\\n        \\n        for(auto num : nums)\\n        {   \\n            myMap[num]++;\\n        }\\n        \\n        if (k > 0) \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += myMap.find(k + iter.first) != myMap.end() ? 1 : 0;\\n            }\\n        }\\n        \\n        else \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += iter.second > 1 ? 1 : 0;\\n            }\\n        }\\n        \\n        return kDiffPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> myMap;\\n        size_t kDiffPairs = 0;\\n        \\n        for(auto num : nums)\\n        {   \\n            myMap[num]++;\\n        }\\n        \\n        if (k > 0) \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += myMap.find(k + iter.first) != myMap.end() ? 1 : 0;\\n            }\\n        }\\n        \\n        else \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += iter.second > 1 ? 1 : 0;\\n            }\\n        }\\n        \\n        return kDiffPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877008,
                "title": "python-3-two-pointers-zero-diff-special-case",
                "content": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and a non-negative\\n        target difference (k), this program counts the unique\\n        pairs within nums whose difference is k.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param k: target difference\\n        :type k: int\\n        :return: number of unique pairs in nums with difference k\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Special Case: k = 0\\n        - Use the Python collections Counter to get the frequency\\n          of each value in nums.\\n        - Determine the number of zero differences by counting\\n          the number of values in nums with frequency > 1.\\n        \"\"\"\\n        if k == 0:\\n            freqs = Counter(nums)\\n            return sum(freqs[k] > 1 for k in freqs)\\n\\n        \"\"\"\\n        General Case: k > 0\\n        - Pre-process nums to produce a sorted list of values\\n          without duplicates.\\n        - Use two pointers (slow and fast) in a sliding window\\n          protocol to find all pairs whose difference is k.\\n          - If difference is smaller than k, advance fast pointer.\\n          - If difference is larger than k, advance slow pointer.\\n          - If difference equals k, advance both pointers and\\n            increment a counter that is later returned from this\\n            program.\\n        \"\"\"\\n        sorted_set_list = sorted(list(set(nums)))\\n        length = len(sorted_set_list)\\n        slow = 0\\n        fast = 0\\n        answer = 0\\n        while fast < length:\\n            difference = sorted_set_list[fast] - sorted_set_list[slow]\\n            if difference < k:\\n                fast += 1\\n            elif difference > k:\\n                slow += 1\\n            else:\\n                answer += 1\\n                slow += 1\\n                fast += 1\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and a non-negative\\n        target difference (k), this program counts the unique\\n        pairs within nums whose difference is k.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param k: target difference\\n        :type k: int\\n        :return: number of unique pairs in nums with difference k\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Special Case: k = 0\\n        - Use the Python collections Counter to get the frequency\\n          of each value in nums.\\n        - Determine the number of zero differences by counting\\n          the number of values in nums with frequency > 1.\\n        \"\"\"\\n        if k == 0:\\n            freqs = Counter(nums)\\n            return sum(freqs[k] > 1 for k in freqs)\\n\\n        \"\"\"\\n        General Case: k > 0\\n        - Pre-process nums to produce a sorted list of values\\n          without duplicates.\\n        - Use two pointers (slow and fast) in a sliding window\\n          protocol to find all pairs whose difference is k.\\n          - If difference is smaller than k, advance fast pointer.\\n          - If difference is larger than k, advance slow pointer.\\n          - If difference equals k, advance both pointers and\\n            increment a counter that is later returned from this\\n            program.\\n        \"\"\"\\n        sorted_set_list = sorted(list(set(nums)))\\n        length = len(sorted_set_list)\\n        slow = 0\\n        fast = 0\\n        answer = 0\\n        while fast < length:\\n            difference = sorted_set_list[fast] - sorted_set_list[slow]\\n            if difference < k:\\n                fast += 1\\n            elif difference > k:\\n                slow += 1\\n            else:\\n                answer += 1\\n                slow += 1\\n                fast += 1\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876465,
                "title": "c-first-sort-then-two-pointers-concise-o-nlogn-runtime-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        auto i = 0, j = 1, pairs = 0;\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] == k) {\\n                pairs++;\\n                i++;\\n                j++;\\n            }\\n            else if (nums[j] - nums[i] < k) j++;\\n            else i++;\\n            while (i > 0 && i < nums.size() && nums[i - 1] == nums[i]) i++;\\n            j = max(j, i + 1);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        auto i = 0, j = 1, pairs = 0;\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] == k) {\\n                pairs++;\\n                i++;\\n                j++;\\n            }\\n            else if (nums[j] - nums[i] < k) j++;\\n            else i++;\\n            while (i > 0 && i < nums.size() && nums[i - 1] == nums[i]) i++;\\n            j = max(j, i + 1);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876413,
                "title": "c-o-n-map-solution-with-detailed-explanation-97-time-98-space",
                "content": "**HashMap Solution in C++:**\\n1. We keep a Hash Map to track the elements that we have encountered till now. We mark them as true in the HashMap.\\n1. Just iterate over the array and check for the element (num[i]+k) and (num[i]-k) in the hash. If they are present, add it in the answer set.\\n1. The size of the set would be the answer. Those are the unique number of pairs with \\'k\\' difference.\\n1. We need not sort the vector, and it happens in just one pass, so O(n) solution :)\\n\\n\\n```\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    set<pair<int, int>> s; \\n    unordered_map <int, bool> m;\\n    int n = nums.size();\\n    \\n    for(int i=0;i<n;++i){\\n      if (m.find(nums[i]+k)!=m.end()){\\n        s.insert(make_pair(nums[i], nums[i]+k));\\n      }\\n      if (m.find(nums[i]-k)!=m.end()){\\n        s.insert(make_pair(nums[i]-k, nums[i]));\\n      }\\n      m[nums[i]] = true;\\n    }\\n    \\n    return s.size();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    set<pair<int, int>> s; \\n    unordered_map <int, bool> m;\\n    int n = nums.size();\\n    \\n    for(int i=0;i<n;++i){\\n      if (m.find(nums[i]+k)!=m.end()){\\n        s.insert(make_pair(nums[i], nums[i]+k));\\n      }\\n      if (m.find(nums[i]-k)!=m.end()){\\n        s.insert(make_pair(nums[i]-k, nums[i]));\\n      }\\n      m[nums[i]] = true;\\n    }\\n    \\n    return s.size();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876312,
                "title": "k-diff-pairs-in-an-array-solution-java",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int num: nums)\\n        {\\n            m.put(num, m.getOrDefault(num, 0) + 1);\\n        }\\n        int count = k == 0 ? 1 : 0;\\n        m.forEach((key, value)->{\\n            if (m.getOrDefault(key + k, 0) > count) res++;    \\n        });\\n        return res;\\n    }\\n    private int res = 0;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int num: nums)\\n        {\\n            m.put(num, m.getOrDefault(num, 0) + 1);\\n        }\\n        int count = k == 0 ? 1 : 0;\\n        m.forEach((key, value)->{\\n            if (m.getOrDefault(key + k, 0) > count) res++;    \\n        });\\n        return res;\\n    }\\n    private int res = 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876261,
                "title": "c-binary-search-99",
                "content": "The problem states that\\n```\\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\\n- 0 <= i, j < nums.length\\n- i != j\\n- a <= b\\n- b - a == k\\n```\\nSo either `(nums[i],nums[j])` or `(nums[j],nums[i])` is a sufficient k-diff pair. That means, the order of elements doesn\\'t matter -> sort the array and use binary search.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int prev = INT_MIN, ret = 0, n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto &v = nums[i];\\n            if (v != prev) {\\n                if (binary_search(nums.begin()+i+1,nums.end(),v+k)) {\\n                    ret++;\\n                }\\n                prev = v;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\\n- 0 <= i, j < nums.length\\n- i != j\\n- a <= b\\n- b - a == k\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int prev = INT_MIN, ret = 0, n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto &v = nums[i];\\n            if (v != prev) {\\n                if (binary_search(nums.begin()+i+1,nums.end(),v+k)) {\\n                    ret++;\\n                }\\n                prev = v;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772006,
                "title": "o-n-solution-using-unordered-set",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& a, int k) {\\n        \\n        \\n        if(k==0){\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<a.size();i++)\\n            {\\n                mp[a[i]]++;\\n            }\\n            \\n            int cnt=0;\\n            for(auto u : mp)\\n            {\\n                if(u.second> 1) cnt++;\\n            }\\n            \\n            return cnt;\\n        }\\n        \\n        else if(k<0) return 0;\\n        \\n        else\\n        {\\n        unordered_set<int> s;\\n        unordered_set<int> after;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        int cnt=0;\\n        for(auto u : s)\\n        {\\n             if(s.count(u+k))\\n             {\\n                 if(!after.count(u))\\n                 {\\n                     cnt++;\\n                     after.insert(u);\\n                     \\n                 }\\n             }\\n            \\n           \\n        }\\n        \\n        \\n        return cnt;\\n        }\\n        \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& a, int k) {\\n        \\n        \\n        if(k==0){\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<a.size();i++)\\n            {\\n                mp[a[i]]++;\\n            }\\n            \\n            int cnt=0;\\n            for(auto u : mp)\\n            {\\n                if(u.second> 1) cnt++;\\n            }\\n            \\n            return cnt;\\n        }\\n        \\n        else if(k<0) return 0;\\n        \\n        else\\n        {\\n        unordered_set<int> s;\\n        unordered_set<int> after;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        int cnt=0;\\n        for(auto u : s)\\n        {\\n             if(s.count(u+k))\\n             {\\n                 if(!after.count(u))\\n                 {\\n                     cnt++;\\n                     after.insert(u);\\n                     \\n                 }\\n             }\\n            \\n           \\n        }\\n        \\n        \\n        return cnt;\\n        }\\n        \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749407,
                "title": "rust-solutions",
                "content": "\\n### 1. Set\\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        if k < 0 {\\n            return 0;\\n        }\\n\\n        let mut nums_set = HashSet::new();\\n        let mut pairs_j = HashSet::new();\\n\\n        for n in nums {\\n            if nums_set.contains(&(n - k)) {\\n                pairs_j.insert(n);\\n            }\\n            if nums_set.contains(&(n + k)) {\\n                pairs_j.insert(n + k);\\n            }\\n\\n            nums_set.insert(n);\\n        }\\n\\n        pairs_j.len() as i32\\n    }\\n}\\n```\\n\\n### 2. Binary Search\\n```Rust\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        let mut ret = 0;\\n\\n        for i in 0..nums.len() {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            if nums[i + 1..].binary_search(&(nums[i] + k)).is_ok() {\\n                ret += 1;\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        if k < 0 {\\n            return 0;\\n        }\\n\\n        let mut nums_set = HashSet::new();\\n        let mut pairs_j = HashSet::new();\\n\\n        for n in nums {\\n            if nums_set.contains(&(n - k)) {\\n                pairs_j.insert(n);\\n            }\\n            if nums_set.contains(&(n + k)) {\\n                pairs_j.insert(n + k);\\n            }\\n\\n            nums_set.insert(n);\\n        }\\n\\n        pairs_j.len() as i32\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        let mut ret = 0;\\n\\n        for i in 0..nums.len() {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            if nums[i + 1..].binary_search(&(nums[i] + k)).is_ok() {\\n                ret += 1;\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745330,
                "title": "two-easy-solutions-in-c-using-hashing-and-two-pointer-approach",
                "content": "# **First:-**\\n**using set,pair and map**\\n```\\n        int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],k-nums[i]));\\n                \\n            }\\n            m[nums[i]]=1;\\n        }\\n        \\n        return unq.size();\\n     } \\n```  \\n        \\n# \\t**Second:-(more prefered)**\\n\\t\\n```\\nint findPairs(vector<int>& nums, int k) {\\n sort(nums.begin(),nums.end());\\n int fast=1;\\n int slow=0;\\n int ans=0;\\n while(slow<nums.size() && fast<nums.size()){\\n\\tif(nums[fast]-nums[slow]==k){\\n\\t\\tans++;\\n\\t\\tfast++;\\n\\t\\tslow++;\\n\\t\\t// For Duplicacy\\n\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\tfast++;\\n\\t\\t}\\n\\t}\\n\\telse if(nums[fast]-nums[slow]>k){\\n\\t\\tslow++;  \\n\\t\\tif(fast-slow==0){\\n\\t\\t\\tfast++;}\\n\\t}\\n\\telse{      \\n\\t\\tfast++;\\n\\t}         \\n}\\nreturn ans;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],k-nums[i]));\\n                \\n            }\\n            m[nums[i]]=1;\\n        }\\n        \\n        return unq.size();\\n     } \\n```\n```\\nint findPairs(vector<int>& nums, int k) {\\n sort(nums.begin(),nums.end());\\n int fast=1;\\n int slow=0;\\n int ans=0;\\n while(slow<nums.size() && fast<nums.size()){\\n\\tif(nums[fast]-nums[slow]==k){\\n\\t\\tans++;\\n\\t\\tfast++;\\n\\t\\tslow++;\\n\\t\\t// For Duplicacy\\n\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\tfast++;\\n\\t\\t}\\n\\t}\\n\\telse if(nums[fast]-nums[slow]>k){\\n\\t\\tslow++;  \\n\\t\\tif(fast-slow==0){\\n\\t\\t\\tfast++;}\\n\\t}\\n\\telse{      \\n\\t\\tfast++;\\n\\t}         \\n}\\nreturn ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739345,
                "title": "c-using-binary-search-and-set-bst-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) { \\n        int n = nums.size();  \\n        set<pair<int,int>> s;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i = 0; i < n; i++){  \\n            int find = nums[i] - k; \\n            int ldx = i+1,rdx = n-1;  \\n                while(ldx <= rdx){\\n                    int mid = ldx + (rdx-ldx)/2; \\n                    if(nums[mid] == find)  \\n                         {s.insert({nums[i],nums[mid]}); break;} \\n                    else if(nums[mid] > find) ldx = mid+1; \\n                    else rdx = mid-1;\\n                } \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) { \\n        int n = nums.size();  \\n        set<pair<int,int>> s;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i = 0; i < n; i++){  \\n            int find = nums[i] - k; \\n            int ldx = i+1,rdx = n-1;  \\n                while(ldx <= rdx){\\n                    int mid = ldx + (rdx-ldx)/2; \\n                    if(nums[mid] == find)  \\n                         {s.insert({nums[i],nums[mid]}); break;} \\n                    else if(nums[mid] > find) ldx = mid+1; \\n                    else rdx = mid-1;\\n                } \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726372,
                "title": "c-binary-search-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()<2) return 0;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i>0 && nums[i]==nums[i-1]) continue;\\n\\t\\t\\t\\tint target=nums[i]+k;\\n\\t\\t\\t\\tauto it=lower_bound(nums.begin()+i+1,nums.end(),target);\\n\\t\\t\\t\\tif(it!=nums.end() && *it==target)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()<2) return 0;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i>0 && nums[i]==nums[i-1]) continue;\\n\\t\\t\\t\\tint target=nums[i]+k;\\n\\t\\t\\t\\tauto it=lower_bound(nums.begin()+i+1,nums.end(),target);\\n\\t\\t\\t\\tif(it!=nums.end() && *it==target)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 701213,
                "title": "c-simple-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0) return 0;\\n        unordered_map<int,int> x;\\n        for(int i : nums) x[i]++;\\n        int ans = 0;\\n        if(k==0) {for(auto itr : x) if(itr.second >1) ans++;}\\n        else {for(auto itr : x) if(x.count(itr.first +k)) ans++;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0) return 0;\\n        unordered_map<int,int> x;\\n        for(int i : nums) x[i]++;\\n        int ans = 0;\\n        if(k==0) {for(auto itr : x) if(itr.second >1) ans++;}\\n        else {for(auto itr : x) if(x.count(itr.first +k)) ans++;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585471,
                "title": "python-76-83-hash-set",
                "content": "```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n        # special case\\n        if k == 0:\\n            d = {}\\n            for e in nums:\\n                if e not in d:\\n                    d[e] = 1\\n                else:\\n                    d[e] += 1\\n            return len([v for v in d.values() if v >= 2])\\n            \\n        elif k < 0:\\n            return 0\\n        \\n        d = {}\\n        s = set()\\n        \\n        for e in nums:\\n            if e not in d:\\n                d[e] = 1\\n        \\n        for key in d.keys():\\n            up, down = key+k, key-k\\n            if up in d:\\n                s.add((up, key)) \\n            if down in d:\\n                s.add((key, down))\\n        # print(s)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n        # special case\\n        if k == 0:\\n            d = {}\\n            for e in nums:\\n                if e not in d:\\n                    d[e] = 1\\n                else:\\n                    d[e] += 1\\n            return len([v for v in d.values() if v >= 2])\\n            \\n        elif k < 0:\\n            return 0\\n        \\n        d = {}\\n        s = set()\\n        \\n        for e in nums:\\n            if e not in d:\\n                d[e] = 1\\n        \\n        for key in d.keys():\\n            up, down = key+k, key-k\\n            if up in d:\\n                s.add((up, key)) \\n            if down in d:\\n                s.add((key, down))\\n        # print(s)\\n        return len(s)\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1564992,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565811,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565385,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1568614,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1570793,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1567396,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1576362,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1572292,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1745310,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1571764,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1564992,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565811,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565385,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1568614,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1570793,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1567396,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1576362,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1572292,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1745310,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1571764,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            }
        ]
    }
]