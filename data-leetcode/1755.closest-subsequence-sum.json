[
    {
        "title": "Number of Recent Calls",
        "question_content": "You have a RecentCounter class which counts the number of recent requests within a certain time frame.\nImplement the RecentCounter class:\n\n\tRecentCounter() Initializes the counter with zero recent requests.\n\tint ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].\n\nIt is guaranteed that every call to ping uses a strictly larger value of t than the previous call.\n&nbsp;\nExample 1:\n\nInput\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\nOutput\n[null, 1, 2, 3, 3]\nExplanation\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3\n\n&nbsp;\nConstraints:\n\n\t1 <= t <= 109\n\tEach test case will call ping with strictly increasing values of t.\n\tAt most 104 calls will be made to ping.",
        "solutions": [
            {
                "id": 189239,
                "title": "java-python-3-five-solutions-treemap-treeset-arraylist-queue-circular-list",
                "content": "**Update 2**: Added 2 implementations of Python 3.\\n**Update 1**: Method 4 added for those who are interested in space optimization.\\n\\n**Mehod 1:** `TreeMap`.\\n\\nUse current time and total number of calls as the key and value of `TreeMap`, respectively.\\n\\n**Analysis**\\nTime: O(logN), space: O(N), where N is the number of ping calls from first one till now.\\n\\n```TreeMap.tailMap()``` and `put()` both cost time O(logN).\\n```\\n    TreeMap<Integer, Integer> tm;\\n\\n    public RecentCounter() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public int ping(int t) {\\n        tm.put(t, 1 + tm.size());\\n        return tm.tailMap(t - 3000).size();\\n    }\\n```\\n**Mehod 2:** `TreeSet`.\\n\\nOr similarly use ```TreeSet``` instead.\\n\\n```TreeSet.tailSet()``` and `add()` both cost time O(logN).\\n\\n```\\n    TreeSet<Integer> ts;\\n\\n    public RecentCounter() {\\n        ts = new TreeSet<>();\\n    }\\n    \\n    public int ping(int t) {\\n        ts.add(t);\\n        return ts.tailSet(t - 3000).size();\\n    }\\n```\\nSince some complain that the above two methods cause `TLE`, I guess that besides `tailMap` and `tailSet, TreeMap.put()` and `TreeSet.add()` also cost `O(logN)`, therefore the total time cost is high.\\n\\nThe following method will use less time.\\n\\n**Mehod 3:** \\n**Java: Binary Search `ArrayList`**.\\n\\nUse binary search to find the index of the ceiling of `t - 3000`, then `list.size() - index` is the answer.\\n\\n`binarySearch()` cost `O(logN)`.\\n```\\n\\n    List<Integer> list;\\n\\n    public RecentCounter() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int index = Collections.binarySearch(list, t - 3000); // search the index of t - 3000.\\n        if (index < 0) { index = ~index; } // if t - 3000 is not in list, use the index of the ceiling of t - 3000.\\n        return list.size() - index;\\n    }\\n```\\n**Python 3: bisect**\\n```\\n    def __init__(self):\\n        self.ls = []\\n\\n    def ping(self, t: int) -> int:\\n        self.ls.append(t)\\n        return len(self.ls) - bisect.bisect_left(self.ls, t - 3000)\\n```\\n**Mehod 4:** `Queue`.\\n\\nTime & space: `O(Math.min(N, 3000))`.\\n**Java**\\n```\\n    Queue<Integer> q;\\n\\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.offer(t);\\n        while (q.peek() < t - 3000) { q.poll(); }\\n        return q.size();\\n    }\\n```\\n**Python 3: deque**\\n```\\n    def __init__(self):\\n        self.dq = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.dq.append(t)\\n        while self.dq[0] < t - 3000:\\n            self.dq.popleft()\\n        return len(self.dq)\\n```\\n**Method 5: Fixed size array to implement Circular List**\\nBy **@wushangzhen**\\n\\n```\\n    int[] time;\\n    public RecentCounter() {\\n        time = new int[3001];\\n    }\\n    \\n    public int ping(int t) {\\n        int res = 0;\\n        time[t % 3001] = t;\\n        for (int i = 0; i < 3001; i++) {\\n            if (time[i] != 0 && time[i] >= t - 3000) {\\n                res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Note:** the following Python 3 implementation of the method get **TLE**:\\nLet me know if you have any idea to make it faster.\\n```\\n    def __init__(self):\\n        self.time = [0] * 3001\\n\\n    def ping(self, t: int) -> int:\\n        self.time[t % 3001] = t\\n        return sum([self.time[i] and self.time[i] >= t - 3000 for i in range(3001)])\\n```",
                "solutionTags": [],
                "code": "```TreeMap.tailMap()```\n```\\n    TreeMap<Integer, Integer> tm;\\n\\n    public RecentCounter() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public int ping(int t) {\\n        tm.put(t, 1 + tm.size());\\n        return tm.tailMap(t - 3000).size();\\n    }\\n```\n```TreeSet```\n```TreeSet.tailSet()```\n```\\n    TreeSet<Integer> ts;\\n\\n    public RecentCounter() {\\n        ts = new TreeSet<>();\\n    }\\n    \\n    public int ping(int t) {\\n        ts.add(t);\\n        return ts.tailSet(t - 3000).size();\\n    }\\n```\n```\\n\\n    List<Integer> list;\\n\\n    public RecentCounter() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int index = Collections.binarySearch(list, t - 3000); // search the index of t - 3000.\\n        if (index < 0) { index = ~index; } // if t - 3000 is not in list, use the index of the ceiling of t - 3000.\\n        return list.size() - index;\\n    }\\n```\n```\\n    def __init__(self):\\n        self.ls = []\\n\\n    def ping(self, t: int) -> int:\\n        self.ls.append(t)\\n        return len(self.ls) - bisect.bisect_left(self.ls, t - 3000)\\n```\n```\\n    Queue<Integer> q;\\n\\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.offer(t);\\n        while (q.peek() < t - 3000) { q.poll(); }\\n        return q.size();\\n    }\\n```\n```\\n    def __init__(self):\\n        self.dq = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.dq.append(t)\\n        while self.dq[0] < t - 3000:\\n            self.dq.popleft()\\n        return len(self.dq)\\n```\n```\\n    int[] time;\\n    public RecentCounter() {\\n        time = new int[3001];\\n    }\\n    \\n    public int ping(int t) {\\n        int res = 0;\\n        time[t % 3001] = t;\\n        for (int i = 0; i < 3001; i++) {\\n            if (time[i] != 0 && time[i] >= t - 3000) {\\n                res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def __init__(self):\\n        self.time = [0] * 3001\\n\\n    def ping(self, t: int) -> int:\\n        self.time[t % 3001] = t\\n        return sum([self.time[i] and self.time[i] >= t - 3000 for i in range(3001)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189334,
                "title": "c-easy-and-clean-solution-using-queue",
                "content": "if the queue is not empty , pop the elements which are lesser than t-3000  \\nPush the current element into the queue\\nReturn queue size\\n \\n    queue<int> q;\\n    \\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        \\n\\t\\tq.push(t);\\n\\t\\t   \\n        while(q.front() < t-3000)\\n            q.pop();\\n        \\n        return q.size();\\n    }\\n",
                "solutionTags": [],
                "code": "if the queue is not empty , pop the elements which are lesser than t-3000  \\nPush the current element into the queue\\nReturn queue size\\n \\n    queue<int> q;\\n    \\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        \\n\\t\\tq.push(t);\\n\\t\\t   \\n        while(q.front() < t-3000)\\n            q.pop();\\n        \\n        return q.size();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 189425,
                "title": "python-straightforward-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p = collections.deque()        \\n\\n    def ping(self, t):\\n        self.p.append(t)\\n        while self.p[0] < t - 3000:\\n            self.p.popleft()\\n        return len(self.p)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p = collections.deque()        \\n\\n    def ping(self, t):\\n        self.p.append(t)\\n        while self.p[0] < t - 3000:\\n            self.p.popleft()\\n        return len(self.p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873333,
                "title": "python-easy-solution-using-queue-explained",
                "content": "What we need to keep in this problem is sliding window of recent calls. So, we need to remove old calls, if they are too old and append new ones. Ideal data structure is queue, and in python we usualy use `deque`. So, there are 3 simple steps to succes:\\n\\n1. Add new call time to the end of our queue.\\n2. Remove old times: we pop from the beginning of our queue until time is not older than `last - 3000`.\\n3. Return length of our queue: it will be exaclty what we need.\\n\\n**Complexity**: even though for each call of `ping` function we can potentially call a lot of `popleft()`, if we run `ping` `n` times we will have `O(n)` complexity: each element go to queue and from queue only once, so we can say amortised time complexity is `O(1)`. Space complexity can be potentially `O(3000)`. \\n\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.calls = deque()\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < self.calls[-1] - 3000:\\n            self.calls.popleft()\\n        return len(self.calls)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.calls = deque()\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < self.calls[-1] - 3000:\\n            self.calls.popleft()\\n        return len(self.calls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322357,
                "title": "javascript-detailed-explanation-beats-99-76-o-n-time-o-n-space",
                "content": "Similar to the rate limiter question. Represent the calls at time T as a streaming array of integers using a queue.\\n1. For each call, add t to the end of the queue.\\n2. Maintain the queue so that the front is always within the time frame of t - 3000 (we trim the values that dont appear in this interval)\\n```\\nPing(1)\\nstream = [ 1 ] \\nPing(100)\\nstream = [ 1, 100 ] \\nping(3001)\\nstream = [ 1, 100, 3001 ]\\nping(3002)\\nstream = [ 100, 3001, 3002 ] \\nReturn the stream\\'s count after each call\\n```\\n```\\nvar RecentCounter = function() {\\n    this.stream = []\\n};\\nRecentCounter.prototype.ping = function(t) {\\n    this.stream.push(t) // Everytime we recieve a ping, add the time to the stream of integers\\n  /*\\n  To exclude the times that are not included within the range of t - 3000,\\n  we remove the first element from the stream while it is less than the calculated range \\n  */\\n    while(this.stream[0] < t - 3000){ \\n      this.stream.shift()\\n  } \\n    // When the loop ends the length of calls will be the length of the array\\n    return this.stream.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nPing(1)\\nstream = [ 1 ] \\nPing(100)\\nstream = [ 1, 100 ] \\nping(3001)\\nstream = [ 1, 100, 3001 ]\\nping(3002)\\nstream = [ 100, 3001, 3002 ] \\nReturn the stream\\'s count after each call\\n```\n```\\nvar RecentCounter = function() {\\n    this.stream = []\\n};\\nRecentCounter.prototype.ping = function(t) {\\n    this.stream.push(t) // Everytime we recieve a ping, add the time to the stream of integers\\n  /*\\n  To exclude the times that are not included within the range of t - 3000,\\n  we remove the first element from the stream while it is less than the calculated range \\n  */\\n    while(this.stream[0] < t - 3000){ \\n      this.stream.shift()\\n  } \\n    // When the loop ends the length of calls will be the length of the array\\n    return this.stream.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594800,
                "title": "question-and-solution-both-clearly-explained",
                "content": "ok!\\nlets do this!\\nso this is one of the worst explained questions and solutions of leetcode!\\nlet me try and make it easy for you guys!!\\n\\nso what the basic idea of the question is that several ping times will be given and we have to return the number of \" valid \" pings!\\n\\ni describe \"valid\"  as follows:\\nsuppose i ping at t=3000 \\nlet t1=3000\\nthen i again ping at t=3001\\nlet t2=3001;\\n\\n**the constraint for a ping to be a \"valid\" ping is that \"t2-t1<=3000\"\\n\"i.e the difference of two ping times should not exceed 3000\"**\\n\\nso lets try the example in the question:\\nping times are[1,100,3001,30002]\\n\\nso lets say t1=0;(because t2==1 is the first ping,no pings are made befre t==1)\\nt2=1\\nsp t2-t1<=3000(validity condition met)\\nso for t==1 we output 1;\\n\\nthen t2=100\\nt1=1\\nsame thing\\nwe return the total number of valid pings ==2;\\n\\nfor t2=3001\\nwe have :\\nt1=100;\\nt2-t1<=3000(valid)\\nalso\\nt1=1\\nt2-t1<=3000(valid)\\nso both the pings before t=3001 are valid hence output =3;\\nNOW:\\nt2=3002;\\nwe have t1=3001;\\nt2-t1<=3000\\nso valid\\nt1=100\\nt2-t1<=3000\\nso valid\\nbut t1=1;\\nt2-t1=3001\\nwhich is not less than or equal to 3000!\\nso we dont count t==1;\\ntherefore valid pings for t=3002 are t1=100,3001,3002!\\n\\nhope i was able to explain!\\n\\ncode for reference:\\n```\\n\\nhope it helps\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q = new LinkedList();\\n    }\\n\\n    public int ping(int t) {\\n        q.add(t);\\n        while (q.peek() < t - 3000)\\n            q.poll();\\n        return q.size();\\n    }\\n}\\n```\\n\\nhope it helps!\\nthank you!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nhope it helps\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q = new LinkedList();\\n    }\\n\\n    public int ping(int t) {\\n        q.add(t);\\n        while (q.peek() < t - 3000)\\n            q.poll();\\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430731,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass RecentCounter {\\n\\tpublic:\\n\\t\\tRecentCounter() {\\n\\n\\t\\t}\\n\\n\\t\\tqueue<int> q;\\n\\n\\t\\tint ping(int t) {\\n\\n\\t\\t\\tq.push(t);\\n\\n\\t\\t\\twhile(q.front() < t - 3000){\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn q.size();\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "\\tclass RecentCounter {\\n\\tpublic:\\n\\t\\tRecentCounter() {\\n\\n\\t\\t}\\n\\n\\t\\tqueue<int> q;\\n\\n\\t\\tint ping(int t) {\\n\\n\\t\\t\\tq.push(t);\\n\\n\\t\\t\\twhile(q.front() < t - 3000){\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn q.size();\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Java"
            },
            {
                "id": 873418,
                "title": "python-and-c-multiple-approaches-binary-search-dequeue",
                "content": "Python \\n```\\n# USING DEQUE\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        queue = self.queue\\n        start = t - 3000\\n        queue.append(t)\\n        while(queue and queue[0] < start):\\n            queue.popleft()\\n        return len(queue)\\n```\\n\\nC++\\n```\\n//USING DEQUE\\nclass RecentCounter {\\npublic:\\n    deque<int> dq;\\n    RecentCounter() {\\n        return ;\\n    }\\n    \\n    int ping(int t) {\\n        dq.push_back(t);\\n        while(!dq.empty() && dq.front()<t-3000)\\n            dq.pop_front();\\n        return dq.size();\\n    }\\n};\\n```\\n\\n\\nBINARY SEARCH APPROACH IN PYTHON\\n```\\n# USING BINARY SEARCH\\nclass RecentCounter:\\n    def __init__(self):\\n        self.arr = []\\n\\n    def ping(self, t: int) -> int:\\n        self.arr.append(t)\\n        start = t - 3000\\n        if(t<=0):\\n            return len(self.arr)\\n      # find t which is >= start in arr\\n        def binSearch(start,arr):\\n            i = 0\\n            j = len(arr)\\n            while(i<=j):\\n                mid = (i+j)//2\\n                if(arr[mid] > start):\\n                    j = mid - 1\\n                elif(arr[mid] < start):\\n                    i = mid + 1\\n                else:\\n                    return mid\\n            return i\\n        \\n        indx = binSearch(start,self.arr)\\n        return len(self.arr) - indx\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n# USING DEQUE\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        queue = self.queue\\n        start = t - 3000\\n        queue.append(t)\\n        while(queue and queue[0] < start):\\n            queue.popleft()\\n        return len(queue)\\n```\n```\\n//USING DEQUE\\nclass RecentCounter {\\npublic:\\n    deque<int> dq;\\n    RecentCounter() {\\n        return ;\\n    }\\n    \\n    int ping(int t) {\\n        dq.push_back(t);\\n        while(!dq.empty() && dq.front()<t-3000)\\n            dq.pop_front();\\n        return dq.size();\\n    }\\n};\\n```\n```\\n# USING BINARY SEARCH\\nclass RecentCounter:\\n    def __init__(self):\\n        self.arr = []\\n\\n    def ping(self, t: int) -> int:\\n        self.arr.append(t)\\n        start = t - 3000\\n        if(t<=0):\\n            return len(self.arr)\\n      # find t which is >= start in arr\\n        def binSearch(start,arr):\\n            i = 0\\n            j = len(arr)\\n            while(i<=j):\\n                mid = (i+j)//2\\n                if(arr[mid] > start):\\n                    j = mid - 1\\n                elif(arr[mid] < start):\\n                    i = mid + 1\\n                else:\\n                    return mid\\n            return i\\n        \\n        indx = binSearch(start,self.arr)\\n        return len(self.arr) - indx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189277,
                "title": "java-super-short-deque-solution",
                "content": "```\\n    Deque<Integer> dq;\\n\\n    public RecentCounter() {\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!dq.isEmpty() && t - dq.getFirst() > 3000) dq.removeFirst();\\n        dq.addLast(t);\\n        return dq.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Deque<Integer> dq;\\n\\n    public RecentCounter() {\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!dq.isEmpty() && t - dq.getFirst() > 3000) dq.removeFirst();\\n        dq.addLast(t);\\n        return dq.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582485,
                "title": "c-code-most-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() { }\\n    \\n    int ping(int t) {\\n        int st=t-3000,c=0;\\n        q.push(t);\\n\\n        while(!q.empty() ){\\n            if(q.front() <st )\\n            q.pop();\\n            else\\n            break;\\n        }\\n\\n        return q.size();\\n\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Queue",
                    "Data Stream"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() { }\\n    \\n    int ping(int t) {\\n        int st=t-3000,c=0;\\n        q.push(t);\\n\\n        while(!q.empty() ){\\n            if(q.front() <st )\\n            q.pop();\\n            else\\n            break;\\n        }\\n\\n        return q.size();\\n\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984449,
                "title": "java-queue",
                "content": "\\n\\n# Code\\n```\\nclass RecentCounter {\\n      Queue<Integer> q;\\n    public RecentCounter() {\\n        q= new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek()<t-3000){\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n      Queue<Integer> q;\\n    public RecentCounter() {\\n        q= new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek()<t-3000){\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873209,
                "title": "python-super-simple-and-short-solution-o-1-time-o-1-space",
                "content": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.recent = []\\n\\n    def ping(self, t: int) -> int:\\n        self.recent.append(t)\\n        while self.recent[0] < t-3000:\\n            self.recent.pop(0)\\n        return len(self.recent)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.recent = []\\n\\n    def ping(self, t: int) -> int:\\n        self.recent.append(t)\\n        while self.recent[0] < t-3000:\\n            self.recent.pop(0)\\n        return len(self.recent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826041,
                "title": "python-3-88-08-faster-used-list-as-queue",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe can use list as a queue or use collections.deque.\\ncollections.deque has a function popleft() to remove first element. Since it\\'s not available in list, we can pass index 0 to pop()\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.pop(0)\\n        self.queue.append(t)\\n        return len(self.queue)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.pop(0)\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506905,
                "title": "c-simple-solution-using-queue",
                "content": "```\\npublic class RecentCounter {\\n    private Queue<int> _queue;\\n    private const int Interval = 3000;\\n\\n    public RecentCounter() {\\n        _queue = new Queue<int>();\\n    }\\n    \\n    public int Ping(int t) {\\n        _queue.Enqueue(t);\\n        while (t - _queue.Peek() > Interval)\\n            _queue.Dequeue();\\n        return _queue.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Queue"
                ],
                "code": "```\\npublic class RecentCounter {\\n    private Queue<int> _queue;\\n    private const int Interval = 3000;\\n\\n    public RecentCounter() {\\n        _queue = new Queue<int>();\\n    }\\n    \\n    public int Ping(int t) {\\n        _queue.Enqueue(t);\\n        while (t - _queue.Peek() > Interval)\\n            _queue.Dequeue();\\n        return _queue.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269419,
                "title": "python",
                "content": "class RecentCounter(object):\\n\\n    def __init__(self):\\n        \\n        # \\u7528\\u961F\\u5217\\u601D\\u60F3\\uFF0C\\u5DE6\\u8FB9\\u51FA\\uFF0C\\u53F3\\u8FB9\\u8FDB\\n        self.queue = collections.deque()\\n        \\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        # given a time t, time t-3000 \\u4E3A 3000 \\u6BEB\\u79D2\\u4E4B\\u524D\\u7684\\u65F6\\u95F4\\u70B9\\uFF0C\\u4EFB\\u4F55\\u5C0F\\u4E8E\\u90A3\\u4E2A\\u65F6\\u95F4\\u70B9\\u7684\\u65F6\\u95F4\\u7684\\u90FD\\u4F1A\\u88AB\\u820D\\u5F03\\uFF0C \\u4ECE\\u5DE6\\u8FB9\\u51FA\\u961F\\u5217\\n        while self.queue and self.queue[0] < t-3000:\\n            self.queue.popleft()\\n            \\n        # \\u628A t \\u52A0\\u5165\\u961F\\u5217\\n        self.queue.append(t)\\n        \\n        # \\u8FD4\\u56DE\\u961F\\u5217\\u7684\\u957F\\u5EA6\\uFF0C\\u5C31\\u662F\\u961F\\u5217\\u4E2Dt\\u4EE5\\u53CAt3000\\u79D2\\u4E4B\\u524D\\u65F6\\u95F4\\u7684\\u603B\\u4E2A\\u6570\\n        return len(self.queue)\\n        \\n\\n",
                "solutionTags": [],
                "code": "class RecentCounter(object):\\n\\n    def __init__(self):\\n        \\n        # \\u7528\\u961F\\u5217\\u601D\\u60F3\\uFF0C\\u5DE6\\u8FB9\\u51FA\\uFF0C\\u53F3\\u8FB9\\u8FDB\\n        self.queue = collections.deque()\\n        \\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        # given a time t, time t-3000 \\u4E3A 3000 \\u6BEB\\u79D2\\u4E4B\\u524D\\u7684\\u65F6\\u95F4\\u70B9\\uFF0C\\u4EFB\\u4F55\\u5C0F\\u4E8E\\u90A3\\u4E2A\\u65F6\\u95F4\\u70B9\\u7684\\u65F6\\u95F4\\u7684\\u90FD\\u4F1A\\u88AB\\u820D\\u5F03\\uFF0C \\u4ECE\\u5DE6\\u8FB9\\u51FA\\u961F\\u5217\\n        while self.queue and self.queue[0] < t-3000:\\n            self.queue.popleft()\\n            \\n        # \\u628A t \\u52A0\\u5165\\u961F\\u5217\\n        self.queue.append(t)\\n        \\n        # \\u8FD4\\u56DE\\u961F\\u5217\\u7684\\u957F\\u5EA6\\uFF0C\\u5C31\\u662F\\u961F\\u5217\\u4E2Dt\\u4EE5\\u53CAt3000\\u79D2\\u4E4B\\u524D\\u65F6\\u95F4\\u7684\\u603B\\u4E2A\\u6570\\n        return len(self.queue)\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3834769,
                "title": "easy-3000-milliseconds",
                "content": "# Intuition\\nThe task requires us to count the number of recent requests within a certain time frame. The first intuition is to keep track of the requests as they come in. However, we only care about the requests that happened in the last 3000 milliseconds. This suggests that we should remove old requests that are no longer within this time frame. A queue data structure is ideal for this because it allows us to easily add new requests at the end and remove old requests from the front.\\n\\n# Approach\\nOur approach is to use a deque (double-ended queue) data structure to store the times of the requests. Each time the \\'ping\\' method is called, we add the new time at the end of the deque. We then remove all times at the front of the deque that are less than \\'t - 3000\\'. The remaining times in the deque are the requests that happened within the last 3000 milliseconds. To get the number of these requests, we simply return the length of the deque.\\n\\n# Complexity\\n- Time complexity: The time complexity of the \\'ping\\' operation is \\\\( O(1) \\\\). Each \\'ping\\' call results in a constant number of operations, which does not depend on the size of \\'t\\' or the number of requests.\\n\\n- Space complexity: The space complexity is \\\\( O(N) \\\\), where \\\\( N \\\\) is the maximum number of \\'pings\\' within a 3000 millisecond time frame. This is because all these \\'pings\\' could potentially be stored in the deque at the same time.\\n\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque() \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: \\n            self.queue.popleft() \\n        return len(self.queue)                           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque() \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: \\n            self.queue.popleft() \\n        return len(self.queue)                           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568692,
                "title": "beating-99-34-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/0fcc35b3-81ce-40f3-9246-62cf557178cd_1685203647.425843.png)\\n\\n\\n# Code\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873862,
                "title": "number-of-recent-calls-java",
                "content": "```\\nclass RecentCounter \\n{\\n    /* This is a really straight foreword implementation.  Instantiate a queue.  On each call to ping \\n     * add the new value to the tail of the queue and then eat the values which have timed out (i.e. \\n     * values below t - 3000) from the head of the queue.  Once the queue holds the right data set \\n     * just return it\\'s size.  My guess is most people will do something similar.\\n     *\\n\\t * n.b.  By adding t to the queue first you\\'ll always be assured of having an item which will \\n\\t * cause the while loop to terminate and won\\'t need to do a null check.\\n     */\\n    \\n    private Queue<Integer>      q = new LinkedList<Integer>();\\n\\n    public RecentCounter() {}\\n    \\n    public int ping(int t) \\n    {\\n        q.add( t );\\n        \\n        while( q.peek() < t - 3000 )\\n        {\\n            q.poll();\\n        }\\n        \\n        return q.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter \\n{\\n    /* This is a really straight foreword implementation.  Instantiate a queue.  On each call to ping \\n     * add the new value to the tail of the queue and then eat the values which have timed out (i.e. \\n     * values below t - 3000) from the head of the queue.  Once the queue holds the right data set \\n     * just return it\\'s size.  My guess is most people will do something similar.\\n     *\\n\\t * n.b.  By adding t to the queue first you\\'ll always be assured of having an item which will \\n\\t * cause the while loop to terminate and won\\'t need to do a null check.\\n     */\\n    \\n    private Queue<Integer>      q = new LinkedList<Integer>();\\n\\n    public RecentCounter() {}\\n    \\n    public int ping(int t) \\n    {\\n        q.add( t );\\n        \\n        while( q.peek() < t - 3000 )\\n        {\\n            q.poll();\\n        }\\n        \\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405318,
                "title": "python-solution-using-deque-queue",
                "content": "This is a good example of using deque (double-ended queue) data structure. deque is implemented in Python using doubly-linked list. As a result, it has much better performance compared to Python list for push/pop in both ends, and much worse when it comes to indexing. A few obvious differences between deque and list:\\n1) deque doesn\\'t support slicing;\\n2) deque has a few extra methods on the left side including appendleft(), extendleft() and popleft();\\n3) deque doesn\\'t have a sort() method. \\n\\n```\\nfrom collections import deque \\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n\\t\\t#append first, no need to check empty deque\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: self.queue.popleft()\\n        return len(self.queue)\\n```\\nUsing Python list is also possible, but it takes longer to run. \\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque \\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n\\t\\t#append first, no need to check empty deque\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: self.queue.popleft()\\n        return len(self.queue)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675606,
                "title": "python-99-5-solution-queue-4-lines",
                "content": "Basically, we don\\'t care about the ping that last for more than 3000 seconds. So just pop it out of the queue.\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "Basically, we don\\'t care about the ping that last for more than 3000 seconds. So just pop it out of the queue.\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)",
                "codeTag": "Java"
            },
            {
                "id": 1654544,
                "title": "java-solution-number-of-recent-calls-using-queue",
                "content": "Java Solution:\\n```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    int min;\\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {        \\n        q.offer(t);\\n        min = t-3000;       \\n        while(min>q.peek()){\\n            q.poll();\\n        }\\n        return q.size();        \\n    }\\n}\\n```\\nFeel free to upvote if you like this Solution.\\nHappy Coding!!!\\n[Twitter](https://twitter.com/rohit_mittal17)\\n[GitHub](https://github.com/rohitm17)\\n[Medium](https://medium.com/@rohitm17)",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    int min;\\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {        \\n        q.offer(t);\\n        min = t-3000;       \\n        while(min>q.peek()){\\n            q.poll();\\n        }\\n        return q.size();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873283,
                "title": "number-of-recent-calls-python-98-using-queue",
                "content": "```\\ncompare least recent calls to t-3000, if less then pop calls\\ndeque over list because popleft() is O(1) time over list pop(0) O(n) time\\n```\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n```",
                "solutionTags": [],
                "code": "```\\ncompare least recent calls to t-3000, if less then pop calls\\ndeque over list because popleft() is O(1) time over list pop(0) O(n) time\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873253,
                "title": "number-of-recent-calls-c-using-queue-98",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        int start=t-3000;\\n        int end=t;\\n        while(q.front()<start){\\n            q.pop();\\n        }\\n        return q.size(); \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        int start=t-3000;\\n        int end=t;\\n        while(q.front()<start){\\n            q.pop();\\n        }\\n        return q.size(); \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492668,
                "title": "intuitive-javascript-solution",
                "content": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.queue.push(t);\\n    // keep pings within 3000 from the latest ping \\n    while(this.queue[0] < t - 3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.queue.push(t);\\n    // keep pings within 3000 from the latest ping \\n    while(this.queue[0] < t - 3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118441,
                "title": "python-simple-queue-solution-beats-97",
                "content": "# Code\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.s = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.s and t - self.s[0] > 3000:\\n            self.s.pop(0)  # remove 1st el if it\\'s 3000+ away from t\\n        self.s.append(t)\\n        return len(self.s) \\n\\n```\\n\\nupdate:\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-04-03 \\u0432 13.55.16.png](https://assets.leetcode.com/users/images/5d6980a6-d23c-483e-8ce1-b6ab49b2860a_1680519361.3573725.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.s = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.s and t - self.s[0] > 3000:\\n            self.s.pop(0)  # remove 1st el if it\\'s 3000+ away from t\\n        self.s.append(t)\\n        return len(self.s) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178137,
                "title": "java-smaller-queue-solution",
                "content": "# Please Upvote If You Find This Helpful\\n```\\nclass RecentCounter {\\n    private Queue<Integer> queue;\\n    public RecentCounter() {\\n        this.queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < t - 3000) queue.remove();\\n        return queue.size();\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    private Queue<Integer> queue;\\n    public RecentCounter() {\\n        this.queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < t - 3000) queue.remove();\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880478,
                "title": "python-binary-search-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self): \\n        self.requests = []\\n\\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        left = 0\\n        right = len(self.requests)\\n        \\n        while left < right:\\n            mid = int((left + right) / 2)\\n            if self.requests[mid] >= (self.requests[-1] - 3000):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return len(self.requests) - left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self): \\n        self.requests = []\\n\\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        left = 0\\n        right = len(self.requests)\\n        \\n        while left < right:\\n            mid = int((left + right) / 2)\\n            if self.requests[mid] >= (self.requests[-1] - 3000):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return len(self.requests) - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875210,
                "title": "easiest-possible-explanation-using-min-heap",
                "content": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n    public RecentCounter() {\\n        pq = new PriorityQueue<>((a,b)-> a-b);\\n    }\\n    \\n    public int ping(int t) {\\n        if(!pq.isEmpty()){\\n            int min = t-3000;\\n\\t\\t\\t//recursively pop elements from top of MinHeap till top element is greater than t-3000\\n            while(!pq.isEmpty() && pq.peek() < min){\\n                pq.poll();\\n            }\\n        }\\n        pq.offer(t);\\n        return pq.size();\\n    }\\n}\\n```\\n\\nThe idea above is to somehow store t values, from current_time to current_time - 3000.\\nHow can we achieve that, one of the easiset ways is to use Min Heap, so that the mimimum element is stored at top/root.\\nEach time we get a ping, we check the current top/root, if its lesser than remove elements from Min Heap recursively till top/root is greater than current_time-3000.\\nThis way at any point of time we just have the required elements in the min-heap.\\n\\nTime complexity: O(n * log(n)) Each insert, and reordering after poll takes O(log(n)) time, but while trying to empty the minheap recursively we might have to do it for n elements, hence n * log(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n    public RecentCounter() {\\n        pq = new PriorityQueue<>((a,b)-> a-b);\\n    }\\n    \\n    public int ping(int t) {\\n        if(!pq.isEmpty()){\\n            int min = t-3000;\\n\\t\\t\\t//recursively pop elements from top of MinHeap till top element is greater than t-3000\\n            while(!pq.isEmpty() && pq.peek() < min){\\n                pq.poll();\\n            }\\n        }\\n        pq.offer(t);\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874696,
                "title": "just-another-c-solution-using-bitset-no-queues",
                "content": "I assume everyone understand the queue solution. With this post I just want to show that `there are always other possibilities`\\n\\nSo we want to record all the time points in the past 3001 ms. Instead of using a vector, which is very inefficient when moving its elements, we use a bitset.\\nWhen a new call comes in, all we need to do is shift all the bits to the left by `this time - previous time`, and mark the right most bit `1`, then return the number of 1 bits.\\n\\nFurther thoughts: if the time range goes very huge, the shift operation may become slow. However, it still beats the queue method on memory usage, and runs within reasonable time frame.\\n(I tried to set the time range to 1,000,000,000 instead of 3000, it still runs. The queue method may be faster _some times_, but it is just unrealistic for the queue to hold that many of nodes)\\n\\n```cpp\\nclass RecentCounter {\\npublic:\\n    RecentCounter() : m_calls(0), m_last(0) {\\n    }\\n    \\n    int ping(int t) {\\n        m_calls <<= t - m_last;\\n        m_calls.set(0);\\n        m_last = t;\\n        return m_calls.count();\\n    }\\n    \\nprivate:\\n    bitset<3001> m_calls;\\n    int m_last; // time of previous ping()\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass RecentCounter {\\npublic:\\n    RecentCounter() : m_calls(0), m_last(0) {\\n    }\\n    \\n    int ping(int t) {\\n        m_calls <<= t - m_last;\\n        m_calls.set(0);\\n        m_last = t;\\n        return m_calls.count();\\n    }\\n    \\nprivate:\\n    bitset<3001> m_calls;\\n    int m_last; // time of previous ping()\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873222,
                "title": "c-super-simple-easy-and-short-solution-o-1-time-space",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        calls.push_back(t);\\n        while (calls[0] < t - 3000)\\n            calls.erase(calls.begin());\\n        return calls.size();\\n    }\\n    \\nprivate:\\n    vector<int> calls;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        calls.push_back(t);\\n        while (calls[0] < t - 3000)\\n            calls.erase(calls.begin());\\n        return calls.size();\\n    }\\n    \\nprivate:\\n    vector<int> calls;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726473,
                "title": "go",
                "content": "Slice (as queue) implementation: (Ping() is O(N))\\n```\\ntype RecentCounter struct {\\n    q []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.q = append(this.q, t)\\n    for i, val := range this.q {\\n        if val >= t - 3000 {\\n            this.q = this.q[i:]\\n            break\\n        }\\n    }\\n    return len(this.q)\\n}\\n```\\n\\nBinary Search: (Ping() is O(logN))\\n```\\ntype RecentCounter struct {\\n    a []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.a = append(this.a, t)\\n    \\n    idx := binarySearch(this.a, t - 3000)\\n    \\n    return len(this.a) - idx\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    lo, hi := 0, len(arr)-1\\n    \\n    for lo <= hi {\\n        mid := (lo + hi) / 2\\n        if arr[mid] > target {\\n            hi = mid - 1\\n        } else if arr[mid] < target {\\n            lo = mid + 1\\n        } else {\\n            return mid\\n        }\\n    }\\n    \\n    return lo\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RecentCounter struct {\\n    q []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.q = append(this.q, t)\\n    for i, val := range this.q {\\n        if val >= t - 3000 {\\n            this.q = this.q[i:]\\n            break\\n        }\\n    }\\n    return len(this.q)\\n}\\n```\n```\\ntype RecentCounter struct {\\n    a []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.a = append(this.a, t)\\n    \\n    idx := binarySearch(this.a, t - 3000)\\n    \\n    return len(this.a) - idx\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    lo, hi := 0, len(arr)-1\\n    \\n    for lo <= hi {\\n        mid := (lo + hi) / 2\\n        if arr[mid] > target {\\n            hi = mid - 1\\n        } else if arr[mid] < target {\\n            lo = mid + 1\\n        } else {\\n            return mid\\n        }\\n    }\\n    \\n    return lo\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490723,
                "title": "rust-24-ms",
                "content": "```\\nuse std::borrow::BorrowMut;\\nuse std::collections::VecDeque;\\n\\nstruct RecentCounter {\\n    queue: VecDeque<i32>,\\n}\\n\\nimpl RecentCounter {\\n    fn new() -> Self {\\n        RecentCounter {\\n            queue: VecDeque::new(),\\n        }\\n    }\\n\\n    fn ping(&mut self, t: i32) -> i32 {\\n        let q = self.queue.borrow_mut();\\n        q.push_back(t);\\n        while let Some(value) = q.front() {\\n            if *value < t - 3000 {\\n                q.pop_front();\\n            } else {\\n                break;\\n            }\\n        }\\n        q.len() as i32\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nuse std::borrow::BorrowMut;\\nuse std::collections::VecDeque;\\n\\nstruct RecentCounter {\\n    queue: VecDeque<i32>,\\n}\\n\\nimpl RecentCounter {\\n    fn new() -> Self {\\n        RecentCounter {\\n            queue: VecDeque::new(),\\n        }\\n    }\\n\\n    fn ping(&mut self, t: i32) -> i32 {\\n        let q = self.queue.borrow_mut();\\n        q.push_back(t);\\n        while let Some(value) = q.front() {\\n            if *value < t - 3000 {\\n                q.pop_front();\\n            } else {\\n                break;\\n            }\\n        }\\n        q.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419958,
                "title": "simple-java-solution-w-queue-comments",
                "content": "```java\\nclass RecentCounter {\\n    \\n    //primary data structure\\n    Queue<Integer> queue;\\n\\n    public RecentCounter() {\\n        //initialize our queue\\n        queue = new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        //add current ping to queue\\n        queue.offer(t);\\n        \\n        //keep removing from queue while more than 3000ms ago\\n        while (!queue.isEmpty() && t - queue.peek() > 3000) {\\n            //pop first in queue\\n            queue.poll();\\n        }\\n        \\n        //just return size of our queue (every ping here is within 3000 ms)\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```java\\nclass RecentCounter {\\n    \\n    //primary data structure\\n    Queue<Integer> queue;\\n\\n    public RecentCounter() {\\n        //initialize our queue\\n        queue = new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        //add current ping to queue\\n        queue.offer(t);\\n        \\n        //keep removing from queue while more than 3000ms ago\\n        while (!queue.isEmpty() && t - queue.peek() > 3000) {\\n            //pop first in queue\\n            queue.poll();\\n        }\\n        \\n        //just return size of our queue (every ping here is within 3000 ms)\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189291,
                "title": "simple-javascript-solution-3-lines",
                "content": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n   this.queue.push(t);\\n    while(this.queue.length && this.queue[0] < t-3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = Object.create(RecentCounter).createNew()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n   this.queue.push(t);\\n    while(this.queue.length && this.queue[0] < t-3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = Object.create(RecentCounter).createNew()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749681,
                "title": "c-very-simple-queue",
                "content": "# Code\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        int limit = t - 3000;\\n        Q.push(t);\\n        while (Q.front() < limit) Q.pop();\\n        return Q.size();\\n    }\\n\\nprivate:\\n    queue<int> Q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        int limit = t - 3000;\\n        Q.push(t);\\n        while (Q.front() < limit) Q.pop();\\n        return Q.size();\\n    }\\n\\nprivate:\\n    queue<int> Q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432422,
                "title": "kotlin-style-short-solution",
                "content": "```\\nclass RecentCounter() {\\n\\n    val list = mutableListOf<Int>()\\n\\n    fun ping(t: Int): Int {\\n        list.add(t)\\n        return list.count { it in t - 3000..t }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass RecentCounter() {\\n\\n    val list = mutableListOf<Int>()\\n\\n    fun ping(t: Int): Int {\\n        list.add(t)\\n        return list.count { it in t - 3000..t }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126484,
                "title": "c-solution-using-only-one-queue-short-simple",
                "content": "**Code:**\\n\\n```\\nclass RecentCounter\\n{\\npublic:\\n    queue<int> q;\\n\\n    RecentCounter()\\n    {\\n    }\\n\\n    int ping(int t)\\n    {\\n        q.push(t);\\n        while (q.front() < t - 3000)\\n        {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter\\n{\\npublic:\\n    queue<int> q;\\n\\n    RecentCounter()\\n    {\\n    }\\n\\n    int ping(int t)\\n    {\\n        q.push(t);\\n        while (q.front() < t - 3000)\\n        {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1316432,
                "title": "smallest-solution-in-c-ever-with-funny-explaination-3-line-code",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    priority_queue<int, vector<int>,greater<int>> res;\\n    RecentCounter() {}    //vella Constructor \\n    int ping(int t) {\\n        res.push(t);\\n        while(t-res.top() >3000)   res.pop();    //Coz difference cant be greater than 3000  \\n        return res.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    priority_queue<int, vector<int>,greater<int>> res;\\n    RecentCounter() {}    //vella Constructor \\n    int ping(int t) {\\n        res.push(t);\\n        while(t-res.top() >3000)   res.pop();    //Coz difference cant be greater than 3000  \\n        return res.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013108,
                "title": "c-simple-4-line-solution-faster-than-100-with-queue",
                "content": "Just four lines are needed for `ping`, and the constructor is not needed at all: On every call, add the current time `t` and remove all times greater smaller than `t-3000` from the back of the queue.\\n\\n```\\nclass RecentCounter {\\n    queue<int> recents;\\npublic:\\n    int ping(int t) {\\n        recents.push(t);\\n        while(recents.front() < (t - 3000))\\n            recents.pop();\\n        return recents.size();\\n    }\\n};\\n```\\n\\nFast and low memory:\\n![image](https://assets.leetcode.com/users/images/bd1c96b7-c355-4c96-a0f5-4d4395efdc3c_1610455821.3957345.png)\\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue<int> recents;\\npublic:\\n    int ping(int t) {\\n        recents.push(t);\\n        while(recents.front() < (t - 3000))\\n            recents.pop();\\n        return recents.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874262,
                "title": "c-2-pointers-binary-search-solution-explained-100-time-new-record-10-memory",
                "content": "As usual, I decided to sacrifice as much as possible in order to gain top speed.\\n\\nTo do so, I eschewed having any constructor and instead just set 3 class variables:\\n* `store`, an array of `10000` ints;\\n* `last` and `first`, to keep track of how extended is our window of elements, both initialised to `0`.\\n\\ni then put all the logic just in `ping`:\\n* every new element `t` is added to `store` in the `last` position, increasing `last` with the postfix operator;\\n* `first` is updated doing a binary search on the `first - last` range for any value smaller than `t - 3000`, as per specs;\\n* we return `last - first` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass RecentCounter {\\npublic:\\n    int store[10000], last = 0, first = 0;    \\n    int ping(int t) {\\n        store[last++] = t;\\n        first = lower_bound(store + first, store + last, t - 3000) - store;\\n        return last - first;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/176d0720-7a6b-482d-bf9e-e731b730dd4a_1601588934.2631395.png)\\n\\nThe further brag:\\n![image](https://assets.leetcode.com/users/images/558b0b42-9992-49f3-ae42-1481013f6dfa_1601589054.0014238.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass RecentCounter {\\npublic:\\n    int store[10000], last = 0, first = 0;    \\n    int ping(int t) {\\n        store[last++] = t;\\n        first = lower_bound(store + first, store + last, t - 3000) - store;\\n        return last - first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873463,
                "title": "easy-python-3-solution-beginner-friendly",
                "content": "class RecentCounter:\\n\\n    def __init__(self):\\n\\t\\t#a list to store the request calls\\n        self.req=[]\\n    def ping(self, t: int) -> int:\\n        self.req.append(t)\\n\\t\\t#loop to pop out the requests which are out of time range of 300 milisecond\\n        while self.req[0]<t-3000:\\n            self.req.pop(0)\\n        return len(self.req)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)``",
                "solutionTags": [],
                "code": "class RecentCounter:\\n\\n    def __init__(self):\\n\\t\\t#a list to store the request calls\\n        self.req=[]\\n    def ping(self, t: int) -> int:\\n        self.req.append(t)\\n\\t\\t#loop to pop out the requests which are out of time range of 300 milisecond\\n        while self.req[0]<t-3000:\\n            self.req.pop(0)\\n        return len(self.req)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)``",
                "codeTag": "Java"
            },
            {
                "id": 743058,
                "title": "in-rust",
                "content": "```\\nstruct RecentCounter {\\n    pings: Vec<i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        RecentCounter { pings: vec!() }\\n    }\\n    \\n    fn ping(&mut self, t: i32) -> i32 {\\n        self.pings.push(t);\\n        return match self.pings.binary_search(&(t - 3000)) {\\n            Ok(i) => (self.pings.len() - i) as i32,\\n            Err(i) => (self.pings.len() - i) as i32,\\n        };\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * let obj = RecentCounter::new();\\n * let ret_1: i32 = obj.ping(t);\\n */\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct RecentCounter {\\n    pings: Vec<i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        RecentCounter { pings: vec!() }\\n    }\\n    \\n    fn ping(&mut self, t: i32) -> i32 {\\n        self.pings.push(t);\\n        return match self.pings.binary_search(&(t - 3000)) {\\n            Ok(i) => (self.pings.len() - i) as i32,\\n            Err(i) => (self.pings.len() - i) as i32,\\n        };\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * let obj = RecentCounter::new();\\n * let ret_1: i32 = obj.ping(t);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 636175,
                "title": "python-simple-solution-quick-explanation",
                "content": "**Quick Explanation of the Question:**\\n\\nThis question could probably be written a little more clearly so I will leave a few lines here for those who may find it helpful.  The question is saying that it will do the following:\\n\\n    In [1]: temp = RecentCounter()\\n\\tIn [2]: temp.ping(1)\\n\\tIn [3]: temp.ping(100)\\n\\tIn [4]: temp.ping(3001)\\n\\tIn [5]: temp.ping(3002)\\n\\nEverytime it calls ping, you get an input value t (the time that has elapsed since temp was created).  Your job is to return how many ping times there are between the given t and t - 3000 ms inclusive.  \\n\\t\\n\\n**Solution:**\\n\\nStore all times in a doubly ended queue (deque) so that new times can be appended to the end of the queue and removed from the beginning of the queue in constant time.  \\n\\nThe former to append the current time (t) every time ping is called.  \\n\\nThe latter to remove times less than t-3000 ms before calculating the result.\\n\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.count=0\\n        self.times = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.times.append(t)\\n        while self.times[0] < t-3000:\\n            self.times.popleft()\\n        return len(self.times)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.count=0\\n        self.times = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.times.append(t)\\n        while self.times[0] < t-3000:\\n            self.times.popleft()\\n        return len(self.times)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239143,
                "title": "c-solution",
                "content": "```\\n#define MAX_SIZE 10000\\n\\ntypedef struct {\\n    int* pingHistory;\\n    int head;\\n    int tail; \\n} RecentCounter;\\n\\nRecentCounter* recentCounterCreate() {\\n    RecentCounter* obj = malloc(sizeof(RecentCounter));\\n    obj -> pingHistory = calloc(10000, sizeof(int));\\n    obj -> head = 0;\\n    obj -> tail = 0;\\n    return obj;\\n}\\n\\nint recentCounterPing(RecentCounter* obj, int t) {\\n    obj -> pingHistory[obj->head++] = t;\\n    \\n    for(; obj->tail < obj -> head; obj->tail++)\\n    {\\n        if((t-3000) <= obj -> pingHistory[obj->tail])\\n        {\\n            break;\\n        }\\n    }\\n    return obj->head-obj->tail;\\n}\\n\\nvoid recentCounterFree(RecentCounter* obj) {\\n    free(obj->pingHistory);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_SIZE 10000\\n\\ntypedef struct {\\n    int* pingHistory;\\n    int head;\\n    int tail; \\n} RecentCounter;\\n\\nRecentCounter* recentCounterCreate() {\\n    RecentCounter* obj = malloc(sizeof(RecentCounter));\\n    obj -> pingHistory = calloc(10000, sizeof(int));\\n    obj -> head = 0;\\n    obj -> tail = 0;\\n    return obj;\\n}\\n\\nint recentCounterPing(RecentCounter* obj, int t) {\\n    obj -> pingHistory[obj->head++] = t;\\n    \\n    for(; obj->tail < obj -> head; obj->tail++)\\n    {\\n        if((t-3000) <= obj -> pingHistory[obj->tail])\\n        {\\n            break;\\n        }\\n    }\\n    return obj->head-obj->tail;\\n}\\n\\nvoid recentCounterFree(RecentCounter* obj) {\\n    free(obj->pingHistory);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4038917,
                "title": "go-solution-easy-explanation-o-n-time-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe maintain a queue of timestamps for incoming requests. When a new request comes in, we add its timestamp to the queue. We then remove timestamps from the front of the queue that are outside the 3000 milliseconds window. The length of the queue at any point represents the number of requests within the window.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use a queue (implemented as a slice) to store timestamps.\\n2. In the Ping method, we append the current timestamp to the queue.\\n3. We iterate through the front of the queue and remove timestamps that are older than t - 3000.\\n4. The length of the queue represents the number of requests within the window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - The Constructor method has a time complexity of O(1).\\n    - The Ping method has a time complexity of O(N), where N is the number of requests within the 3000 milliseconds window. In practice, N is bounded by the number of calls to Ping.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - The space complexity is O(N), where N is the number of requests within the 3000 milliseconds window.\\n\\n# Code\\n```\\ntype RecentCounter struct {\\n    requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    // Add the current timestamp to the queue\\n    this.requests = append(this.requests, t)\\n    \\n    // Remove timestamps that are outside the 3000 milliseconds window\\n    for this.requests[0] < t-3000 {\\n        this.requests = this.requests[1:]\\n    }\\n    \\n    // Return the number of requests within the window\\n    return len(this.requests)\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RecentCounter struct {\\n    requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    // Add the current timestamp to the queue\\n    this.requests = append(this.requests, t)\\n    \\n    // Remove timestamps that are outside the 3000 milliseconds window\\n    for this.requests[0] < t-3000 {\\n        this.requests = this.requests[1:]\\n    }\\n    \\n    // Return the number of requests within the window\\n    return len(this.requests)\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Ping(t);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965562,
                "title": "19ms-beats-81-34-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo Need to use array or arraylist.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just have to add new entry and check from start if any out of range element is there ? then pop it until whole queue is in range . then return queue size. It\\'s simple , In ArrayList we have to traverse it in every function call but here we are just traversing only that much which is needed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n\\n    Queue<Integer> q = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n\\n        int s = t-3000;\\n\\n        while(q.peek() < s)\\n        {\\n            q.poll();\\n        }\\n\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    Queue<Integer> q = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n\\n        int s = t-3000;\\n\\n        while(q.peek() < s)\\n        {\\n            q.poll();\\n        }\\n\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666594,
                "title": "python-solution-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n\\n# Code\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.all = []\\n\\n    def ping(self, t: int) -> int:\\n        self.all.append(t)\\n        min_time = t-3000\\n        while self.all[0] < min_time:\\n            self.all.pop(0)\\n        return len(self.all)    \\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.all = []\\n\\n    def ping(self, t: int) -> int:\\n        self.all.append(t)\\n        min_time = t-3000\\n        while self.all[0] < min_time:\\n            self.all.pop(0)\\n        return len(self.all)    \\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647168,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q=new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        q.add(t);\\n        int min=t-3000;\\n        while(q.peek()<min){\\n            q.remove();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q=new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        q.add(t);\\n        int min=t-3000;\\n        while(q.peek()<min){\\n            q.remove();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548121,
                "title": "easy-java-solution-with-deque-26ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    private LinkedList<Integer> pingList;\\n\\n    public RecentCounter() {\\n        this.pingList = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        pingList.addLast(t);\\n        while (t - 3000 > pingList.getFirst()) {\\n            pingList.removeFirst();\\n        }\\n        return pingList.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    private LinkedList<Integer> pingList;\\n\\n    public RecentCounter() {\\n        this.pingList = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        pingList.addLast(t);\\n        while (t - 3000 > pingList.getFirst()) {\\n            pingList.removeFirst();\\n        }\\n        return pingList.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521765,
                "title": "solution",
                "content": "```C++ []\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {   \\n    }\\n    int ping(int t) {\\n       q.push(t);\\n       while(q.front()<t-3000){\\n           q.pop();\\n       }\\n       return q.size(); \\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while t - 3000 > self.queue[0]:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```\\n\\n```Java []\\nclass RecentCounter {\\n    LinkedList<Integer> swin;\\n    public RecentCounter() {\\n        swin = new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        swin.addLast(t);\\n        while (swin.getFirst() < t - 3000) swin.removeFirst();\\n        return swin.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {   \\n    }\\n    int ping(int t) {\\n       q.push(t);\\n       while(q.front()<t-3000){\\n           q.pop();\\n       }\\n       return q.size(); \\n    }\\n};\\n```\n```Python3 []\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while t - 3000 > self.queue[0]:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```\n```Java []\\nclass RecentCounter {\\n    LinkedList<Integer> swin;\\n    public RecentCounter() {\\n        swin = new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        swin.addLast(t);\\n        while (swin.getFirst() < t - 3000) swin.removeFirst();\\n        return swin.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513494,
                "title": "python-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and t - self.queue[0] > 3000:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        \\n        return len(self.queue)\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and t - self.queue[0] > 3000:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        \\n        return len(self.queue)\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388299,
                "title": "go-solution-using-binary-search",
                "content": "```\\ntype RecentCounter struct {\\n        requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n        return RecentCounter{requests: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n        this.requests = append(this.requests, t)\\n        min := t - 3000\\n        i := binarySearch(this.requests, min)\\n        return len(this.requests) - i\\n}\\n\\nfunc binarySearch(nums []int, target int) int {\\n        l, r := 0, len(nums)-1\\n        for l <= r {\\n                mid := (l + r) / 2\\n                if num := nums[mid]; num == target {\\n                        return mid\\n                } else if num < target {\\n                        l = mid + 1\\n                } else {\\n                        r = mid - 1\\n                }\\n        }\\n\\n        return l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\ntype RecentCounter struct {\\n        requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n        return RecentCounter{requests: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n        this.requests = append(this.requests, t)\\n        min := t - 3000\\n        i := binarySearch(this.requests, min)\\n        return len(this.requests) - i\\n}\\n\\nfunc binarySearch(nums []int, target int) int {\\n        l, r := 0, len(nums)-1\\n        for l <= r {\\n                mid := (l + r) / 2\\n                if num := nums[mid]; num == target {\\n                        return mid\\n                } else if num < target {\\n                        l = mid + 1\\n                } else {\\n                        r = mid - 1\\n                }\\n        }\\n\\n        return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382418,
                "title": "100-runtime-typescript-javascript-solution",
                "content": "\\n# TypeScript Code\\n```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t: number): number {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```\\n\\n\\n# JavaScript Code\\n```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t) {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t: number): number {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857815,
                "title": "smallest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < t - 3000){\\n            q.pop();\\n        }\\n        \\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < t - 3000){\\n            q.pop();\\n        }\\n        \\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267307,
                "title": "python-deque-o-1-99-faster",
                "content": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.que = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.que.append(t)\\n        while self.que and self.que[0] < t - 3000:\\n            self.que.popleft()\\n        return len(self.que)",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.que = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.que.append(t)\\n        while self.que and self.que[0] < t - 3000:\\n            self.que.popleft()\\n        return len(self.que)",
                "codeTag": "Java"
            },
            {
                "id": 2231165,
                "title": "c-simplest-with-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue <int> qu;\\n  \\n    RecentCounter() { \\n    }\\n\\t\\n    int ping(int t) {\\n        qu.push(t); //insert ping time in queue\\n        while(qu.front() < t-3000) qu.pop(); //remove all pings before 3000ms of current time\\n        return qu.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue <int> qu;\\n  \\n    RecentCounter() { \\n    }\\n\\t\\n    int ping(int t) {\\n        qu.push(t); //insert ping time in queue\\n        while(qu.front() < t-3000) qu.pop(); //remove all pings before 3000ms of current time\\n        return qu.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238452,
                "title": "c-5-lines-of-code",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while ( q.front() < t - 3000 )      q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while ( q.front() < t - 3000 )      q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158707,
                "title": "easy-clear-100-00-of-javascript-online-submissions",
                "content": "```\\nvar RecentCounter = function() {\\n    this.oldCalls = [];    \\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.oldCalls.push(t);    \\n    \\n    while(this.oldCalls[0] < (t-3000))            \\n        this.oldCalls.shift();            \\n    \\n    return this.oldCalls.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RecentCounter = function() {\\n    this.oldCalls = [];    \\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.oldCalls.push(t);    \\n    \\n    while(this.oldCalls[0] < (t-3000))            \\n        this.oldCalls.shift();            \\n    \\n    return this.oldCalls.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979754,
                "title": "simple-java-solution-queue-o-n",
                "content": "```\\nclass RecentCounter {\\nprivate Queue<Integer> queue;\\n    public RecentCounter() {\\n       queue = new LinkedList<>(); \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\nprivate Queue<Integer> queue;\\n    public RecentCounter() {\\n       queue = new LinkedList<>(); \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949129,
                "title": "python-deque-o-1-time-o-1-space",
                "content": "1.  Consider the worst case in which t is extremely large i.e >10^6,  it takes O(3000) to iterate over the past 3000 elements, which is still a constant.\\n2.  Since we only return the size of deque, it takes O(1) space.\\n```\\nfrom collections import deque\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        low_limit=self.q[-1]-3000\\n        while self.q and self.q[0]<low_limit:\\n              self.q.popleft()\\n        return len(self.q)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        low_limit=self.q[-1]-3000\\n        while self.q and self.q[0]<low_limit:\\n              self.q.popleft()\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914416,
                "title": "easy-python-using-queue",
                "content": "class RecentCounter:\\n\\n    def __init__(self):\\n        self.queue=list()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (self.queue[0] < t-3000):\\n            self.queue.pop(0)\\n        return len(self.queue)",
                "solutionTags": [],
                "code": "class RecentCounter:\\n\\n    def __init__(self):\\n        self.queue=list()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (self.queue[0] < t-3000):\\n            self.queue.pop(0)\\n        return len(self.queue)",
                "codeTag": "Java"
            },
            {
                "id": 874190,
                "title": "kotlin-with-an-optimised-binary-search",
                "content": "I started out pretty much with a fold operation, then realised the solution could be done with a binary search, as will follow shortly.\\nHowever, there is a further time optimisation that can be made: I know that my next boundary will never be any further to the left than my last left pointer in BS, so after each search I can cache the position of the left pointer so that I don\\'t have to start from zero every time:\\n\\n```\\nclass RecentCounter(\\n  var recentRequests: Int = 0,\\n  var leftCache: Int = 0\\n) {\\n    private var allRequests = mutableListOf<Int>()\\n    fun ping(t: Int): Int {\\n        allRequests.add(t)\\n        var l = leftCache; var r = allRequests.size - 1\\n        while (l < r) {\\n          val mid = l + (r - l) / 2\\n          if (allRequests[mid] < t - 3000) l = mid + 1\\n          else r = mid\\n        }\\n        leftCache = l\\n        return allRequests.size - l\\n    }\\n}\\n```\\n\\nNot sure why it\\'s necessary to keep a `recentRequests` count though. A bit pointless I think...",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter(\\n  var recentRequests: Int = 0,\\n  var leftCache: Int = 0\\n) {\\n    private var allRequests = mutableListOf<Int>()\\n    fun ping(t: Int): Int {\\n        allRequests.add(t)\\n        var l = leftCache; var r = allRequests.size - 1\\n        while (l < r) {\\n          val mid = l + (r - l) / 2\\n          if (allRequests[mid] < t - 3000) l = mid + 1\\n          else r = mid\\n        }\\n        leftCache = l\\n        return allRequests.size - l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873740,
                "title": "java-solution-with-a-circular-array-that-beats-100-submissions",
                "content": "The official solution recommends a dynamic data structure, which in situations like this, is a bit of an overkill, due to many unnecessary additions and removals of objects on the heap. A faster and more memory friendly approach is to leverage a static circular buffer of a fixed size, as shown below. You might consider this technique whenever you need to track some fixed number of records.\\n```\\nclass RecentCounter {\\n    // The extra padding is added for easier calculation of actual window size.\\n    private static final int WINDOW_SIZE = 3002;\\n    \\n    private final int[] timestamps = new int[WINDOW_SIZE];\\n    private int start, end;\\n\\n    public int ping(int t) {\\n        timestamps[end] = t;\\n        end = (end + 1) % WINDOW_SIZE;        \\n        // Prune away old entries from the window.\\n        while (t - timestamps[start] >= WINDOW_SIZE - 1) start = (start + 1) % WINDOW_SIZE;\\n        return start < end ? end - start : WINDOW_SIZE - start + end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RecentCounter {\\n    // The extra padding is added for easier calculation of actual window size.\\n    private static final int WINDOW_SIZE = 3002;\\n    \\n    private final int[] timestamps = new int[WINDOW_SIZE];\\n    private int start, end;\\n\\n    public int ping(int t) {\\n        timestamps[end] = t;\\n        end = (end + 1) % WINDOW_SIZE;        \\n        // Prune away old entries from the window.\\n        while (t - timestamps[start] >= WINDOW_SIZE - 1) start = (start + 1) % WINDOW_SIZE;\\n        return start < end ? end - start : WINDOW_SIZE - start + end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873449,
                "title": "cpp-solution-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n      queue<int> q;\\n      RecentCounter() {\\n      }\\n      int ping(int t) {\\n         q.push(t);\\n\\t     while(q.front() < t-3000)\\n             q.pop();\\n         return q.size();\\n      }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n      queue<int> q;\\n      RecentCounter() {\\n      }\\n      int ping(int t) {\\n         q.push(t);\\n\\t     while(q.front() < t-3000)\\n             q.pop();\\n         return q.size();\\n      }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873291,
                "title": "c-solution-with-lower-bound-easy-to-understand",
                "content": "Do <b>Upvote</b> this solution, if you like it. :)\\nIf you have any suggestions on how to improve this solution further, then feel free to comment down below.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    vector<int> requests;\\n    RecentCounter() {\\n        requests.clear();\\n    }\\n    \\n    int ping(int t) {\\n        requests.push_back(t);\\n        int num = 0;\\n        \\n        if(requests.size() == 1)\\n            return 1;\\n        else {\\n            int first = lower_bound(requests.begin(), requests.end(), t - 3000) - requests.begin();\\n            int second = lower_bound(requests.begin(), requests.end(), t) - requests.begin();\\n            cout<<second<<\" \"<<first<<endl;\\n            return second - first + 1;\\n        }\\n    }\\n};\\n\\n```\\n<b> Happy Coding :) </b>",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> requests;\\n    RecentCounter() {\\n        requests.clear();\\n    }\\n    \\n    int ping(int t) {\\n        requests.push_back(t);\\n        int num = 0;\\n        \\n        if(requests.size() == 1)\\n            return 1;\\n        else {\\n            int first = lower_bound(requests.begin(), requests.end(), t - 3000) - requests.begin();\\n            int second = lower_bound(requests.begin(), requests.end(), t) - requests.begin();\\n            cout<<second<<\" \"<<first<<endl;\\n            return second - first + 1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 873273,
                "title": "in-java",
                "content": "```\\nclass RecentCounter {\\n    ArrayList<Integer> requests = new ArrayList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        this.requests.add(t);\\n        int leftRange = t-3000;\\n        int rightRange = t;\\n        int count=0;\\n        for(Integer num:this.requests){\\n            if(num>=leftRange && num<=rightRange){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    ArrayList<Integer> requests = new ArrayList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        this.requests.add(t);\\n        int leftRange = t-3000;\\n        int rightRange = t;\\n        int count=0;\\n        for(Integer num:this.requests){\\n            if(num>=leftRange && num<=rightRange){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873207,
                "title": "number-of-recent-calls-c-10-lines",
                "content": "Keep a window for most recent pings that are at most 3000 ms apart\\n```\\nclass RecentCounter {\\n    queue<int> pings_;\\npublic:    \\n    int ping(int t) {\\n        pings_.push(t);\\n        while (t - pings_.front() > 3000)\\n            pings_.pop();        \\n        return pings_.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue<int> pings_;\\npublic:    \\n    int ping(int t) {\\n        pings_.push(t);\\n        while (t - pings_.front() > 3000)\\n            pings_.pop();        \\n        return pings_.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515296,
                "title": "python-queue",
                "content": "```python\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n\\n        while(self.queue and self.queue[0] < t - 3000):\\n            self.queue.popleft()\\n            \\n        return len(self.queue)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n\\n        while(self.queue and self.queue[0] < t - 3000):\\n            self.queue.popleft()\\n            \\n        return len(self.queue)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490516,
                "title": "binary-search-solution-using-ruby",
                "content": "```\\nclass RecentCounter\\n    def initialize()\\n        @pings = []\\n    end\\n\\n    def ping(t)\\n        @pings << t\\n        @pings.slice!(0 ... @pings.bsearch_index {|x| x >= t-3000})\\n        @pings.size\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\nclass RecentCounter\\n    def initialize()\\n        @pings = []\\n    end\\n\\n    def ping(t)\\n        @pings << t\\n        @pings.slice!(0 ... @pings.bsearch_index {|x| x >= t-3000})\\n        @pings.size\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479320,
                "title": "java-simple-solution-by-using-queue-queue-is-acted-as-a-sliding-window-for-maintaing-the-interval",
                "content": "```\\nclass RecentCounter {\\n    //inclusive [t-3000,3000]\\n    Queue<Integer>queue;\\n    public RecentCounter() {\\n        queue=new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size()>0&&queue.peek()<(t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    //inclusive [t-3000,3000]\\n    Queue<Integer>queue;\\n    public RecentCounter() {\\n        queue=new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size()>0&&queue.peek()<(t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453924,
                "title": "python-3-beats-98",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self): self.H = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.H.append(t)\\n        while self.H[0] < t - 3000: self.H.popleft()\\n        return len(self.H)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self): self.H = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.H.append(t)\\n        while self.H[0] < t - 3000: self.H.popleft()\\n        return len(self.H)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 389431,
                "title": "easy-to-understand-c-solution",
                "content": "Runtime: 204 ms, faster than 73.58% of C++ online submissions for Number of Recent Calls.\\nMemory Usage: 49.8 MB, less than 100.00% of C++ online submissions for Number of Recent Calls.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        while(t - q.front() > 3000)\\n            q.pop();\\n        return q.size();\\n    }\\n    \\n    private:\\n        queue<int> q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "solutionTags": [
                    "Queue"
                ],
                "code": "Runtime: 204 ms, faster than 73.58% of C++ online submissions for Number of Recent Calls.\\nMemory Usage: 49.8 MB, less than 100.00% of C++ online submissions for Number of Recent Calls.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        while(t - q.front() > 3000)\\n            q.pop();\\n        return q.size();\\n    }\\n    \\n    private:\\n        queue<int> q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 355572,
                "title": "a-simple-java-solution-explained",
                "content": "So, tbf, this question can be worded much, much better. For example\\n<p>\\nWrite a class RecentCounter to count \"recent\" requests.\\nIt has only one method: ping(int t), where <strong>t</strong> represents some timestamp, in milliseconds.\\nReturn the number of pings that have occurred from 3000 milliseconds ago until timestamp <strong>t</strong> parameter.\\nTherefore, any ping occurred in the \"last 3000ms\", i.e. a range [t - 3000, t] will count, including the current ping.\\nIt is guaranteed that every call to ping uses a strictly larger value of t than before.\\n</p>\\n\\n```\\nclass RecentCounter {\\n    private final Queue<Integer> requestQueue = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    /*\\n        The question does not explain clearly that t (in their example)\\n        is timeNow. They do say, that [timeNow - 3000, timeNow] (inclusive) counts.\\n        Therefore, when 3002 comes in, 3001 falls outside the range, since it was before.\\n    */\\n    public int ping(int timeNow) {\\n\\n        requestQueue.add(timeNow);\\n        \\n        while (requestQueue.peek() < (timeNow - 3000)) {\\n            requestQueue.poll();\\n        }\\n        \\n        return requestQueue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private final Queue<Integer> requestQueue = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    /*\\n        The question does not explain clearly that t (in their example)\\n        is timeNow. They do say, that [timeNow - 3000, timeNow] (inclusive) counts.\\n        Therefore, when 3002 comes in, 3001 falls outside the range, since it was before.\\n    */\\n    public int ping(int timeNow) {\\n\\n        requestQueue.add(timeNow);\\n        \\n        while (requestQueue.peek() < (timeNow - 3000)) {\\n            requestQueue.poll();\\n        }\\n        \\n        return requestQueue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282480,
                "title": "java-queue",
                "content": "```java\\nclass RecentCounter {\\n\\n    private Deque<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.size() > 0 && queue.peek() < t - 3000)\\n            queue.remove();\\n        \\n        return queue.size();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass RecentCounter {\\n\\n    private Deque<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.size() > 0 && queue.peek() < t - 3000)\\n            queue.remove();\\n        \\n        return queue.size();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257833,
                "title": "java-solution-using-queue-beats-94-44",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size() > 0) {\\n            int first = queue.peek();\\n            if(t - first > 3000)\\n                queue.poll();\\n            else\\n                break;\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size() > 0) {\\n            int first = queue.peek();\\n            if(t - first > 3000)\\n                queue.poll();\\n            else\\n                break;\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192324,
                "title": "java-array-binary-search-111-ms-o-log-3000-time-o-logn-space",
                "content": "Keep track of the rising watermark after each call to limit the search space for the next call to no more than 3000 elements.\\n\\n```\\nclass RecentCounter {\\n\\n    private int[] times;\\n    private int watermark;\\n    private int size;\\n    \\n    public RecentCounter() {\\n        times = new int[10000];\\n        watermark = 0;\\n        size = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        times[size] = t;\\n        size ++;\\n        watermark = binarySearch(t-3000, watermark, size);\\n        return size - watermark;\\n    }\\n    \\n    private int binarySearch(int t, int start, int end) {\\n        int lo = start, hi = end;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (times[mid] < t) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    private int[] times;\\n    private int watermark;\\n    private int size;\\n    \\n    public RecentCounter() {\\n        times = new int[10000];\\n        watermark = 0;\\n        size = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        times[size] = t;\\n        size ++;\\n        watermark = binarySearch(t-3000, watermark, size);\\n        return size - watermark;\\n    }\\n    \\n    private int binarySearch(int t, int start, int end) {\\n        int lo = start, hi = end;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (times[mid] < t) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189261,
                "title": "java-binary-search-o-1",
                "content": "The timestamp input is a increasing sequence \\nTherefore, in each ping, we can use binary search to search for the `target just >= t - 3000`\\nAnd return the result calculated from the index of the target\\n\\n**Optimization:**\\nMaintain a `lowerBound` index to shrink the binary search range to `[lowerBound, list.size()-1]`\\nUpdate `lowerBound` in each ping\\nThis speed up about `30ms`\\n```\\nclass RecentCounter {\\n    List<Integer> list = new ArrayList<>();\\n    int lowerBound = 0;\\n    public RecentCounter() {}\\n    public int ping(int t) {\\n        list.add(t);\\n        int r = list.size() - 1;\\n        int target = t - 3000;\\n        while (lowerBound < r) {\\n            int m = lowerBound + (r-lowerBound) / 2;\\n            if (list.get(m) >= target)\\n                r = m;\\n            else\\n                lowerBound = m + 1;\\n        }\\n        return list.size() - lowerBound;\\n    }\\n}\\n```\\n**Time Complexity:** `O(log3001)` => `O(1)`\\n**Space Complexity:** `O(N)` for list",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    List<Integer> list = new ArrayList<>();\\n    int lowerBound = 0;\\n    public RecentCounter() {}\\n    public int ping(int t) {\\n        list.add(t);\\n        int r = list.size() - 1;\\n        int target = t - 3000;\\n        while (lowerBound < r) {\\n            int m = lowerBound + (r-lowerBound) / 2;\\n            if (list.get(m) >= target)\\n                r = m;\\n            else\\n                lowerBound = m + 1;\\n        }\\n        return list.size() - lowerBound;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906604,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class RecentCounter {\\n    int counter;\\n    Queue<int> q = new Queue<int>();\\n\\n    public RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    public int Ping(int t) {\\n        q.Enqueue(t);\\n        counter += 1;\\n        while (q.Count > 0 && (q.Peek() > t || q.Peek() < (t - 3000)))\\n        {\\n            q.Dequeue();\\n            counter -= 1;\\n        }\\n\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RecentCounter {\\n    int counter;\\n    Queue<int> q = new Queue<int>();\\n\\n    public RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    public int Ping(int t) {\\n        q.Enqueue(t);\\n        counter += 1;\\n        while (q.Count > 0 && (q.Peek() > t || q.Peek() < (t - 3000)))\\n        {\\n            q.Dequeue();\\n            counter -= 1;\\n        }\\n\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879598,
                "title": "kotlin-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter() {\\n\\n    val queue = ArrayDeque<Int>()\\n\\n    fun ping(t: Int): Int {\\n        while (queue.isNotEmpty() && queue.first() < t - 3000) {\\n            queue.removeFirst()\\n        }\\n        queue.add(t)\\n        return queue.size\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass RecentCounter() {\\n\\n    val queue = ArrayDeque<Int>()\\n\\n    fun ping(t: Int): Int {\\n        while (queue.isNotEmpty() && queue.first() < t - 3000) {\\n            queue.removeFirst()\\n        }\\n        queue.add(t)\\n        return queue.size\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678085,
                "title": "simple-iterative-approach-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Arrays\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    ArrayList<Integer> calls ;\\n    public RecentCounter() {\\n        calls = new ArrayList<Integer>();\\n        }\\n    \\n    public int ping(int t) {\\n        calls.add(t);\\n        int count = 0;\\n        for(Integer call:calls){\\n            if( t-call<=3000) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    ArrayList<Integer> calls ;\\n    public RecentCounter() {\\n        calls = new ArrayList<Integer>();\\n        }\\n    \\n    public int ping(int t) {\\n        calls.add(t);\\n        int count = 0;\\n        for(Integer call:calls){\\n            if( t-call<=3000) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608833,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class RecentCounter\\n{\\n    int[] pings;\\n    int idx;\\n\\n    public RecentCounter()\\n    {\\n        pings = new int[10000];\\n        idx= 0;\\n    }\\n\\n    public int Ping(int t)\\n    {\\n        pings[idx++] = t;\\n        int left = t - 3000;\\n        int cnt = 1;\\n\\n        for(int i = idx-2; i >= 0; --i) \\n        {\\n            if (pings[i] < left)\\n                return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RecentCounter\\n{\\n    int[] pings;\\n    int idx;\\n\\n    public RecentCounter()\\n    {\\n        pings = new int[10000];\\n        idx= 0;\\n    }\\n\\n    public int Ping(int t)\\n    {\\n        pings[idx++] = t;\\n        int left = t - 3000;\\n        int cnt = 1;\\n\\n        for(int i = idx-2; i >= 0; --i) \\n        {\\n            if (pings[i] < left)\\n                return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438043,
                "title": "simple-solution-but-logical-beats-99-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw this problem for the first time, I thought problems related to queue in leetcode need to be solved by Node, but it is easier than Nodes here.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn while statement we check is it empty or not first if it is, we simply append it to queue (composition).\\nIn next Input, there is 1 in queue, so we add 1 + 3000 < t, t in this case 100, if it is the case we remove it from queue\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBig O(n Log (n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBig O(n)\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873768,
                "title": "c-easy-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    vector<int> arr;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        arr.push_back(t);\\n        int cnt=0;\\n        for (int i : arr) if (i>=t-3000 && i<=t) cnt++;\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> arr;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        arr.push_back(t);\\n        int cnt=0;\\n        for (int i : arr) if (i>=t-3000 && i<=t) cnt++;\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857801,
                "title": "one-line-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444491,
                "title": "java-simple-and-friendly-97",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList<>();\\n\\n    public RecentCounter() {        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < (t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList<>();\\n\\n    public RecentCounter() {        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < (t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337766,
                "title": "simple-c-queue-solution",
                "content": "Please upvote if you like my solution .\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        int x = q.front();\\n        while(x < t-3000){\\n            q.pop(); x = q.front();\\n        }\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        int x = q.front();\\n        while(x < t-3000){\\n            q.pop(); x = q.front();\\n        }\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168734,
                "title": "python3-o-n-o-n-with-explanation",
                "content": "https://photos.app.goo.gl/sFqFttroBwRzf7MaA couldn\\'t upload it here dont know \\n\\n```\\nclass RecentCounter:\\n#     O(n) || O(n)\\n# Runtime: 310ms 78.53% || memory: 19.6mb 46.67%\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (t - self.queue[0]) > 3000:\\n            self.queue.pop(0)\\n            \\n        return self.queue.__len__()\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n#     O(n) || O(n)\\n# Runtime: 310ms 78.53% || memory: 19.6mb 46.67%\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (t - self.queue[0]) > 3000:\\n            self.queue.pop(0)\\n            \\n        return self.queue.__len__()\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142681,
                "title": "kotlin-concise-solution-with-a-queue-mutablelist",
                "content": "We instantiate a queue to keep track of the ping values. When we ping, we add to the queue and we dequeue items while `t - item > 3000`. The remaining items will all be pings that took place in the last 3000ms, so we can just return the size of the queue.\\n\\n```\\nclass RecentCounter(private val queue: MutableList<Int> = mutableListOf<Int>()) {\\n    fun ping(t: Int): Int {\\n        queue.add(t)\\n        while (t - queue[0] > 3000) queue.removeAt(0)\\n        return queue.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter(private val queue: MutableList<Int> = mutableListOf<Int>()) {\\n    fun ping(t: Int): Int {\\n        queue.add(t)\\n        while (t - queue[0] > 3000) queue.removeAt(0)\\n        return queue.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094027,
                "title": "python-deque",
                "content": "Some alternative solution with the Deque object which has Insertion or removal of elements at the end or beginning - constant O(1)\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        from collections import deque\\n        self.t = deque()\\n\\n    def ping(self, t: int) -> int:        \\n        while self.t and self.t[0] < t - 3000:\\n            self.t.popleft()\\n        self.t.append(t)\\n        return len(self.t)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        from collections import deque\\n        self.t = deque()\\n\\n    def ping(self, t: int) -> int:        \\n        while self.t and self.t[0] < t - 3000:\\n            self.t.popleft()\\n        self.t.append(t)\\n        return len(self.t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011643,
                "title": "java-queue",
                "content": "```\\nclass RecentCounter {\\n\\n    /**\\n     * Time Complexity: O(1)\\n     * Space Complexity: O(n)\\n     * @topic Number of Recent Calls\\n     * @author ArtistS\\n     */\\n    Queue<Integer> recentRequests;\\n    public RecentCounter() {\\n        recentRequests = new LinkedList<Integer>();\\n    }\\n\\n    public int ping(int t) {\\n        recentRequests.offer(t);\\n        while (recentRequests.peek() < t - 3000) {\\n            recentRequests.poll();\\n        }\\n        return recentRequests.size();\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    /**\\n     * Time Complexity: O(1)\\n     * Space Complexity: O(n)\\n     * @topic Number of Recent Calls\\n     * @author ArtistS\\n     */\\n    Queue<Integer> recentRequests;\\n    public RecentCounter() {\\n        recentRequests = new LinkedList<Integer>();\\n    }\\n\\n    public int ping(int t) {\\n        recentRequests.offer(t);\\n        while (recentRequests.peek() < t - 3000) {\\n            recentRequests.poll();\\n        }\\n        return recentRequests.size();\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981013,
                "title": "c-using-queue-easy-to-understand",
                "content": "class RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n if its help please don\\'t forget to upvote it \\uD83D\\uDE0A.",
                "solutionTags": [
                    "Array",
                    "Queue"
                ],
                "code": "class RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n if its help please don\\'t forget to upvote it \\uD83D\\uDE0A.",
                "codeTag": "Java"
            },
            {
                "id": 1889394,
                "title": "python-two-solutions-deque",
                "content": "Using a deque:\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while t - self.pings[0] > 3000:\\n            self.pings.popleft()\\n        return len(self.pings)\\n```\\n\\nOtherwise, using a list to save all the pings:\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n        self.start = 0\\n        self.cnt = 0\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        self.cnt += 1\\n        while t - self.pings[self.start] > 3000:\\n            self.start += 1\\n            self.cnt -= 1\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while t - self.pings[0] > 3000:\\n            self.pings.popleft()\\n        return len(self.pings)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n        self.start = 0\\n        self.cnt = 0\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        self.cnt += 1\\n        while t - self.pings[self.start] > 3000:\\n            self.start += 1\\n            self.cnt -= 1\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871821,
                "title": "java-queue-5-loc-super-easy-to-understand",
                "content": "```\\nclass RecentCounter {\\n    \\n    private Queue<Integer> q;\\n    \\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek() < t - 3000) {\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    \\n    private Queue<Integer> q;\\n    \\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek() < t - 3000) {\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841306,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.calls = []\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < t-3000:\\n            self.calls.pop(0)\\n        return len(self.calls)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.calls = []\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < t-3000:\\n            self.calls.pop(0)\\n        return len(self.calls)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526660,
                "title": "linear-solution-queue",
                "content": "```\\ntype RecentCounter struct {\\n    values []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{values: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    v := this.values\\n\\t// add the new values to the queue (end of slice)\\n    v = append(v, t)\\n    \\n    ind := 0\\n\\t// remove first elements till it\\'s in range we need [t-3000:t] (because every new t is bigger than previous)\\n    for ind<len(v) && v[ind] < t-3000 {\\n        ind++\\n    }\\n\\t// cut the first values that we don\\'t need anymore, cause they will not be in range for next queries\\n    this.values = v[ind:]\\n    \\n    return len(this.values)\\n}\\n ```\\n",
                "solutionTags": [],
                "code": "```\\ntype RecentCounter struct {\\n    values []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{values: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    v := this.values\\n\\t// add the new values to the queue (end of slice)\\n    v = append(v, t)\\n    \\n    ind := 0\\n\\t// remove first elements till it\\'s in range we need [t-3000:t] (because every new t is bigger than previous)\\n    for ind<len(v) && v[ind] < t-3000 {\\n        ind++\\n    }\\n\\t// cut the first values that we don\\'t need anymore, cause they will not be in range for next queries\\n    this.values = v[ind:]\\n    \\n    return len(this.values)\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445135,
                "title": "range-and-queues",
                "content": "```\\n queue<int> q; \\n    RecentCounter(){\\n    }\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < q.back()-3000) {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n queue<int> q; \\n    RecentCounter(){\\n    }\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < q.back()-3000) {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426727,
                "title": "c-queue-simple-queue-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(t-q.front()>3000){q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(t-q.front()>3000){q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327267,
                "title": "java-simple-solution-with-queues",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> q; \\n    \\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!q.isEmpty() && t - 3000 > q.peek()) q.remove();\\n        \\n        q.add(t);\\n        \\n        return q.size();\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n \\n ```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q; \\n    \\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!q.isEmpty() && t - 3000 > q.peek()) q.remove();\\n        \\n        q.add(t);\\n        \\n        return q.size();\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1324137,
                "title": "java-binary-search",
                "content": "```\\nclass RecentCounter {\\n    private ArrayList<Integer> req = new ArrayList<>();\\n    \\n    public RecentCounter() {\\n        this.req = new ArrayList<>();    \\n    }\\n    \\n    public int ping(int t) {\\n        req.add(t);\\n        int start = t - 3000;\\n        int idx = binarySearch(req, start);\\n        idx += req.get(idx) >= start ? 0 : 1;\\n        return req.size() - idx;\\n    }\\n    \\n    // find index of element >= k\\n    public int binarySearch(ArrayList<Integer> s, int k) {\\n        int n = s.size();\\n        int l = 0; \\n        int r = n-1;\\n        while (l < r) {\\n            int mid = (l+r)/2;\\n            if (s.get(mid) == k) return mid;\\n            if (s.get(mid) > k) r = mid-1;\\n            if (s.get(mid) < k) l = mid+1;\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private ArrayList<Integer> req = new ArrayList<>();\\n    \\n    public RecentCounter() {\\n        this.req = new ArrayList<>();    \\n    }\\n    \\n    public int ping(int t) {\\n        req.add(t);\\n        int start = t - 3000;\\n        int idx = binarySearch(req, start);\\n        idx += req.get(idx) >= start ? 0 : 1;\\n        return req.size() - idx;\\n    }\\n    \\n    // find index of element >= k\\n    public int binarySearch(ArrayList<Integer> s, int k) {\\n        int n = s.size();\\n        int l = 0; \\n        int r = n-1;\\n        while (l < r) {\\n            int mid = (l+r)/2;\\n            if (s.get(mid) == k) return mid;\\n            if (s.get(mid) > k) r = mid-1;\\n            if (s.get(mid) < k) l = mid+1;\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309447,
                "title": "java",
                "content": "class RecentCounter {\\n    List<Integer> a;\\n    public RecentCounter() {\\n        a=new ArrayList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        int n=1;\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            if(t-a.get(i)>3000)\\n                break;\\n            n++;\\n        }\\n        a.add(t);\\n        return n;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */",
                "solutionTags": [],
                "code": "class RecentCounter {\\n    List<Integer> a;\\n    public RecentCounter() {\\n        a=new ArrayList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        int n=1;\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            if(t-a.get(i)>3000)\\n                break;\\n            n++;\\n        }\\n        a.add(t);\\n        return n;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1296327,
                "title": "golang-solution-faster-than-100-with-quick-explanation",
                "content": "For this solution, we have got to look at something that is said in the problem description:\\n\\n> It is ***guaranteed*** that every call to ping uses a strictly larger value of `t` than the previous call.\\n\\nSo using that, we can make a variable (Which I called `k`) and store the position of the last position of the value that is greater than or equal to `t - 3000`. Then when we add a `t` to an array, and we can keep adding to `k` so we find the number of recent calls/\\n\\n``` go\\ntype RecentCounter struct {\\n    k int\\n    arr []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{0, []int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.arr = append(this.arr, t)\\n    \\n    for this.arr[this.k] < t - 3000 {\\n        this.k++\\n    }\\n    return len(this.arr) - this.k\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\ntype RecentCounter struct {\\n    k int\\n    arr []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{0, []int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.arr = append(this.arr, t)\\n    \\n    for this.arr[this.k] < t - 3000 {\\n        this.k++\\n    }\\n    return len(this.arr) - this.k\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280732,
                "title": "using-min-heap-c-easy-approach",
                "content": "class RecentCounter {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>res;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        res.push(t);\\n               while(t-res.top()>3000)\\n               {\\n                   res.pop();\\n               }\\n           return res.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "solutionTags": [],
                "code": "class RecentCounter {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>res;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        res.push(t);\\n               while(t-res.top()>3000)\\n               {\\n                   res.pop();\\n               }\\n           return res.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1204527,
                "title": "simple-c-solution",
                "content": "```\\n\\nclass RecentCounter {\\npublic:\\n    vector<int>v;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        int count=0;\\n        int l=t-3000;\\n        int u=t;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i]>=l && v[i]<=u)\\n                count++;\\nreturn count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass RecentCounter {\\npublic:\\n    vector<int>v;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        int count=0;\\n        int l=t-3000;\\n        int u=t;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i]>=l && v[i]<=u)\\n                count++;\\nreturn count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181188,
                "title": "python-3-straightforward-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n        \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < (t - 3000):\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n        \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < (t - 3000):\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166259,
                "title": "java-solution-100",
                "content": "```\\nclass RecentCounter {\\n    List<Integer> list;\\n    public RecentCounter() {\\n        list = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int range = t - 3000;\\n        while(range > list.get(0)){\\n            list.remove(0);\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    List<Integer> list;\\n    public RecentCounter() {\\n        list = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int range = t - 3000;\\n        while(range > list.get(0)){\\n            list.remove(0);\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105645,
                "title": "108-ms-runtime-faster-than-100-c-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    int counter;\\n    RecentCounter() {\\n        counter= 0;\\n    }\\n    queue<int> myQ;\\n    int ping(int t) {\\n        myQ.push(t);\\n        while(myQ.front()<(t-3000)){//[t - 3000, t]\\n            myQ.pop();\\n            counter--;\\n        }\\n        counter++;\\n        return counter;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    int counter;\\n    RecentCounter() {\\n        counter= 0;\\n    }\\n    queue<int> myQ;\\n    int ping(int t) {\\n        myQ.push(t);\\n        while(myQ.front()<(t-3000)){//[t - 3000, t]\\n            myQ.pop();\\n            counter--;\\n        }\\n        counter++;\\n        return counter;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036132,
                "title": "python3-sliding-window-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[0] < (t - 3000):\\n            self.counter.pop(0)\\n        return len(self.counter)\\n```\\nAnother way :-\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n        self.left = 0\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[self.left] < (t - 3000):\\n            self.left += 1\\n        return len(self.counter[self.left:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[0] < (t - 3000):\\n            self.counter.pop(0)\\n        return len(self.counter)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n        self.left = 0\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[self.left] < (t - 3000):\\n            self.left += 1\\n        return len(self.counter[self.left:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023185,
                "title": "python-solution",
                "content": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975776,
                "title": "priorityqueue-soln-java",
                "content": "```\\nclass RecentCounter {\\n\\n    PriorityQueue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000)\\n            queue.poll();\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    PriorityQueue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000)\\n            queue.poll();\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949641,
                "title": "binary-search-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> v;\\n    \\n    RecentCounter() {\\n       \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        \\n        int low = t - 3000;\\n        int high = t;\\n        \\n        auto lowIdx = lower_bound(v.begin(), v.end(), low);\\n        auto highIdx = upper_bound(v.begin(), v.end(), high);\\n        \\n        return highIdx - lowIdx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> v;\\n    \\n    RecentCounter() {\\n       \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        \\n        int low = t - 3000;\\n        int high = t;\\n        \\n        auto lowIdx = lower_bound(v.begin(), v.end(), low);\\n        auto highIdx = upper_bound(v.begin(), v.end(), high);\\n        \\n        return highIdx - lowIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915985,
                "title": "5-lines-easy-soln-beat-99-21-soln-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic: queue<int>q;\\n    RecentCounter() {\\n      }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)\\n        {q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n```\\nhappy coding :)\\nplease upvote",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic: queue<int>q;\\n    RecentCounter() {\\n      }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)\\n        {q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906722,
                "title": "c-queue",
                "content": "```\\nclass RecentCounter {\\n    queue<int> requests;\\n    int counter;\\npublic:\\n    RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    int ping(int t) {\\n        requests.push(t);\\n        counter++;\\n        while(requests.front() < t-3000) {\\n            requests.pop();\\n            counter--;\\n        }\\n        return counter;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    queue<int> requests;\\n    int counter;\\npublic:\\n    RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    int ping(int t) {\\n        requests.push(t);\\n        counter++;\\n        while(requests.front() < t-3000) {\\n            requests.pop();\\n            counter--;\\n        }\\n        return counter;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896064,
                "title": "python-3-manual-binary-search",
                "content": "```\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        low = 0\\n        high = len(self.pings)-1\\n        while low<=high:\\n            mid = low + ((high-low)//2)\\n            if self.pings[mid] < t-3000:\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return len(self.pings)-max(high,low)\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        low = 0\\n        high = len(self.pings)-1\\n        while low<=high:\\n            mid = low + ((high-low)//2)\\n            if self.pings[mid] < t-3000:\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return len(self.pings)-max(high,low)\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 888330,
                "title": "simple-python-without-recursion",
                "content": "Because t always increasing, we can use a loop to drop values from our list of pings until the value is greater than or equal to the minimum window for the most recent ping. There is no requirement to keep all of the timings, so we can remove each value that doesn\\'t fall in the range. This will shorten the loop for future pings. Then the number of pings in the range is just the length of our list of pings.\\n\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pingTimes = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pingTimes.append(t)\\n        i = 0\\n        while self.pingTimes[i] < t - 3000:\\n            self.pingTimes.pop(i)\\n        \\n        return len(self.pingTimes)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pingTimes = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pingTimes.append(t)\\n        i = 0\\n        while self.pingTimes[i] < t - 3000:\\n            self.pingTimes.pop(i)\\n        \\n        return len(self.pingTimes)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882160,
                "title": "c-simple-short-solution-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() \\n    {\\n        queue<int> temp;\\n        q=temp;\\n    }\\n    \\n    int ping(int t) \\n    {\\n        q.push(t);\\n        while(!q.empty()&&q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() \\n    {\\n        queue<int> temp;\\n        q=temp;\\n    }\\n    \\n    int ping(int t) \\n    {\\n        q.push(t);\\n        while(!q.empty()&&q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875595,
                "title": "recent-counter-c-3-line",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {}\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)q.pop();\\n        return q.size();\\n    }    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {}\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)q.pop();\\n        return q.size();\\n    }    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874715,
                "title": "python-number-of-recent-calls-easy-solution-using-priority-queue",
                "content": "```py\\nimport heapq\\nfrom typing import List\\n\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.timestamps: List[int] = []\\n\\n    def ping(self, t: int) -> int:\\n        heapq.heappush(self.timestamps, t)\\n        limit = t - 3000\\n        while self.timestamps[0] < limit:\\n            self.timestamps.pop(0)\\n        return len(self.timestamps)\\n\\n```",
                "solutionTags": [],
                "code": "```py\\nimport heapq\\nfrom typing import List\\n\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.timestamps: List[int] = []\\n\\n    def ping(self, t: int) -> int:\\n        heapq.heappush(self.timestamps, t)\\n        limit = t - 3000\\n        while self.timestamps[0] < limit:\\n            self.timestamps.pop(0)\\n        return len(self.timestamps)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874688,
                "title": "c-3-lines-simple-o-n-time-o-1-o-3000-space",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.size() && q.front() < (t - 3000)) q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.size() && q.front() < (t - 3000)) q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874631,
                "title": "python-binary-search-a-bit-slower-but-effective-and-easy-to-understand",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p=[]   \\n\\n    def ping(self, t: int) -> int:\\n        self.p.append(t)\\n        if(t<=3000):\\n            return len(self.p)\\n        else:\\n            target=t-3000\\n            s,e=0,len(self.p)\\n            while(s<=e):\\n                mid=(s+e)//2\\n                if(self.p[mid]==target):\\n                    return len(self.p[mid:])\\n                elif(self.p[mid]<target):\\n                    s=mid+1\\n                else:\\n                    e=mid-1\\n            return len(self.p[s:])\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p=[]   \\n\\n    def ping(self, t: int) -> int:\\n        self.p.append(t)\\n        if(t<=3000):\\n            return len(self.p)\\n        else:\\n            target=t-3000\\n            s,e=0,len(self.p)\\n            while(s<=e):\\n                mid=(s+e)//2\\n                if(self.p[mid]==target):\\n                    return len(self.p[mid:])\\n                elif(self.p[mid]<target):\\n                    s=mid+1\\n                else:\\n                    e=mid-1\\n            return len(self.p[s:])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874622,
                "title": "anyone-can-understand-this-solution",
                "content": "```\\nclass RecentCounter {\\n\\n    CustomeLL root = null;//current node at time t\\n    CustomeLL prev = null;//last node, in range of 3000\\n    \\n    int time_interval = 3000;\\n    \\n    int request_count = 0;//number of request\\n    \\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        if(root==null){\\n            root = new CustomeLL(t);\\n            prev = root;\\n            request_count++;\\n        }else{\\n            root.next = new CustomeLL(t);\\n            root = root.next;\\n            request_count++; //when new time added, increment count\\n            \\n            //check if last time and current time is in range of 3000\\n            while(prev!=root && root.t-prev.t>time_interval){\\n                prev = prev.next;\\n                request_count--;\\n            }\\n        }\\n        return request_count;\\n    }\\n}\\n//cutome linked List\\nclass CustomeLL{\\n    CustomeLL next;\\n    int t;\\n    CustomeLL(int t){\\n        this.t = t;\\n        this.next = null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    CustomeLL root = null;//current node at time t\\n    CustomeLL prev = null;//last node, in range of 3000\\n    \\n    int time_interval = 3000;\\n    \\n    int request_count = 0;//number of request\\n    \\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        if(root==null){\\n            root = new CustomeLL(t);\\n            prev = root;\\n            request_count++;\\n        }else{\\n            root.next = new CustomeLL(t);\\n            root = root.next;\\n            request_count++; //when new time added, increment count\\n            \\n            //check if last time and current time is in range of 3000\\n            while(prev!=root && root.t-prev.t>time_interval){\\n                prev = prev.next;\\n                request_count--;\\n            }\\n        }\\n        return request_count;\\n    }\\n}\\n//cutome linked List\\nclass CustomeLL{\\n    CustomeLL next;\\n    int t;\\n    CustomeLL(int t){\\n        this.t = t;\\n        this.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874365,
                "title": "javascript-clean-code-beat-99",
                "content": "```javascript\\nclass RecentCounter {\\n    constructor() {\\n        this.queue = [];\\n    }\\n    \\n    ping(t) {\\n        this.queue.push(t);\\n        while(this.queue[0] < t - 3000) this.queue.shift();\\n        return this.queue.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RecentCounter {\\n    constructor() {\\n        this.queue = [];\\n    }\\n    \\n    ping(t) {\\n        this.queue.push(t);\\n        while(this.queue[0] < t - 3000) this.queue.shift();\\n        return this.queue.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874330,
                "title": "java-using-a-minheap-to-store-the-recent-pings",
                "content": "\\n```\\nclass RecentCounter {\\n    private static final int MAX_DURATION = 3000;\\n    private Queue<Integer> recentPings;\\n\\n    public RecentCounter() {\\n        this.recentPings = new PriorityQueue<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!recentPings.isEmpty() && (t - recentPings.peek()) > MAX_DURATION) {\\n            recentPings.remove();\\n        }\\n        recentPings.add(t);\\n        return recentPings.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private static final int MAX_DURATION = 3000;\\n    private Queue<Integer> recentPings;\\n\\n    public RecentCounter() {\\n        this.recentPings = new PriorityQueue<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!recentPings.isEmpty() && (t - recentPings.peek()) > MAX_DURATION) {\\n            recentPings.remove();\\n        }\\n        recentPings.add(t);\\n        return recentPings.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874304,
                "title": "python-3-solution-using-list-runtime-beats-98-34",
                "content": "1. In the __init__ method, initialize requests list and size to 0.\\n2. In the ping method, when there is a ping and t is passed to it, add t to the requests lists and increment the size by 1.\\n3. If the first call in the requests list is more than or equal to t - 3000, then return the size.\\n4. Otherwise, remove from the requests list all the calls before t - 3000 and everytime a call is deleted using pop on the requests list, decrement the size by 1.\\nReturn the size.\\n\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.requests = []\\n        self.size = 0\\n    \\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        self.size += 1\\n        \\n        while self.requests[0] < t - 3000:\\n            self.requests.pop(0)\\n            self.size -= 1\\n            \\n        return(self.size)\\n            \\n    \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.requests = []\\n        self.size = 0\\n    \\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        self.size += 1\\n        \\n        while self.requests[0] < t - 3000:\\n            self.requests.pop(0)\\n            self.size -= 1\\n            \\n        return(self.size)\\n            \\n    \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874298,
                "title": "java-ring-buffer-bs-solution-99-perfomance",
                "content": "I expected more perfomance for my solution. WIth predef ring buffer. UPDATED\\nNew optimized solution:\\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n     public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n\\n        int value = t - THRESHOLD + 1;\\n\\n        int l = 0;\\n        int r = length;\\n        int shift = head - length;\\n         \\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) \\n                return length = mShift > head ? THRESHOLD - mShift + head + 1 : head + 1 - mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        int lShift = (THRESHOLD + (l + shift)) % THRESHOLD;\\n\\n        return length = lShift > head ? THRESHOLD - lShift + head + 1 : head + 1 - lShift;\\n    }\\n    \\n}\\n```\\n\\n\\nOld one:\\n\\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int tail = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n    public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n        if (head == tail || tail == -1) {\\n            tail = ++tail % THRESHOLD;\\n        }\\n        length = Math.min(length + 1, THRESHOLD);\\n\\n        int idx = findIdx(t - THRESHOLD + 1);\\n        length -= idx >= tail ? idx - tail : head - idx;\\n        tail = idx;\\n      \\n        return tail > head ? head + (THRESHOLD - tail + 1) : head - tail + 1;\\n    }\\n\\n    private int findIdx(int value) {\\n        int l = 0;\\n        int r = length - 1;\\n        int shift = head - (length - 1);\\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) return mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        return (THRESHOLD + (l + shift)) % THRESHOLD;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n     public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n\\n        int value = t - THRESHOLD + 1;\\n\\n        int l = 0;\\n        int r = length;\\n        int shift = head - length;\\n         \\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) \\n                return length = mShift > head ? THRESHOLD - mShift + head + 1 : head + 1 - mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        int lShift = (THRESHOLD + (l + shift)) % THRESHOLD;\\n\\n        return length = lShift > head ? THRESHOLD - lShift + head + 1 : head + 1 - lShift;\\n    }\\n    \\n}\\n```\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int tail = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n    public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n        if (head == tail || tail == -1) {\\n            tail = ++tail % THRESHOLD;\\n        }\\n        length = Math.min(length + 1, THRESHOLD);\\n\\n        int idx = findIdx(t - THRESHOLD + 1);\\n        length -= idx >= tail ? idx - tail : head - idx;\\n        tail = idx;\\n      \\n        return tail > head ? head + (THRESHOLD - tail + 1) : head - tail + 1;\\n    }\\n\\n    private int findIdx(int value) {\\n        int l = 0;\\n        int r = length - 1;\\n        int shift = head - (length - 1);\\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) return mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        return (THRESHOLD + (l + shift)) % THRESHOLD;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874257,
                "title": "number-of-recent-calls-java-queue",
                "content": "```\\nclass RecentCounter {\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue= new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        \\n        int start = t-3000;\\n        while(!queue.isEmpty() && queue.peek()<start) queue.poll();\\n        \\n        queue.add(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue= new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        \\n        int start = t-3000;\\n        while(!queue.isEmpty() && queue.peek()<start) queue.poll();\\n        \\n        queue.add(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874195,
                "title": "simple-javascript",
                "content": "```\\nvar RecentCounter = function() {\\n    this.req = [];\\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.req.push(t);\\n    let range = [t - 3000, t];\\n    let res = 0;\\n    for (let i = 0; i < this.req.length; i++)\\n    {\\n        if (this.req[i] >= range[0] && this.req[i] <= range[1])\\n            res++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar RecentCounter = function() {\\n    this.req = [];\\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.req.push(t);\\n    let range = [t - 3000, t];\\n    let res = 0;\\n    for (let i = 0; i < this.req.length; i++)\\n    {\\n        if (this.req[i] >= range[0] && this.req[i] <= range[1])\\n            res++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874125,
                "title": "java-faster-than-99",
                "content": "I had a variable to track the index of the lowest ping time within the valid range (most recent time - 3000), and updated it each time I added a time to the list.\\n\\n```\\nclass RecentCounter {\\n\\n    /**\\n     * List of all ping requests made.\\n     */\\n    private List<Integer> requests;\\n    \\n    /**\\n     * The index containing the the first element whose value is at most 3000\\n     * less than the last element.\\n     */\\n    private int minIndex;\\n    \\n    public RecentCounter() {\\n        requests = new ArrayList<>();\\n        minIndex = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        requests.add(t); // Add new request\\n        \\n        // Increment minIndex until the element at minIndex is the first element in the 3000 range\\n        while(requests.get(minIndex) < t - 3000 && minIndex < requests.size() - 1) minIndex++;\\n        \\n        \\n        // Number of requests in range is the number of total requests minus\\n        // the index of the first element in the range\\n        return requests.size() - minIndex;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    /**\\n     * List of all ping requests made.\\n     */\\n    private List<Integer> requests;\\n    \\n    /**\\n     * The index containing the the first element whose value is at most 3000\\n     * less than the last element.\\n     */\\n    private int minIndex;\\n    \\n    public RecentCounter() {\\n        requests = new ArrayList<>();\\n        minIndex = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        requests.add(t); // Add new request\\n        \\n        // Increment minIndex until the element at minIndex is the first element in the 3000 range\\n        while(requests.get(minIndex) < t - 3000 && minIndex < requests.size() - 1) minIndex++;\\n        \\n        \\n        // Number of requests in range is the number of total requests minus\\n        // the index of the first element in the range\\n        return requests.size() - minIndex;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 873933,
                "title": "c-very-simple-using-queue-100-runtime",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        while(!q_.empty() && q_.front() + 3000 < t) {\\n            q_.pop_front();\\n        }\\n        q_.push_back(t);\\n        return q_.size();\\n    }\\n\\nprivate:\\n    deque<int> q_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        while(!q_.empty() && q_.front() + 3000 < t) {\\n            q_.pop_front();\\n        }\\n        q_.push_back(t);\\n        return q_.size();\\n    }\\n\\nprivate:\\n    deque<int> q_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873829,
                "title": "double-ended-queue-solution-in-rust",
                "content": "```\\nuse std::collections::VecDeque;\\nuse std::cell::RefCell;\\n\\nstruct RecentCounter {\\n    reqs: RefCell<VecDeque<i32>>,\\n}\\n\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        Self { reqs: RefCell::new(VecDeque::new()) }\\n    }\\n    \\n    fn ping(&self, t: i32) -> i32 {\\n        let mut reqs = self.reqs.borrow_mut();\\n        reqs.push_back(t);\\n        while reqs.front().unwrap() < &(t - 3000) {\\n            reqs.pop_front();\\n        }\\n        reqs.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::VecDeque;\\nuse std::cell::RefCell;\\n\\nstruct RecentCounter {\\n    reqs: RefCell<VecDeque<i32>>,\\n}\\n\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        Self { reqs: RefCell::new(VecDeque::new()) }\\n    }\\n    \\n    fn ping(&self, t: i32) -> i32 {\\n        let mut reqs = self.reqs.borrow_mut();\\n        reqs.push_back(t);\\n        while reqs.front().unwrap() < &(t - 3000) {\\n            reqs.pop_front();\\n        }\\n        reqs.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873712,
                "title": "java-recent-calls-97-queue-well-explained-max-space-time-of-3k-constant-space",
                "content": "\\nSince we need to store only recent events, to avoid filling up space, we should remove older elements with event time greater than 3000.\\nSo for any event, if it\\'s event time is less than , current time - 3000, ie. if eventTime < t-3000, remove that event.\\nWe initially store all the event in a queue,  Basically store an event time in a queue.\\n\\nThe size of queue gives total number of events.\\nSince we are removing older elements, we ONLY have elements in the queue within 3000 time limit.\\nHence we return the queue size everytime.\\nWe dequeue elements from the queue, until all old elements are removed.\\n\\n```\\nclass RecentCounter {\\n\\n    Queue<Integer> recentEvents;\\n    \\n    public RecentCounter() {\\n      recentEvents = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        //while queue is not empty, and still holds events with event time more than 3000, remove those events\\n        while(recentEvents.size()>0 && recentEvents.peek()<t-3000){\\n            recentEvents.remove();\\n        }\\n        recentEvents.add(t);\\n        return recentEvents.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    Queue<Integer> recentEvents;\\n    \\n    public RecentCounter() {\\n      recentEvents = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        //while queue is not empty, and still holds events with event time more than 3000, remove those events\\n        while(recentEvents.size()>0 && recentEvents.peek()<t-3000){\\n            recentEvents.remove();\\n        }\\n        recentEvents.add(t);\\n        return recentEvents.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873705,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n\\n    public RecentCounter() {\\n        pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return a - b;\\n            }\\n        });\\n    }\\n    \\n    public int ping(int t) {\\n        pq.add(t);\\n        while(!pq.isEmpty() && pq.peek() < (t - 3000)) {\\n            pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n\\n    public RecentCounter() {\\n        pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return a - b;\\n            }\\n        });\\n    }\\n    \\n    public int ping(int t) {\\n        pq.add(t);\\n        while(!pq.isEmpty() && pq.peek() < (t - 3000)) {\\n            pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873380,
                "title": "question-explained-python-code-video-code",
                "content": "[](https://www.youtube.com/watch?v=NtNeA48tJDk)\\nhttps://www.youtube.com/watch?v=NtNeA48tJDk\\n```\\nimport collections\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nimport collections\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873355,
                "title": "c-simplest-solution-possible-beats-100-with-explanation-comments",
                "content": "```\\nclass RecentCounter {\\npublic:\\n\\t// Queue for storing requests\\n    queue<int> req;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        // If the queue contains elements which will not come in the [t-3000, t] range then pop them.\\n\\t\\t// Example: Queue: [24, 42, 45, 90] and the request comes at 6000 sec.\\n\\t\\t// Then we have to pop all the elements in the queue as they don\\'t fit into [3000, 6000] range.\\n\\t\\t\\n        while(!req.empty() && req.front() + 3000 < t){\\n            req.pop();\\n        }\\n        // Now, pushing the current request.\\n        req.push(t);\\n\\t\\t// The size of the queue will be the answer as the elements will be in the range [t-3000, t].\\n        return req.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n\\t// Queue for storing requests\\n    queue<int> req;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        // If the queue contains elements which will not come in the [t-3000, t] range then pop them.\\n\\t\\t// Example: Queue: [24, 42, 45, 90] and the request comes at 6000 sec.\\n\\t\\t// Then we have to pop all the elements in the queue as they don\\'t fit into [3000, 6000] range.\\n\\t\\t\\n        while(!req.empty() && req.front() + 3000 < t){\\n            req.pop();\\n        }\\n        // Now, pushing the current request.\\n        req.push(t);\\n\\t\\t// The size of the queue will be the answer as the elements will be in the range [t-3000, t].\\n        return req.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873318,
                "title": "java-easy-to-understand-concise-queue",
                "content": "**if helpful.... please do Upvote**\\n**Time / space Complexity: O(Math.min(N, 3000))**\\n```\\nclass RecentCounter {\\n    \\n    // It actually means the total numbers of pings within its range 3000.\\n    // 1 then count total number 1 (1-3001)\\n    // 2 then count total number 2 because previous 1 is also within its 3000 range. (1-3001)\\n    // then 3001 count total number 3 because 1 , 2 is within its 3000 range. ( also from 1- 3001)\\n    // then 3302 count total number 3 because 1 is out of its range and be omitted,\\n\\t//but then add 3002 itself. the total number 3 here is not the same meaning as previous total number 3( here is 2-3002, previous 3 is 1-3001)\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue=new LinkedList<>();       \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.peek()<t-3000){\\n            queue.remove();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    \\n    // It actually means the total numbers of pings within its range 3000.\\n    // 1 then count total number 1 (1-3001)\\n    // 2 then count total number 2 because previous 1 is also within its 3000 range. (1-3001)\\n    // then 3001 count total number 3 because 1 , 2 is within its 3000 range. ( also from 1- 3001)\\n    // then 3302 count total number 3 because 1 is out of its range and be omitted,\\n\\t//but then add 3002 itself. the total number 3 here is not the same meaning as previous total number 3( here is 2-3002, previous 3 is 1-3001)\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue=new LinkedList<>();       \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.peek()<t-3000){\\n            queue.remove();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873306,
                "title": "c-easy-and-short-solution-queue",
                "content": "```\\nclass RecentCounter {\\n    priority_queue<int, vector<int>, greater<int> > pq;\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        while( !pq.empty() && t - 3000 > pq.top() ) \\n            pq.pop(); \\n        pq.push(t);\\n        return pq.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    priority_queue<int, vector<int>, greater<int> > pq;\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        while( !pq.empty() && t - 3000 > pq.top() ) \\n            pq.pop(); \\n        pq.push(t);\\n        return pq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873192,
                "title": "number-of-recent-calls-cpp",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> a;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        int c=0;\\n        int min=t-3000>t?t:t-3000;\\n        int max=t-3000>t?t-3000:t;\\n        a.push_back(t);\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<min){\\n                c++;\\n            }\\n        }\\n     return a.size()-c;   \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> a;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        int c=0;\\n        int min=t-3000>t?t:t-3000;\\n        int max=t-3000>t?t-3000:t;\\n        a.push_back(t);\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<min){\\n                c++;\\n            }\\n        }\\n     return a.size()-c;   \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 722615,
                "title": "c-here-s-my-approach-pretty-hard-to-understand-question-simple-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> prev;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        if(prev.empty()){\\n            prev.push_back(t);\\n            return 1;\\n        }\\n        else{\\n            int val = t - 3000;\\n            int count = 0;\\n            for(int i = prev.size() -1 ;i>=0 && val <= prev[i];i--){\\n                count++;\\n            }\\n            if(count == 0)  prev.clear();\\n            prev.push_back(t);\\n            return count + 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> prev;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        if(prev.empty()){\\n            prev.push_back(t);\\n            return 1;\\n        }\\n        else{\\n            int val = t - 3000;\\n            int count = 0;\\n            for(int i = prev.size() -1 ;i>=0 && val <= prev[i];i--){\\n                count++;\\n            }\\n            if(count == 0)  prev.clear();\\n            prev.push_back(t);\\n            return count + 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 662551,
                "title": "simple-solution-by-python-3",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while self.pings[0] < t - 3000:\\n            self.pings.pop(0)\\n        return len(self.pings)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while self.pings[0] < t - 3000:\\n            self.pings.pop(0)\\n        return len(self.pings)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627188,
                "title": "go-solution-with-queue",
                "content": "``` go\\nimport \"container/list\"\\n\\ntype RecentCounter struct {\\n\\tqueue *list.List\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{queue: list.New()}\\n}\\n\\n// Learning: Elements from the list need to be cast into specific type before being used.\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue.PushBack(t)\\n\\tfor this.queue.Front().Value.(int) < t-3000 {\\n\\t\\tthis.queue.Remove(this.queue.Front())\\n\\t}\\n\\n\\treturn this.queue.Len()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nimport \"container/list\"\\n\\ntype RecentCounter struct {\\n\\tqueue *list.List\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{queue: list.New()}\\n}\\n\\n// Learning: Elements from the list need to be cast into specific type before being used.\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue.PushBack(t)\\n\\tfor this.queue.Front().Value.(int) < t-3000 {\\n\\t\\tthis.queue.Remove(this.queue.Front())\\n\\t}\\n\\n\\treturn this.queue.Len()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 600880,
                "title": "simple-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass RecentCounter {\\n    private final Queue<Integer> queue = new LinkedList<>();\\n    \\n    public int ping(int t) {\\n        while (!queue.isEmpty() && queue.peek() < t - 3000)\\n            queue.poll();\\n        queue.offer(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private final Queue<Integer> queue = new LinkedList<>();\\n    \\n    public int ping(int t) {\\n        while (!queue.isEmpty() && queue.peek() < t - 3000)\\n            queue.poll();\\n        queue.offer(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583861,
                "title": "java-100-faster-solution",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.offer(t);\\n        while(queue.peek() < (t - 3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.offer(t);\\n        while(queue.peek() < (t - 3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581876,
                "title": "go-clean-code-112ms-beats-100",
                "content": "```\\ntype RecentCounter struct {\\n\\tqueue []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue = append(this.queue, t)\\n\\tfor this.queue[0]+3000 < t {\\n\\t\\tthis.queue = this.queue[1:]\\n\\t}\\n\\treturn len(this.queue)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype RecentCounter struct {\\n\\tqueue []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue = append(this.queue, t)\\n\\tfor this.queue[0]+3000 < t {\\n\\t\\tthis.queue = this.queue[1:]\\n\\t}\\n\\treturn len(this.queue)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 572853,
                "title": "if-u-understood-the-q-its-a-joke",
                "content": "**Let me explain the Q first in simpler words**\\nAccording to  the Q at a time **t** when a message pings then it will stay in the notification till 3000 ms after that it will disappear.We need to tell the number of messages in notifications at time t when the current ping is done.\\n\\nSay \\nt=**0** ,, notification= 0 **(1)**\\nt=**100** ,, notification= 0,100 **(2)**\\nt=**1500** ,, notification= 0,100,1500 **(3)**\\nt=**3001** ,, notification= 100,1500,3001 **(3)**\\n**(Notice that at t=3001ms notificcation message which arrived at 0ms disappeared)**\\nt=**3099** ,, norification = 100,1500,3001,3099 **(4)**\\nt=**3101** ,, notification= 1500,3001,3099,3101 **(4)**\\n**(Notice that at t=3101ms notificcation message which arrived at 100ms disappeared)**\\n\\n\\nSo logic is simple the one at first come will first go so we need just a queue\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);                                               //At time t only [(t-3000)->t] will remain in the queue\\n        while(q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);                                               //At time t only [(t-3000)->t] will remain in the queue\\n        while(q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547013,
                "title": "ruby-solution-with-custom-kueue-class",
                "content": "```\\nclass RecentCounter\\n    def initialize()\\n        @queue = Kueue.new\\n    end\\n\\n\\n=begin\\n    :type t: Integer\\n    :rtype: Integer\\n=end\\n    def ping(t)\\n        @queue.enq(t)\\n        if @queue.size > 0\\n            while t - @queue.peek > 3000\\n                @queue.shift\\n            end\\n        end\\n        @queue.size\\n    end\\n\\n\\nend\\n\\nclass Kueue\\n   \\n    attr_reader :kueue \\n    \\n    def initialize\\n        @kueue = []\\n    end\\n    \\n    def peek\\n        kueue[0]\\n    end\\n    \\n    def enq(x)\\n        @kueue << x\\n    end\\n    \\n    def shift\\n        @kueue.shift\\n    end\\n    \\n    def size\\n       kueue.length \\n    end\\nend\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter.new()\\n# param_1 = obj.ping(t)\\n```\\n\\nRuby\\'s built-in queue class does not support peeking at the first item without removing it. \\xAF\\\\\\\\_(\\u30C4)_/\\xAF Faster than 45.45% of solutions, 100% less memory. \\n\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter\\n    def initialize()\\n        @queue = Kueue.new\\n    end\\n\\n\\n=begin\\n    :type t: Integer\\n    :rtype: Integer\\n=end\\n    def ping(t)\\n        @queue.enq(t)\\n        if @queue.size > 0\\n            while t - @queue.peek > 3000\\n                @queue.shift\\n            end\\n        end\\n        @queue.size\\n    end\\n\\n\\nend\\n\\nclass Kueue\\n   \\n    attr_reader :kueue \\n    \\n    def initialize\\n        @kueue = []\\n    end\\n    \\n    def peek\\n        kueue[0]\\n    end\\n    \\n    def enq(x)\\n        @kueue << x\\n    end\\n    \\n    def shift\\n        @kueue.shift\\n    end\\n    \\n    def size\\n       kueue.length \\n    end\\nend\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter.new()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529902,
                "title": "c-this-question-sucks-heres-a-commented-90-queue-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    std::queue<int> q;\\n    RecentCounter() {\\n        return;\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n\\t\\t// Remove all pings that are too old\\n        while(!q.empty() and q.front() < t - 3000) q.pop();\\n\\t\\t// Return how many pings remain\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    std::queue<int> q;\\n    RecentCounter() {\\n        return;\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n\\t\\t// Remove all pings that are too old\\n        while(!q.empty() and q.front() < t - 3000) q.pop();\\n\\t\\t// Return how many pings remain\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489645,
                "title": "c-using-queues",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> que;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        this->que.push(t);\\n        while(que.front()<(t-3000))\\n        {\\n            que.pop();\\n        }\\n        return que.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> que;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        this->que.push(t);\\n        while(que.front()<(t-3000))\\n        {\\n            que.pop();\\n        }\\n        return que.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485711,
                "title": "simple-js-100-memory-and-100-time-optimal",
                "content": "\\n```\\nvar RecentCounter = function() {\\n    this.arr = [];\\n    this.start = 0;\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.arr.push(t);\\n    while(this.arr[this.start] < t - 3000) {\\n        this.start++;\\n    }\\n    return this.arr.length - this.start;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RecentCounter = function() {\\n    this.arr = [];\\n    this.start = 0;\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.arr.push(t);\\n    while(this.arr[this.start] < t - 3000) {\\n        this.start++;\\n    }\\n    return this.arr.length - this.start;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476693,
                "title": "python-by-double-ended-queue-run-time-90-with-explanation",
                "content": "Python by double-ended queue\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        \\n        # a double-ended queue that keep fresh calls in math interval [t-3000, t]\\n        self.call_queue = collections.deque()\\n\\n\\n\\n    def ping(self, t: int) -> int:\\n        \\n        # pop out-of-date calls which calling time is smaller than t-3000 on the front\\n        while self.call_queue and self.call_queue[0] < t-3000:    \\n            self.call_queue.popleft()\\n        \\n        \\n        # push in-coming call on the rear\\n        self.call_queue.append(t)\\n        \\n        \\n        return len(self.call_queue)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        \\n        # a double-ended queue that keep fresh calls in math interval [t-3000, t]\\n        self.call_queue = collections.deque()\\n\\n\\n\\n    def ping(self, t: int) -> int:\\n        \\n        # pop out-of-date calls which calling time is smaller than t-3000 on the front\\n        while self.call_queue and self.call_queue[0] < t-3000:    \\n            self.call_queue.popleft()\\n        \\n        \\n        # push in-coming call on the rear\\n        self.call_queue.append(t)\\n        \\n        \\n        return len(self.call_queue)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469308,
                "title": "short-kotlin-solution",
                "content": "```\\nclass RecentCounter() {\\n    \\n    var pings = listOf<Int>()\\n    \\n    fun ping(t: Int): Int {\\n        pings = pings.filter {it in (t - 3000)..t} + t\\n        return pings.size\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter() {\\n    \\n    var pings = listOf<Int>()\\n    \\n    fun ping(t: Int): Int {\\n        pings = pings.filter {it in (t - 3000)..t} + t\\n        return pings.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459575,
                "title": "c-solution-queue-t",
                "content": "Every time Ping is called we use the queue to remove any times that happened more than 3000 ms ago. The queue data struture is ideal for this problem because the oldest pings are stored at the end of the queue. When we get a new ping we just dequeue pings while they are invalid. Then we enque the new ping timestamp and return the Count value of our queue.\\n\\nAlso I made a custom queue that I used to solve the problem on my first attempt.  The custom queue was mainly created as an exercise to understand how a variable size queue is actually stored and the result is a bit rough I think. I included it below, but feel free to ignore it.\\n\\nBasically the queue keeps grows like a circular array until it is full, then all the contents are copied into a new array that is double the size of the previous one. I did not code in any mechanism for the array container to shrink though.\\n\\n```\\npublic class RecentCounter\\n    {\\n\\n        Queue<int> queue;\\n        public RecentCounter()\\n        {\\n            queue = new Queue<int>();\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            \\n            for (int i = 0; i < queue.Count; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            queue.Enqueue(t);\\n            return queue.Count;\\n        }\\n    }\\n\\t\\n\\tpublic class RecentCounterCustomQueue\\n    {\\n\\n        VariableSizeQueue<int> queue;\\n        public RecentCounterCustomQueue()\\n        {\\n            queue = new VariableSizeQueue<int>(10, -1);\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            queue.Enqueue(t);\\n            int startingCount = queue.Count - 1;\\n            for (int i = 0; i < startingCount; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            return queue.Count;\\n        }\\n    }\\n\\n    public class VariableSizeQueue<T>\\n    {\\n        public VariableSizeQueue(int capacity, T sentinelValue)\\n        {\\n            QueueInternal = new T[capacity];\\n            this.SentinelValue = sentinelValue;\\n        }\\n\\n        public T SentinelValue;\\n        public int Capacity\\n        {\\n            get => QueueInternal.Length;\\n        }\\n        public int Count = 0;\\n        public T[] QueueInternal;\\n\\n        public int QueueHeadIndex = 0;\\n        public int QueueTailIndex = 0;\\n\\n        public void Enqueue(T item)\\n        {\\n            if (QueueTailIndex == QueueHeadIndex && Count != 0)\\n                ResizeQueue();\\n            QueueInternal[QueueTailIndex] = item;\\n            Count++;\\n            QueueTailIndex = (QueueTailIndex + 1) % Capacity;\\n        }\\n\\n        //only called internally when all queue is completly full\\n        private void ResizeQueue()\\n        {\\n            //Create a new Queue starting from the beginning\\n            T[] resizedQueue = new T[Capacity * 2];\\n            int j = 0;\\n            for (int i = QueueHeadIndex; j < Capacity; i = (i + 1) % Capacity)\\n            {\\n                resizedQueue[j] = QueueInternal[i];\\n                j++;\\n            }\\n\\n            //change all of the pointers\\n            QueueHeadIndex = 0;\\n            QueueTailIndex = (Capacity);//tail will go one index to the end of old data\\n\\n            QueueInternal = resizedQueue;\\n        }\\n\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n            return QueueInternal[QueueHeadIndex];\\n        }\\n\\n        public T Dequeue()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n\\n            T head = QueueInternal[QueueHeadIndex];\\n            QueueInternal[QueueHeadIndex] = SentinelValue;\\n            QueueHeadIndex = (QueueHeadIndex + 1) % Capacity;\\n            Count--;\\n            return head;\\n        }\\n\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "Every time Ping is called we use the queue to remove any times that happened more than 3000 ms ago. The queue data struture is ideal for this problem because the oldest pings are stored at the end of the queue. When we get a new ping we just dequeue pings while they are invalid. Then we enque the new ping timestamp and return the Count value of our queue.\\n\\nAlso I made a custom queue that I used to solve the problem on my first attempt.  The custom queue was mainly created as an exercise to understand how a variable size queue is actually stored and the result is a bit rough I think. I included it below, but feel free to ignore it.\\n\\nBasically the queue keeps grows like a circular array until it is full, then all the contents are copied into a new array that is double the size of the previous one. I did not code in any mechanism for the array container to shrink though.\\n\\n```\\npublic class RecentCounter\\n    {\\n\\n        Queue<int> queue;\\n        public RecentCounter()\\n        {\\n            queue = new Queue<int>();\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            \\n            for (int i = 0; i < queue.Count; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            queue.Enqueue(t);\\n            return queue.Count;\\n        }\\n    }\\n\\t\\n\\tpublic class RecentCounterCustomQueue\\n    {\\n\\n        VariableSizeQueue<int> queue;\\n        public RecentCounterCustomQueue()\\n        {\\n            queue = new VariableSizeQueue<int>(10, -1);\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            queue.Enqueue(t);\\n            int startingCount = queue.Count - 1;\\n            for (int i = 0; i < startingCount; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            return queue.Count;\\n        }\\n    }\\n\\n    public class VariableSizeQueue<T>\\n    {\\n        public VariableSizeQueue(int capacity, T sentinelValue)\\n        {\\n            QueueInternal = new T[capacity];\\n            this.SentinelValue = sentinelValue;\\n        }\\n\\n        public T SentinelValue;\\n        public int Capacity\\n        {\\n            get => QueueInternal.Length;\\n        }\\n        public int Count = 0;\\n        public T[] QueueInternal;\\n\\n        public int QueueHeadIndex = 0;\\n        public int QueueTailIndex = 0;\\n\\n        public void Enqueue(T item)\\n        {\\n            if (QueueTailIndex == QueueHeadIndex && Count != 0)\\n                ResizeQueue();\\n            QueueInternal[QueueTailIndex] = item;\\n            Count++;\\n            QueueTailIndex = (QueueTailIndex + 1) % Capacity;\\n        }\\n\\n        //only called internally when all queue is completly full\\n        private void ResizeQueue()\\n        {\\n            //Create a new Queue starting from the beginning\\n            T[] resizedQueue = new T[Capacity * 2];\\n            int j = 0;\\n            for (int i = QueueHeadIndex; j < Capacity; i = (i + 1) % Capacity)\\n            {\\n                resizedQueue[j] = QueueInternal[i];\\n                j++;\\n            }\\n\\n            //change all of the pointers\\n            QueueHeadIndex = 0;\\n            QueueTailIndex = (Capacity);//tail will go one index to the end of old data\\n\\n            QueueInternal = resizedQueue;\\n        }\\n\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n            return QueueInternal[QueueHeadIndex];\\n        }\\n\\n        public T Dequeue()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n\\n            T head = QueueInternal[QueueHeadIndex];\\n            QueueInternal[QueueHeadIndex] = SentinelValue;\\n            QueueHeadIndex = (QueueHeadIndex + 1) % Capacity;\\n            Count--;\\n            return head;\\n        }\\n\\n    }\\n\\t\\n\\t",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564925,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565392,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566126,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1826057,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1905405,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566562,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564796,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565709,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1574362,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1790072,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564925,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565392,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566126,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1826057,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1905405,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566562,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564796,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565709,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1574362,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1790072,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1874703,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1953281,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1921900,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574798,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574255,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574433,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2076686,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2075388,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2066308,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2043535,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            }
        ]
    },
    {
        "title": "Linked List in Binary Tree",
        "question_content": "<p>Given a binary tree <code>root</code> and a&nbsp;linked list with&nbsp;<code>head</code>&nbsp;as the first node.&nbsp;</p>\n\n<p>Return True if all the elements in the linked list starting from the <code>head</code> correspond to some <em>downward path</em> connected in the binary tree&nbsp;otherwise return False.</p>\n\n<p>In this context downward path means a path that starts at some node and goes downwards.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png\" style=\"width: 220px; height: 280px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Nodes in blue form a subpath in the binary Tree.  \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png\" style=\"width: 220px; height: 280px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no path in the binary tree that contains all the elements of the linked list from <code>head</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree will be in the range <code>[1, 2500]</code>.</li>\n\t<li>The number of nodes in the list will be in the range <code>[1, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val&nbsp;&lt;= 100</code>&nbsp;for each node in the linked list and binary tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 524881,
                "title": "python-recursive-solution-o-n-l-time",
                "content": "# Solution 1: Brute DFS\\nTime `O(N * min(L,H))`\\nSpace `O(H)`\\nwhere N = tree size, H = tree height, L = list length.\\n<br>\\n\\n**Java**\\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\\n**C++**\\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n    bool dfs(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (dfs(head->next, root->left) || dfs(head->next, root->right));\\n    }\\n```\\n**Python:**\\n```py\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head: return True\\n            if not root: return False\\n            return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right))\\n        if not head: return True\\n        if not root: return False\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```\\n<br>\\n\\n# Solution 2: DP\\n1. Iterate the whole link, find the maximum matched length of prefix.\\n2. Iterate the whole tree, find the maximum matched length of prefix.\\n\\nAbout this dp, @fukuzawa_yumi gave a link of reference:\\nhttps://en.wikipedia.org/wiki/Knuth\\u2013Morris\\u2013Pratt_algorithm\\n\\nTime `O(N + L)`\\nSpace `O(L + H)`\\nwhere N = tree size, H = tree height, L = list length.\\n<br>\\n\\n**Java**\\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<Integer> A = new ArrayList(), dp = new ArrayList();\\n        A.add(head.val);\\n        dp.add(0);\\n        int i = 0;\\n        head = head.next;\\n        while (head != null) {\\n            while (i > 0 && head.val != A.get(i))\\n                i = dp.get(i - 1);\\n            if (head.val == A.get(i)) ++i;\\n            A.add(head.val);\\n            dp.add(i);\\n            head = head.next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    private boolean dfs(TreeNode root, int i, List<Integer> A, List<Integer> dp) {\\n        if (root == null) return false;\\n        while (i > 0 && root.val != A.get(i))\\n            i = dp.get(i - 1);\\n        if (root.val == A.get(i)) ++i;\\n        return i == dp.size() || dfs(root.left, i, A, dp) || dfs(root.right, i, A, dp);\\n    }\\n```\\n**C++**\\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<int> A = {head->val}, dp = {0};\\n        int i = 0;\\n        head = head->next;\\n        while (head) {\\n            while (i && head->val != A[i])\\n                i = dp[i - 1];\\n            i += head->val == A[i];\\n            A.push_back(head->val);\\n            dp.push_back(i);\\n            head = head->next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    bool dfs(TreeNode* root, int i, vector<int>& A, vector<int>& dp) {\\n        if (!root) return false;\\n        while (i && root->val != A[i])\\n            i = dp[i - 1];\\n        i += root->val == A[i];\\n        return i == dp.size() || dfs(root->left, i, A, dp) || dfs(root->right, i, A, dp);\\n    }\\n```\\n**Python**\\n```py\\nclass Solution(object):\\n\\n    def isSubPath(self, head, root):\\n        A, dp = [head.val], [0]\\n        i = 0\\n        node = head.next\\n        while node:\\n            while i and node.val != A[i]:\\n                i = dp[i - 1]\\n            i += node.val == A[i]\\n            A.append(node.val)\\n            dp.append(i)\\n            node = node.next\\n\\n        def dfs(root, i):\\n            if not root: return False\\n            while i and root.val != A[i]:\\n                i = dp[i - 1]\\n            i += root.val == A[i]\\n            return i == len(dp) or dfs(root.left, i) or dfs(root.right, i)\\n        return dfs(root, 0)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n    bool dfs(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (dfs(head->next, root->left) || dfs(head->next, root->right));\\n    }\\n```\n```py\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head: return True\\n            if not root: return False\\n            return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right))\\n        if not head: return True\\n        if not root: return False\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<Integer> A = new ArrayList(), dp = new ArrayList();\\n        A.add(head.val);\\n        dp.add(0);\\n        int i = 0;\\n        head = head.next;\\n        while (head != null) {\\n            while (i > 0 && head.val != A.get(i))\\n                i = dp.get(i - 1);\\n            if (head.val == A.get(i)) ++i;\\n            A.add(head.val);\\n            dp.add(i);\\n            head = head.next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    private boolean dfs(TreeNode root, int i, List<Integer> A, List<Integer> dp) {\\n        if (root == null) return false;\\n        while (i > 0 && root.val != A.get(i))\\n            i = dp.get(i - 1);\\n        if (root.val == A.get(i)) ++i;\\n        return i == dp.size() || dfs(root.left, i, A, dp) || dfs(root.right, i, A, dp);\\n    }\\n```\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<int> A = {head->val}, dp = {0};\\n        int i = 0;\\n        head = head->next;\\n        while (head) {\\n            while (i && head->val != A[i])\\n                i = dp[i - 1];\\n            i += head->val == A[i];\\n            A.push_back(head->val);\\n            dp.push_back(i);\\n            head = head->next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    bool dfs(TreeNode* root, int i, vector<int>& A, vector<int>& dp) {\\n        if (!root) return false;\\n        while (i && root->val != A[i])\\n            i = dp[i - 1];\\n        i += root->val == A[i];\\n        return i == dp.size() || dfs(root->left, i, A, dp) || dfs(root->right, i, A, dp);\\n    }\\n```\n```py\\nclass Solution(object):\\n\\n    def isSubPath(self, head, root):\\n        A, dp = [head.val], [0]\\n        i = 0\\n        node = head.next\\n        while node:\\n            while i and node.val != A[i]:\\n                i = dp[i - 1]\\n            i += node.val == A[i]\\n            A.append(node.val)\\n            dp.append(i)\\n            node = node.next\\n\\n        def dfs(root, i):\\n            if not root: return False\\n            while i and root.val != A[i]:\\n                i = dp[i - 1]\\n            i += root.val == A[i]\\n            return i == len(dp) or dfs(root.left, i) or dfs(root.right, i)\\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524821,
                "title": "c-simple-recursion",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool findSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool findSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535370,
                "title": "java-kmp-search-o-m-n-clean-code",
                "content": "**Solution 1: Brute force**\\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\\nComplexity\\n- Time: `O(m * min(n, h))`, where `n` is size of binary tree, `m` is size of linked list\\n- Space: `O(h)`, `h` is height of the binary tree.\\n\\n**Solution 2: KMP Search**\\nCan check bare KMP implement on this solution: [28. Implement strStr()](https://leetcode.com/problems/implement-strstr/discuss/535326/java-kmp-solution)\\nIdea:\\n- This problem is the same with problem: find `needle` in `haystack` where `haystack` is the binary tree, `needle` is the linked list.\\n- Convert `needle` linked list to array, so we can jump to any position of the `needle`.\\n- Compute KMP table (LPS) which is **Longest Prefix** also **Suffix**.\\n- KMP Search, where `i++` in string equal to `i.left` or `i.right` in binary tree.\\n```java\\n    int[] needle, lps;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        needle = convertLinkedListToArray(head);\\n        lps = computeKMPTable(needle);\\n        return kmpSearch(root, 0);\\n    }\\n    boolean kmpSearch(TreeNode i, int j) {\\n        if (j == needle.length) return true;\\n        if (i == null) return false;\\n        while (j > 0 && i.val != needle[j]) j = lps[j - 1];\\n        if (i.val == needle[j]) j++;\\n        return kmpSearch(i.left, j) || kmpSearch(i.right, j);\\n    }\\n    int[] computeKMPTable(int[] pattern) {\\n        int n = pattern.length;\\n        int[] lps = new int[n];\\n        for (int i = 1, j = 0; i < n; i++) {\\n            while (j > 0 && pattern[i] != pattern[j]) j = lps[j - 1];\\n            if (pattern[i] == pattern[j]) lps[i] = ++j;\\n        }\\n        return lps;\\n    }\\n    int[] convertLinkedListToArray(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        while (head != null) { list.add(head.val); head = head.next; }\\n        int[] arr = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);\\n        return arr;\\n    }\\n```\\nComplexity\\n- Time: `O(m+n)`, where `n` is size of binary tree, `m` is size of linked list\\n- Space: `O(h+m)`, `h` is height of the binary tree.",
                "solutionTags": [],
                "code": "```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\n```java\\n    int[] needle, lps;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        needle = convertLinkedListToArray(head);\\n        lps = computeKMPTable(needle);\\n        return kmpSearch(root, 0);\\n    }\\n    boolean kmpSearch(TreeNode i, int j) {\\n        if (j == needle.length) return true;\\n        if (i == null) return false;\\n        while (j > 0 && i.val != needle[j]) j = lps[j - 1];\\n        if (i.val == needle[j]) j++;\\n        return kmpSearch(i.left, j) || kmpSearch(i.right, j);\\n    }\\n    int[] computeKMPTable(int[] pattern) {\\n        int n = pattern.length;\\n        int[] lps = new int[n];\\n        for (int i = 1, j = 0; i < n; i++) {\\n            while (j > 0 && pattern[i] != pattern[j]) j = lps[j - 1];\\n            if (pattern[i] == pattern[j]) lps[i] = ++j;\\n        }\\n        return lps;\\n    }\\n    int[] convertLinkedListToArray(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        while (head != null) { list.add(head.val); head = head.next; }\\n        int[] arr = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525828,
                "title": "possible-reason-for-failing-61st-test-case-accepted",
                "content": "Try checking your code against:\\n```python\\n[1,2,1,2,3]\\n[1,null,2,null,1,2,null,1,null,null,2,null,3]\\n```\\n\\n![image](https://assets.leetcode.com/users/ashishsirohi/image_1583094177.png)\\n\\n\\nAnd the reason being, the new matching path starts somwhere from already matching path. For above example,\\n`1->2->1->2` will match the linked list but matching 3 will fail as the next node in the tree is 1. So, I stopped and checked whether current node matches the head of my linked list (in this case, it does) and I started my next path matching from here and I reached the last node without completely exhausting my linked list and hence return `False` but the correct answer is `True`. The mistake I made was not checking already exhausted path again for the possible start for my next path matching in case of previous failure. Hope it makes sense.\\n\\nHere is my code which was failing for 61st test case:\\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode:\\n                return True\\n            \\n            if not tnode:\\n                return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            else:\\n                lnode = orig if tnode.val != orig.val else orig.next\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        return dfs(root, head, head)\\n```\\n\\nAnd Here is my code for accepted solution:\\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode: return True\\n            \\n            if not tnode: return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            elif tnode.val == orig.val:\\n                lnode = orig.next\\n            else:\\n                return False\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        if not head: return True\\n        if not root: return False\\n        \\n        return (dfs(root, head, head) or self.isSubPath(head, root.left)\\n                or self.isSubPath(head, root.right))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n[1,2,1,2,3]\\n[1,null,2,null,1,2,null,1,null,null,2,null,3]\\n```\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode:\\n                return True\\n            \\n            if not tnode:\\n                return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            else:\\n                lnode = orig if tnode.val != orig.val else orig.next\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        return dfs(root, head, head)\\n```\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode: return True\\n            \\n            if not tnode: return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            elif tnode.val == orig.val:\\n                lnode = orig.next\\n            else:\\n                return False\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        if not head: return True\\n        if not root: return False\\n        \\n        return (dfs(root, head, head) or self.isSubPath(head, root.left)\\n                or self.isSubPath(head, root.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113360,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-99-54-clean-code-and-comment-added",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        //if head val, found in tree\\n        //search path\\n        if(head.val == root.val){\\n            if(searchPath(head, root)) return true;\\n        }\\n        \\n        //path didn\\'t find\\n        //now search in left subtree, \\n        //if didn\\'t found search in right subtree\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean searchPath(ListNode listNode, TreeNode treeNode){\\n        //base cases\\n        //if tree node reched to end,\\n        //check list node reached to end or node\\n        if(treeNode == null) return listNode == null;\\n        \\n        //list node reached to end, it meand found \\n        if(listNode == null) return true;\\n        \\n        //if treeNode val is not match with list val,\\n        //return, no need to search further\\n        if(treeNode.val != listNode.val) return false;\\n        \\n        return searchPath(listNode.next, treeNode.left) \\n            || searchPath(listNode.next, treeNode.right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        //if head val, found in tree\\n        //search path\\n        if(head.val == root.val){\\n            if(searchPath(head, root)) return true;\\n        }\\n        \\n        //path didn\\'t find\\n        //now search in left subtree, \\n        //if didn\\'t found search in right subtree\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean searchPath(ListNode listNode, TreeNode treeNode){\\n        //base cases\\n        //if tree node reched to end,\\n        //check list node reached to end or node\\n        if(treeNode == null) return listNode == null;\\n        \\n        //list node reached to end, it meand found \\n        if(listNode == null) return true;\\n        \\n        //if treeNode val is not match with list val,\\n        //return, no need to search further\\n        if(treeNode.val != listNode.val) return false;\\n        \\n        return searchPath(listNode.next, treeNode.left) \\n            || searchPath(listNode.next, treeNode.right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524882,
                "title": "java-o-n-2",
                "content": "```\\nclass Solution {\\n    public static boolean check(TreeNode root, ListNode head) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(head == null) return true;\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return false;\\n        if(root.val != head.val) return false;\\n        return check(root.left, head.next) || check(root.right, head.next);\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        return check(root, head) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean check(TreeNode root, ListNode head) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(head == null) return true;\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return false;\\n        if(root.val != head.val) return false;\\n        return check(root.left, head.next) || check(root.right, head.next);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1121287,
                "title": "c-dynamic-programming-dfs",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<ListNode*, TreeNode*>, bool> m;\\n    bool check(ListNode* head, TreeNode* root, ListNode* ihead){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(m.count({head, root})!=0){\\n            return m[{head, root}];\\n        }\\n        bool o1=false,o2=false;\\n        if(ihead->val==root->val){\\n            o1 = check(ihead->next, root->left, ihead) || check(ihead->next, root->right, ihead);\\n        }\\n        else{\\n            o1 = check(ihead, root->left, ihead) || check(ihead, root->right, ihead);\\n        }\\n        if(head->val==root->val){\\n            o2 = check(head->next, root->left, ihead) || check(head->next, root->right, ihead);\\n        }\\n        return m[{head, root}]=o1||o2;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return check(head, root, head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<ListNode*, TreeNode*>, bool> m;\\n    bool check(ListNode* head, TreeNode* root, ListNode* ihead){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(m.count({head, root})!=0){\\n            return m[{head, root}];\\n        }\\n        bool o1=false,o2=false;\\n        if(ihead->val==root->val){\\n            o1 = check(ihead->next, root->left, ihead) || check(ihead->next, root->right, ihead);\\n        }\\n        else{\\n            o1 = check(ihead, root->left, ihead) || check(ihead, root->right, ihead);\\n        }\\n        if(head->val==root->val){\\n            o2 = check(head->next, root->left, ihead) || check(head->next, root->right, ihead);\\n        }\\n        return m[{head, root}]=o1||o2;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return check(head, root, head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630094,
                "title": "java-recursive-dfs-beats-100-time-and-space-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        //Check if a downward path is found starting from the root node.\\n        boolean ans = check(head, root);\\n        \\n        //If path is not found, check in the left and right subtrees.      \\n        if (root!=null && !ans)\\n        {\\n            ans |= isSubPath(head, root.left);\\n            ans |= isSubPath(head, root.right);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root){\\n        \\n        //If the ListNode is null, we\\'ve reached the end of the list where all values match the ones in the tree. This means we\\'ve found a path.       \\n        if (head==null)\\n            return true;\\n        \\n        //If the TreeNode is null, but the ListNode is not, we\\'ve reached the end of the subtree but not the list, so, return False.\\n        if (root==null)\\n            return false;\\n        \\n        //If the value of the current node matches the next node of the list, try to find a path in the left or right subtree, otherwise return False\\n        if (root.val==head.val)\\n            return check(head.next, root.left) || check(head.next, root.right);\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        //Check if a downward path is found starting from the root node.\\n        boolean ans = check(head, root);\\n        \\n        //If path is not found, check in the left and right subtrees.      \\n        if (root!=null && !ans)\\n        {\\n            ans |= isSubPath(head, root.left);\\n            ans |= isSubPath(head, root.right);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root){\\n        \\n        //If the ListNode is null, we\\'ve reached the end of the list where all values match the ones in the tree. This means we\\'ve found a path.       \\n        if (head==null)\\n            return true;\\n        \\n        //If the TreeNode is null, but the ListNode is not, we\\'ve reached the end of the subtree but not the list, so, return False.\\n        if (root==null)\\n            return false;\\n        \\n        //If the value of the current node matches the next node of the list, try to find a path in the left or right subtree, otherwise return False\\n        if (root.val==head.val)\\n            return check(head.next, root.left) || check(head.next, root.right);\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524852,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        res = []\\n        while head:\\n            res.append(str(head.val))\\n            head = head.next\\n        head = \"\".join(res)\\n    \\n        def dfs(root, path):\\n            if head in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)) or dfs(root.right, path+str(root.val))\\n            \\n        return dfs(root, \"\")\\n```\\n\\n@cool_shark helped improve it.\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        DELIMITER = \\'|\\'\\n        subpath = \\'\\'\\n        while head:\\n            subpath += str(head.val) + DELIMITER\\n            head = head.next\\n    \\n        def dfs(root, path):\\n            if subpath in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)+DELIMITER) or dfs(root.right, path+str(root.val)+DELIMITER)\\n            \\n        return dfs(root, \"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        res = []\\n        while head:\\n            res.append(str(head.val))\\n            head = head.next\\n        head = \"\".join(res)\\n    \\n        def dfs(root, path):\\n            if head in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)) or dfs(root.right, path+str(root.val))\\n            \\n        return dfs(root, \"\")\\n```\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        DELIMITER = \\'|\\'\\n        subpath = \\'\\'\\n        while head:\\n            subpath += str(head.val) + DELIMITER\\n            head = head.next\\n    \\n        def dfs(root, path):\\n            if subpath in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)+DELIMITER) or dfs(root.right, path+str(root.val)+DELIMITER)\\n            \\n        return dfs(root, \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525249,
                "title": "java-exactly-the-same-as-572-subtree-of-another-tree",
                "content": "```\\nclass Solution {\\n //   Listnode cur = null;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(dfs(head, root)) return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean dfs(ListNode h, TreeNode node) {\\n        if(h == null) return true;\\n        if(node == null) return false;\\n        if(node.val == h.val) \\n            return dfs(h.next, node.left) || dfs(h.next, node.right);\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n //   Listnode cur = null;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(dfs(head, root)) return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 524842,
                "title": "concise-10-lines-c-recursion-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(h(head, root)) return true;\\n        if(!head) return true;\\n        if(!root) return false;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool h(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val != root->val ) return false;\\n        return h(head->next, root->left) || h(head->next, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(h(head, root)) return true;\\n        if(!head) return true;\\n        if(!root) return false;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool h(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val != root->val ) return false;\\n        return h(head->next, root->left) || h(head->next, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525615,
                "title": "c-simple-8-lines-solution-beats-100-space-and-85-time",
                "content": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL) return false;\\n        return find(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n    bool find(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(root->val == head->val)\\n            return find(head->next,root->left) || find(head->next,root->right);\\n        else return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL) return false;\\n        return find(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n    bool find(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(root->val == head->val)\\n            return find(head->next,root->left) || find(head->next,root->right);\\n        else return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967733,
                "title": "easy-c-faster-than-95-less-memory-than-57",
                "content": "The main approach here is to call a recursive function to:\\n* **Check every node** if it\\'s a starting point of the match sequence in the main isSubPath function.\\n* If yes, try to find a match sequence using the match function for the downward left and right paths\\nIf you like my appraoch , please **Up vote**  it \\uD83D\\uDD25\\n\\n```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n       if(root==nullptr) return false;//if we reached the end of the tree\\n        if(match(head,root)) return true;//if we find a path to match the pattern\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);//Search for the pattern in left subtree and right subtree\\n    }\\n    bool match(ListNode* head, TreeNode* root)\\n    {\\n        if(!head) return true;//if the head is null then we found a path\\n        if(!root||root->val!=head->val) return false;//we didn\\'t find a match starting from this node\\n        return match(head->next,root->left)||match(head->next,root->right);//Continue matching from this node downwards\\n    }\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n       if(root==nullptr) return false;//if we reached the end of the tree\\n        if(match(head,root)) return true;//if we find a path to match the pattern\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);//Search for the pattern in left subtree and right subtree\\n    }\\n    bool match(ListNode* head, TreeNode* root)\\n    {\\n        if(!head) return true;//if the head is null then we found a path\\n        if(!root||root->val!=head->val) return false;//we didn\\'t find a match starting from this node\\n        return match(head->next,root->left)||match(head->next,root->right);//Continue matching from this node downwards\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2059884,
                "title": "a-test-case-suggested-to-avoid-failing-the-61st-test-case",
                "content": "I would suggest adding the following test case prior to the 61st test case.\\n\\n```\\n[1,2,3]\\n[1,4,null,2,null,null,3]\\n```\\n\\n\\nBelow is the procedure to find out why it is helpful.\\n\\nI wrote some immature code snipet and failed the 61st test case. It\\'s quite long and inconvenient to debug the root cause. Reffering to the post https://leetcode.com/problems/linked-list-in-binary-tree/discuss/525828/Possible-reason-for-failing-61st-Test-Case-Accepted, the author enumerate a test case which might lead to the failure. Howerver my code did pass the short test case and still got WA in the 61st one. It took me quite a while to find out my bug.\\n\\nMy original error code:\\n\\n```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        if(head->val==root->val)    {\\n            return isSubPath(head->next,root->left) || isSubPath(head->next,root->right);  // *** Error \\n        }\\n        else\\n            return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n```\\n\\nThe two isSubPath procedure in //*** Error line is misused, the function will return true if there is a gap between the first element and latter elements in the list. For example, the list is [1]->[2]->[3], if there is a sequence downgrading in binary tree such as 1,4,2,3 or 1,5,2,3 or 1,4,5,6,2,3, the function will reture true and get WA.\\n\\nSo it\\'s necessary to add a short and simple test case before the interminable 61st case.\\n\\nAfter changing my code to below, it passed all the test cases and got AC.\\n\\n```\\nclass Solution {\\n    bool isStartPath(ListNode* head, TreeNode* root) {\\n        if (head==nullptr) return true;\\n        if (root==nullptr) return false;\\n        return (head->val==root->val) && (isStartPath(head->next, root->left) || isStartPath(head->next, root->right));\\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        return head->val==root->val && isStartPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[1,2,3]\\n[1,4,null,2,null,null,3]\\n```\n```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        if(head->val==root->val)    {\\n            return isSubPath(head->next,root->left) || isSubPath(head->next,root->right);  // *** Error \\n        }\\n        else\\n            return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n```\n```\\nclass Solution {\\n    bool isStartPath(ListNode* head, TreeNode* root) {\\n        if (head==nullptr) return true;\\n        if (root==nullptr) return false;\\n        return (head->val==root->val) && (isStartPath(head->next, root->left) || isStartPath(head->next, root->right));\\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        return head->val==root->val && isStartPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940570,
                "title": "6-lines-code-beats-94",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (isStartPath(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right));\\n    }\\n\\n    private boolean isStartPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (head.val == root.val) && (isStartPath(head.next, root.left) || isStartPath(head.next, root.right));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (isStartPath(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right));\\n    }\\n\\n    private boolean isStartPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (head.val == root.val) && (isStartPath(head.next, root.left) || isStartPath(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525799,
                "title": "java-kmp-algorithm-same-idea-as-28",
                "content": "***I\\'m very surprised that the brute force approach is accepted, I think this problem aims to test if you know how to use KMP for quick pattern lookup. (also I don\\'t think this is a good interview question as KMP shouldn\\'t be required for tech interviews)***\\n\\nFirst of all, if you don\\'t know how to use KMP to match a pattern within a string, please go [Implement strStr()](https://leetcode.com/problems/implement-strstr/), the core part is to use a LPS (longest prefix suffix) array to quickly jump to possible matching index in the pattern string when the current position doesn\\'t result in a match\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int m = haystack.length();\\n        int n = needle.length();\\n        if (n > m) {\\n            return -1;\\n        }\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        int[] lps = getLPS(needle);\\n        for (int i = 0; i < n; i++) {\\n            System.out.println(lps[i]);\\n        }\\n        \\n        int i = 0, j = 0;\\n        while (i < m) {\\n            System.out.println(i + \"   \" + j);\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                if (j == n - 1) {\\n                    return i - n + 1;\\n                }\\n                i++;\\n                j++;\\n            } else if (j > 0) {\\n                j = lps[j-1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[] getLPS(String needle) {\\n        int n = needle.length();\\n        char[] chars = needle.toCharArray();\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (chars[i] == chars[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThis problem is essentially just a variation of the above string KMP issue\\n* we iterate through the linked list to build a LPS array\\n* during tree iteration, we track an index on the list\\n\\t* if the index reaches to the end of the list, we\\'re done\\n\\t* if list[index] matches current tree node, we increment index by 1 and move to current node\\'s child nodes for further check\\n\\t* if list[index] doesn\\'t match current tree node, we use LPS array to switch index to previous possible match position\\n\\t\\t* if the new index position matches current tree node, we move forward to current node\\'s child nodes with index + 1\\n\\t\\t* if index falls back to 0 and still we don\\'t find a match, means current tree node is not useful, we move to its child nodes with index = 0\\n```\\nclass Solution {\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        // convert linked list to a list array\\n        List<Integer> list_elements = new LinkedList<>();\\n        while (head != null) {\\n            list_elements.add(head.val);\\n            head = head.next;\\n        }\\n        Integer[] list = list_elements.toArray(new Integer[0]);\\n        // build LPS (longest prefix suffix array)\\n        int[] lps = getLPS(list);\\n        \\n        return check(lps, list, 0, root);\\n    }\\n    \\n    public boolean check(int[] lps, Integer[] list, int index, TreeNode root) {\\n        if (index == list.length) {\\n            return true;\\n        }\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (list[index] == root.val) {\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        } else {\\n            boolean res = false;\\n            while (index > 0 && list[index] != root.val) {\\n                index = lps[index-1];\\n            }\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        }\\n    }\\n    \\n    private int[] getLPS(Integer[] list) {\\n        int n = list.length;\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (list[i] == list[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int m = haystack.length();\\n        int n = needle.length();\\n        if (n > m) {\\n            return -1;\\n        }\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        int[] lps = getLPS(needle);\\n        for (int i = 0; i < n; i++) {\\n            System.out.println(lps[i]);\\n        }\\n        \\n        int i = 0, j = 0;\\n        while (i < m) {\\n            System.out.println(i + \"   \" + j);\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                if (j == n - 1) {\\n                    return i - n + 1;\\n                }\\n                i++;\\n                j++;\\n            } else if (j > 0) {\\n                j = lps[j-1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[] getLPS(String needle) {\\n        int n = needle.length();\\n        char[] chars = needle.toCharArray();\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (chars[i] == chars[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        // convert linked list to a list array\\n        List<Integer> list_elements = new LinkedList<>();\\n        while (head != null) {\\n            list_elements.add(head.val);\\n            head = head.next;\\n        }\\n        Integer[] list = list_elements.toArray(new Integer[0]);\\n        // build LPS (longest prefix suffix array)\\n        int[] lps = getLPS(list);\\n        \\n        return check(lps, list, 0, root);\\n    }\\n    \\n    public boolean check(int[] lps, Integer[] list, int index, TreeNode root) {\\n        if (index == list.length) {\\n            return true;\\n        }\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (list[index] == root.val) {\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        } else {\\n            boolean res = false;\\n            while (index > 0 && list[index] != root.val) {\\n                index = lps[index-1];\\n            }\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        }\\n    }\\n    \\n    private int[] getLPS(Integer[] list) {\\n        int n = list.length;\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (list[i] == list[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524867,
                "title": "can-anyone-tell-me-why-my-code-cannot-pass-the-59th-case",
                "content": "I think the problem is that the downward pass must be continuous. I just noticed that it is stated the downward pass is connected\\n\\nThis is the accepted answer 1ms 100% time complexity O(n^2)\\n\\nclass Solution {\\n\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null) return true;\\n        if(root==null) return false;\\n        return root.val!=head.val? \\n\\t\\t\\tisSubPath(head, root.left)||isSubPath(head, root.right):\\n            dfs(head.next, root.left)||dfs(head.next, root.right)||isSubPath(head, root.left)||isSubPath(head, root.right);\\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root){\\n        if(head==null) return true;\\n        if(root==null||root.val!=head.val){\\n            return false;\\n        }\\n        return dfs(head.next,root.left)||dfs(head.next,root.right);\\n    }  \\n}\\n\\n\\nwrong answer\\nclass Solution {\\n\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root==null){\\n            if(head==null) return true;\\n            return false;\\n        }\\n        if(head==null) return true;\\n        if(root.val==head.val){\\n            head = head.next;\\n        }\\n        return isSubPath(head, root.left)||isSubPath(head, root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null) return true;\\n        if(root==null) return false;\\n        return root.val!=head.val? \\n\\t\\t\\tisSubPath(head, root.left)||isSubPath(head, root.right):\\n            dfs(head.next, root.left)||dfs(head.next, root.right)||isSubPath(head, root.left)||isSubPath(head, root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2621739,
                "title": "6-line-consise-cose-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool s(ListNode* h, TreeNode* r) {\\n        if(!h) return 1;\\n        if(!r) return 0;\\n        if(r->val == h->val) return s(h->next,r->left) || s(h->next,r->right) ;\\n        return 0;\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return 0;\\n        if(s(head,root)) return 1;\\n        return isSubPath(head,root->left) || isSubPath(head,root->right) ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s(ListNode* h, TreeNode* r) {\\n        if(!h) return 1;\\n        if(!r) return 0;\\n        if(r->val == h->val) return s(h->next,r->left) || s(h->next,r->right) ;\\n        return 0;\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return 0;\\n        if(s(head,root)) return 1;\\n        return isSubPath(head,root->left) || isSubPath(head,root->right) ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378283,
                "title": "beginner-friendly-java-javascrpit-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null)    return false;\\n        if(issame(head, root))  return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean issame(ListNode head, TreeNode root) {\\n        if(head == null)    return true;\\n        if(root == null)    return false;\\n        if(head.val != root.val)    return false;\\n        return issame(head.next, root.left) || issame(head.next, root.right);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar isSubPath = function(head, root) {\\n    if(!root)    return false\\n    if(issame(head, root))  return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction issame(head, root){\\n    if(!head)   return true\\n    if(!root)   return false\\n    if(head.val != root.val)    return false\\n    return issame(head.next, root.left) || issame(head.next, root.right)\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        if not root:    \\n            return False\\n        if self.issame(head, root):\\n            return True\\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n    def issame(self, head, root):\\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if head.val != root.val:\\n            return False\\n        return self.issame(head.next, root.left) or self.issame(head.next, root.right)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null)    return false;\\n        if(issame(head, root))  return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean issame(ListNode head, TreeNode root) {\\n        if(head == null)    return true;\\n        if(root == null)    return false;\\n        if(head.val != root.val)    return false;\\n        return issame(head.next, root.left) || issame(head.next, root.right);\\n    }\\n}\\n```\n```\\nvar isSubPath = function(head, root) {\\n    if(!root)    return false\\n    if(issame(head, root))  return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction issame(head, root){\\n    if(!head)   return true\\n    if(!root)   return false\\n    if(head.val != root.val)    return false\\n    return issame(head.next, root.left) || issame(head.next, root.right)\\n};\\n```\n```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        if not root:    \\n            return False\\n        if self.issame(head, root):\\n            return True\\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n    def issame(self, head, root):\\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if head.val != root.val:\\n            return False\\n        return self.issame(head.next, root.left) or self.issame(head.next, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525211,
                "title": "python-sol-by-dfs-75-w-hint-and-diagram",
                "content": "Python sol by DFS.\\n\\n---\\n**Hint**:\\n\\nThink of *DFS*\\n\\nThink of *path string representation*\\n\\nThe given input linked list is a subpath of binary tree, if and only if, \\nthe **path string of linked list** is a **substring** among the **path strings of binary tree**.\\n\\n---\\n\\n**Diagram with example**:\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583046952.png)\\n\\n\\n\\n---\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def string_of_linked_list( head: ListNode ):\\n            \\n            linked_list_string = \\'\\'\\n            cur = head\\n            \\n            while cur:\\n                linked_list_string += str( cur.val ) + \\',\\'\\n                cur = cur.next\\n                \\n            return linked_list_string\\n                \\n        # ----------------------------------------------------\\n        \\n        # Get the path string of linked list\\n        linked_list_string = string_of_linked_list( head )\\n        \\n        # ----------------------------------------------------\\n            \\n        def dfs( node: TreeNode, path_string: str) -> bool:\\n            \\n            if not node:\\n                \\n                # If path string of binary tree includes path string of linked list, \\n                # then Accept and return True\\n                if path_string.find(linked_list_string) != -1:\\n                    return True\\n                else:\\n                    return False\\n                \\n                \\n            else:\\n\\n                # Update path string of binary tree, and DFS down to next level\\n\\n                path_string += str( node.val) + \\',\\'\\n                return dfs( node.left, path_string ) or dfs( node.right, path_string )\\n        \\n        # -----------------------------------------------------\\n        \\n        return dfs( root, \\'\\')\\n```\\n\\n---\\n\\nShare another DFS implementation\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(list_cur: ListNode, tree_cur:ListNode):\\n            \\n            if not list_cur:\\n                # current linked list is a subpath of given tree\\n                return True\\n            \\n            if not tree_cur:\\n                # current linked list is not a subpath of given tree\\n                return False\\n            \\n            # node value check, and keep checking on next level with DFS\\n            return list_cur.val == tree_cur.val and ( dfs(list_cur.next, tree_cur.left) or dfs(list_cur.next, tree_cur.right) )\\n            \\n        # ------------------------------------------------------\\n        \\n        if not head:\\n            # linked list is empty\\n            return True\\n        \\n        if not root:\\n            # tree is empty\\n            return False\\n        \\n        # try to match linked list with given tree in DFS\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about str.find()](https://docs.python.org/3/library/stdtypes.html?highlight=str%20find#str.find)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def string_of_linked_list( head: ListNode ):\\n            \\n            linked_list_string = \\'\\'\\n            cur = head\\n            \\n            while cur:\\n                linked_list_string += str( cur.val ) + \\',\\'\\n                cur = cur.next\\n                \\n            return linked_list_string\\n                \\n        # ----------------------------------------------------\\n        \\n        # Get the path string of linked list\\n        linked_list_string = string_of_linked_list( head )\\n        \\n        # ----------------------------------------------------\\n            \\n        def dfs( node: TreeNode, path_string: str) -> bool:\\n            \\n            if not node:\\n                \\n                # If path string of binary tree includes path string of linked list, \\n                # then Accept and return True\\n                if path_string.find(linked_list_string) != -1:\\n                    return True\\n                else:\\n                    return False\\n                \\n                \\n            else:\\n\\n                # Update path string of binary tree, and DFS down to next level\\n\\n                path_string += str( node.val) + \\',\\'\\n                return dfs( node.left, path_string ) or dfs( node.right, path_string )\\n        \\n        # -----------------------------------------------------\\n        \\n        return dfs( root, \\'\\')\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(list_cur: ListNode, tree_cur:ListNode):\\n            \\n            if not list_cur:\\n                # current linked list is a subpath of given tree\\n                return True\\n            \\n            if not tree_cur:\\n                # current linked list is not a subpath of given tree\\n                return False\\n            \\n            # node value check, and keep checking on next level with DFS\\n            return list_cur.val == tree_cur.val and ( dfs(list_cur.next, tree_cur.left) or dfs(list_cur.next, tree_cur.right) )\\n            \\n        # ------------------------------------------------------\\n        \\n        if not head:\\n            # linked list is empty\\n            return True\\n        \\n        if not root:\\n            # tree is empty\\n            return False\\n        \\n        # try to match linked list with given tree in DFS\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301573,
                "title": "java-beats-of-java-submissions-well-explained",
                "content": "If helpful do consider ***upvote***\\n```\\nclass Solution {\\n    \\n    public boolean isSamePath(ListNode head, TreeNode root){\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n\\n        if(root.val == head.val){//if root and head values are same then check if root left or root right tree downwpath is same as head.next linked list\\n            if(isSamePath(head.next,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where\\n            \\n            if(isSamePath(head.next,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        }\\n\\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, return false\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n        \\n\\n        if(root.val==head.val){\\n            if(isSamePath(head,root)) return true;//if linked list is present in subtree of root node then return true no need to check elsewhere\\n        }\\n        // if root.val is not equal to head.val then we check for the linked list in ledt sub tree and right sub tree OR if root.val was equal to head.val but somehow\\n        // remaning linkedlist is not similar to the downward path of the the root node then also we try to check in left and right subtree\\n        \\n        if(isSubPath(head,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where       \\n        \\n        if(isSubPath(head,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        \\n        \\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, retun false\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isSamePath(ListNode head, TreeNode root){\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n\\n        if(root.val == head.val){//if root and head values are same then check if root left or root right tree downwpath is same as head.next linked list\\n            if(isSamePath(head.next,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where\\n            \\n            if(isSamePath(head.next,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        }\\n\\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, return false\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n        \\n\\n        if(root.val==head.val){\\n            if(isSamePath(head,root)) return true;//if linked list is present in subtree of root node then return true no need to check elsewhere\\n        }\\n        // if root.val is not equal to head.val then we check for the linked list in ledt sub tree and right sub tree OR if root.val was equal to head.val but somehow\\n        // remaning linkedlist is not similar to the downward path of the the root node then also we try to check in left and right subtree\\n        \\n        if(isSubPath(head,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where       \\n        \\n        if(isSubPath(head,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        \\n        \\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, retun false\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675485,
                "title": "c-bfs-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/linked-list-in-binary-tree/submissions/\\n    \\n    Idea is do BFS of tree and once we get the a node which has the same value as that\\n    of the list head, then we start DFS of tree from that node and list head to check if that\\n    path exists from that node.\\n    \\n*/\\nclass Solution {\\npublic:\\n    bool checkPath(ListNode* head, TreeNode* root) {\\n        // if the list has ended\\n        if(!head)\\n            return true;\\n        // if the list hasnt ended but tree has\\n        if(!root)\\n            return false;\\n\\n        return head->val == root->val && (checkPath(head->next, root->left) ||\\n                                         checkPath(head->next, root->right));\\n    }\\n\\n    // TC: O(M * min(M, N)), M: size of linked list, N: No. of nodes in tree\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.emplace(root);\\n\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n\\n            // check if the current node match the list head\\n            if(curr->val == head->val && checkPath(head, curr))\\n                return true;\\n\\n            if(curr->left)\\n                q.emplace(curr->left);\\n            if(curr->right)\\n                q.emplace(curr->right);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/linked-list-in-binary-tree/submissions/\\n    \\n    Idea is do BFS of tree and once we get the a node which has the same value as that\\n    of the list head, then we start DFS of tree from that node and list head to check if that\\n    path exists from that node.\\n    \\n*/\\nclass Solution {\\npublic:\\n    bool checkPath(ListNode* head, TreeNode* root) {\\n        // if the list has ended\\n        if(!head)\\n            return true;\\n        // if the list hasnt ended but tree has\\n        if(!root)\\n            return false;\\n\\n        return head->val == root->val && (checkPath(head->next, root->left) ||\\n                                         checkPath(head->next, root->right));\\n    }\\n\\n    // TC: O(M * min(M, N)), M: size of linked list, N: No. of nodes in tree\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.emplace(root);\\n\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n\\n            // check if the current node match the list head\\n            if(curr->val == head->val && checkPath(head, curr))\\n                return true;\\n\\n            if(curr->left)\\n                q.emplace(curr->left);\\n            if(curr->right)\\n                q.emplace(curr->right);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897130,
                "title": "c-easy-to-understand-well-commented-common-mistake-explained",
                "content": "### **Intuition**\\nThe approach is to check whether the path:\\ni. starts from the current node in the tree\\nii. exists in the left subtree\\niii. exists in the right subtree\\n\\n**Why recursion?** Because in this type of situation, when we need to check for the same thing again and again on subproblems, recursion seems quite convenient and intuitive.\\n\\n### **A mistake I made initially**\\nThe first solution I came up with was to check whether the current value of the head equals the node value or not. If yes, then check in the left and right subtree for the next value in the linked list, and, if not, then check in the left and right subtree for the current value of the head.\\n```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)return true;\\n        if(!root) return false;\\n        if(head->val==root->val){\\n            return isSubPath(head->next, root->left) or isSubPath(head->next, root->right);\\n        }\\n        else{\\n            return isSubPath(head,root->left) or isSubPath(head,root->right);\\n        }\\n    }\\n```\\nWhat\\'s wrong with this? If some part of our LinkedList matches a path in the tree, then it will keep checking in the left and right part for the next value of the head without checking for the initial values.\\nExample: \\nLinked list: [2,1,2] \\nTree: [2,null, 1, null, 5, null, 2, null, 1, null, 5,null,null]\\n\\n![image](https://assets.leetcode.com/users/images/8bf3dc48-c1a1-4084-9d6d-e7b6d8866027_1648634716.2691994.png)\\n\\n\\n\\nIn the tree, [2,1,2] don\\'t exist, but still, the code will return true. Because it will first encounter 2, then it will search for 1 in the remaining part and then, similarly, it will search for 2 in the remaining tree without checking for the previous elements (2 and 1). \\n\\n## **Code**\\n```\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(!head) return true;  //if we reach the end of linkedlist return true\\n        if(!root)return false;  //if we have exhausted the current path in the tree return false\\n        \\n        return (head->val==root->val) and (dfs(head->next,root->left) or dfs(head->next,root->right)); \\n        //check for current value of tree and ll and then recurse to check for the remaining part\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);  //dfs will check whether the path starts from the current node or not \\n        // if dfs returns false, then isSubPath will recurse to check for the path in the remaining tree.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)return true;\\n        if(!root) return false;\\n        if(head->val==root->val){\\n            return isSubPath(head->next, root->left) or isSubPath(head->next, root->right);\\n        }\\n        else{\\n            return isSubPath(head,root->left) or isSubPath(head,root->right);\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(!head) return true;  //if we reach the end of linkedlist return true\\n        if(!root)return false;  //if we have exhausted the current path in the tree return false\\n        \\n        return (head->val==root->val) and (dfs(head->next,root->left) or dfs(head->next,root->right)); \\n        //check for current value of tree and ll and then recurse to check for the remaining part\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);  //dfs will check whether the path starts from the current node or not \\n        // if dfs returns false, then isSubPath will recurse to check for the path in the remaining tree.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684678,
                "title": "java-dfs",
                "content": "Ref: https://leetcode.com/problems/linked-list-in-binary-tree/discuss/524881/Python-Recursive-Solution-O(N)-Time\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return root.val == head.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return root.val == head.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549091,
                "title": "accepted-c-solution-beats-100",
                "content": "Runtime: 16 ms, faster than 100.00% of C online submissions for Linked List in Binary Tree.\\nMemory Usage: 13.6 MB, less than 100.00% of C online submissions for Linked List in Binary Tree.\\n```\\n    bool findSubPath(struct ListNode* head,struct TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(struct ListNode* head, struct TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "Runtime: 16 ms, faster than 100.00% of C online submissions for Linked List in Binary Tree.\\nMemory Usage: 13.6 MB, less than 100.00% of C online submissions for Linked List in Binary Tree.\\n```\\n    bool findSubPath(struct ListNode* head,struct TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(struct ListNode* head, struct TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3109084,
                "title": "java-dfs-dfs-explained-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       // dfs with dfs \\n        \\n        return helper(head, root);\\n    }\\n    // implementing dfs with dfs \\n    \\n    // first dfs which checks from every node in the binary tree \\n    public boolean helper(ListNode head, TreeNode root)\\n    {\\n        if(root ==null)\\n            return false;\\n        if(dfs(head, root))\\n        {\\n            return true;\\n        }\\n        // if condns for if we get true then directly return true, no need to check more \\n        if(helper(head, root.left))\\n            return true;\\n          \\n        \\n        if(helper(head, root.right))\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    // second dfs which looks for the linked list \\n    public boolean dfs(ListNode head, TreeNode root)\\n    {\\n        // if we reach the end of linked list return true \\n        if(head ==null)\\n            return true;\\n        \\n        // return statement -> if linked list val doesnt match the binary tree node value \\n        if(root==null ||  head.val != root.val)\\n            return false;\\n        \\n        // return true when got true \\n        if(dfs(head.next, root.left))\\n            return true;\\n        \\n        if(dfs(head.next, root.right))\\n            return true;\\n        \\n        return false;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       // dfs with dfs \\n        \\n        return helper(head, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2379894,
                "title": "c-solution-dfs-8lines-fast-than-98",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head,TreeNode* root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        return head->val==root->val&&(dfs(head->next,root->right)||dfs(head->next, root->left));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(!head) return true;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head,TreeNode* root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        return head->val==root->val&&(dfs(head->next,root->right)||dfs(head->next, root->left));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(!head) return true;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879827,
                "title": "c-simple-dfs-recursion",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool inpath(ListNode* head, TreeNode* root)\\n    {\\n        if(root==NULL && head!=NULL)\\n            return false;\\n    \\n        if(head==NULL)\\n            return true;\\n    \\n        if(head->val!=root->val)\\n            return false;\\n        \\n        // if(root->left && head->next && root->left->val == head->next->val)\\n        bool b1=inpath(head->next,root->left);\\n        \\n        //if(root->right && head->next && root->right->val == head->next->val)\\n        bool b2=inpath(head->next,root->right);\\n    \\n        return b1||b2;\\n    \\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {        \\n        \\n        if(root==NULL)\\n            return false;\\n    \\n        if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n    \\n        bool b1=isSubPath(head,root->left);\\n        bool b2=isSubPath(head,root->right);\\n    \\n        return b1 || b2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool inpath(ListNode* head, TreeNode* root)\\n    {\\n        if(root==NULL && head!=NULL)\\n            return false;\\n    \\n        if(head==NULL)\\n            return true;\\n    \\n        if(head->val!=root->val)\\n            return false;\\n        \\n        // if(root->left && head->next && root->left->val == head->next->val)\\n        bool b1=inpath(head->next,root->left);\\n        \\n        //if(root->right && head->next && root->right->val == head->next->val)\\n        bool b2=inpath(head->next,root->right);\\n    \\n        return b1||b2;\\n    \\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {        \\n        \\n        if(root==NULL)\\n            return false;\\n    \\n        if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n    \\n        bool b1=isSubPath(head,root->left);\\n        bool b2=isSubPath(head,root->right);\\n    \\n        return b1 || b2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368483,
                "title": "c-easy-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, ListNode* head){\\n        if(head==NULL) return true;\\n        if(root==NULL || root->val!=head->val) return false;\\n        return dfs(root->left, head->next) || dfs(root->right, head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return false;\\n        if(root==NULL) return false;\\n        if(dfs(root, head)) return true;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, ListNode* head){\\n        if(head==NULL) return true;\\n        if(root==NULL || root->val!=head->val) return false;\\n        return dfs(root->left, head->next) || dfs(root->right, head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return false;\\n        if(root==NULL) return false;\\n        if(dfs(root, head)) return true;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532774,
                "title": "python-solution",
                "content": "```\\ndef isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val and self.isPathExists(head, root):\\n\\t\\treturn True\\n\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n        \\ndef isPathExists(self, head, root):\\n\\tif head==None: \\n\\t\\treturn True\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val:\\n\\t\\treturn self.isPathExists(head.next, root.left) or self.isPathExists(head.next, root.right)\\n\\telse:\\n\\t\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val and self.isPathExists(head, root):\\n\\t\\treturn True\\n\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n        \\ndef isPathExists(self, head, root):\\n\\tif head==None: \\n\\t\\treturn True\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val:\\n\\t\\treturn self.isPathExists(head.next, root.left) or self.isPathExists(head.next, root.right)\\n\\telse:\\n\\t\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 526031,
                "title": "java-one-pass-solution-keep-all-possible-lists-in-a-list",
                "content": "One-Pass Solution: A different way to solve this question just for reference.  \\n\\nHave a list to store all possible remaining linkedlist avoid searching repeatedly. For every node, we need to check if it could be the real head of the list (so we add the head to our list every time). Keep searching and passing all possible lists until we reach the end of one of lists.  \\n\\n```java\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n\\tList<ListNode> list = new LinkedList<>();\\n\\treturn helper(root, list, head);\\n}\\n\\nprivate boolean helper(TreeNode root, List<ListNode> list, ListNode head) {\\n\\n\\tif (root == null) return false;\\n\\tlist.add(head);\\n\\n\\tList<ListNode> nextList = new LinkedList<>();\\n\\n\\tfor (ListNode node : list) {\\n\\t\\tif (root.val == node.val) {\\n\\t\\t\\tif (node.next == null) return true;\\n\\t\\t\\telse nextList.add(node.next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn helper(root.left, nextList, head) || helper(root.right, nextList, head);\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n\\tList<ListNode> list = new LinkedList<>();\\n\\treturn helper(root, list, head);\\n}\\n\\nprivate boolean helper(TreeNode root, List<ListNode> list, ListNode head) {\\n\\n\\tif (root == null) return false;\\n\\tlist.add(head);\\n\\n\\tList<ListNode> nextList = new LinkedList<>();\\n\\n\\tfor (ListNode node : list) {\\n\\t\\tif (root.val == node.val) {\\n\\t\\t\\tif (node.next == null) return true;\\n\\t\\t\\telse nextList.add(node.next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn helper(root.left, nextList, head) || helper(root.right, nextList, head);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525131,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef dfs(self, head, root):\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif head.val == root.val:\\n\\t\\t\\t\\treturn self.dfs(head.next, root.left) or self.dfs(head.next, root.right) \\n\\n\\t\\t\\treturn False\\n\\n\\n\\t\\tdef isSubPath(self, head, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type head: ListNode\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif self.dfs(head, root):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef dfs(self, head, root):\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif head.val == root.val:\\n\\t\\t\\t\\treturn self.dfs(head.next, root.left) or self.dfs(head.next, root.right) \\n\\n\\t\\t\\treturn False\\n\\n\\n\\t\\tdef isSubPath(self, head, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type head: ListNode\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif self.dfs(head, root):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n",
                "codeTag": "Java"
            },
            {
                "id": 525026,
                "title": "java-100-runtime-with-explanations",
                "content": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        return isSubPath(head, root, false);\\n    }\\n    \\n    private boolean isSubPath(ListNode head, TreeNode root, boolean listElementFound) {\\n        if (head == null) return true; // all list element are found\\n        if (root == null) return false; // reached the bottom of the tree\\n        if (listElementFound && root.val != head.val) return false; // if list element was previously found, but the current list element is not matching to current tree node\\n        \\n        if (root.val == head.val) { // curr node matches the first element of the list\\n            if (isSubPath(head.next, root.left, true) ||\\n                isSubPath(head.next, root.right, true)) return true;\\n            \\n            if (listElementFound) return false; // if list element was previously found, but the next list element is not found\\n        }\\n        return isSubPath(head, root.left, false) || isSubPath(head, root.right, false);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        return isSubPath(head, root, false);\\n    }\\n    \\n    private boolean isSubPath(ListNode head, TreeNode root, boolean listElementFound) {\\n        if (head == null) return true; // all list element are found\\n        if (root == null) return false; // reached the bottom of the tree\\n        if (listElementFound && root.val != head.val) return false; // if list element was previously found, but the current list element is not matching to current tree node\\n        \\n        if (root.val == head.val) { // curr node matches the first element of the list\\n            if (isSubPath(head.next, root.left, true) ||\\n                isSubPath(head.next, root.right, true)) return true;\\n            \\n            if (listElementFound) return false; // if list element was previously found, but the next list element is not found\\n        }\\n        return isSubPath(head, root.left, false) || isSubPath(head, root.right, false);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003253,
                "title": "easy-recursive-java-beats-99-69-memory-usage-less-than-86-72",
                "content": "**Run time:** O( M\\\\*N)\\n*M: size of LinkedList\\nN: Number of nodes of Tree*\\n\\nWe call the **match** function whenever the **head** of linkedList is found to be equal to **root.val**\\n\\n```\\nclass Solution {\\n    public boolean match(ListNode head, TreeNode root){\\n        if(head == null) return true;\\n        \\n        if(root == null) return false;\\n        \\n        if(head.val != root.val) return false;\\n        \\n        return match(head.next, root.left) || match(head.next, root.right);\\n            \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\n        if(head == null) return true;\\n        if(root == null) return false;\\n                \\n        if(head.val == root.val)\\n            if(match(head, root)) return true;\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean match(ListNode head, TreeNode root){\\n        if(head == null) return true;\\n        \\n        if(root == null) return false;\\n        \\n        if(head.val != root.val) return false;\\n        \\n        return match(head.next, root.left) || match(head.next, root.right);\\n            \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\n        if(head == null) return true;\\n        if(root == null) return false;\\n                \\n        if(head.val == root.val)\\n            if(match(head, root)) return true;\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870024,
                "title": "cpp-recursive-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root && head) return false;\\n        bool check = head->val == root->val;\\n        if(!check) return false;\\n        bool left = isPath(head->next, root->left);\\n        bool right = isPath(head->next, root->right);\\n        return (left || right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root && head) return false;\\n        bool check = head->val == root->val;\\n        if(!check) return false;\\n        bool left = isPath(head->next, root->left);\\n        bool right = isPath(head->next, root->right);\\n        return (left || right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818806,
                "title": "c-dfs-approach-easy-to-understand",
                "content": "***Runtime: 52 ms, faster than 80.44% of C++ online submissions for Linked List in Binary Tree.\\nMemory Usage: 31.9 MB, less than 81.61% of C++ online submissions for Linked List in Binary Tree.***\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(isEqual(head, root)){\\n                return true;\\n            }\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n        }\\n        return false;\\n    }\\n    bool isEqual(ListNode* head, TreeNode* root){\\n        if(!head){\\n            return true;\\n        }\\n        if(!root){\\n            return false;\\n        }\\n        return head->val == root->val && (isEqual(head->next, root->left) || isEqual(head->next, root->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(isEqual(head, root)){\\n                return true;\\n            }\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n        }\\n        return false;\\n    }\\n    bool isEqual(ListNode* head, TreeNode* root){\\n        if(!head){\\n            return true;\\n        }\\n        if(!root){\\n            return false;\\n        }\\n        return head->val == root->val && (isEqual(head->next, root->left) || isEqual(head->next, root->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525230,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool IsSubPath(ListNode head, TreeNode root) \\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return IsSubPathFromRoot(head, root)  \\n               || IsSubPath(head, root.left) \\n               || IsSubPath(head, root.right);\\n    }\\n    \\n    private bool IsSubPathFromRoot(ListNode head, TreeNode root)\\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val \\n               && (IsSubPathFromRoot(head.next, root.right) \\n               || IsSubPathFromRoot(head.next, root.left));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsSubPath(ListNode head, TreeNode root) \\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return IsSubPathFromRoot(head, root)  \\n               || IsSubPath(head, root.left) \\n               || IsSubPath(head, root.right);\\n    }\\n    \\n    private bool IsSubPathFromRoot(ListNode head, TreeNode root)\\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val \\n               && (IsSubPathFromRoot(head.next, root.right) \\n               || IsSubPathFromRoot(head.next, root.left));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650945,
                "title": "java-recursive-solution-o-n-without-space",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null && root==null){\\n            return true;\\n        }\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        boolean res = f(head,root);\\n        \\n        return res || isSubPath(head,root.left) || isSubPath(head,root.right);\\n        \\n    }\\n    \\n    public static boolean f(ListNode head,TreeNode root){\\n        if(root==null && head==null){\\n            return true;\\n        }\\n        if(root==null){\\n            return false;\\n        }\\n        if(head==null){\\n\\t\\t\\n\\t\\t// If My LinkedList became null that means upto this point all the values matched with the nodes in this path so we\\'ll return true from here that we found the link list structure in tree\\n\\t\\t\\n            return true;\\n        }\\n        if(head.val!=root.val){\\n            return false;\\n        }\\n        \\n        return f(head.next,root.left) || f(head.next,root.right); // This OR operator will make sure if it gets true from any part of tree we\\'ll conserve the true value\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null && root==null){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2467765,
                "title": "c-simple-recursive-and-dfs-approach-solution",
                "content": "```\\n\\nclass Solution {\\n    \\n    bool dfs(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return dfs(head->next , root->left) || dfs(head->next, root->right);\\n    }\\n    \\n    bool SolveByRecursion(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL)\\n            return false;\\n        \\n        if(dfs(head, root))\\n                return true;\\n        \\n        return SolveByRecursion(head, root->left) || SolveByRecursion(head, root->right);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return SolveByRecursion(head, root);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    bool dfs(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return dfs(head->next , root->left) || dfs(head->next, root->right);\\n    }\\n    \\n    bool SolveByRecursion(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL)\\n            return false;\\n        \\n        if(dfs(head, root))\\n                return true;\\n        \\n        return SolveByRecursion(head, root->left) || SolveByRecursion(head, root->right);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return SolveByRecursion(head, root);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949306,
                "title": "python-95-faster-easy-soultion",
                "content": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        pattern = \"\"\\n        curr = head\\n        while curr:\\n            pattern += f\"{curr.val}-\"\\n            curr = curr.next\\n        stack = [(root, f\"{root.val}-\")]\\n        while stack:\\n            (node, curr_path) = stack.pop()\\n            if pattern in curr_path:\\n                return True\\n            if node.left:\\n                stack.append((node.left, curr_path+f\"{node.left.val}-\"))\\n            if node.right:\\n                stack.append((node.right, curr_path+f\"{node.right.val}-\"))\\n        return False\\n```",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        pattern = \"\"\\n        curr = head\\n        while curr:\\n            pattern += f\"{curr.val}-\"\\n            curr = curr.next\\n        stack = [(root, f\"{root.val}-\")]\\n        while stack:\\n            (node, curr_path) = stack.pop()\\n            if pattern in curr_path:\\n                return True\\n            if node.left:\\n                stack.append((node.left, curr_path+f\"{node.left.val}-\"))\\n            if node.right:\\n                stack.append((node.right, curr_path+f\"{node.right.val}-\"))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499304,
                "title": "c-solution-using-dfs-dfs-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(ListNode* head, TreeNode* root)\\n    {\\n        if(head!=nullptr&&root==nullptr)\\n         return false;\\n        if(head->val==root->val&&head->next==nullptr)/*the entire Linked List has been traversed and is present in Binary                                                             tree */\\n            return true;\\n        if(head->val==root->val)\\n        {\\n       return compare(head->next,root->left)||compare(head->next,root->right);//we are moving to the next node\\n        }\\n        return false;        \\n    }\\n bool dfs(ListNode* head, TreeNode* root)\\n {\\n     if(head!=nullptr&&root==nullptr)\\n         return false;//The entire tree has been traversed and no value equal to the head node has been found\\n     if(compare(head,root))\\n         return true;\\n    return dfs(head,root->left)||dfs(head,root->right);//DFS traversal\\n  \\n }\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return dfs(head,root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(ListNode* head, TreeNode* root)\\n    {\\n        if(head!=nullptr&&root==nullptr)\\n         return false;\\n        if(head->val==root->val&&head->next==nullptr)/*the entire Linked List has been traversed and is present in Binary                                                             tree */\\n            return true;\\n        if(head->val==root->val)\\n        {\\n       return compare(head->next,root->left)||compare(head->next,root->right);//we are moving to the next node\\n        }\\n        return false;        \\n    }\\n bool dfs(ListNode* head, TreeNode* root)\\n {\\n     if(head!=nullptr&&root==nullptr)\\n         return false;//The entire tree has been traversed and no value equal to the head node has been found\\n     if(compare(head,root))\\n         return true;\\n    return dfs(head,root->left)||dfs(head,root->right);//DFS traversal\\n  \\n }\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return dfs(head,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393919,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return rec(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean rec(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (rec(head.next, root.left) || rec(head.next, root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return rec(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean rec(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (rec(head.next, root.left) || rec(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179155,
                "title": "c-simple-recursive-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // check whether it is possible to get the linked list from the current tree node\\n    // dfs based recursive function\\n    bool startsWith(ListNode *head, TreeNode *root) {\\n        // base case: you reached the end of the linked list\\n        if(!head)\\n            return true;\\n        // root becomes null and linked list is not fully traversed || value of the current node doesnt match with linked list\\n        if(head && !root || head->val != root->val)\\n            return false;\\n        // recursive calls\\n        return startsWith(head->next, root->left) || startsWith(head->next, root->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        // base case\\n        if(!root)\\n            return false;\\n        // check for the linked list to start with root node\\n        if(startsWith(head, root))\\n            return true;\\n        // recursive calls: check for linked list to start with child nodes\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // check whether it is possible to get the linked list from the current tree node\\n    // dfs based recursive function\\n    bool startsWith(ListNode *head, TreeNode *root) {\\n        // base case: you reached the end of the linked list\\n        if(!head)\\n            return true;\\n        // root becomes null and linked list is not fully traversed || value of the current node doesnt match with linked list\\n        if(head && !root || head->val != root->val)\\n            return false;\\n        // recursive calls\\n        return startsWith(head->next, root->left) || startsWith(head->next, root->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        // base case\\n        if(!root)\\n            return false;\\n        // check for the linked list to start with root node\\n        if(startsWith(head, root))\\n            return true;\\n        // recursive calls: check for linked list to start with child nodes\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847652,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public static boolean checking(ListNode head,TreeNode root)\\n    {\\n        if(head==null)\\n            return true;\\n        if(root==null)\\n            return false;            \\n        if(root.val!=head.val)\\n            return false;\\n        return(checking(head.next,root.left)||checking(head.next,root.right));\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root==null || head==null)\\n            return false;\\n        if(root.val==head.val && checking(head,root))\\n            return true;\\n        return (isSubPath(head,root.left)||isSubPath(head,root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static boolean checking(ListNode head,TreeNode root)\\n    {\\n        if(head==null)\\n            return true;\\n        if(root==null)\\n            return false;            \\n        if(root.val!=head.val)\\n            return false;\\n        return(checking(head.next,root.left)||checking(head.next,root.right));\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root==null || head==null)\\n            return false;\\n        if(root.val==head.val && checking(head,root))\\n            return true;\\n        return (isSubPath(head,root.left)||isSubPath(head,root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695058,
                "title": "python-dfs-beats-99",
                "content": "class Solution:\\n\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        target = \"\"\\n        while head:\\n            target = target + str(head.val)\\n            head = head.next\\n            \\n        \\n        def dfs(root, path):\\n            if target in path:\\n                return True\\n                \\n            if root.left:\\n                ans =  dfs(root.left, path + str(root.left.val))\\n                if ans == True:\\n                    return True\\n                    \\n            if root.right:\\n                ans  = dfs(root.right, path + str(root.right.val))\\n                if ans == True:\\n                    return True\\n            \\n            return False\\n            \\n                \\n        return dfs(root, str(root.val))",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        target = \"\"\\n        while head:\\n            target = target + str(head.val)\\n            head = head.next\\n            \\n        \\n        def dfs(root, path):\\n            if target in path:\\n                return True\\n                \\n            if root.left:\\n                ans =  dfs(root.left, path + str(root.left.val))\\n                if ans == True:\\n                    return True\\n                    \\n            if root.right:\\n                ans  = dfs(root.right, path + str(root.right.val))\\n                if ans == True:\\n                    return True\\n            \\n            return False\\n            \\n                \\n        return dfs(root, str(root.val))",
                "codeTag": "Java"
            },
            {
                "id": 525912,
                "title": "javascript-bfs-then-dfs-with-explanation",
                "content": "* traverse tree BFS\\n* for each node, call dfs and verify if true:\\n\\t* if node is equal to linked list node:\\n\\t\\t* if no next node in list, then we found a sequence!\\n\\t\\t* else, gotta keep going. Recursively call for left and right with next node in list\\n* if all nodes explored and none have a path, then return false\\n\\n\\n```javascript\\nconst isSubPath = (head, root) => {\\n    const queue = [root];\\n    \\n    while(queue.length > 0) {\\n        const curr = queue.pop();\\n        \\n        if(helper(curr, head)) return true;\\n        \\n        if(curr.left) queue.unshift(curr.left);\\n        if(curr.right) queue.unshift(curr.right);\\n    }\\n    \\n    return false;\\n    \\n};\\n\\nconst helper = (treeNode, listNode) => {\\n    if(!treeNode) return false;\\n    \\n    if(treeNode.val !== listNode.val) return false;\\n    \\n    if(!listNode.next) return true;\\n    \\n    listNode = listNode.next;\\n    \\n    const leftResult = helper(treeNode.left, listNode);\\n    const rightResult = helper(treeNode.right, listNode);\\n    \\n    return leftResult || rightResult;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst isSubPath = (head, root) => {\\n    const queue = [root];\\n    \\n    while(queue.length > 0) {\\n        const curr = queue.pop();\\n        \\n        if(helper(curr, head)) return true;\\n        \\n        if(curr.left) queue.unshift(curr.left);\\n        if(curr.right) queue.unshift(curr.right);\\n    }\\n    \\n    return false;\\n    \\n};\\n\\nconst helper = (treeNode, listNode) => {\\n    if(!treeNode) return false;\\n    \\n    if(treeNode.val !== listNode.val) return false;\\n    \\n    if(!listNode.next) return true;\\n    \\n    listNode = listNode.next;\\n    \\n    const leftResult = helper(treeNode.left, listNode);\\n    const rightResult = helper(treeNode.right, listNode);\\n    \\n    return leftResult || rightResult;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525123,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSubPath = function(head, root) {\\n    if(!root) return false\\n    if(dfs(head, root)) return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction dfs(head, node) {\\n    if(!head) return true\\n    if(!node) return false\\n    if(node.val !== head.val) return false\\n    return dfs(head.next, node.left) || dfs(head.next, node.right)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSubPath = function(head, root) {\\n    if(!root) return false\\n    if(dfs(head, root)) return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction dfs(head, node) {\\n    if(!head) return true\\n    if(!node) return false\\n    if(node.val !== head.val) return false\\n    return dfs(head.next, node.left) || dfs(head.next, node.right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797505,
                "title": "python-3-bfs-dfs-combination",
                "content": "### Time complexity: \\n`O(N) * min(O(H), O(L))`\\nwhere N - tree size,  H - tree height, L - list length\\n```python3 []\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)\\n\\n        queue = deque([root])\\n        while queue:\\n            for _ in range(len(queue)):\\n                cur = queue.popleft()\\n                if cur.val == head.val and isEqual(cur, head):\\n                    return True\\n                if cur.left: queue.append(cur.left)\\n                if cur.right: queue.append(cur.right)\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)\\n\\n        queue = deque([root])\\n        while queue:\\n            for _ in range(len(queue)):\\n                cur = queue.popleft()\\n                if cur.val == head.val and isEqual(cur, head):\\n                    return True\\n                if cur.left: queue.append(cur.left)\\n                if cur.right: queue.append(cur.right)\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578405,
                "title": "i-have-try-to-explain-you-in-the-most-easiest-way-have-a-look-and-if-you-have-doubt-you-can-ask-me",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool helper(ListNode* head, TreeNode* root){\\n       if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr || head->val!=root->val) { \\n            //bec we are checking link also so we have to do  this. Basically here all the root we come through isSubPath function and if we are able to find first element of head in root than we wil check weathere there is link or not\\n\\n            return false; \\n        }\\n\\n   return helper(head->next,root->left)|| helper(head->next,root->right);\\n   // see here we are passing head->next also so that it we check if head->next and root->left  or right is link or not \\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr) {\\n            return false; // Reached the end of the tree\\n        }\\n\\n        //now we will check if there is some path int the tree or not \\n        if(helper(head,root)){\\n            return true;\\n        } // if it doesn\\'t return true means we are not able to find the link in root now we wil call on left and right side to check link available or not\\n\\n\\n        \\n        // here we are doing mistake is that we are only finding the element of linklist but not checking weathere the link is also prest or not \\n\\n        // if (root->val == head->val) { \\n        //     // Check if the current head value matches the root value\\n        //     // Make recursive calls to the left and right subtrees\\n        //     return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        // } \\n\\n\\n\\n        // If the values don\\'t match, make recursive calls to the left and right subtrees independently\\n        return isSubPath(head, root->left) || isSubPath(head, root->right) ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool helper(ListNode* head, TreeNode* root){\\n       if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr || head->val!=root->val) { \\n            //bec we are checking link also so we have to do  this. Basically here all the root we come through isSubPath function and if we are able to find first element of head in root than we wil check weathere there is link or not\\n\\n            return false; \\n        }\\n\\n   return helper(head->next,root->left)|| helper(head->next,root->right);\\n   // see here we are passing head->next also so that it we check if head->next and root->left  or right is link or not \\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr) {\\n            return false; // Reached the end of the tree\\n        }\\n\\n        //now we will check if there is some path int the tree or not \\n        if(helper(head,root)){\\n            return true;\\n        } // if it doesn\\'t return true means we are not able to find the link in root now we wil call on left and right side to check link available or not\\n\\n\\n        \\n        // here we are doing mistake is that we are only finding the element of linklist but not checking weathere the link is also prest or not \\n\\n        // if (root->val == head->val) { \\n        //     // Check if the current head value matches the root value\\n        //     // Make recursive calls to the left and right subtrees\\n        //     return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        // } \\n\\n\\n\\n        // If the values don\\'t match, make recursive calls to the left and right subtrees independently\\n        return isSubPath(head, root->left) || isSubPath(head, root->right) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109347,
                "title": "the-easiest-solution",
                "content": "# Approach\\nOrdinary DFS traversal is used. Each node of tree is checked to be part of the list - as easy as possible.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ in most usual cases, $$O(n^2)$$ in the worst case, when the tree and list contain the same value but list is larger then tree height.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        return self.traverseDFS(head, root)\\n    \\n\\n    def traverseDFS(self, head, treeNode):\\n        if not treeNode:\\n            return False\\n        \\n        ret = self.checkDFS(head, treeNode)\\n        if ret:\\n            return ret\\n\\n        ret = self.traverseDFS(head, treeNode.left)\\n        if ret:\\n            return ret\\n        \\n        return self.traverseDFS(head, treeNode.right)\\n\\n\\n    def checkDFS(self, listNode, treeNode):\\n        if listNode == None:\\n            return True\\n        elif treeNode == None:\\n            return False\\n        elif treeNode.val == listNode.val:\\n            ret = self.checkDFS(listNode.next, treeNode.left)\\n            if ret:\\n                return ret\\n\\n            return self.checkDFS(listNode.next, treeNode.right)\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Tree"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        return self.traverseDFS(head, root)\\n    \\n\\n    def traverseDFS(self, head, treeNode):\\n        if not treeNode:\\n            return False\\n        \\n        ret = self.checkDFS(head, treeNode)\\n        if ret:\\n            return ret\\n\\n        ret = self.traverseDFS(head, treeNode.left)\\n        if ret:\\n            return ret\\n        \\n        return self.traverseDFS(head, treeNode.right)\\n\\n\\n    def checkDFS(self, listNode, treeNode):\\n        if listNode == None:\\n            return True\\n        elif treeNode == None:\\n            return False\\n        elif treeNode.val == listNode.val:\\n            ret = self.checkDFS(listNode.next, treeNode.left)\\n            if ret:\\n                return ret\\n\\n            return self.checkDFS(listNode.next, treeNode.right)\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044011,
                "title": "c-recursion-binary-tree",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root, ListNode* curr, ListNode* head) {\\n        if(!curr) return true;\\n        if(!root) return false;\\n\\n        bool ans = false;\\n        \\n        ListNode *temp = curr;\\n        if(temp -> val == root -> val) {\\n            temp = curr -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }else{\\n            temp = head;\\n            if(head -> val == root -> val) temp = head -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }\\n\\n        return ans;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(root, head, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root, ListNode* curr, ListNode* head) {\\n        if(!curr) return true;\\n        if(!root) return false;\\n\\n        bool ans = false;\\n        \\n        ListNode *temp = curr;\\n        if(temp -> val == root -> val) {\\n            temp = curr -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }else{\\n            temp = head;\\n            if(head -> val == root -> val) temp = head -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }\\n\\n        return ans;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(root, head, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436467,
                "title": "simple-and-easy-to-understand-c-solution-using-recursion",
                "content": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n    \\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL)\\n            return false;\\n        if(match(head, root))\\n            return true;\\n        return dfs(head, root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool match(ListNode* head, TreeNode* root){\\n        if(head== NULL)\\n            return true;\\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return match(head->next,root->left) || match(head->next,root->right);\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n    \\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL)\\n            return false;\\n        if(match(head, root))\\n            return true;\\n        return dfs(head, root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool match(ListNode* head, TreeNode* root){\\n        if(head== NULL)\\n            return true;\\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return match(head->next,root->left) || match(head->next,root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2358081,
                "title": "c-brute-force-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool func(ListNode *head,TreeNode *root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val == root->val) return func(head->next,root->left) or func(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(func(head,root)) return true;\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/d813140d-dfa0-4566-96f9-5b88034f3eef_1659241756.820241.png)\\n**Please Upvote this post if you get any help from it.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(ListNode *head,TreeNode *root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val == root->val) return func(head->next,root->left) or func(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(func(head,root)) return true;\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355262,
                "title": "python-97-faster-recursive-approach-easy-and-clean-solution",
                "content": "***Please do upvote if found it helpful !!!!!!***\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkNextNode(self,head,root):\\n        checkLeft, checkRight = False, False\\n        if not head:\\n            return True\\n        if root.left and root.left.val == head.val:\\n            checkLeft = self.checkNextNode(head.next,root.left)\\n        if root.right and root.right.val == head.val:\\n            checkRight = self.checkNextNode(head.next,root.right)\\n        \\n        return checkLeft or checkRight\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.checkNextNode(head.next,root):\\n                return True\\n            \\n        checkLeft = self.isSubPath(head,root.left)\\n        checkRight = self.isSubPath(head,root.right)\\n            \\n        return checkLeft or checkRight\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkNextNode(self,head,root):\\n        checkLeft, checkRight = False, False\\n        if not head:\\n            return True\\n        if root.left and root.left.val == head.val:\\n            checkLeft = self.checkNextNode(head.next,root.left)\\n        if root.right and root.right.val == head.val:\\n            checkRight = self.checkNextNode(head.next,root.right)\\n        \\n        return checkLeft or checkRight\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.checkNextNode(head.next,root):\\n                return True\\n            \\n        checkLeft = self.isSubPath(head,root.left)\\n        checkRight = self.isSubPath(head,root.right)\\n            \\n        return checkLeft or checkRight\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219454,
                "title": "c-very-concise-code-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(!root) return (head==NULL);\\n         if(!head) return true;\\n        if(root->val!=head->val) return false;\\n            return check(head->next,root->left)|| check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(head,root)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(!root) return (head==NULL);\\n         if(!head) return true;\\n        if(root->val!=head->val) return false;\\n            return check(head->next,root->left)|| check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(head,root)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192635,
                "title": "java-dfs-faster-than-100-speed-optimised",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.val == head.val && check(head, root)) {\\n            return true;\\n        }\\n        \\n        if (isSubPath(head, root.left) || isSubPath(head, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if (head == null) {\\n            return true;\\n        }    \\n        \\n        if (root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        if (check(head.next, root.left) || check(head.next, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.val == head.val && check(head, root)) {\\n            return true;\\n        }\\n        \\n        if (isSubPath(head, root.left) || isSubPath(head, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if (head == null) {\\n            return true;\\n        }    \\n        \\n        if (root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        if (check(head.next, root.left) || check(head.next, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105593,
                "title": "c-short-beauty-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if (head == NULL) return true;\\n        if (root == NULL) return false;\\n        if (head->val != root->val) return false;\\n        return isPath(head->next, root->left) || isPath(head->next, root->right); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if (head == NULL) return true;\\n        if (root == NULL) return false;\\n        if (head->val != root->val) return false;\\n        return isPath(head->next, root->left) || isPath(head->next, root->right); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089608,
                "title": "python3-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def match(self,head,root):\\n        if(head == None): \\n            return True\\n        \\n        if(root == None):\\n            return False\\n        \\n        if(head.val != root.val):\\n            return False\\n        \\n        return self.match(head.next, root.left) or self.match(head.next, root.right)\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if(head == None): \\n            return True\\n        if(root == None):\\n            return False\\n                \\n        if(head.val == root.val):\\n            if(self.match(head, root)):\\n                return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def match(self,head,root):\\n        if(head == None): \\n            return True\\n        \\n        if(root == None):\\n            return False\\n        \\n        if(head.val != root.val):\\n            return False\\n        \\n        return self.match(head.next, root.left) or self.match(head.next, root.right)\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if(head == None): \\n            return True\\n        if(root == None):\\n            return False\\n                \\n        if(head.val == root.val):\\n            if(self.match(head, root)):\\n                return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088162,
                "title": "java-easy-dfs-approach",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(head == null) return true;\\n        return dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n        //The above line is to check the root.val and root.left.val and root.right.val , if anyone is true should be checked , then the dfs function will enable searching the depth of the tree\\n    }\\n    public boolean dfs(ListNode head, TreeNode root){\\n        //Depth first search\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val && (dfs(head.next,root.left) || dfs(head.next,root.right)); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(head == null) return true;\\n        return dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n        //The above line is to check the root.val and root.left.val and root.right.val , if anyone is true should be checked , then the dfs function will enable searching the depth of the tree\\n    }\\n    public boolean dfs(ListNode head, TreeNode root){\\n        //Depth first search\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val && (dfs(head.next,root.left) || dfs(head.next,root.right)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900313,
                "title": "c-dfs-bfs-reursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode *root,ListNode * head)\\n    {\\n        if(!head)\\n            return true;\\n        if(!root||root->val!=head->val)\\n        {\\n            return false;\\n        }\\n         if(dfs(root->right,head->next))\\n             return true;\\n        if(dfs(root->left,head->next))\\n            return true;\\n        \\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                TreeNode *temp=q.front();\\n                q.pop();\\n                bool cnt=0;\\n                if(temp->val==head->val)\\n                {\\n                     cnt=dfs(temp,head);\\n\\n                }\\n                if(cnt)\\n                {\\n                    return true;\\n                }\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n                \\n                \\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(TreeNode *root,ListNode * head)\\n    {\\n        if(!head)\\n            return true;\\n        if(!root||root->val!=head->val)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855468,
                "title": "simple-and-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        if (isPath(head, root)) return true;\\n        \\n        if (root == null || head == null) return false;\\n        \\n        return isSubPath(head, root.left) || \\n                isSubPath(head, root.right);\\n    }\\n    \\n    public boolean isPath(ListNode head, TreeNode root) {  \\n        if (head == null) return true;\\n        if (root == null) return false;\\n        \\n        if (head.val == root.val) {\\n            return isPath(head.next, root.left) || \\n                isPath(head.next, root.right);\\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        if (isPath(head, root)) return true;\\n        \\n        if (root == null || head == null) return false;\\n        \\n        return isSubPath(head, root.left) || \\n                isSubPath(head, root.right);\\n    }\\n    \\n    public boolean isPath(ListNode head, TreeNode root) {  \\n        if (head == null) return true;\\n        if (root == null) return false;\\n        \\n        if (head.val == root.val) {\\n            return isPath(head.next, root.left) || \\n                isPath(head.next, root.right);\\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795540,
                "title": "java-100-faster-dfs",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null || root == null) return false;\\n        \\n        //if the starting value is same then only we can try solving further\\n        if(root.val == head.val){\\n            \\n            /*\\n                Since java follows pass by reference by default,\\n                we need to store head and root in a separate variable and then pass it\\n                otherwise we will end by changing the value of head and root for the \\n                next possible iteration\\n            */\\n            TreeNode temproot = root;\\n            ListNode temphead = head;\\n            \\n            //now if our function returns true, then we stop here\\n            if(solve(temphead, temproot)) return true;\\n        }\\n        \\n        //otherwise keep on exploring for equal starting point\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    public boolean solve(ListNode head, TreeNode root){\\n        //if head == null, that means we have successfully traversed our list\\n        if(head == null) return true;\\n        \\n        //if root == null that means we have a few elements in list, but\\n        //not sufficient elements to compare with\\n        if(root == null) return false;\\n        \\n        /*\\n            if current values of both match then,\\n            try with left and right children now\\n        */\\n        if(head.val == root.val) \\n            return solve(head.next, root.left) || solve(head.next, root.right);\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null || root == null) return false;\\n        \\n        //if the starting value is same then only we can try solving further\\n        if(root.val == head.val){\\n            \\n            /*\\n                Since java follows pass by reference by default,\\n                we need to store head and root in a separate variable and then pass it\\n                otherwise we will end by changing the value of head and root for the \\n                next possible iteration\\n            */\\n            TreeNode temproot = root;\\n            ListNode temphead = head;\\n            \\n            //now if our function returns true, then we stop here\\n            if(solve(temphead, temproot)) return true;\\n        }\\n        \\n        //otherwise keep on exploring for equal starting point\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    public boolean solve(ListNode head, TreeNode root){\\n        //if head == null, that means we have successfully traversed our list\\n        if(head == null) return true;\\n        \\n        //if root == null that means we have a few elements in list, but\\n        //not sufficient elements to compare with\\n        if(root == null) return false;\\n        \\n        /*\\n            if current values of both match then,\\n            try with left and right children now\\n        */\\n        if(head.val == root.val) \\n            return solve(head.next, root.left) || solve(head.next, root.right);\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793183,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(ListNode* head, TreeNode* root){\\n        if(head==NULL) return true;//complete\\n        if(root==NULL) return false;\\n        if(head->val != root->val) return false;\\n        return helper(head->next, root->left) || helper(head->next, root->right);\\n    }\\n    \\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return true;\\n        if(root==NULL) return false;\\n        return helper(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(ListNode* head, TreeNode* root){\\n        if(head==NULL) return true;//complete\\n        if(root==NULL) return false;\\n        if(head->val != root->val) return false;\\n        return helper(head->next, root->left) || helper(head->next, root->right);\\n    }\\n    \\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return true;\\n        if(root==NULL) return false;\\n        return helper(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721625,
                "title": "simple-explaination-with-dfs-optimal-approach",
                "content": "# Recursive Approach:-\\n> Here the main point is to catch the idea that we will have to use DFS and will  have to define 2 recursion function .\\n> Since Linked List can start from any node so will have to make a single function which will check -- that linked list   start from this given head so for that we do this as :--\\n```\\n  bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n```\\nthat is simply check for current node and return if this note is starting point of linked list \\n\\n>Now actuall function will go for every node of tree in dfs manner hence we do it as:\\n```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) ||  isSubPath(head,root->right);\\n    }\\n  \\n```\\n\\n# Hence complete code will go like this :-\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n   \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n  };\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n```\n```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) ||  isSubPath(head,root->right);\\n    }\\n  \\n```\n```\\nclass Solution {\\npublic:\\n   \\n    bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n   \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n  };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440858,
                "title": "c-2-approaches-dfs-dfs-and-dfs-bfs",
                "content": "## 1. DFS + DFS \\n```\\n// DFS + DFS\\nclass Solution {\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(dfs2(head,root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool dfs2(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(head->val!=root->val) return false;\\n        return dfs2(head->next,root->left) || dfs2(head->next,root->right); \\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }  \\n};\\n```\\n\\n\\n## 2. DFS + BFS \\n```\\n// DFS + BFS\\n class Solution {\\n     bool dfs(ListNode* head, TreeNode* root){\\n         if(root == NULL) return false;\\n         bool ans=false;\\n         if(head->val == root->val){\\n             ans = bfs(head,root);\\n         }\\n         bool left = dfs(head,root->left);\\n         bool right = dfs(head,root->right);\\n         return left || right || ans;\\n     }\\n    \\n     bool bfs(ListNode* head, TreeNode* root){\\n         queue<TreeNode*> q;\\n         q.push(root);\\n         ListNode* temp=head->next;\\n         while(!q.empty()){\\n             int size = q.size();\\n             for(int i=0;i<size;i++){\\n                 TreeNode* node=q.front();\\n                 q.pop();\\n                \\n                 if(node->left && temp && node->left->val == temp->val){\\n                     q.push(node->left);\\n                 }\\n                 if(node->right && temp && node->right->val == temp->val){\\n                     q.push(node->right);\\n                 }\\n             }  \\n             if(!q.empty()) temp=temp->next;\\n         }\\n         return temp==NULL;\\n     }\\n public:\\n     bool isSubPath(ListNode* head, TreeNode* root) {\\n         return dfs(head,root);\\n     }\\n };\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// DFS + DFS\\nclass Solution {\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(dfs2(head,root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool dfs2(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(head->val!=root->val) return false;\\n        return dfs2(head->next,root->left) || dfs2(head->next,root->right); \\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }  \\n};\\n```\n```\\n// DFS + BFS\\n class Solution {\\n     bool dfs(ListNode* head, TreeNode* root){\\n         if(root == NULL) return false;\\n         bool ans=false;\\n         if(head->val == root->val){\\n             ans = bfs(head,root);\\n         }\\n         bool left = dfs(head,root->left);\\n         bool right = dfs(head,root->right);\\n         return left || right || ans;\\n     }\\n    \\n     bool bfs(ListNode* head, TreeNode* root){\\n         queue<TreeNode*> q;\\n         q.push(root);\\n         ListNode* temp=head->next;\\n         while(!q.empty()){\\n             int size = q.size();\\n             for(int i=0;i<size;i++){\\n                 TreeNode* node=q.front();\\n                 q.pop();\\n                \\n                 if(node->left && temp && node->left->val == temp->val){\\n                     q.push(node->left);\\n                 }\\n                 if(node->right && temp && node->right->val == temp->val){\\n                     q.push(node->right);\\n                 }\\n             }  \\n             if(!q.empty()) temp=temp->next;\\n         }\\n         return temp==NULL;\\n     }\\n public:\\n     bool isSubPath(ListNode* head, TreeNode* root) {\\n         return dfs(head,root);\\n     }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331966,
                "title": "python3-recursion-easy-to-understand",
                "content": "```\\n\\n# o(n*k)\\n\\nclass Solution:\\n    \\n    def isEmptyHead(self, head, root):\\n         \\n        # o(k)\\n        if not head: return True \\n        \\n        if not root: return False\\n        \\n        if head.val != root.val: return False\\n        \\n        if head:\\n            head = head.next \\n        \\n        left = self.isEmptyHead(head, root.left)\\n        right = self.isEmptyHead(head, root.right)\\n                \\n        return left or right \\n    \\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        # o(n)\\n        if root is None or head is None: return False \\n        \\n        if self.isEmptyHead(head, root): return True\\n        \\n        left = self.isSubPath(head, root.left)\\n        right = self.isSubPath(head, root.right)\\n        \\n        return left or right\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n# o(n*k)\\n\\nclass Solution:\\n    \\n    def isEmptyHead(self, head, root):\\n         \\n        # o(k)\\n        if not head: return True \\n        \\n        if not root: return False\\n        \\n        if head.val != root.val: return False\\n        \\n        if head:\\n            head = head.next \\n        \\n        left = self.isEmptyHead(head, root.left)\\n        right = self.isEmptyHead(head, root.right)\\n                \\n        return left or right \\n    \\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        # o(n)\\n        if root is None or head is None: return False \\n        \\n        if self.isEmptyHead(head, root): return True\\n        \\n        left = self.isSubPath(head, root.left)\\n        right = self.isSubPath(head, root.right)\\n        \\n        return left or right\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306639,
                "title": "traverse-the-tree-and-recursively-check-with-the-list-90-speed",
                "content": "Runtime: 96 ms, faster than 90.37% of Python3 online submissions for Linked List in Binary Tree.\\nMemory Usage: 14.8 MB, less than 96.67% of Python3 online submissions for Linked List in Binary Tree.\\n\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\n        def compare_values(l_node: ListNode, t_node: TreeNode):\\n            if not l_node:\\n                return True\\n            if t_node and l_node.val == t_node.val:\\n                return (compare_values(l_node.next, t_node.left) or\\n                        compare_values(l_node.next, t_node.right))\\n            return False\\n\\n        row = {root}\\n        while row:\\n            next_row = set()\\n            for node in row:\\n                if node.val == head.val and compare_values(head, node):\\n                    return True\\n                if node.left:\\n                    next_row.add(node.left)\\n                if node.right:\\n                    next_row.add(node.right)\\n            row = next_row\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\n        def compare_values(l_node: ListNode, t_node: TreeNode):\\n            if not l_node:\\n                return True\\n            if t_node and l_node.val == t_node.val:\\n                return (compare_values(l_node.next, t_node.left) or\\n                        compare_values(l_node.next, t_node.right))\\n            return False\\n\\n        row = {root}\\n        while row:\\n            next_row = set()\\n            for node in row:\\n                if node.val == head.val and compare_values(head, node):\\n                    return True\\n                if node.left:\\n                    next_row.add(node.left)\\n                if node.right:\\n                    next_row.add(node.right)\\n            row = next_row\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215163,
                "title": "java-tree-linkedlist-beats-100-1ms-t-c-o-n-l-s-c-o-n",
                "content": "\\n    // O(N*L) O(N)\\n\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean self = isSubPathHelper(root, head);\\n\\t\\tif (self)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean left = isSubPath(head, root.left);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPath(head, root.right);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// O(L) O(L)\\n\\tpublic boolean isSubPathHelper(TreeNode root, ListNode head) {\\n\\n\\t\\tif (head == null)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (root == null || root.val != head.val)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean left = isSubPathHelper(root.left, head.next);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPathHelper(root.right, head.next);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(N*L) O(N)\\n\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean self = isSubPathHelper(root, head);\\n\\t\\tif (self)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean left = isSubPath(head, root.left);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPath(head, root.right);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// O(L) O(L)\\n\\tpublic boolean isSubPathHelper(TreeNode root, ListNode head) {\\n\\n\\t\\tif (head == null)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (root == null || root.val != head.val)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean left = isSubPathHelper(root.left, head.next);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPathHelper(root.right, head.next);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1120893,
                "title": "java-dfs-beats-99",
                "content": "more details can be found here: [Leetcode 1367. Linked List in Binary Tree](https://www.tipeca.com/learning/leetcode-1367-linked-list-in-binary-tree/)\\n\\n```\\nclass Solution {\\n    List<Integer> target;\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        target = new ArrayList();\\n        while (head != null) {\\n            target.add(head.val);\\n            head = head.next;\\n        }\\n        return isSubPath(new ArrayList(), root);\\n    }\\n    \\n    private boolean isSubPath(List<Integer> path, TreeNode node) {\\n        if (node == null) return false;\\n        path.add(node.val);\\n        if (match(path)) return true;\\n        if (isSubPath(path, node.left)) return true;\\n        if (isSubPath(path, node.right)) return true;\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n    \\n    private boolean match(List<Integer> path) {\\n        if (path.size() < target.size()) return false;\\n        int pi = path.size() - 1, ti = target.size() - 1;\\n        while (ti >= 0) {\\n            if (path.get(pi) != target.get(ti)) return false;\\n            pi--;\\n            ti--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> target;\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        target = new ArrayList();\\n        while (head != null) {\\n            target.add(head.val);\\n            head = head.next;\\n        }\\n        return isSubPath(new ArrayList(), root);\\n    }\\n    \\n    private boolean isSubPath(List<Integer> path, TreeNode node) {\\n        if (node == null) return false;\\n        path.add(node.val);\\n        if (match(path)) return true;\\n        if (isSubPath(path, node.left)) return true;\\n        if (isSubPath(path, node.right)) return true;\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n    \\n    private boolean match(List<Integer> path) {\\n        if (path.size() < target.size()) return false;\\n        int pi = path.size() - 1, ti = target.size() - 1;\\n        while (ti >= 0) {\\n            if (path.get(pi) != target.get(ti)) return false;\\n            pi--;\\n            ti--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056364,
                "title": "java-using-dfs-1ms-match-with-each-tree-node-as-starting-point",
                "content": "```\\nclass Solution {\\n    // Call Match the List with Tree on each tree node as starting point\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root){\\n        \\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        boolean flag = isSubPathRoot(head, root);\\n        flag = flag || dfs(head, root.left) || dfs(head, root.right);\\n        return flag;\\n        \\n    }\\n    \\n    boolean isSubPathRoot(ListNode head, TreeNode root){\\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        if(head.val == root.val){\\n            return isSubPathRoot(head.next, root.left) || isSubPathRoot(head.next, root.right);\\n        }else{\\n            return false;\\n        }\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Call Match the List with Tree on each tree node as starting point\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root){\\n        \\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        boolean flag = isSubPathRoot(head, root);\\n        flag = flag || dfs(head, root.left) || dfs(head, root.right);\\n        return flag;\\n        \\n    }\\n    \\n    boolean isSubPathRoot(ListNode head, TreeNode root){\\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        if(head.val == root.val){\\n            return isSubPathRoot(head.next, root.left) || isSubPathRoot(head.next, root.right);\\n        }else{\\n            return false;\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026181,
                "title": "simple-java-easy-understanding-recusrion",
                "content": "```\\n\\nclass Solution {\\n    boolean isCheckPath=false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        boolean isCheckPath = checkForSubPath(head, root);\\n        if (root!=null && !isCheckPath)\\n            return  isSubPath(head, root.left)||isSubPath(head, root.right);\\n        return isCheckPath;\\n    }\\n    \\n    public boolean checkForSubPath(ListNode head, TreeNode root){\\n        \\n        if (head==null)\\n            return true;\\n        \\n        if (root==null)\\n            return false;\\n        \\n        if (head.val==root.val)\\n            return checkForSubPath(head.next, root.left) || checkForSubPath(head.next, root.right);\\n        \\n        return isCheckPath;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    boolean isCheckPath=false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        boolean isCheckPath = checkForSubPath(head, root);\\n        if (root!=null && !isCheckPath)\\n            return  isSubPath(head, root.left)||isSubPath(head, root.right);\\n        return isCheckPath;\\n    }\\n    \\n    public boolean checkForSubPath(ListNode head, TreeNode root){\\n        \\n        if (head==null)\\n            return true;\\n        \\n        if (root==null)\\n            return false;\\n        \\n        if (head.val==root.val)\\n            return checkForSubPath(head.next, root.left) || checkForSubPath(head.next, root.right);\\n        \\n        return isCheckPath;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954918,
                "title": "python-dp",
                "content": "I\\'ve read Lee\\'s post, but it took me a very long time to understand his DP solution, so I\\'m posting mine, with one key observation:\\n\\n`dp[i]` contains the length of the longest prefix of `A` that is also a suffix of `A[1:i]`.\\nTo understand the while loop one can observe that a suffix of a suffix of `A` is also a suffix of `A`.\\n\\nHeres the code:\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        A = []\\n        while head:\\n            A += [head.val]\\n            head = head.next\\n        dp = [0,0]\\n        i = 0\\n        for c in A[1:]:\\n            while i and c != A[i]:\\n                i = dp[i-1]\\n            i += c == A[i]\\n            dp += [i]\\n        def dfs(node,i):\\n            if not node:\\n                return False \\n            \\n            c = node.val\\n            while i and c != A[i]:\\n                i = dp[i]\\n            i += c == A[i]\\n            return i == len(A) or dfs(node.left,i) or dfs(node.right,i)\\n        \\n        return dfs(root,0)\\n            \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        A = []\\n        while head:\\n            A += [head.val]\\n            head = head.next\\n        dp = [0,0]\\n        i = 0\\n        for c in A[1:]:\\n            while i and c != A[i]:\\n                i = dp[i-1]\\n            i += c == A[i]\\n            dp += [i]\\n        def dfs(node,i):\\n            if not node:\\n                return False \\n            \\n            c = node.val\\n            while i and c != A[i]:\\n                i = dp[i]\\n            i += c == A[i]\\n            return i == len(A) or dfs(node.left,i) or dfs(node.right,i)\\n        \\n        return dfs(root,0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 947631,
                "title": "c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(TreeNode*root,ListNode*head)\\n    {\\n        if(head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return (root->val==head->val)&&(find(root->left,head->next)||find(root->right,head->next));\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {    \\n        if(root==NULL&&head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return find(root,head)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(TreeNode*root,ListNode*head)\\n    {\\n        if(head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return (root->val==head->val)&&(find(root->left,head->next)||find(root->right,head->next));\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {    \\n        if(root==NULL&&head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return find(root,head)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825022,
                "title": "can-someone-please-help-what-is-wrong-with-my-code-its-passing-59-61-test-cases",
                "content": "\\'\\'\\'\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(root==NULL && head!=NULL)\\n        {\\n            return false;\\n        }\\n        if(head==NULL)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            if(root->val==head->val)\\n            {\\n                head=head->next;\\n            }\\n            if(isSubPath(head,root->left) || isSubPath(head,root->right))\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(root==NULL && head!=NULL)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 810533,
                "title": "c-greedily-dfs-search",
                "content": "```csharp\\npublic class Solution {\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        return (root != null) && (Find(head, root) || IsSubPath(head, root.left) || IsSubPath(head, root.right));\\n    }\\n    \\n    private bool Find(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (root.val == head.val) && (Find(head.next, root.left) || Find(head.next, root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        return (root != null) && (Find(head, root) || IsSubPath(head, root.left) || IsSubPath(head, root.right));\\n    }\\n    \\n    private bool Find(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (root.val == head.val) && (Find(head.next, root.left) || Find(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809839,
                "title": "recursive-solution-beats-98-95-in-time-and-97-61-in-space-c",
                "content": "* ### 40 ms runtime\\n* ### 31.9 MB space\\n```\\nclass Solution\\n{\\npublic:\\n    \\n    bool containsList(ListNode* head, TreeNode* root)\\n    {\\n        if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        return (head->val == root->val) && (containsList(head->next, root->left) || containsList(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root) return false;\\n        if(containsList(head, root)) return true;\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```\\n#### If you like the solution, do give it an upvote. In case of queries, feel free to leave them in the comment.\\n#### LeetCode and Chill !!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool containsList(ListNode* head, TreeNode* root)\\n    {\\n        if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        return (head->val == root->val) && (containsList(head->next, root->left) || containsList(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root) return false;\\n        if(containsList(head, root)) return true;\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794913,
                "title": "my-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> storingList = new ArrayList();\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        storeToList(head, root);\\n        for (TreeNode element: storingList){\\n            if (checkSubPath(head, element))\\n                return true;\\n        }\\n        return false;\\n    }\\n    public void storeToList(ListNode head, TreeNode node){\\n        if (head == null || node == null)\\n            return;\\n        if (head.val == node.val)\\n            storingList.add(node);\\n        storeToList(head, node.left);\\n        storeToList(head, node.right);\\n    }\\n    public boolean checkSubPath(ListNode head, TreeNode node){\\n        if (head == null)\\n            return true;\\n        if (node == null)\\n            return false;\\n        if (head.val == node.val)\\n            return (checkSubPath(head.next, node.left) || checkSubPath(head.next, node.right));\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> storingList = new ArrayList();\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        storeToList(head, root);\\n        for (TreeNode element: storingList){\\n            if (checkSubPath(head, element))\\n                return true;\\n        }\\n        return false;\\n    }\\n    public void storeToList(ListNode head, TreeNode node){\\n        if (head == null || node == null)\\n            return;\\n        if (head.val == node.val)\\n            storingList.add(node);\\n        storeToList(head, node.left);\\n        storeToList(head, node.right);\\n    }\\n    public boolean checkSubPath(ListNode head, TreeNode node){\\n        if (head == null)\\n            return true;\\n        if (node == null)\\n            return false;\\n        if (head.val == node.val)\\n            return (checkSubPath(head.next, node.left) || checkSubPath(head.next, node.right));\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739090,
                "title": "cpp-simple-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode* head, TreeNode* root){\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return false;\\n        return check(head->next,root->left)||check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        else{\\n            return check(head->next,root->left)||\\n                   check(head->next,root->right)||\\n                   isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode* head, TreeNode* root){\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return false;\\n        return check(head->next,root->left)||check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        else{\\n            return check(head->next,root->left)||\\n                   check(head->next,root->right)||\\n                   isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710322,
                "title": "c-recursive-solution",
                "content": "```\\nbool dfs(ListNode *head, TreeNode *root){\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\tif(root->val != head->val)\\n\\t\\treturn false;\\n\\treturn dfs(head->next,root->left) || dfs(head->next,root->right);\\n}\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\n\\treturn dfs(head,root) || isSubPath(head,root->left) ||isSubPath(head,root->right);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool dfs(ListNode *head, TreeNode *root){\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\tif(root->val != head->val)\\n\\t\\treturn false;\\n\\treturn dfs(head->next,root->left) || dfs(head->next,root->right);\\n}\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\n\\treturn dfs(head,root) || isSubPath(head,root->left) ||isSubPath(head,root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670466,
                "title": "java-bfs-dfs",
                "content": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        // idea is to start a dfs whenever we find a matching head\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            \\n            if(node.val == head.val && dfs(head, node))   return true;\\n            \\n            if(node.left!=null)   q.offer(node.left);\\n            if(node.right!=null)  q.offer(node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        // idea is to start a dfs whenever we find a matching head\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            \\n            if(node.val == head.val && dfs(head, node))   return true;\\n            \\n            if(node.left!=null)   q.offer(node.left);\\n            if(node.right!=null)  q.offer(node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 603775,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return head == null;\\n        }\\n        \\n        return dfs(head, root) || isSubPath(head, root.right) || isSubPath(head, root.left);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        } \\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        return dfs(head.next, root.left) || dfs(head.next, root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return head == null;\\n        }\\n        \\n        return dfs(head, root) || isSubPath(head, root.right) || isSubPath(head, root.left);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        } \\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        return dfs(head.next, root.left) || dfs(head.next, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589982,
                "title": "recursion-solution-using-kmp-time-beat-100-space-beat-100",
                "content": "Inspired by the KMP solution [here](https://leetcode.com/problems/implement-strstr/discuss/589972/Implement-of-KMP-with-python-(in-line-explanation)), we can easily solve this challenge by using the same approach, which is always used to solve pattern matching problems.\\n\\nM = length(pattern)    N = size(tree)    L = logN   (tree hight)\\nTime: O(N)\\nSpace: O(M + L)\\n\\n```\\n\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        global pattern, nxt\\n        \\n\\t\\t# transform the pattern into array list\\n        def LinkedListToArray(head):\\n            ans = []\\n            while(head):\\n                ans.append(head.val)\\n                head = head.next\\n            return ans\\n        \\n\\t\\t# to generate a index array, which is the core part of the KMP\\n        def createLPS(pattern, len):\\n            ans = [0] * len\\n            i, j = 0, 1\\n            while(j < len):\\n                if pattern[i] == pattern[j]:\\n                    i += 1\\n                    ans[j] = i\\n                    j += 1\\n                else:\\n                    if i != 0:\\n                        i = ans[i-1]\\n                    else:\\n                        ans[j] = i\\n                        j += 1\\n            return ans\\n        \\n\\t\\t# recursion part\\n        def dfs(root, i):\\n            if i == len(pattern): return True\\n            if root is None: return False\\n            \\n            global pattern, nxt\\n            \\n            if root.val == pattern[i]:\\n                return dfs(root.left, i + 1) or dfs(root.right, i + 1)\\n            if i > 0:\\n                i = nxt[i - 1]\\n                return dfs(root, i)\\n            else:\\n                return dfs(root.left, i) or dfs(root.right, i)\\n                \\n        global pattern, nxt\\n        pattern = LinkedListToArray(head)\\n        M = len(pattern)\\n        nxt = createLPS(pattern, M)\\n        if M == 0:\\n            return True\\n        return dfs(root, 0)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        global pattern, nxt\\n        \\n\\t\\t# transform the pattern into array list\\n        def LinkedListToArray(head):\\n            ans = []\\n            while(head):\\n                ans.append(head.val)\\n                head = head.next\\n            return ans\\n        \\n\\t\\t# to generate a index array, which is the core part of the KMP\\n        def createLPS(pattern, len):\\n            ans = [0] * len\\n            i, j = 0, 1\\n            while(j < len):\\n                if pattern[i] == pattern[j]:\\n                    i += 1\\n                    ans[j] = i\\n                    j += 1\\n                else:\\n                    if i != 0:\\n                        i = ans[i-1]\\n                    else:\\n                        ans[j] = i\\n                        j += 1\\n            return ans\\n        \\n\\t\\t# recursion part\\n        def dfs(root, i):\\n            if i == len(pattern): return True\\n            if root is None: return False\\n            \\n            global pattern, nxt\\n            \\n            if root.val == pattern[i]:\\n                return dfs(root.left, i + 1) or dfs(root.right, i + 1)\\n            if i > 0:\\n                i = nxt[i - 1]\\n                return dfs(root, i)\\n            else:\\n                return dfs(root.left, i) or dfs(root.right, i)\\n                \\n        global pattern, nxt\\n        pattern = LinkedListToArray(head)\\n        M = len(pattern)\\n        nxt = createLPS(pattern, M)\\n        if M == 0:\\n            return True\\n        return dfs(root, 0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 589556,
                "title": "sharing-my-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(null == head)\\n        {\\n            return true;\\n        }\\n        if(null == root)\\n        {\\n            return false;\\n        }\\n        \\n        if(root.val == head.val)\\n        {\\n             if(path(root, head))\\n             {\\n                 return true;\\n             }\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    private boolean path(TreeNode node, ListNode head)\\n    {\\n        if(head == null)\\n        {\\n            return true;\\n        }\\n        \\n        if(node == null)\\n        {\\n            return false;\\n        }\\n        \\n        if(node.val != head.val)\\n        {\\n            return false; \\n        }\\n        \\n        return path(node.left, head.next) || path(node.right, head.next);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(null == head)\\n        {\\n            return true;\\n        }\\n        if(null == root)\\n        {\\n            return false;\\n        }\\n        \\n        if(root.val == head.val)\\n        {\\n             if(path(root, head))\\n             {\\n                 return true;\\n             }\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    private boolean path(TreeNode node, ListNode head)\\n    {\\n        if(head == null)\\n        {\\n            return true;\\n        }\\n        \\n        if(node == null)\\n        {\\n            return false;\\n        }\\n        \\n        if(node.val != head.val)\\n        {\\n            return false; \\n        }\\n        \\n        return path(node.left, head.next) || path(node.right, head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577567,
                "title": "java-dfs-100-faster-and-space-efficient-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(isIdentical(head,root)){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn isSubPath(head,root.left) || isSubPath(head,root.right);\\n\\t\\t}\\n\\n\\t\\tprivate boolean isIdentical(ListNode head, TreeNode root){\\n\\t\\t\\tif(head == null)\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif(root == null || root.val != head.val)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn isIdentical(head.next, root.left) || isIdentical(head.next, root.right);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(isIdentical(head,root)){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 573030,
                "title": "please-find-out-the-error-in-this-solution-c",
                "content": "**class Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root)return false;if(!head)return true;\\n        if(root->val==head->val)\\n            return(isSubPath(head->next,root->left)||isSubPath(head->next,root->right));\\n        \\n        return(isSubPath(head,root->left)||isSubPath(head,root->right));\\n    \\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root)return false;if(!head)return true;\\n        if(root->val==head->val)\\n            return(isSubPath(head->next,root->left)||isSubPath(head->next,root->right));\\n        \\n        return(isSubPath(head,root->left)||isSubPath(head,root->right));\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 538905,
                "title": "c-find-the-first-node-and-recursion",
                "content": "```\\n// it\\'s a little bit complex but might be clearer to read and hopefully reduce some calculation\\n\\nclass Solution {\\n    void findFirstMatch(ListNode* head, TreeNode* node, vector<TreeNode*>& total) {\\n\\t\\t// find the TreeNodes that matches the head ListNode, in order to reduce calculation\\n        if(!node || !head)\\n            return;\\n        if(node->val == head->val)\\n            total.push_back(node);\\n        findFirstMatch(head, node->left, total);\\n        findFirstMatch(head, node->right, total);\\n    }\\npublic:\\n    bool helper(ListNode* node_list, TreeNode* node_tree) {\\n        if(!node_list)\\n            return true;\\n        else if(!node_tree)\\n            return false;\\n        if(node_list->val != node_tree->val)\\n            return false;\\n        return helper(node_list->next, node_tree->left) || helper(node_list->next, node_tree->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> total;\\n        findFirstMatch(head, root, total);\\n        if(total.size() == 0)\\n            return false;\\n        for(auto node: total) {\\n            if(helper(head, node))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// it\\'s a little bit complex but might be clearer to read and hopefully reduce some calculation\\n\\nclass Solution {\\n    void findFirstMatch(ListNode* head, TreeNode* node, vector<TreeNode*>& total) {\\n\\t\\t// find the TreeNodes that matches the head ListNode, in order to reduce calculation\\n        if(!node || !head)\\n            return;\\n        if(node->val == head->val)\\n            total.push_back(node);\\n        findFirstMatch(head, node->left, total);\\n        findFirstMatch(head, node->right, total);\\n    }\\npublic:\\n    bool helper(ListNode* node_list, TreeNode* node_tree) {\\n        if(!node_list)\\n            return true;\\n        else if(!node_tree)\\n            return false;\\n        if(node_list->val != node_tree->val)\\n            return false;\\n        return helper(node_list->next, node_tree->left) || helper(node_list->next, node_tree->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> total;\\n        findFirstMatch(head, root, total);\\n        if(total.size() == 0)\\n            return false;\\n        for(auto node: total) {\\n            if(helper(head, node))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532841,
                "title": "c-fastest-matching-using-kmp-dfa",
                "content": "I see a lot of brute force recursions, but I used KMP (Knuth-Morris-Pratt) with a simple DFA which is easy and matches faster.\\n\\nThe key observations related to having a tree as input source:\\n\\n1. The sequencing splits every time you descend left/right. So state restoration by \"backing up\" the source with all this branching isn\\'t easy ... or even possible for some algorithms.\\n2. Match state should ideally be self-contained per recursive frame as a simple index or tag. So that merely returning back up the call chain suffices to back up processing on failures.\\n3. Preprocessing the pattern which can be used at all call levels by simply knowing the right state index you are at in it works great. The linked list is just noise that you only need until you have the DFA which is what you actually use.\\n4. The ideal is to only pass through a given node ONCE and never have to backtrack to it and re-descend. For example, you want to avoid separate visitations from overall node traversal vs. path existence checking. This does that.\\n\\nHence KMP.\\n\\n[Note: Obviously building the DFA is some overhead that might dominate a trivially small example but is a drop in the ocean on large ones. Try a few maxed examples.]\\n\\n```\\npublic class Solution\\n{\\n\\tconst int MAX_PAT = 100;\\n\\n\\tpublic bool IsSubPath(ListNode pattern, TreeNode root)\\n\\t{\\n\\t\\tif (pattern == null || root == null) return false;\\n\\t\\tbyte[,] dfa = MakeDfa(pattern);\\n\\t\\tDumpDfa(dfa);\\n\\t\\treturn IsSubPath(root, 0, dfa);\\n\\t}\\n\\n\\tbool IsSubPath(TreeNode tn, byte dfaState, byte[,] dfa/*, int depth=0*/)\\n\\t{\\n\\t\\t//Console.WriteLine($\"{\"\".PadLeft(depth*2)} Node: {(tn==null?\"\":tn.val.ToString())} state={dfaState}\");\\n\\t\\tif (dfaState == dfa.GetLength(1)) return true; // bingo! since GetLength(1) is the pattern length we reached the final state\\n\\t\\tif (tn == null) return false; // ran out of tree data\\n\\n\\t\\t// Assume 0 for any char value higher then what the pattern has to save rows in the dfa.\\n\\t\\tbyte nextState = tn.val >= dfa.GetLength(0) ? (byte)0 : dfa[tn.val, dfaState];\\n\\t\\treturn IsSubPath(tn.left, nextState, dfa/*, depth+1*/) || IsSubPath(tn.right, nextState, dfa/*, depth+1*/);\\n\\t}\\n\\n\\t// Use KMP dfa table since it doesn\\'t need to back up in the tree,\\n\\t// and just sets the proper state (pattern position) for whatever the current tree node val is\\n\\tbyte[,] MakeDfa(ListNode listPattern)\\n\\t{\\n\\t\\t// Use a temp pattern[] for ease; we don\\'t need it or the linked list version after we build our dfa anyhow\\n\\t\\tList<byte> pat = new List<byte>(MAX_PAT);\\n\\t\\tint patMaxVal = 0;\\n\\t\\tfor (ListNode ln = listPattern; ln != null; ln = ln.next)\\n\\t\\t{\\n\\t\\t\\tif (ln.val > patMaxVal) patMaxVal = ln.val; // highest pattern value seen\\n\\t\\t\\tpat.Add((byte)ln.val);\\n\\t\\t}\\n\\n\\t\\t// The dfa that will drive the mismatch handling.\\n\\t\\t// Determines which pattern position we check against the next input value:\\n\\t\\t// - back up to some previous pattern position on mismatches\\n\\t\\t// - +1 for matches\\n\\t\\t// Note: The input form the tree recursion always moves forward\\n\\t\\t// which is important since the input is from recursively iterating a tree\\n\\t\\t// that would not be trivial to \"back up\".\\n\\t\\t// This is why we use the KMP dfa mechanism as opposed to, say, Boyer-Moore or Rabin-Karp.\\n\\t\\tbyte[,] dfa = new byte[patMaxVal+1, pat.Count];\\n\\t\\tdfa[pat[0], 0] = 1;\\n\\t\\tfor (byte x = 0, j = 1; j < pat.Count; j++)\\n\\t\\t{\\n\\t\\t\\tfor (byte ch = 1; ch <= patMaxVal; ch++)\\n\\t\\t\\t\\tdfa[ch, j] = dfa[ch, x];\\n\\t\\t\\tdfa[pat[j], j] = (byte)(j + 1);\\n\\t\\t\\tx = dfa[pat[j], x];\\n\\t\\t}\\n\\t\\tpat = null;\\n\\t\\treturn dfa;\\n\\t}\\n\\n\\t[Conditional(\"DEBUG\")]\\n\\tvoid DumpDfa(byte[,] dfa)\\n\\t{\\n\\t\\tConsole.WriteLine($\"DFA: {dfa.GetLength(0)} x {dfa.GetLength(1)}\");\\n\\t\\tConsole.Write(\"    \");\\n\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\tConsole.Write($\"{j,4}\");\\n\\t\\tConsole.WriteLine();\\n\\t\\tfor (int i = 0; i < dfa.GetLength(0); i++)\\n\\t\\t{\\n\\t\\t\\tConsole.Write($\"{i,4}\");\\n\\t\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\t\\tConsole.Write($\"{dfa[i,j],4}\");\\n\\t\\t\\tConsole.WriteLine();\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n\\tconst int MAX_PAT = 100;\\n\\n\\tpublic bool IsSubPath(ListNode pattern, TreeNode root)\\n\\t{\\n\\t\\tif (pattern == null || root == null) return false;\\n\\t\\tbyte[,] dfa = MakeDfa(pattern);\\n\\t\\tDumpDfa(dfa);\\n\\t\\treturn IsSubPath(root, 0, dfa);\\n\\t}\\n\\n\\tbool IsSubPath(TreeNode tn, byte dfaState, byte[,] dfa/*, int depth=0*/)\\n\\t{\\n\\t\\t//Console.WriteLine($\"{\"\".PadLeft(depth*2)} Node: {(tn==null?\"\":tn.val.ToString())} state={dfaState}\");\\n\\t\\tif (dfaState == dfa.GetLength(1)) return true; // bingo! since GetLength(1) is the pattern length we reached the final state\\n\\t\\tif (tn == null) return false; // ran out of tree data\\n\\n\\t\\t// Assume 0 for any char value higher then what the pattern has to save rows in the dfa.\\n\\t\\tbyte nextState = tn.val >= dfa.GetLength(0) ? (byte)0 : dfa[tn.val, dfaState];\\n\\t\\treturn IsSubPath(tn.left, nextState, dfa/*, depth+1*/) || IsSubPath(tn.right, nextState, dfa/*, depth+1*/);\\n\\t}\\n\\n\\t// Use KMP dfa table since it doesn\\'t need to back up in the tree,\\n\\t// and just sets the proper state (pattern position) for whatever the current tree node val is\\n\\tbyte[,] MakeDfa(ListNode listPattern)\\n\\t{\\n\\t\\t// Use a temp pattern[] for ease; we don\\'t need it or the linked list version after we build our dfa anyhow\\n\\t\\tList<byte> pat = new List<byte>(MAX_PAT);\\n\\t\\tint patMaxVal = 0;\\n\\t\\tfor (ListNode ln = listPattern; ln != null; ln = ln.next)\\n\\t\\t{\\n\\t\\t\\tif (ln.val > patMaxVal) patMaxVal = ln.val; // highest pattern value seen\\n\\t\\t\\tpat.Add((byte)ln.val);\\n\\t\\t}\\n\\n\\t\\t// The dfa that will drive the mismatch handling.\\n\\t\\t// Determines which pattern position we check against the next input value:\\n\\t\\t// - back up to some previous pattern position on mismatches\\n\\t\\t// - +1 for matches\\n\\t\\t// Note: The input form the tree recursion always moves forward\\n\\t\\t// which is important since the input is from recursively iterating a tree\\n\\t\\t// that would not be trivial to \"back up\".\\n\\t\\t// This is why we use the KMP dfa mechanism as opposed to, say, Boyer-Moore or Rabin-Karp.\\n\\t\\tbyte[,] dfa = new byte[patMaxVal+1, pat.Count];\\n\\t\\tdfa[pat[0], 0] = 1;\\n\\t\\tfor (byte x = 0, j = 1; j < pat.Count; j++)\\n\\t\\t{\\n\\t\\t\\tfor (byte ch = 1; ch <= patMaxVal; ch++)\\n\\t\\t\\t\\tdfa[ch, j] = dfa[ch, x];\\n\\t\\t\\tdfa[pat[j], j] = (byte)(j + 1);\\n\\t\\t\\tx = dfa[pat[j], x];\\n\\t\\t}\\n\\t\\tpat = null;\\n\\t\\treturn dfa;\\n\\t}\\n\\n\\t[Conditional(\"DEBUG\")]\\n\\tvoid DumpDfa(byte[,] dfa)\\n\\t{\\n\\t\\tConsole.WriteLine($\"DFA: {dfa.GetLength(0)} x {dfa.GetLength(1)}\");\\n\\t\\tConsole.Write(\"    \");\\n\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\tConsole.Write($\"{j,4}\");\\n\\t\\tConsole.WriteLine();\\n\\t\\tfor (int i = 0; i < dfa.GetLength(0); i++)\\n\\t\\t{\\n\\t\\t\\tConsole.Write($\"{i,4}\");\\n\\t\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\t\\tConsole.Write($\"{dfa[i,j],4}\");\\n\\t\\t\\tConsole.WriteLine();\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526365,
                "title": "readable-recursive-solution-using-only-one-method-c",
                "content": "```\\n public bool IsSubPath(ListNode head, TreeNode root, bool mustHaveEqualValues = false)\\n        {\\n            if (head == null)\\n                return true;\\n            if (root == null)\\n                return false;\\n\\n            if (head.val == root.val && (IsSubPath(head.next, root.left, true) || IsSubPath(head.next, root.right, true)))\\n                return true;\\n            if (mustHaveEqualValues)\\n                return false;\\n\\n            return IsSubPath(head, root.left) || IsSubPath(head, root.right);\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n public bool IsSubPath(ListNode head, TreeNode root, bool mustHaveEqualValues = false)\\n        {\\n            if (head == null)\\n                return true;\\n            if (root == null)\\n                return false;\\n\\n            if (head.val == root.val && (IsSubPath(head.next, root.left, true) || IsSubPath(head.next, root.right, true)))\\n                return true;\\n            if (mustHaveEqualValues)\\n                return false;\\n\\n            return IsSubPath(head, root.left) || IsSubPath(head, root.right);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525814,
                "title": "python3-a-naive-dp-approach",
                "content": "Algorithm: \\nThis approached is insired by the discussion in this [thread](https://leetcode.com/problems/linked-list-in-binary-tree/discuss/525208/Help-Can-somebody-Help-why-this-is-TLE). \\n\\nImplementation (152ms): \\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(node, root): \\n            if not node: return True \\n            if not root: return False \\n            \\n            if root.val == node.val: \\n                return fn(node.next, root.left) or fn(node.next, root.right) or fn(head, root.left) or fn(head, root.right)\\n            else: \\n                return fn(head, root.left) or fn(head, root.right)\\n                    \\n        return fn(head, root)\\n```\\n\\nAnalysis:\\nTime complexity `O(MN)`\\nSpace complexity `O(MN)`\\n\\nUpdated with KMP algorithm per @lee215\\n\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        #build longest prefix-suffix array\\n        pattern, lps = [head.val], [0] #longest prefix-suffix array\\n        j = 0\\n        while head.next: \\n            head = head.next \\n            pattern.append(head.val)\\n            \\n            while j and head.val != pattern[j]: j = lps[j-1]\\n            if head.val == pattern[j]: j += 1\\n            lps.append(j)\\n            \\n        def dfs(root, i): \\n            \"\"\"Return True of tree rooted at \"root\" match pattern\"\"\"\\n            if i == len(pattern): return True\\n            if not root: return False \\n            \\n            while i > 0 and root.val != pattern[i]: i = lps[i-1]\\n            if root.val == pattern[i]: i += 1\\n            return dfs(root.left, i) or dfs(root.right, i)\\n        \\n        return dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(node, root): \\n            if not node: return True \\n            if not root: return False \\n            \\n            if root.val == node.val: \\n                return fn(node.next, root.left) or fn(node.next, root.right) or fn(head, root.left) or fn(head, root.right)\\n            else: \\n                return fn(head, root.left) or fn(head, root.right)\\n                    \\n        return fn(head, root)\\n```\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        #build longest prefix-suffix array\\n        pattern, lps = [head.val], [0] #longest prefix-suffix array\\n        j = 0\\n        while head.next: \\n            head = head.next \\n            pattern.append(head.val)\\n            \\n            while j and head.val != pattern[j]: j = lps[j-1]\\n            if head.val == pattern[j]: j += 1\\n            lps.append(j)\\n            \\n        def dfs(root, i): \\n            \"\"\"Return True of tree rooted at \"root\" match pattern\"\"\"\\n            if i == len(pattern): return True\\n            if not root: return False \\n            \\n            while i > 0 and root.val != pattern[i]: i = lps[i-1]\\n            if root.val == pattern[i]: i += 1\\n            return dfs(root.left, i) or dfs(root.right, i)\\n        \\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524987,
                "title": "java-solution",
                "content": "```Java\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        if(path(head, root)){\\n            return true;\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean path(ListNode head, TreeNode node){\\n        if(head == null) return true;\\n        if(node == null) return false;\\n        \\n        if(node.val == head.val){\\n            return path(head.next, node.left) || path(head.next, node.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        if(path(head, root)){\\n            return true;\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean path(ListNode head, TreeNode node){\\n        if(head == null) return true;\\n        if(node == null) return false;\\n        \\n        if(node.val == head.val){\\n            return path(head.next, node.left) || path(head.next, node.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524953,
                "title": "c-python3-recursion",
                "content": "Check if a linked list exists as a path in a binary tree.\\n\\n# Explanation\\n\\nDFS through the tree. For each node, record the places in the linked list that can be ends of paths in the tree. Then check if the path can extend to the child nodes.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\n    bool ans = false;\\n    \\n    ListNode* head;\\n    \\n    void checkSubPath(TreeNode* root, vector<ListNode*> ps) {\\n        if (root == NULL) return;\\n        if (ans) return;\\n        vector<ListNode*> newPs;\\n        for (auto p: ps) {\\n            if (p->val == root->val) {\\n                if (p->next == NULL) {\\n                    ans = true;\\n                    return;\\n                }\\n                newPs.push_back(p->next);\\n            }\\n        }\\n        newPs.push_back(head);\\n        checkSubPath(root->left, newPs);\\n        checkSubPath(root->right, newPs);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        this->head = head;\\n        checkSubPath(root, {head});\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python3 Solution\\n\\nWhy must `ans` be a class variable?\\n\\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        self.ans = False\\n        \\n        def checkSubPath(root: TreeNode, ps: List[ListNode]):\\n            if root is None: return\\n            if self.ans: return\\n            newPs = []\\n            for p in ps:\\n                if p.val == root.val:\\n                    if p.next is None:\\n                        self.ans = True\\n                        return\\n                    newPs.append(p.next)\\n            newPs.append(head)\\n            checkSubPath(root.left, newPs)\\n            checkSubPath(root.right, newPs)\\n        \\n        checkSubPath(root, [head])\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    bool ans = false;\\n    \\n    ListNode* head;\\n    \\n    void checkSubPath(TreeNode* root, vector<ListNode*> ps) {\\n        if (root == NULL) return;\\n        if (ans) return;\\n        vector<ListNode*> newPs;\\n        for (auto p: ps) {\\n            if (p->val == root->val) {\\n                if (p->next == NULL) {\\n                    ans = true;\\n                    return;\\n                }\\n                newPs.push_back(p->next);\\n            }\\n        }\\n        newPs.push_back(head);\\n        checkSubPath(root->left, newPs);\\n        checkSubPath(root->right, newPs);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        this->head = head;\\n        checkSubPath(root, {head});\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        self.ans = False\\n        \\n        def checkSubPath(root: TreeNode, ps: List[ListNode]):\\n            if root is None: return\\n            if self.ans: return\\n            newPs = []\\n            for p in ps:\\n                if p.val == root.val:\\n                    if p.next is None:\\n                        self.ans = True\\n                        return\\n                    newPs.append(p.next)\\n            newPs.append(head)\\n            checkSubPath(root.left, newPs)\\n            checkSubPath(root.right, newPs)\\n        \\n        checkSubPath(root, [head])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524900,
                "title": "python-o-n-kmp-solution",
                "content": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        nums, dfa = self.prepare(head)\\n        return self.dfs(root, nums, dfa, 0)\\n    \\n    def prepare(self, head: ListNode) -> (List[int], List[int]):\\n        nums = []\\n        while head is not None:\\n            nums.append(head.val)\\n            head = head.next\\n        dfa = [0]\\n        j = 0\\n        for i, n in enumerate(nums[1:]):\\n            while j > 0 and nums[i] != nums[j]:\\n                j = dfa[j-1]\\n            if nums[i] == nums[j]:\\n                j += 1\\n            dfa.append(j)\\n        return nums, dfa\\n\\n    def dfs(self, treenode, nums, dfa, j) -> bool:\\n        if treenode == None:\\n            return False\\n        while j > 0 and treenode.val != nums[j]:\\n            j = dfa[j-1]\\n        if treenode.val == nums[j]:\\n            j += 1\\n        if j == len(nums):\\n            return True\\n        return self.dfs(treenode.left, nums, dfa, j) or self.dfs(treenode.right, nums, dfa, j)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        nums, dfa = self.prepare(head)\\n        return self.dfs(root, nums, dfa, 0)\\n    \\n    def prepare(self, head: ListNode) -> (List[int], List[int]):\\n        nums = []\\n        while head is not None:\\n            nums.append(head.val)\\n            head = head.next\\n        dfa = [0]\\n        j = 0\\n        for i, n in enumerate(nums[1:]):\\n            while j > 0 and nums[i] != nums[j]:\\n                j = dfa[j-1]\\n            if nums[i] == nums[j]:\\n                j += 1\\n            dfa.append(j)\\n        return nums, dfa\\n\\n    def dfs(self, treenode, nums, dfa, j) -> bool:\\n        if treenode == None:\\n            return False\\n        while j > 0 and treenode.val != nums[j]:\\n            j = dfa[j-1]\\n        if treenode.val == nums[j]:\\n            j += 1\\n        if j == len(nums):\\n            return True\\n        return self.dfs(treenode.left, nums, dfa, j) or self.dfs(treenode.right, nums, dfa, j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029522,
                "title": "python3-very-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        self.graph = collections.defaultdict(list)\\n        self.lst = []\\n        tmp = head\\n        while tmp != None:\\n            self.lst.append(tmp)\\n            tmp = tmp.next\\n\\n        def helper(root, parent):\\n            if not root: return\\n            if parent != None:\\n                self.graph[parent].append(root)\\n                self.graph[root].append(parent)\\n\\n            helper(root.left, root)\\n            helper(root.right, root)\\n        \\n        helper(root, None)\\n\\n        self.ans = False\\n        self.seen = set()\\n\\n\\n        def dfs(root, depth):\\n            if depth==len(self.lst):\\n                self.ans = True\\n                return\\n            for v in self.graph[root]:\\n                if v in self.seen: continue\\n                if v.val == self.lst[depth].val:\\n                    self.seen.add(v)\\n                    dfs(v, depth+1)\\n                    self.seen.remove(v)\\n        \\n        def dfs2(root):\\n            if not root:\\n                return\\n            \\n            if root.val==head.val:\\n                self.seen.add(root)\\n                dfs(root, 1)\\n                self.seen.remove(root)\\n            \\n            dfs2(root.left)\\n            dfs2(root.right)\\n\\n        dfs2(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        self.graph = collections.defaultdict(list)\\n        self.lst = []\\n        tmp = head\\n        while tmp != None:\\n            self.lst.append(tmp)\\n            tmp = tmp.next\\n\\n        def helper(root, parent):\\n            if not root: return\\n            if parent != None:\\n                self.graph[parent].append(root)\\n                self.graph[root].append(parent)\\n\\n            helper(root.left, root)\\n            helper(root.right, root)\\n        \\n        helper(root, None)\\n\\n        self.ans = False\\n        self.seen = set()\\n\\n\\n        def dfs(root, depth):\\n            if depth==len(self.lst):\\n                self.ans = True\\n                return\\n            for v in self.graph[root]:\\n                if v in self.seen: continue\\n                if v.val == self.lst[depth].val:\\n                    self.seen.add(v)\\n                    dfs(v, depth+1)\\n                    self.seen.remove(v)\\n        \\n        def dfs2(root):\\n            if not root:\\n                return\\n            \\n            if root.val==head.val:\\n                self.seen.add(root)\\n                dfs(root, 1)\\n                self.seen.remove(root)\\n            \\n            dfs2(root.left)\\n            dfs2(root.right)\\n\\n        dfs2(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778191,
                "title": "python-fastest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726315,
                "title": "dp-on-trees",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(l*t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(l*t) (l=size of linked list ,t=size of tree );\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nunordered_map<ListNode *,unordered_map<TreeNode *,int>> mp;\\n      bool solve(ListNode *head,TreeNode *root,ListNode * &orih,TreeNode * &orit) {\\n           if(head==NULL)\\n        return true;\\n        if(root==NULL)\\n        return false;\\n\\n        if(mp[head].find(root)!=mp[head].end())\\n      return  mp[head][root];\\n\\n        if(head->val==root->val){\\n              return  mp[head][root]=solve(head->next,root->left,orih,orit)|solve(head->next,root->right,orih,orit)|solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n        else{\\n              return mp[head][root]= solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n\\n      }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n\\n        return solve(head,root,head,root);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nunordered_map<ListNode *,unordered_map<TreeNode *,int>> mp;\\n      bool solve(ListNode *head,TreeNode *root,ListNode * &orih,TreeNode * &orit) {\\n           if(head==NULL)\\n        return true;\\n        if(root==NULL)\\n        return false;\\n\\n        if(mp[head].find(root)!=mp[head].end())\\n      return  mp[head][root];\\n\\n        if(head->val==root->val){\\n              return  mp[head][root]=solve(head->next,root->left,orih,orit)|solve(head->next,root->right,orih,orit)|solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n        else{\\n              return mp[head][root]= solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n\\n      }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n\\n        return solve(head,root,head,root);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670399,
                "title": "our-straight-forward-dfs-with-self-explanatory-intuitive-comments-clean-code",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! Its Easy Just Take A Look At The Code And Comments Within It, You\\'ll Get It.\\n\\nNOTE : Start Reading From Main Method\\n\\nStill Got Doubts! Feel Free To Comment, I Will Definately Reply.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Our Easy Depth First Search \\uD83D\\uDE0B\\n\\n# Complexity\\n- Time complexity: O(N*M) - Where N let be the total number of nodes of the tree and M let be the length of the list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) - Where H let be the height of the tree used in the implicit stack space while recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to verify is all the elements of the linked list starting from the head correspond to some downward path in the binary tree or not ~ coded by Hiren\\n#include <iostream>\\nusing namespace std;\\n\\n// List template\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n\\n    // Init constructor\\n    ListNode(int val, ListNode* next) : val(val), next(next) {}; \\n\\n    // Init destructor\\n    ~ListNode() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Tree template\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left; TreeNode* right;\\n\\n    // Init constructors\\n    TreeNode(int val) : val(val), left(nullptr), right(nullptr) {};\\n    TreeNode(int val, TreeNode* left, TreeNode* right) : val(val), left(left), right(right) {};\\n\\n    // Init destructor\\n    ~TreeNode() {\\n        if(left) {\\n            delete left;\\n        }\\n        if(right) {\\n             delete right;\\n        }\\n    }\\n};\\n\\n// Method to print list using recursion\\nvoid printList(ListNode* head) {\\n    if(head) {\\n        cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Method to print tree using preOrder traversal\\nvoid printTree(TreeNode* root) {\\n    if(root) {\\n        cout<<root->val<<\\' \\';\\n        printTree(root->left);\\n        printTree(root->right);\\n    }\\n}\\n\\n// Method helper\\nbool checkForPath(TreeNode* root, ListNode* head) {\\n    // Edge case : When the list is empty, it means the path has been matched successfully\\n    if(!head)\\n        return true;\\n\\n    // When the tree node doesn\\'t exist or it exist but its value is not equal to the corrosponding list node\\n    if(!root || root->val != head->val)\\n        return false;\\n\\n    // Recursively check for the list path in the left and right subtree\\n    return checkForPath(root->left, head->next) || checkForPath(root->right, head->next);\\n}\\n\\n// Method to verify is the linked list exist in the binary tree or not - O(N*M) & O(H) : Where N let be the total number of nodes of the tree and M let be the length of the list\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n    // Edge case : When the list is empty, it means an empty path exists in the tree\\n    if(!head)\\n        return true;\\n\\n    // Edge case : When the tree is empty, it means the path cannot exist\\n    if(!root)\\n        return false;\\n\\n    // If the tree node contains the list as a path\\n    if(checkForPath(root, head))\\n        return true;\\n\\n    // Recursively check from each node of the tree\\n    return isSubPath(head, root->left) || isSubPath(head, root->right);\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating list, connecting nodes and initializing their data\\n    ListNode* head = new ListNode(4, new ListNode(5, new ListNode(8, nullptr)));\\n\\n    // Creating tree, connecting nodes and initializing their data\\n    TreeNode* c5 = new TreeNode(8);\\n    TreeNode* c4 = new TreeNode(5, nullptr, c5);\\n    TreeNode* c3 = new TreeNode(4, nullptr, c4);\\n    TreeNode* c2 = new TreeNode(3);\\n    TreeNode* c1 = new TreeNode(2, nullptr, c2);\\n    TreeNode* rt = new TreeNode(1, c1, c3);\\n\\n    // Print list\\n    printList(head); cout<<\\'\\\\n\\';\\n\\n    // Print tree\\n    printTree(rt); cout<<\\'\\\\n\\';\\n\\n    // Verification call\\n    if(isSubPath(head, rt))\\n        cout<<\"The linked list exist as a path in the binary tree!\";\\n    else\\n        cout<<\"The linked list does not exist as a path in the binary tree!\";\\n\\n    // Delete the head node (and recursively the entire list)\\n    delete head;\\n\\n    // Delete the root node (and recursively the entire tree)\\n    delete rt;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-in-binary-tree/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Program to verify is all the elements of the linked list starting from the head correspond to some downward path in the binary tree or not ~ coded by Hiren\\n#include <iostream>\\nusing namespace std;\\n\\n// List template\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n\\n    // Init constructor\\n    ListNode(int val, ListNode* next) : val(val), next(next) {}; \\n\\n    // Init destructor\\n    ~ListNode() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Tree template\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left; TreeNode* right;\\n\\n    // Init constructors\\n    TreeNode(int val) : val(val), left(nullptr), right(nullptr) {};\\n    TreeNode(int val, TreeNode* left, TreeNode* right) : val(val), left(left), right(right) {};\\n\\n    // Init destructor\\n    ~TreeNode() {\\n        if(left) {\\n            delete left;\\n        }\\n        if(right) {\\n             delete right;\\n        }\\n    }\\n};\\n\\n// Method to print list using recursion\\nvoid printList(ListNode* head) {\\n    if(head) {\\n        cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Method to print tree using preOrder traversal\\nvoid printTree(TreeNode* root) {\\n    if(root) {\\n        cout<<root->val<<\\' \\';\\n        printTree(root->left);\\n        printTree(root->right);\\n    }\\n}\\n\\n// Method helper\\nbool checkForPath(TreeNode* root, ListNode* head) {\\n    // Edge case : When the list is empty, it means the path has been matched successfully\\n    if(!head)\\n        return true;\\n\\n    // When the tree node doesn\\'t exist or it exist but its value is not equal to the corrosponding list node\\n    if(!root || root->val != head->val)\\n        return false;\\n\\n    // Recursively check for the list path in the left and right subtree\\n    return checkForPath(root->left, head->next) || checkForPath(root->right, head->next);\\n}\\n\\n// Method to verify is the linked list exist in the binary tree or not - O(N*M) & O(H) : Where N let be the total number of nodes of the tree and M let be the length of the list\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n    // Edge case : When the list is empty, it means an empty path exists in the tree\\n    if(!head)\\n        return true;\\n\\n    // Edge case : When the tree is empty, it means the path cannot exist\\n    if(!root)\\n        return false;\\n\\n    // If the tree node contains the list as a path\\n    if(checkForPath(root, head))\\n        return true;\\n\\n    // Recursively check from each node of the tree\\n    return isSubPath(head, root->left) || isSubPath(head, root->right);\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating list, connecting nodes and initializing their data\\n    ListNode* head = new ListNode(4, new ListNode(5, new ListNode(8, nullptr)));\\n\\n    // Creating tree, connecting nodes and initializing their data\\n    TreeNode* c5 = new TreeNode(8);\\n    TreeNode* c4 = new TreeNode(5, nullptr, c5);\\n    TreeNode* c3 = new TreeNode(4, nullptr, c4);\\n    TreeNode* c2 = new TreeNode(3);\\n    TreeNode* c1 = new TreeNode(2, nullptr, c2);\\n    TreeNode* rt = new TreeNode(1, c1, c3);\\n\\n    // Print list\\n    printList(head); cout<<\\'\\\\n\\';\\n\\n    // Print tree\\n    printTree(rt); cout<<\\'\\\\n\\';\\n\\n    // Verification call\\n    if(isSubPath(head, rt))\\n        cout<<\"The linked list exist as a path in the binary tree!\";\\n    else\\n        cout<<\"The linked list does not exist as a path in the binary tree!\";\\n\\n    // Delete the head node (and recursively the entire list)\\n    delete head;\\n\\n    // Delete the root node (and recursively the entire tree)\\n    delete rt;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-in-binary-tree/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3223402,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\n\\npublic class Solution {\\n    public bool found;\\n    public void tryConnecting(ListNode head,TreeNode root){\\n        if(head==null){\\n            found=true;\\n            return;\\n        }\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head.next,root.left);\\n                tryConnecting(head.next,root.right);\\n            }\\n        }\\n    }\\n    public void dfs(ListNode head,TreeNode root){\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head,root);\\n            }\\n            dfs(head,root.left);\\n            dfs(head,root.right);\\n        }\\n    }\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        found=false;\\n        dfs(head,root);\\n        return found;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public bool found;\\n    public void tryConnecting(ListNode head,TreeNode root){\\n        if(head==null){\\n            found=true;\\n            return;\\n        }\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head.next,root.left);\\n                tryConnecting(head.next,root.right);\\n            }\\n        }\\n    }\\n    public void dfs(ListNode head,TreeNode root){\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head,root);\\n            }\\n            dfs(head,root.left);\\n            dfs(head,root.right);\\n        }\\n    }\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        found=false;\\n        dfs(head,root);\\n        return found;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992629,
                "title": "linked-list-in-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool flag = false ;\\n    void path(ListNode* head , TreeNode* root) {\\n        if(head == NULL) {\\n            flag = true ;\\n            return ;\\n        }\\n        \\n        if(root == NULL) return ;\\n\\n        if(head->val != root->val) {\\n            return ;\\n        }\\n\\n        path(head->next , root->left) ;\\n        path(head->next , root->right) ;\\n    }\\n\\n    void solve(ListNode* head , TreeNode* root) {\\n        if(root == NULL) return ;\\n\\n        if(head->val == root->val) {\\n            path(head , root) ;\\n        }\\n        \\n        solve(head , root->left) ;\\n        solve(head , root->right) ;\\n    }\\n\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        solve(head , root) ;\\n        return flag ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool flag = false ;\\n    void path(ListNode* head , TreeNode* root) {\\n        if(head == NULL) {\\n            flag = true ;\\n            return ;\\n        }\\n        \\n        if(root == NULL) return ;\\n\\n        if(head->val != root->val) {\\n            return ;\\n        }\\n\\n        path(head->next , root->left) ;\\n        path(head->next , root->right) ;\\n    }\\n\\n    void solve(ListNode* head , TreeNode* root) {\\n        if(root == NULL) return ;\\n\\n        if(head->val == root->val) {\\n            path(head , root) ;\\n        }\\n        \\n        solve(head , root->left) ;\\n        solve(head , root->right) ;\\n    }\\n\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        solve(head , root) ;\\n        return flag ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578267,
                "title": "100-faster-1-ms-simple-java-solution",
                "content": "```\\nclass Solution {\\n    Boolean result = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        traverse(head, root);\\n        return result;\\n    }\\n    \\n    private void traverse(ListNode head, TreeNode root) {\\n        if(head != null && root != null) {\\n            if(head.val == root.val) {\\n                validate(head, root);\\n            } \\n            if(result)\\n                return;\\n            else {\\n                traverse(head, root.left);\\n                traverse(head, root.right);\\n\\n            }\\n        } \\n    }\\n    \\n    private void validate(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            result = true;\\n            return;\\n        } else {\\n            if(head == null || root == null)\\n                return;\\n            if(head.val == root.val) {\\n                validate(head.next, root.left);\\n                validate(head.next, root.right);\\n            } else {\\n                return;\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Boolean result = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        traverse(head, root);\\n        return result;\\n    }\\n    \\n    private void traverse(ListNode head, TreeNode root) {\\n        if(head != null && root != null) {\\n            if(head.val == root.val) {\\n                validate(head, root);\\n            } \\n            if(result)\\n                return;\\n            else {\\n                traverse(head, root.left);\\n                traverse(head, root.right);\\n\\n            }\\n        } \\n    }\\n    \\n    private void validate(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            result = true;\\n            return;\\n        } else {\\n            if(head == null || root == null)\\n                return;\\n            if(head.val == root.val) {\\n                validate(head.next, root.left);\\n                validate(head.next, root.right);\\n            } else {\\n                return;\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548434,
                "title": "c-recursion-and-inorder-traversal",
                "content": "~~~\\nclass Solution {\\npublic:\\n    bool ret = false;\\n    bool helper(ListNode* tmp_head, TreeNode* tmp_root){\\n        if(!tmp_head)\\n            return true;\\n        if(!tmp_root || (tmp_head->val != tmp_root->val))\\n            return false;\\n        return (helper(tmp_head->next, tmp_root->left) || helper(tmp_head->next, tmp_root->right));\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n                    \\n        if(!root)\\n            return false;\\n        isSubPath(head, root->left);\\n\\n        if(root->val == head->val){\\n            ret = ret || helper(head, root);\\n        }\\n        isSubPath(head, root->right);\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool ret = false;\\n    bool helper(ListNode* tmp_head, TreeNode* tmp_root){\\n        if(!tmp_head)\\n            return true;\\n        if(!tmp_root || (tmp_head->val != tmp_root->val))\\n            return false;\\n        return (helper(tmp_head->next, tmp_root->left) || helper(tmp_head->next, tmp_root->right));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2547793,
                "title": "js-linked-list-in-binary-tree",
                "content": "```\\nconst compareNodeTree=(node,tree)=>{\\n    if (!tree) return true;\\n     if (!node) return false;\\n    \\n    if(node.val!=tree.val)return false\\n    return compareNodeTree(node.left,tree.next) ||compareNodeTree(node.right,tree.next)\\n    \\n}\\nvar isSubPath = function(head, root) {\\n     const bst=(node)=>{\\n     if(!node)return false\\n     if(compareNodeTree(node,head))return true        \\n        return bst(node.right)||bst(node.left)\\n }\\n   return bst(root)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst compareNodeTree=(node,tree)=>{\\n    if (!tree) return true;\\n     if (!node) return false;\\n    \\n    if(node.val!=tree.val)return false\\n    return compareNodeTree(node.left,tree.next) ||compareNodeTree(node.right,tree.next)\\n    \\n}\\nvar isSubPath = function(head, root) {\\n     const bst=(node)=>{\\n     if(!node)return false\\n     if(compareNodeTree(node,head))return true        \\n        return bst(node.right)||bst(node.left)\\n }\\n   return bst(root)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522543,
                "title": "basic-practice-path-matching-traversal-python",
                "content": "1- Code\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        # 1. helper fn\\n        def helper(head, node):\\n            \"\"\"\\n            check if there is a matching starting from node\\n            \"\"\"\\n            if not head:\\n                return True\\n            if not node:\\n                return False\\n            if node.val != head.val:\\n                return False\\n            return helper(head.next, node.left) or helper(head.next, node.right)\\n        \\n        # 2. do traversal / DFS iterative format\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if helper(head, node):\\n                return True\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return False\\n```\\n\\n2- Video Explanation: [Click Here](https://youtu.be/gkRZDUz7XSA;)\\n\\n3- Analysis\\n\\n\"\"\"\\nMethod: traversal\\n\\n\\nProcedure:\\n\\n - First write a helper fn f(head, node) to check if there is a continuous downward-path starting from thr node that matches the linked list\\n \\n - Do traversal, for example DFS, of the tree to check if we could find a matching path on\\n each subtree.\\n \\n \\n This way of writing the solution contains some redundancy, but for presentation purpose,\\n the logic is clearer and code is cleaner. As the length of linked list is bounded by 100, this is ok in the problem setting here. One could devise slightly complex solution to elimate the redundancy.\\n \\n\"\"\"",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        # 1. helper fn\\n        def helper(head, node):\\n            \"\"\"\\n            check if there is a matching starting from node\\n            \"\"\"\\n            if not head:\\n                return True\\n            if not node:\\n                return False\\n            if node.val != head.val:\\n                return False\\n            return helper(head.next, node.left) or helper(head.next, node.right)\\n        \\n        # 2. do traversal / DFS iterative format\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if helper(head, node):\\n                return True\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394905,
                "title": "simplest-solution-easiest-to-understand-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n        \\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        \\n        if(root==null)\\n            return false;\\n        \\n        if(match(head,root))\\n            return true;\\n        \\n        return dfs(head,root.left) || dfs(head,root.right);\\n        \\n    }\\n    \\n    public boolean match(ListNode head, TreeNode root) {\\n    \\n        if(head==null)\\n            return true;\\n        \\n        if(root==null || root.val!=head.val)\\n            return false;\\n        \\n        return match(head.next,root.left) || match(head.next,root.right);\\n    \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n        \\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        \\n        if(root==null)\\n            return false;\\n        \\n        if(match(head,root))\\n            return true;\\n        \\n        return dfs(head,root.left) || dfs(head,root.right);\\n        \\n    }\\n    \\n    public boolean match(ListNode head, TreeNode root) {\\n    \\n        if(head==null)\\n            return true;\\n        \\n        if(root==null || root.val!=head.val)\\n            return false;\\n        \\n        return match(head.next,root.left) || match(head.next,root.right);\\n    \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355762,
                "title": "simple-java-solution-1ms-faster-than-100-easy-to-understand",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        if(head.val == root.val) {\\n            ListNode thead = head;\\n            boolean ans = check(thead, root);\\n            if(ans) {\\n                return true;\\n            }\\n        }\\n        \\n        boolean left = isSubPath(head, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = isSubPath(head, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        }\\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        boolean left = check(head.next, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = check(head.next, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        if(head.val == root.val) {\\n            ListNode thead = head;\\n            boolean ans = check(thead, root);\\n            if(ans) {\\n                return true;\\n            }\\n        }\\n        \\n        boolean left = isSubPath(head, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = isSubPath(head, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        }\\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        boolean left = check(head.next, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = check(head.next, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342078,
                "title": "2-ms-faster-than-68-52-of-java-online-submissions-for-linked-list-in-binary-tree",
                "content": "Here in this problem only one catch is if **(head==null) return true;** since after leaf nodes you will get **root=null so** it must return **true.**  and all other things are similar to **Subtree of Another Tree** problem.But there you need to go with **and** case since you want **subtree** here. You need to go with **or** case since there is possiblity linkedlist will be either one of the sides.\\n\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n      \\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        \\n        else if(isSameList(head,root)){\\n            return true;\\n        }\\n        else{\\n            return isSubPath(head,root.left) ||isSubPath(head,root.right);\\n        }\\n    }\\n    public boolean isSameList(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        else if(root.val==head.val){\\n            return isSameList(head.next,root.left) || isSameList(head.next,root.right);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n      \\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        \\n        else if(isSameList(head,root)){\\n            return true;\\n        }\\n        else{\\n            return isSubPath(head,root.left) ||isSubPath(head,root.right);\\n        }\\n    }\\n    public boolean isSameList(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        else if(root.val==head.val){\\n            return isSameList(head.next,root.left) || isSameList(head.next,root.right);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339217,
                "title": "python-solution-will-leetcode-bug",
                "content": "```\\nclass Solution:\\n    flag=False\\n    flag2=False\\n    temp1=None\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if Solution.flag2==False:\\n            Solution.temp1=head\\n            Solution.flag2=True\\n        if head==None and Solution.flag==True:\\n            return True\\n        elif root==None:\\n            return False\\n        if head.val==root.val:\\n            head=head.next\\n            Solution.flag=True\\n        else:\\n            head=Solution.temp1\\n            Solution.flag=False\\n        return self.isSubPath(head,root.left) or self.isSubPath(head,root.right)\\n```\\n\\nThis code returns True for the test case \\n```\\n[3]\\n[1,5,3,null,4,null,3]\\n```\\nwhen I run it manually in console\\nbut when I submit the code it returns False\\nThis is a major issue\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    flag=False\\n    flag2=False\\n    temp1=None\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if Solution.flag2==False:\\n            Solution.temp1=head\\n            Solution.flag2=True\\n        if head==None and Solution.flag==True:\\n            return True\\n        elif root==None:\\n            return False\\n        if head.val==root.val:\\n            head=head.next\\n            Solution.flag=True\\n        else:\\n            head=Solution.temp1\\n            Solution.flag=False\\n        return self.isSubPath(head,root.left) or self.isSubPath(head,root.right)\\n```\n```\\n[3]\\n[1,5,3,null,4,null,3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333427,
                "title": "python-simple-maths",
                "content": "\\n    def isSubPath(self, head, root):\\n        paths = []\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            \\n            path += str(node.val)\\n            \\n            if not node.left and not node.right:\\n                paths.append(path)\\n            else:\\n                dfs(node.left, path)\\n                dfs(node.right, path)\\n                \\n                \\n        dfs(root, \"\")\\n            \\n        cur, str1 = head, \"\"\\n        \\n        while cur:\\n            str1 += str(cur.val)\\n            cur = cur.next\\n            \\n        return any([str1 in i for i in paths])",
                "solutionTags": [],
                "code": "\\n    def isSubPath(self, head, root):\\n        paths = []\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            \\n            path += str(node.val)\\n            \\n            if not node.left and not node.right:\\n                paths.append(path)\\n            else:\\n                dfs(node.left, path)\\n                dfs(node.right, path)\\n                \\n                \\n        dfs(root, \"\")\\n            \\n        cur, str1 = head, \"\"\\n        \\n        while cur:\\n            str1 += str(cur.val)\\n            cur = cur.next\\n            \\n        return any([str1 in i for i in paths])",
                "codeTag": "Python3"
            },
            {
                "id": 2263393,
                "title": "c-dfs",
                "content": "```\\nbool eachNode(ListNode *head, TreeNode *root){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root){\\n            if(root->val==head->val){\\n                return eachNode(head->next,root->left)||eachNode(head->next,root->right);\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(head==NULL){\\n                return true;\\n            }\\n\\t\\t\\t// checking is there any subpaths exist from root node\\n            if(eachNode(head,root)){\\n                return true;\\n            }\\n            else{\\n\\t\\t\\t// checking the subpath from left and right childs\\n                return isSubPath(head,root->left)||isSubPath(head,root->right);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nbool eachNode(ListNode *head, TreeNode *root){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root){\\n            if(root->val==head->val){\\n                return eachNode(head->next,root->left)||eachNode(head->next,root->right);\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(head==NULL){\\n                return true;\\n            }\\n\\t\\t\\t// checking is there any subpaths exist from root node\\n            if(eachNode(head,root)){\\n                return true;\\n            }\\n            else{\\n\\t\\t\\t// checking the subpath from left and right childs\\n                return isSubPath(head,root->left)||isSubPath(head,root->right);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2225117,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void trav(TreeNode *root, vector<TreeNode*> &v, int target)\\n    {\\n        if(root == NULL) return;\\n        \\n        if(root->val == target) v.push_back(root);\\n        trav(root->left, v, target);\\n        trav(root->right, v, target);\\n    }\\n    \\n    void check(ListNode* head, TreeNode* root, int* x, bool *flag, int size)\\n    {\\n        if(*x == size) *flag = true;\\n        if(head == NULL) return;\\n        if(root == NULL) return;\\n        if(root->val != head->val)\\n        {\\n            return;\\n        }\\n        \\n        *x += 1;\\n        cout << *x << \"-\" << root->val << \" \"; \\n        \\n        check(head->next, root->left, x, flag, size);\\n        check(head->next, root->right, x, flag, size);\\n        *x -= 1;\\n\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        if(head == NULL || root == NULL)\\n        {\\n            return false;\\n        }\\n        \\n        vector<TreeNode*> v;\\n        trav(root, v, head->val);\\n        \\n        bool x = false;\\n        int count = 0, size = 0;\\n        ListNode* trav = head;\\n        \\n       while(trav != NULL)\\n       {\\n           size += 1;\\n           trav = trav->next;\\n       }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            // x = true;\\n            count = 0;\\n            check(head, v[i], &count, &x, size);\\n            if(x == true)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void trav(TreeNode *root, vector<TreeNode*> &v, int target)\\n    {\\n        if(root == NULL) return;\\n        \\n        if(root->val == target) v.push_back(root);\\n        trav(root->left, v, target);\\n        trav(root->right, v, target);\\n    }\\n    \\n    void check(ListNode* head, TreeNode* root, int* x, bool *flag, int size)\\n    {\\n        if(*x == size) *flag = true;\\n        if(head == NULL) return;\\n        if(root == NULL) return;\\n        if(root->val != head->val)\\n        {\\n            return;\\n        }\\n        \\n        *x += 1;\\n        cout << *x << \"-\" << root->val << \" \"; \\n        \\n        check(head->next, root->left, x, flag, size);\\n        check(head->next, root->right, x, flag, size);\\n        *x -= 1;\\n\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        if(head == NULL || root == NULL)\\n        {\\n            return false;\\n        }\\n        \\n        vector<TreeNode*> v;\\n        trav(root, v, head->val);\\n        \\n        bool x = false;\\n        int count = 0, size = 0;\\n        ListNode* trav = head;\\n        \\n       while(trav != NULL)\\n       {\\n           size += 1;\\n           trav = trav->next;\\n       }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            // x = true;\\n            count = 0;\\n            check(head, v[i], &count, &x, size);\\n            if(x == true)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2205230,
                "title": "javascript-dfs",
                "content": "```\\nvar isSubPath = function(head, root) {\\n  return dfs(root, head)\\n};\\n\\nfunction dfs(root, head){\\n  if(!root) return false\\n  if(search(root, head)) return true\\n  return dfs(root.left, head) || dfs(root.right, head)\\n}\\n\\nfunction search(root, head){\\n  if(!root && head) return false\\n  if(!head) return true\\n  if(root.val !== head.val) return false  \\n  return search(root.left, head.next) || search(root.right, head.next)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar isSubPath = function(head, root) {\\n  return dfs(root, head)\\n};\\n\\nfunction dfs(root, head){\\n  if(!root) return false\\n  if(search(root, head)) return true\\n  return dfs(root.left, head) || dfs(root.right, head)\\n}\\n\\nfunction search(root, head){\\n  if(!root && head) return false\\n  if(!head) return true\\n  if(root.val !== head.val) return false  \\n  return search(root.left, head.next) || search(root.right, head.next)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195209,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isequal(ListNode* ll, TreeNode* bt) {\\n        if (bt == NULL and ll != NULL) return false;\\n        if (ll == NULL) return true;\\n        if (bt -> val != ll -> val) {\\n            return false;\\n        }\\n        return isequal(ll -> next, bt -> left) || isequal(ll -> next, bt -> right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        if (root -> val == head -> val) {\\n            if (isequal (head, root)) {\\n                return true;\\n            }\\n        }\\n        return   isSubPath(head, root -> left) || isSubPath(head, root -> right) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isequal(ListNode* ll, TreeNode* bt) {\\n        if (bt == NULL and ll != NULL) return false;\\n        if (ll == NULL) return true;\\n        if (bt -> val != ll -> val) {\\n            return false;\\n        }\\n        return isequal(ll -> next, bt -> left) || isequal(ll -> next, bt -> right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        if (root -> val == head -> val) {\\n            if (isequal (head, root)) {\\n                return true;\\n            }\\n        }\\n        return   isSubPath(head, root -> left) || isSubPath(head, root -> right) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173810,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> A;\\n    bool check(TreeNode* root, ListNode* head){\\n        if(!head) return true;\\n        if(!root || root -> val != head -> val) return false;\\n        return check(root -> left, head -> next) || check(root -> right, head -> next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        helper(root, head -> val);\\n        for(auto& a: A)\\n            if(check(a, head)) return true;\\n        return false;\\n    }\\n    void helper(TreeNode* root, int& a){\\n        if(!root) return;\\n        if(root -> val == a)\\n            A.push_back(root);\\n        helper(root -> left, a);\\n        helper(root -> right, a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> A;\\n    bool check(TreeNode* root, ListNode* head){\\n        if(!head) return true;\\n        if(!root || root -> val != head -> val) return false;\\n        return check(root -> left, head -> next) || check(root -> right, head -> next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        helper(root, head -> val);\\n        for(auto& a: A)\\n            if(check(a, head)) return true;\\n        return false;\\n    }\\n    void helper(TreeNode* root, int& a){\\n        if(!root) return;\\n        if(root -> val == a)\\n            A.push_back(root);\\n        helper(root -> left, a);\\n        helper(root -> right, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128218,
                "title": "damnn-simpleee-recursive-solution",
                "content": "bool path_from_root(TreeNode* root,ListNode* head)\\n    {\\n         if(!head)\\n            return true;\\n         if(!root)\\n             return false;\\n        \\n         if(root->val!=head->val)\\n            return false;\\n        \\n    return path_from_root(root->left,head->next) or path_from_root(root->right,head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n       if(!head)   //linklist ke last tk phuch gye \\n            return true;\\n        \\n       if(!root)\\n           return false;\\n        \\nreturn path_from_root(root,head) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n\\n    }",
                "solutionTags": [],
                "code": "bool path_from_root(TreeNode* root,ListNode* head)\\n    {\\n         if(!head)\\n            return true;\\n         if(!root)\\n             return false;\\n        \\n         if(root->val!=head->val)\\n            return false;\\n        \\n    return path_from_root(root->left,head->next) or path_from_root(root->right,head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n       if(!head)   //linklist ke last tk phuch gye \\n            return true;\\n        \\n       if(!root)\\n           return false;\\n        \\nreturn path_from_root(root,head) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2090799,
                "title": "java-easy-dfs-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\t\\tif(root == null) return false;\\n\\t\\t\\tif(head == null) return true;\\n\\t\\t\\treturn dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n\\t\\t}\\n\\n\\t\\tboolean dfs(ListNode head,TreeNode root){\\n\\t\\t\\tif(head==null) return true;\\n\\t\\t\\tif(root==null) return false;\\n\\t\\t\\treturn (head.val == root.val) && (dfs(head.next,root.left) || dfs(head.next,root.right));\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\t\\tif(root == null) return false;\\n\\t\\t\\tif(head == null) return true;\\n\\t\\t\\treturn dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2080171,
                "title": "inorder-recursion-c-easy",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL && root==NULL)\\n            return true;\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        return head->val==root->val && (check(head->next,root->left) || check(head->next,root->right));\\n    }\\nvoid inorder(ListNode *head,vector<TreeNode*> &harsh,TreeNode *root)\\n{\\n    if( !root)\\n        return ;\\n    inorder(head,harsh,root->left);\\n    if(head->val==root->val)\\n    {\\n        harsh.push_back(root);\\n    }\\n    inorder(head,harsh,root->right);\\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n      // its actually a very tough question .......\\n        vector<TreeNode*> harsh;\\n        inorder(head,harsh,root);\\n        for(TreeNode *tmp:harsh){\\n            if(check(head,tmp)==true)\\n                return true;\\n        }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL && root==NULL)\\n            return true;\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        return head->val==root->val && (check(head->next,root->left) || check(head->next,root->right));\\n    }\\nvoid inorder(ListNode *head,vector<TreeNode*> &harsh,TreeNode *root)\\n{\\n    if( !root)\\n        return ;\\n    inorder(head,harsh,root->left);\\n    if(head->val==root->val)\\n    {\\n        harsh.push_back(root);\\n    }\\n    inorder(head,harsh,root->right);\\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n      // its actually a very tough question .......\\n        vector<TreeNode*> harsh;\\n        inorder(head,harsh,root);\\n        for(TreeNode *tmp:harsh){\\n            if(check(head,tmp)==true)\\n                return true;\\n        }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051190,
                "title": "simple-preorder-technique-in-java",
                "content": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean check(ListNode head, TreeNode root)\\n    {\\n        if(root ==null) return false;\\n        if(root.val!=head.val) return false;\\n        if(head.next==null) return true;\\n        return check(head.next,root.left) || check(head.next,root.right);\\n    }\\n    public void  f(ListNode head, TreeNode root)\\n    {\\n        if(root==null) return;\\n        if(check(head,root)) flag=true;\\n        f(head,root.left);\\n        f(head,root.right);\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        f(head,root);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean check(ListNode head, TreeNode root)\\n    {\\n        if(root ==null) return false;\\n        if(root.val!=head.val) return false;\\n        if(head.next==null) return true;\\n        return check(head.next,root.left) || check(head.next,root.right);\\n    }\\n    public void  f(ListNode head, TreeNode root)\\n    {\\n        if(root==null) return;\\n        if(check(head,root)) flag=true;\\n        f(head,root.left);\\n        f(head,root.right);\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        f(head,root);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022374,
                "title": "easy-python-solution-with-recursion",
                "content": "**For any doubt please comment , will be happy to help you :)**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def helper(self,head ,root):\\n        if head is None:\\n            return True\\n        \\n        leftCheck = False\\n        if root.left and head.val == root.left.val:\\n            leftCheck = self.helper(head.next,root.left)\\n        \\n        rightCheck = False\\n        if root.right and head.val == root.right.val:\\n            rightCheck = self.helper(head.next,root.right)\\n        \\n        return leftCheck or rightCheck\\n        \\n        \\n            \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if root is None:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.helper(head.next,root):\\n                return True\\n        \\n        leftCheck = self.isSubPath(head,root.left)\\n        rightCheck = self.isSubPath(head,root.right)\\n        \\n        return leftCheck or rightCheck\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def helper(self,head ,root):\\n        if head is None:\\n            return True\\n        \\n        leftCheck = False\\n        if root.left and head.val == root.left.val:\\n            leftCheck = self.helper(head.next,root.left)\\n        \\n        rightCheck = False\\n        if root.right and head.val == root.right.val:\\n            rightCheck = self.helper(head.next,root.right)\\n        \\n        return leftCheck or rightCheck\\n        \\n        \\n            \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if root is None:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.helper(head.next,root):\\n                return True\\n        \\n        leftCheck = self.isSubPath(head,root.left)\\n        rightCheck = self.isSubPath(head,root.right)\\n        \\n        return leftCheck or rightCheck\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991832,
                "title": "java-100-faster-solution-with-comments-for-better-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       return dfs(head,root);\\n    }\\n    private boolean dfs(ListNode head,TreeNode root){\\n        if(root==null)return false;\\n        if(match(head,root))return true;//check that value match or not;\\n        return dfs(head,root.left) || dfs(head,root.right);//traverse on tree \\n        \\n    }\\n    private boolean match(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null || root.val!=head.val)return false;\\n        return match(head.next,root.left) || match(head.next,root.right);  //check that value match or not\\n    }\\n}\\n```\\nif it is helpful upvote please",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       return dfs(head,root);\\n    }\\n    private boolean dfs(ListNode head,TreeNode root){\\n        if(root==null)return false;\\n        if(match(head,root))return true;//check that value match or not;\\n        return dfs(head,root.left) || dfs(head,root.right);//traverse on tree \\n        \\n    }\\n    private boolean match(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null || root.val!=head.val)return false;\\n        return match(head.next,root.left) || match(head.next,root.right);  //check that value match or not\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975238,
                "title": "c-easy-recursion-sol",
                "content": "if you liked it please vote up :)\\n```\\nbool check(struct ListNode* head, struct TreeNode* root);\\nbool isSubPath(struct ListNode* head, struct TreeNode* root)\\n{\\n    bool flag;\\n    if(!root)\\n    {\\n        return false;\\n    }\\n    \\n    flag=check(head,root);\\n    \\n    \\n    return flag|| isSubPath(head,root->left)||isSubPath(head,root->right);  \\n    \\n}\\nbool check(struct ListNode* head, struct TreeNode* root)\\n{\\n    \\n  if(!root)\\n  {\\n      return false;\\n  }\\n  if(!head->next)\\n  {\\n      return head->val==root->val;\\n  }\\n    \\n return head->val==root->val&&(check(head->next,root->left)||check(head->next,root->right)); \\n}",
                "solutionTags": [],
                "code": "if you liked it please vote up :)\\n```\\nbool check(struct ListNode* head, struct TreeNode* root);\\nbool isSubPath(struct ListNode* head, struct TreeNode* root)\\n{\\n    bool flag;\\n    if(!root)\\n    {\\n        return false;\\n    }\\n    \\n    flag=check(head,root);\\n    \\n    \\n    return flag|| isSubPath(head,root->left)||isSubPath(head,root->right);  \\n    \\n}\\nbool check(struct ListNode* head, struct TreeNode* root)\\n{\\n    \\n  if(!root)\\n  {\\n      return false;\\n  }\\n  if(!head->next)\\n  {\\n      return head->val==root->val;\\n  }\\n    \\n return head->val==root->val&&(check(head->next,root->left)||check(head->next,root->right)); \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1970008,
                "title": "c-easy-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948979,
                "title": "simple-java-recurrsive-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.val == head.val){\\n          if(isList(head.next, root.left) || isList(head.next, root.right)){\\n              return true;\\n          }else{\\n              return isSubPath(head, root.left) || isSubPath(head,root.right); \\n          }\\n        }else{\\n          return isSubPath(head, root.left) || isSubPath(head,root.right);  \\n        }\\n    }\\n    \\n    public boolean isList(ListNode head, TreeNode root){\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(head.val == root.val){\\n            return isList(head.next,root.left) || isList(head.next,root.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.val == head.val){\\n          if(isList(head.next, root.left) || isList(head.next, root.right)){\\n              return true;\\n          }else{\\n              return isSubPath(head, root.left) || isSubPath(head,root.right); \\n          }\\n        }else{\\n          return isSubPath(head, root.left) || isSubPath(head,root.right);  \\n        }\\n    }\\n    \\n    public boolean isList(ListNode head, TreeNode root){\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(head.val == root.val){\\n            return isList(head.next,root.left) || isList(head.next,root.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938923,
                "title": "linked-list-in-binary-tree",
                "content": "```\\n# You just need to think like this \\n# If head matches with root value we will go check at right and left \\n# if not then we wil check both left and right.\\n# If any side will traversal path is able to give me right list \\n# we will return true\\n# You have to just think how traversal can be done and base cases\\n```\\n```\\nclass Solution \\n{\\npublic:\\n      bool inpath(ListNode* head, TreeNode* root)\\n      {\\n        if(root==NULL && head!=NULL)\\n            return false;  \\n        if(head==NULL)\\n            return true;\\n        if(head->val!=root->val)\\n            return false;\\n        return inpath(head->next,root->left)||inpath(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {     \\n        if(root==NULL)\\n            return false;\\n        else if(head==NULL)\\n            return true;\\n        else if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n# You just need to think like this \\n# If head matches with root value we will go check at right and left \\n# if not then we wil check both left and right.\\n# If any side will traversal path is able to give me right list \\n# we will return true\\n# You have to just think how traversal can be done and base cases\\n```\n```\\nclass Solution \\n{\\npublic:\\n      bool inpath(ListNode* head, TreeNode* root)\\n      {\\n        if(root==NULL && head!=NULL)\\n            return false;  \\n        if(head==NULL)\\n            return true;\\n        if(head->val!=root->val)\\n            return false;\\n        return inpath(head->next,root->left)||inpath(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {     \\n        if(root==NULL)\\n            return false;\\n        else if(head==NULL)\\n            return true;\\n        else if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928165,
                "title": "java-recursive-solution-100-beat",
                "content": "![image](https://assets.leetcode.com/users/images/2a689bc0-e15d-4b1f-8f89-2380d22e9674_1649432742.9112298.png)\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<TreeNode> treeList = new ArrayList<>();\\n        storeTreeAsList(treeList, head, root);\\n        for(TreeNode treeNode: treeList) {\\n            if(checkPath(head, treeNode)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void storeTreeAsList(List<TreeNode> tree, ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null || treeNode == null) {\\n            return;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            tree.add(treeNode);\\n        }\\n        storeTreeAsList(tree, listNode, treeNode.left);\\n        storeTreeAsList(tree, listNode, treeNode.right);\\n    }\\n    \\n    public boolean checkPath(ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null) {\\n            return true;\\n        }\\n        if(treeNode == null) {\\n            return false;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            return checkPath(listNode.next, treeNode.left) || checkPath(listNode.next, treeNode.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<TreeNode> treeList = new ArrayList<>();\\n        storeTreeAsList(treeList, head, root);\\n        for(TreeNode treeNode: treeList) {\\n            if(checkPath(head, treeNode)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void storeTreeAsList(List<TreeNode> tree, ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null || treeNode == null) {\\n            return;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            tree.add(treeNode);\\n        }\\n        storeTreeAsList(tree, listNode, treeNode.left);\\n        storeTreeAsList(tree, listNode, treeNode.right);\\n    }\\n    \\n    public boolean checkPath(ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null) {\\n            return true;\\n        }\\n        if(treeNode == null) {\\n            return false;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            return checkPath(listNode.next, treeNode.left) || checkPath(listNode.next, treeNode.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923025,
                "title": "c-simple-recursion-dfs",
                "content": "```\\n\\t void search(TreeNode* root,int target,vector<TreeNode*> &hits ){\\n        if(root==NULL)\\n            return;\\n        search(root->left,target,hits);\\n        if(root->val==target)\\n            hits.push_back(root);\\n        search(root->right,target,hits);\\n    }\\n    bool solve(TreeNode* root,ListNode* head){\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        if(root->val == head->val){\\n            return (solve(root->left,head->next) || solve(root->right,head->next));\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> hits;\\n        search(root,head->val,hits);\\n        for(auto x:hits){\\n            if(solve(x,head))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\t void search(TreeNode* root,int target,vector<TreeNode*> &hits ){\\n        if(root==NULL)\\n            return;\\n        search(root->left,target,hits);\\n        if(root->val==target)\\n            hits.push_back(root);\\n        search(root->right,target,hits);\\n    }\\n    bool solve(TreeNode* root,ListNode* head){\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        if(root->val == head->val){\\n            return (solve(root->left,head->next) || solve(root->right,head->next));\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> hits;\\n        search(root,head->val,hits);\\n        for(auto x:hits){\\n            if(solve(x,head))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916045,
                "title": "simple-and-clean-code-using-simple-recursion-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        boolean linkedListStartsFromMe=false;\\n        if(root.val==head.val){\\n            linkedListStartsFromMe = \\n                checkLinkedListFromRoot(head.next,root.left) \\n                || checkLinkedListFromRoot(head.next,root.right);\\n        }\\n        if(linkedListStartsFromMe)return true;\\n        \\n        return isSubPath(head,root.left) || isSubPath(head,root.right);\\n        \\n    }\\n\\t/**\\n\\t* method to check if the LL at head is found in Tree at root beginning from the root\\n\\t*/\\n    private boolean checkLinkedListFromRoot(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        if(root.val!=head.val)return false;\\n        return checkLinkedListFromRoot(head.next,root.left)\\n\\t\\t|| checkLinkedListFromRoot(head.next,root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        boolean linkedListStartsFromMe=false;\\n        if(root.val==head.val){\\n            linkedListStartsFromMe = \\n                checkLinkedListFromRoot(head.next,root.left) \\n                || checkLinkedListFromRoot(head.next,root.right);\\n        }\\n        if(linkedListStartsFromMe)return true;\\n        \\n        return isSubPath(head,root.left) || isSubPath(head,root.right);\\n        \\n    }\\n\\t/**\\n\\t* method to check if the LL at head is found in Tree at root beginning from the root\\n\\t*/\\n    private boolean checkLinkedListFromRoot(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        if(root.val!=head.val)return false;\\n        return checkLinkedListFromRoot(head.next,root.left)\\n\\t\\t|| checkLinkedListFromRoot(head.next,root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913230,
                "title": "c-dfs-code",
                "content": "```\\nclass Solution {\\npublic:\\n    public:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head || !root)\\n            return 0;\\n        \\n        return help(head,root) || isSubPath(head,root->right) || isSubPath(head,root->left);\\n    }\\n    bool help(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL)\\n            return 1;\\n        if(root==NULL)\\n            return 0;\\n        if(head->val!=root->val)\\n            return 0;\\n        \\n        return help(head->next,root->left) || help(head->next,root->right);\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    public:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head || !root)\\n            return 0;\\n        \\n        return help(head,root) || isSubPath(head,root->right) || isSubPath(head,root->left);\\n    }\\n    bool help(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL)\\n            return 1;\\n        if(root==NULL)\\n            return 0;\\n        if(head->val!=root->val)\\n            return 0;\\n        \\n        return help(head->next,root->left) || help(head->next,root->right);\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902258,
                "title": "python-very-easy-iterative-solution",
                "content": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        newls = []\\n        while head != None:\\n            newls.append(head.val)\\n            head = head.next\\n        newstr = \"\".join(map(str, newls))\\n        rootls = [[root, str(root.val)]]\\n        while len(rootls) != 0:\\n            root, rootstring = rootls.pop()\\n            if root != None:\\n                toadd = rootstring + str(root.val)\\n                if newstr in toadd:\\n                    return True\\n                rootls.append([root.left, toadd])\\n                rootls.append([root.right, toadd])\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        newls = []\\n        while head != None:\\n            newls.append(head.val)\\n            head = head.next\\n        newstr = \"\".join(map(str, newls))\\n        rootls = [[root, str(root.val)]]\\n        while len(rootls) != 0:\\n            root, rootstring = rootls.pop()\\n            if root != None:\\n                toadd = rootstring + str(root.val)\\n                if newstr in toadd:\\n                    return True\\n                rootls.append([root.left, toadd])\\n                rootls.append([root.right, toadd])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890531,
                "title": "simple-pre-order-traversal",
                "content": "```\\n  boolean _isSubPath(TreeNode root,String str, StringBuilder sb1){\\n        if(root==null){\\n          return str.contains(sb1.toString());   \\n        }\\n        str=str+root.val;\\n        return _isSubPath(root.left,str,sb1)|| _isSubPath(root.right,str,sb1);\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        StringBuilder sb=new StringBuilder();\\n        StringBuilder sb1=new StringBuilder();\\n        while(head!=null){\\n            sb1.append(head.val);\\n            head=head.next;\\n        }\\n        return _isSubPath(root,\"\",sb1);        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  boolean _isSubPath(TreeNode root,String str, StringBuilder sb1){\\n        if(root==null){\\n          return str.contains(sb1.toString());   \\n        }\\n        str=str+root.val;\\n        return _isSubPath(root.left,str,sb1)|| _isSubPath(root.right,str,sb1);\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        StringBuilder sb=new StringBuilder();\\n        StringBuilder sb1=new StringBuilder();\\n        while(head!=null){\\n            sb1.append(head.val);\\n            head=head.next;\\n        }\\n        return _isSubPath(root,\"\",sb1);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869850,
                "title": "c-recursion",
                "content": "bool checkif(ListNode* head,TreeNode* root){\\n        if(head==NULL ) return true;\\n        if(root==NULL && head !=NULL) return false;\\n        \\n        if(head->val ==root->val) \\n            return checkif(head->next,root->left) || checkif(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n       if(checkif(head,root)) return true;;\\n       return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "bool checkif(ListNode* head,TreeNode* root){\\n        if(head==NULL ) return true;\\n        if(root==NULL && head !=NULL) return false;\\n        \\n        if(head->val ==root->val) \\n            return checkif(head->next,root->left) || checkif(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n       if(checkif(head,root)) return true;;\\n       return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1867112,
                "title": "c-easy-recursive-code",
                "content": "```\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n```\\n**guys if you got the concept then please give and upvote for me.**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858358,
                "title": "python-solution-for-beginners-recursion-with-comments-dfs",
                "content": "\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def isConnected(root,head): ##checks if linked list is in the tree\\n            if head is None: #when linked list ends, it is there! \\n                return True\\n            \\n            if root is None: #when root ends\\n                return root == head\\n            \\n            if root.val != head.val: #value not equal \\n                return False\\n            \\n            # check left and right subtree\\n            return isConnected(root.left,head.next) or isConnected(root.right,head.next)\\n        \\n        \\n        def helper(root):\\n            if not root:\\n                return False\\n            \\n            if root.val == head.val: ##if a values matches, check down the path\\n                if isConnected(root,head):\\n                    return True\\n                    \\n            # go through left and right subtree\\n            return helper(root.left) or helper(root.right)\\n        \\n        \\n        return helper(root)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def isConnected(root,head): ##checks if linked list is in the tree\\n            if head is None: #when linked list ends, it is there! \\n                return True\\n            \\n            if root is None: #when root ends\\n                return root == head\\n            \\n            if root.val != head.val: #value not equal \\n                return False\\n            \\n            # check left and right subtree\\n            return isConnected(root.left,head.next) or isConnected(root.right,head.next)\\n        \\n        \\n        def helper(root):\\n            if not root:\\n                return False\\n            \\n            if root.val == head.val: ##if a values matches, check down the path\\n                if isConnected(root,head):\\n                    return True\\n                    \\n            # go through left and right subtree\\n            return helper(root.left) or helper(root.right)\\n        \\n        \\n        return helper(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856809,
                "title": "go-contiguous-path",
                "content": "```\\nfunc isSubPath(h *ListNode, r *TreeNode) bool {\\n    var isContiguous func(h *ListNode, r *TreeNode) bool\\n    isContiguous = func(h *ListNode, r *TreeNode) bool {\\n        if h == nil { return true }\\n        if r == nil { return false }\\n        if h.Val == r.Val {\\n            return isContiguous(h.Next, r.Left) ||\\n                    isContiguous(h.Next, r.Right)\\n        }\\n        return false\\n    }\\n    \\n    if h == nil { return true }\\n    if r == nil { return false }\\n    if h.Val == r.Val && isContiguous(h,r) { return true }\\n    return isSubPath(h, r.Left) || isSubPath(h, r.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isSubPath(h *ListNode, r *TreeNode) bool {\\n    var isContiguous func(h *ListNode, r *TreeNode) bool\\n    isContiguous = func(h *ListNode, r *TreeNode) bool {\\n        if h == nil { return true }\\n        if r == nil { return false }\\n        if h.Val == r.Val {\\n            return isContiguous(h.Next, r.Left) ||\\n                    isContiguous(h.Next, r.Right)\\n        }\\n        return false\\n    }\\n    \\n    if h == nil { return true }\\n    if r == nil { return false }\\n    if h.Val == r.Val && isContiguous(h,r) { return true }\\n    return isSubPath(h, r.Left) || isSubPath(h, r.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1856785,
                "title": "python-contiguous-path",
                "content": "Need to make sure that the path is contiguous\\n```\\nclass Solution:\\n    \\n    def isContiguousPath(self, h:Optional[ListNode], r:Optional[TreeNode]) ->bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val:\\n            return self.isContiguousPath(h.next, r.left) or \\\\\\n                    self.isContiguousPath(h.next, r.right)\\n            \\n        return False\\n\\n\\n    def isSubPath(self, h: Optional[ListNode], r: Optional[TreeNode]) -> bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val and self.isContiguousPath(h, r): return True\\n                \\n        return self.isSubPath(h, r.left) or \\\\\\n                self.isSubPath(h, r.right)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def isContiguousPath(self, h:Optional[ListNode], r:Optional[TreeNode]) ->bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val:\\n            return self.isContiguousPath(h.next, r.left) or \\\\\\n                    self.isContiguousPath(h.next, r.right)\\n            \\n        return False\\n\\n\\n    def isSubPath(self, h: Optional[ListNode], r: Optional[TreeNode]) -> bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val and self.isContiguousPath(h, r): return True\\n                \\n        return self.isSubPath(h, r.left) or \\\\\\n                self.isSubPath(h, r.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849959,
                "title": "python-traversal-and-search",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        list_ele,itr=\"\",head\\n        while itr:\\n            list_ele+=str(itr.val)\\n            itr=itr.next\\n        ans=[]\\n        def helper(root,list_ele,string):\\n            if root.left is None and root.right is None:\\n                string+=str(root.val)\\n                if list_ele in string:\\n                    ans.append(string)\\n                return\\n            string+=str(root.val)\\n            if root.left:helper(root.left,list_ele,string)\\n            if root.right:helper(root.right,list_ele,string)\\n        helper(root,list_ele,\"\")\\n        return True if len(ans)!=0 else False\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        list_ele,itr=\"\",head\\n        while itr:\\n            list_ele+=str(itr.val)\\n            itr=itr.next\\n        ans=[]\\n        def helper(root,list_ele,string):\\n            if root.left is None and root.right is None:\\n                string+=str(root.val)\\n                if list_ele in string:\\n                    ans.append(string)\\n                return\\n            string+=str(root.val)\\n            if root.left:helper(root.left,list_ele,string)\\n            if root.right:helper(root.right,list_ele,string)\\n        helper(root,list_ele,\"\")\\n        return True if len(ans)!=0 else False\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836302,
                "title": "java-100-faster-self-explainatory-easy",
                "content": "```\\nclass Solution {\\n    boolean flag = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(flag) return true;\\n        if(root == null) return false;\\n        if(root.val == head.val) check(root,head.next);\\n        boolean left = isSubPath(head,root.left);\\n        boolean right = isSubPath(head,root.right);\\n        return left || right;\\n    }\\n    public void check(TreeNode root,ListNode head){\\n        if(flag) return; \\n        if(head == null){\\n            flag = true;\\n            return;\\n        }\\n        if(root.left != null && root.left.val == head.val) check(root.left,head.next);\\n        if(root.right != null && root.right.val == head.val) check(root.right,head.next);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean flag = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(flag) return true;\\n        if(root == null) return false;\\n        if(root.val == head.val) check(root,head.next);\\n        boolean left = isSubPath(head,root.left);\\n        boolean right = isSubPath(head,root.right);\\n        return left || right;\\n    }\\n    public void check(TreeNode root,ListNode head){\\n        if(flag) return; \\n        if(head == null){\\n            flag = true;\\n            return;\\n        }\\n        if(root.left != null && root.left.val == head.val) check(root.left,head.next);\\n        if(root.right != null && root.right.val == head.val) check(root.right,head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607068,
                "title": "python-iterative-bfs-beats-97",
                "content": "**Steps**\\n1. Convert the linked list to a regular list\\n```      \\nself.path = []\\nwhile head:\\n\\tself.path.append(head.val)\\n\\thead = head.next\\n```\\n2. Perform a BFS starting at the root, keeping track of the last n visited nodes where n is the length of the linked list\\n```\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n```\\n\\n3. If the last n visted nodes == the linked list path, return true\\n```\\nif path == self.path: return True\\n```\\n\\n**Complete Code:**\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        self.path = []\\n        while head:\\n            self.path.append(head.val)\\n            head = head.next\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if path == self.path: return True\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n            bfsList = nextList\\n            count += 1\\n        return False\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```      \\nself.path = []\\nwhile head:\\n\\tself.path.append(head.val)\\n\\thead = head.next\\n```\n```\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n```\n```\\nif path == self.path: return True\\n```\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        self.path = []\\n        while head:\\n            self.path.append(head.val)\\n            head = head.next\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if path == self.path: return True\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n            bfsList = nextList\\n            count += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601422,
                "title": "what-s-wrong-with-this-simple-solution-in-python",
                "content": "I tried this simple solution which works for a majority of the test cases but fails on some specific large output. Can somebody tell me what the flaw in the logic is? \\n\\n```\\ndef isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(head, root):\\n            if head == None:\\n                return True\\n            if root == None:\\n                return False\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.left)\\n            else:\\n                ret = dfs(head, root.left)\\n            if ret:\\n                return True\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.right)\\n            else:\\n                ret = dfs(head, root.right)\\n            return ret\\n        \\n        t = dfs(head, root)\\n        return t",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "I tried this simple solution which works for a majority of the test cases but fails on some specific large output. Can somebody tell me what the flaw in the logic is? \\n\\n```\\ndef isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(head, root):\\n            if head == None:\\n                return True\\n            if root == None:\\n                return False\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.left)\\n            else:\\n                ret = dfs(head, root.left)\\n            if ret:\\n                return True\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.right)\\n            else:\\n                ret = dfs(head, root.right)\\n            return ret\\n        \\n        t = dfs(head, root)\\n        return t",
                "codeTag": "Python3"
            },
            {
                "id": 1588730,
                "title": "c-non-recursive-solution-share-for-fun-very-complicate",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        vector<int> values;\\n        while ( head )\\n        {\\n            values.push_back( head->val );\\n            head = head->next;\\n        }\\n\\n        stack<TreeNode*> node_stack;\\n        node_stack.push( root );\\n\\n        stack<TreeNode*> candidates;\\n        while ( !node_stack.empty() )\\n        {\\n            TreeNode* node = node_stack.top();\\n            if ( node->val == values[0] ) candidates.push(node);\\n            node_stack.pop();\\n            if ( node->right ) node_stack.push( node->right );\\n            if ( node->left  ) node_stack.push( node->left  );\\n        }\\n\\n        unordered_map<TreeNode*, bool> skip_nodes;\\n        while ( !candidates.empty() )\\n        {\\n            node_stack.push( candidates.top() );\\n            candidates.pop();\\n            int index = 0;\\n            skip_nodes.clear();\\n            while ( !node_stack.empty() )\\n            {\\n                TreeNode* candidate = node_stack.top();\\n                \\n                bool const chk = ( candidate->val == values[index] );\\n                if ( chk && index == values.size()-1 ) return true;\\n                if ( chk )\\n                {\\n                    if (  (nullptr == candidate->left && nullptr == candidate->right)\\n                       || (   skip_nodes.end() != skip_nodes.find(candidate->left) \\n                           && skip_nodes.end() != skip_nodes.find(candidate->right)     ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 2 >= index ) index = 0;\\n                            else index-=2;\\n                            node_stack.pop();\\n                        }\\n                    }\\n                    else if (  (   nullptr == candidate->left \\n                                && skip_nodes.end() != skip_nodes.find(candidate->right ) \\n                            || (   nullptr == candidate->right\\n                                && skip_nodes.end() != skip_nodes.find(candidate->left  ) ) ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (   ( node_stack.top()->left \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->left ) )\\n                            || ( node_stack.top()->right \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->right) ) )\\n                        {}\\n                        else\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                        \\n                    }\\n                    else\\n                    {\\n                        if ( candidate->right && skip_nodes.end() == skip_nodes.find(candidate->right) ) \\n                            node_stack.push( candidate->right);\\n                        if ( candidate->left && skip_nodes.end() == skip_nodes.find(candidate->left) )  \\n                            node_stack.push( candidate->left );\\n                        index++;\\n                    }\\n                }\\n                else\\n                {\\n                    node_stack.pop();\\n                    if ( node_stack.empty() ) break;\\n                    skip_nodes[candidate] = true;\\n                    if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        vector<int> values;\\n        while ( head )\\n        {\\n            values.push_back( head->val );\\n            head = head->next;\\n        }\\n\\n        stack<TreeNode*> node_stack;\\n        node_stack.push( root );\\n\\n        stack<TreeNode*> candidates;\\n        while ( !node_stack.empty() )\\n        {\\n            TreeNode* node = node_stack.top();\\n            if ( node->val == values[0] ) candidates.push(node);\\n            node_stack.pop();\\n            if ( node->right ) node_stack.push( node->right );\\n            if ( node->left  ) node_stack.push( node->left  );\\n        }\\n\\n        unordered_map<TreeNode*, bool> skip_nodes;\\n        while ( !candidates.empty() )\\n        {\\n            node_stack.push( candidates.top() );\\n            candidates.pop();\\n            int index = 0;\\n            skip_nodes.clear();\\n            while ( !node_stack.empty() )\\n            {\\n                TreeNode* candidate = node_stack.top();\\n                \\n                bool const chk = ( candidate->val == values[index] );\\n                if ( chk && index == values.size()-1 ) return true;\\n                if ( chk )\\n                {\\n                    if (  (nullptr == candidate->left && nullptr == candidate->right)\\n                       || (   skip_nodes.end() != skip_nodes.find(candidate->left) \\n                           && skip_nodes.end() != skip_nodes.find(candidate->right)     ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 2 >= index ) index = 0;\\n                            else index-=2;\\n                            node_stack.pop();\\n                        }\\n                    }\\n                    else if (  (   nullptr == candidate->left \\n                                && skip_nodes.end() != skip_nodes.find(candidate->right ) \\n                            || (   nullptr == candidate->right\\n                                && skip_nodes.end() != skip_nodes.find(candidate->left  ) ) ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (   ( node_stack.top()->left \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->left ) )\\n                            || ( node_stack.top()->right \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->right) ) )\\n                        {}\\n                        else\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                        \\n                    }\\n                    else\\n                    {\\n                        if ( candidate->right && skip_nodes.end() == skip_nodes.find(candidate->right) ) \\n                            node_stack.push( candidate->right);\\n                        if ( candidate->left && skip_nodes.end() == skip_nodes.find(candidate->left) )  \\n                            node_stack.push( candidate->left );\\n                        index++;\\n                    }\\n                }\\n                else\\n                {\\n                    node_stack.pop();\\n                    if ( node_stack.empty() ) break;\\n                    skip_nodes[candidate] = true;\\n                    if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554242,
                "title": "java-clean-and-concise-dfs",
                "content": "```\\nclass Solution {\\n  \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       if(root == null)\\n           return false;\\n       /*check if there is a path which contains same data as the linked list from the current node*/\\n       if(helper(root,head))\\n           return true;\\n       /*if there isnt a path in the particular node then start checking from its left and right child*/ \\n       return isSubPath(head,root.left) || isSubPath(head,root.right); \\n    }\\n    \\n    boolean helper(TreeNode tNode,ListNode lNode) {\\n        /* checking every node is a valid path in the tree */\\n        /*if the lNode is null obviously it is the end of the linked list\\n          which means we found a path in the tree that has the same datas as the linked list*/\\n        if(lNode == null)\\n            return true;\\n        if(tNode == null) \\n            return false;\\n        /*if the tree\\'s current data and list\\'s data doesnt match it will lead to no path\\n        so we just return false*/\\n        if(tNode.val != lNode.val)\\n            return false;\\n        \\n        /*there are two possoibilities we might get a path either from the left or right,\\n        so if one of them is true definitely we found a path*/\\n        return helper(tNode.left,lNode.next) || helper(tNode.right,lNode.next);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n  \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       if(root == null)\\n           return false;\\n       /*check if there is a path which contains same data as the linked list from the current node*/\\n       if(helper(root,head))\\n           return true;\\n       /*if there isnt a path in the particular node then start checking from its left and right child*/ \\n       return isSubPath(head,root.left) || isSubPath(head,root.right); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1449945,
                "title": "java-solution",
                "content": "travel in the main function if root == null and head is not null then return false\\n - if the above statement is not true then use a helper function to find a find from the current node.\\n - along with the above step look for the path in the left and right side in the main function!\\n\\n```\\nclass Solution {\\n    public boolean helper(ListNode head,TreeNode root)\\n    {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        if(head.val == root.val)\\n            return helper(head.next,root.left) || helper(head.next,root.right);\\n        return false;\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        // with helper function we are checking whether we can form a path from the current node\\n        // repeat the same process for the left and right side of the current node\\n        return helper(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean helper(ListNode head,TreeNode root)\\n    {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        if(head.val == root.val)\\n            return helper(head.next,root.left) || helper(head.next,root.right);\\n        return false;\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        // with helper function we are checking whether we can form a path from the current node\\n        // repeat the same process for the left and right side of the current node\\n        return helper(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426231,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(ListNode* head, TreeNode* root){\\n        if(head==NULL||root==NULL)return ;\\n        if(head->val!=root->val)return ;\\n        if(head->next==NULL){     //if we reach the end of list, that means list exists!! :)\\n            if(head->val==root->val){\\n                ans=1;\\n                return;\\n            }\\n        }\\n        helper(head->next,root->left);\\n        helper(head->next,root->right);\\n    }\\n    void doit(ListNode* head, TreeNode* root){\\n        if(!root)return ;\\n        if(head->val==root->val){\\n            helper(head,root);      //once we find values matching in list and tree, then from there, \\n\\t\\t\\t                       //we chek weather the complete list exist in tree or not!!!\\n        }\\n        doit(head,root->left);\\n        doit(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        doit(head,root);\\n        return ans;\\n    }\\n};\\n```\\npl upvote if u find it useful ;)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(ListNode* head, TreeNode* root){\\n        if(head==NULL||root==NULL)return ;\\n        if(head->val!=root->val)return ;\\n        if(head->next==NULL){     //if we reach the end of list, that means list exists!! :)\\n            if(head->val==root->val){\\n                ans=1;\\n                return;\\n            }\\n        }\\n        helper(head->next,root->left);\\n        helper(head->next,root->right);\\n    }\\n    void doit(ListNode* head, TreeNode* root){\\n        if(!root)return ;\\n        if(head->val==root->val){\\n            helper(head,root);      //once we find values matching in list and tree, then from there, \\n\\t\\t\\t                       //we chek weather the complete list exist in tree or not!!!\\n        }\\n        doit(head,root->left);\\n        doit(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        doit(head,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368564,
                "title": "dfs-6-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return dfs(root,head) || isSubPath(head, root->right) || isSubPath(head, root->left) ;\\n    }\\n    \\n    bool dfs(TreeNode* root, ListNode* head){\\n        if(!head) return true;        \\n        if(!root) return false;        \\n        if(root->val != head->val) return false;           \\n        return dfs(root->left,head->next) || dfs(root->right,head->next);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return dfs(root,head) || isSubPath(head, root->right) || isSubPath(head, root->left) ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1368026,
                "title": "python-dfs-o-mn-solution",
                "content": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head:\\n                return True\\n            if not root or root.val != head.val:\\n                return False\\n            \\n            return dfs(head.next, root.left) or dfs(head.next, root.right)\\n        \\n        \\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if dfs(head, root):\\n            return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head:\\n                return True\\n            if not root or root.val != head.val:\\n                return False\\n            \\n            return dfs(head.next, root.left) or dfs(head.next, root.right)\\n        \\n        \\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if dfs(head, root):\\n            return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362665,
                "title": "java-simple-solution-using-bfs-for-traversal-and-recursion-for-search",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode temp = q.poll();\\n            \\n            if(temp.val==head.val && verify(head.next, temp))\\n                return true;\\n            \\n            if(temp.left!=null)\\n                q.offer(temp.left);\\n            if(temp.right!=null)\\n                q.offer(temp.right);\\n        }\\n        return false;\\n    }\\n    \\n    public boolean verify(ListNode head, TreeNode root) {\\n        if(head == null)\\n            return true;\\n        \\n        if(root==null || head.val!=root.val)\\n            return false;\\n            \\n        return verify(head.next, root.right) || verify(head.next, root.left);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode temp = q.poll();\\n            \\n            if(temp.val==head.val && verify(head.next, temp))\\n                return true;\\n            \\n            if(temp.left!=null)\\n                q.offer(temp.left);\\n            if(temp.right!=null)\\n                q.offer(temp.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346569,
                "title": "java-solution-100-faster-dfs",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isMatched(ListNode head, TreeNode root) {\\n\\t\\t\\tif(head == null)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(root == null || head.val != root.val)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn (isMatched(head.next, root.left) || isMatched(head.next, root.right));\\n\\t\\t}\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\t   if(head == null) \\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif(root == null) \\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(isMatched(head, root))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn (isSubPath(head, root.left) || isSubPath(head, root.right));\\n\\t\\t}  \\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isMatched(ListNode head, TreeNode root) {\\n\\t\\t\\tif(head == null)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(root == null || head.val != root.val)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn (isMatched(head.next, root.left) || isMatched(head.next, root.right));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1326734,
                "title": "c-very-easy-find-string-method",
                "content": "```class Solution {\\npublic:\\n    bool ans;\\n    void preorder(TreeNode* root,string temp,string s) {\\n        if(root==NULL) return;\\n        \\n        temp+=(root->val);\\n        if(temp.find(s)!=string::npos) {\\n            ans=true;\\n            return;\\n        }\\n        preorder(root->left,temp,s);\\n        preorder(root->right,temp,s);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        string s=\"\";\\n        ListNode* curr=head;\\n        while(curr!=NULL) {\\n            s+=(curr->val);\\n            curr=curr->next;\\n        }\\n        ans=false;\\n        preorder(root,\"\",s);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool ans;\\n    void preorder(TreeNode* root,string temp,string s) {\\n        if(root==NULL) return;\\n        \\n        temp+=(root->val);\\n        if(temp.find(s)!=string::npos) {\\n            ans=true;\\n            return;\\n        }\\n        preorder(root->left,temp,s);\\n        preorder(root->right,temp,s);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        string s=\"\";\\n        ListNode* curr=head;\\n        while(curr!=NULL) {\\n            s+=(curr->val);\\n            curr=curr->next;\\n        }\\n        ans=false;\\n        preorder(root,\"\",s);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1326135,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ans=false;\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL && head!=NULL)return false;\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root->val!=head->val) return false;\\n        return dfs(head->next,root->left) || dfs(head->next,root->right); \\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n        if(ans==true) return true;\\n        if(head->val==root->val){\\n           if(dfs(head,root)){\\n               ans=true;\\n               return true;\\n           }\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ans=false;\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL && head!=NULL)return false;\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root->val!=head->val) return false;\\n        return dfs(head->next,root->left) || dfs(head->next,root->right); \\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n        if(ans==true) return true;\\n        if(head->val==root->val){\\n           if(dfs(head,root)){\\n               ans=true;\\n               return true;\\n           }\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318763,
                "title": "c-recursion",
                "content": "```\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n\\t\\t// For each treenode, start a new search\\n        return search(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool search(ListNode * head, TreeNode * root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n        if (head->val == root->val) {\\n            return search(head->next, root->left) || search(head->next, root->right);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n\\t\\t// For each treenode, start a new search\\n        return search(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool search(ListNode * head, TreeNode * root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n        if (head->val == root->val) {\\n            return search(head->next, root->left) || search(head->next, root->right);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311174,
                "title": "c-solution-easy-to-understand",
                "content": "bool isIdentical(ListNode* head,TreeNode* root)\\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL) return true;\\n        if(root == NULL && head != NULL) return false;\\n        if(root->val == head->val)\\n        {\\n            return isIdentical(head->next,root->left) || isIdentical(head->next,root->right);         \\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL || root == NULL) return false;\\n        if(isIdentical(head,root))\\n        {\\n            return true;\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "bool isIdentical(ListNode* head,TreeNode* root)\\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL) return true;\\n        if(root == NULL && head != NULL) return false;\\n        if(root->val == head->val)\\n        {\\n            return isIdentical(head->next,root->left) || isIdentical(head->next,root->right);         \\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL || root == NULL) return false;\\n        if(isIdentical(head,root))\\n        {\\n            return true;\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1283736,
                "title": "faster-then-90-concise-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool help(ListNode* head, TreeNode* root){\\n       //base case\\n        if(!head){return true;} //if list is complete return true\\n        if(head and !root){return false;}//tree ended before list return false\\n        if(head->val==root->val){//if head value equals root value \\n            bool left=help(head->next,root->left); //check left subtree for rest of the list\\n            bool right=help(head->next,root->right);//check right subtree for rest of the list\\n            return left or right;//return true if any side of the tree has the complete list\\n        }\\n        return false;//if head val is not equal root val return false\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root){return false;}\\n        if(root->val==head->val){\\n            bool ans=help(head,root);\\n            if(ans){return true;}\\n        }\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help(ListNode* head, TreeNode* root){\\n       //base case\\n        if(!head){return true;} //if list is complete return true\\n        if(head and !root){return false;}//tree ended before list return false\\n        if(head->val==root->val){//if head value equals root value \\n            bool left=help(head->next,root->left); //check left subtree for rest of the list\\n            bool right=help(head->next,root->right);//check right subtree for rest of the list\\n            return left or right;//return true if any side of the tree has the complete list\\n        }\\n        return false;//if head val is not equal root val return false\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root){return false;}\\n        if(root->val==head->val){\\n            bool ans=help(head,root);\\n            if(ans){return true;}\\n        }\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1868917,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1763819,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 2044202,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1876924,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1751735,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1675335,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Closest Subsequence Sum",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>goal</code>.</p>\n\n<p>You want to choose a subsequence of <code>nums</code> such that the sum of its elements is the closest possible to <code>goal</code>. That is, if the sum of the subsequence&#39;s elements is <code>sum</code>, then you want to <strong>minimize the absolute difference</strong> <code>abs(sum - goal)</code>.</p>\n\n<p>Return <em>the <strong>minimum</strong> possible value of</em> <code>abs(sum - goal)</code>.</p>\n\n<p>Note that a subsequence of an array is an array formed by removing some elements <strong>(possibly all or none)</strong> of the original array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,-7,3,5], goal = 6\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,-9,15,-2], goal = -5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], goal = -7\n<strong>Output:</strong> 7\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 40</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1053522,
                "title": "python-meet-in-the-middle",
                "content": "If we just brute force and generate all sums of subsequences of the origial array, the time complexity would be `O(2^n)` which is too slow for `n=40`.\\nInstead we can break the array in half and generate all possible sums of each half. For each possible sum of the 1st half, we binary seach for the sum in the 2nd half that gives the closest value to `goal`.\\nTime complexity: `O(n2^(n/2))`\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # function that generates all possible sums of sebsequences\\n        def dfs(i,cur,arr,sums):\\n            if i==len(arr):\\n                sums.add(cur)\\n                return\\n            dfs(i+1,cur,arr,sums)\\n            dfs(i+1,cur+arr[i],arr,sums)\\n        \\n        sums1,sums2=set(),set()\\n        # generate all possible sums of the 1st and 2nd half \\n        dfs(0,0,nums[:len(nums)//2],sums1)\\n        dfs(0,0,nums[len(nums)//2:],sums2)\\n        \\n        # sort the possible sums of the 2nd half\\n        s2=sorted(sums2)\\n        ans=10**10\\n        # for each possible sum of the 1st half, find the sum in the 2nd half\\n        # that gives a value closest to the goal using binary search\\n        for s in sums1:\\n            remain=goal-s\\n\\t\\t\\t# binary search for the value in s2 that\\'s closest to the remaining value\\n            i2=bisect_left(s2,remain)\\n            if i2<len(s2):\\n                ans=min(ans,abs(remain-s2[i2]))\\n            if i2>0:\\n                ans=min(ans,abs(remain-s2[i2-1]))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # function that generates all possible sums of sebsequences\\n        def dfs(i,cur,arr,sums):\\n            if i==len(arr):\\n                sums.add(cur)\\n                return\\n            dfs(i+1,cur,arr,sums)\\n            dfs(i+1,cur+arr[i],arr,sums)\\n        \\n        sums1,sums2=set(),set()\\n        # generate all possible sums of the 1st and 2nd half \\n        dfs(0,0,nums[:len(nums)//2],sums1)\\n        dfs(0,0,nums[len(nums)//2:],sums2)\\n        \\n        # sort the possible sums of the 2nd half\\n        s2=sorted(sums2)\\n        ans=10**10\\n        # for each possible sum of the 1st half, find the sum in the 2nd half\\n        # that gives a value closest to the goal using binary search\\n        for s in sums1:\\n            remain=goal-s\\n\\t\\t\\t# binary search for the value in s2 that\\'s closest to the remaining value\\n            i2=bisect_left(s2,remain)\\n            if i2<len(s2):\\n                ans=min(ans,abs(remain-s2[i2]))\\n            if i2>0:\\n                ans=min(ans,abs(remain-s2[i2-1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053751,
                "title": "java-detailed-explanation-comments-meet-in-the-middle-o-n-2-n-2",
                "content": "Approach:\\n\\n* Generate all possible subsequence sums from one half of the array, and store it in a list/set. Let us call this `first`\\n* Sort this list/set in non decreasing order.\\n* Generate all possible subsequence sums from the other half of the array, store this in a list/set as well. Let us call this `second`.\\n* For each possible subsequence sum, say `currSum` from the second half of the array, calculate how far off this sum is from the desired goal. Let us call this value `left`\\n* Try to find an exact match for `left` in `first` via binary search. If an exact match is found in `first`, -> We will be able to reach `goal` using the `currSum`  (from second half) + `left` (from first half) Stop early and return 0.\\n* If no exact match is found, we find the largest subsequence sum `< left` from `first` and the smallest subsequence sum `> left` from `first`. We consider these as candidates for our answer. We update our answer, `ans = Math.min(ans, Math.abs(candidate + currSum - goal))`\\n* Having iterated over all subsequence sums from `second`, we would have by now found the most suitable candidate. Return this candidate as answer.\\n\\n\\n```\\nclass Solution {\\n    int[] arr;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        arr = nums;\\n        int n = nums.length;\\n        \\n        \\n        List<Integer> first = new ArrayList<>();\\n        List<Integer> second = new ArrayList<>();\\n        \\n        generate(0,n/2,0, first); //generate all possible subset sums from half the array\\n        generate(n/2, n , 0, second);//generate all possible subset sums from the second half of the array\\n        \\n        \\n        Collections.sort(first);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        \\n        for(int secondSetSum : second ) {\\n            int left = goal - secondSetSum; // How far off are we from the desired goal?\\n            \\n            if(first.get(0) > left) { // all subset sums from first half are too big => Choose the smallest\\n                ans = (int)(Math.min(ans, Math.abs((first.get(0) + secondSetSum) - goal)));\\n                continue;\\n            }\\n            if(first.get(first.size() - 1) < left) { // all subset sums from first half are too small => Choose the largest\\n                ans = (int)(Math.min(ans, Math.abs((first.get(first.size() - 1) + secondSetSum) - goal)));\\n                continue;\\n            }\\n            int pos = Collections.binarySearch(first, left);\\n            if(pos >= 0) // Exact match found! => first.get(pos) + secondSetSum == goal\\n                return 0;\\n            else        // If exact match not found, binarySearch in java returns (-(insertionPosition) - 1)\\n                pos = -1 * (pos + 1);\\n            int low = pos - 1;\\n            ans = (int)Math.min(ans, Math.abs(secondSetSum + first.get(low) - goal)); // Checking for the floor value (largest sum < goal)\\n            ans = (int)Math.min(ans, Math.abs(secondSetSum + first.get(pos) - goal)); //Checking for the ceiling value (smallest sum > goal)\\n        }\\n        return ans;\\n    }\\n\\n    /**\\n    * Generating all possible subset sums. 2 choices at each index,i -> pick vs do not pick \\n    */\\n    void generate(int i, int end, int sum, List<Integer> listOfSubsetSums) {\\n        if (i == end) {\\n            listOfSubsetSums.add(sum); //add\\n            return;\\n        }\\n        generate(i + 1, end, sum + arr[i], set);\\n        generate(i + 1, end, sum, set);\\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[] arr;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        arr = nums;\\n        int n = nums.length;\\n        \\n        \\n        List<Integer> first = new ArrayList<>();\\n        List<Integer> second = new ArrayList<>();\\n        \\n        generate(0,n/2,0, first); //generate all possible subset sums from half the array\\n        generate(n/2, n , 0, second);//generate all possible subset sums from the second half of the array\\n        \\n        \\n        Collections.sort(first);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        \\n        for(int secondSetSum : second ) {\\n            int left = goal - secondSetSum; // How far off are we from the desired goal?\\n            \\n            if(first.get(0) > left) { // all subset sums from first half are too big => Choose the smallest\\n                ans = (int)(Math.min(ans, Math.abs((first.get(0) + secondSetSum) - goal)));\\n                continue;\\n            }\\n            if(first.get(first.size() - 1) < left) { // all subset sums from first half are too small => Choose the largest\\n                ans = (int)(Math.min(ans, Math.abs((first.get(first.size() - 1) + secondSetSum) - goal)));\\n                continue;\\n            }\\n            int pos = Collections.binarySearch(first, left);\\n            if(pos >= 0) // Exact match found! => first.get(pos) + secondSetSum == goal\\n                return 0;\\n            else        // If exact match not found, binarySearch in java returns (-(insertionPosition) - 1)\\n                pos = -1 * (pos + 1);\\n            int low = pos - 1;\\n            ans = (int)Math.min(ans, Math.abs(secondSetSum + first.get(low) - goal)); // Checking for the floor value (largest sum < goal)\\n            ans = (int)Math.min(ans, Math.abs(secondSetSum + first.get(pos) - goal)); //Checking for the ceiling value (smallest sum > goal)\\n        }\\n        return ans;\\n    }\\n\\n    /**\\n    * Generating all possible subset sums. 2 choices at each index,i -> pick vs do not pick \\n    */\\n    void generate(int i, int end, int sum, List<Integer> listOfSubsetSums) {\\n        if (i == end) {\\n            listOfSubsetSums.add(sum); //add\\n            return;\\n        }\\n        generate(i + 1, end, sum + arr[i], set);\\n        generate(i + 1, end, sum, set);\\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054149,
                "title": "c-two-sum-closest",
                "content": "I stumbled over this one during the contest. I think I got very close, but the runtime limits for C++ seems to be super tight.\\n\\nAnyways, the main idea is to generate all possible combination sums. However, that would be too expensive even for 40 elements, and you\\'ll get TLE. \\n\\nSo, we pivot this problem into Two Sum Closest: generate all possible sums for the first half of the array and store it in a set `h1`. Then, generate possible sums for the second half in `h2`.\\n\\nFor each sum from the second half, use binary search to find a complement sum in the first half.\\n\\nAdditional optimizations:\\n- Compute sum of all positive and all negative values. If the goal is larger (or smaller), we know what\\'s the best at this point.\\n- Check if `res == 0` and exit. We cannot do better than zero!\\n- Check if a sum is already in the set and do not search for a compliment in this case.\\n\\n```cpp\\nint minAbsDifference(vector<int>& ns, int goal) {\\n    int res = abs(goal), pos = 0, neg = 0;\\n    for (auto n : ns)\\n        pos += max(0, n), neg += min(0, n);\\n    if (goal < neg || goal > pos)\\n        return min(abs(neg - goal), abs(goal - pos));\\n    set<int> h1{0}, h2{0};\\n    for (auto i = 0; i < ns.size() / 2; ++i)\\n        for (auto n : vector<int>(begin(h1), end(h1)))\\n            if (h1.insert(n + ns[i]).second)\\n                res = min(res, abs(goal - n - ns[i]));\\n    for (auto i = ns.size() / 2; i < ns.size(); ++i)\\n        for (auto n : vector<int>(begin(h2), end(h2)))\\n            if (h2.insert(n + ns[i]).second) {\\n                auto it = h1.lower_bound(goal - n - ns[i]);\\n                if (it != end(h1))\\n                    res = min(res, abs(goal - n - ns[i] - *it));\\n                if (it != begin(h1))\\n                    res = min(res, abs(goal - n - ns[i] - *prev(it)));\\n                if (res == 0)\\n                    return res;\\n            }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minAbsDifference(vector<int>& ns, int goal) {\\n    int res = abs(goal), pos = 0, neg = 0;\\n    for (auto n : ns)\\n        pos += max(0, n), neg += min(0, n);\\n    if (goal < neg || goal > pos)\\n        return min(abs(neg - goal), abs(goal - pos));\\n    set<int> h1{0}, h2{0};\\n    for (auto i = 0; i < ns.size() / 2; ++i)\\n        for (auto n : vector<int>(begin(h1), end(h1)))\\n            if (h1.insert(n + ns[i]).second)\\n                res = min(res, abs(goal - n - ns[i]));\\n    for (auto i = ns.size() / 2; i < ns.size(); ++i)\\n        for (auto n : vector<int>(begin(h2), end(h2)))\\n            if (h2.insert(n + ns[i]).second) {\\n                auto it = h1.lower_bound(goal - n - ns[i]);\\n                if (it != end(h1))\\n                    res = min(res, abs(goal - n - ns[i] - *it));\\n                if (it != begin(h1))\\n                    res = min(res, abs(goal - n - ns[i] - *prev(it)));\\n                if (res == 0)\\n                    return res;\\n            }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053790,
                "title": "python3-divide-in-half",
                "content": "**Algo**\\nDivide `nums` in half. Collect subsequence subs of the two halves respectively and search for a combined sum that is closest to given `target`. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        def fn(nums):\\n            ans = {0}\\n            for x in nums: \\n                ans |= {x + y for y in ans}\\n            return ans \\n        \\n        nums0 = sorted(fn(nums[:len(nums)//2]))\\n        \\n        ans = inf\\n        for x in fn(nums[len(nums)//2:]): \\n            k = bisect_left(nums0, goal - x)\\n            if k < len(nums0): ans = min(ans, nums0[k] + x - goal)\\n            if 0 < k: ans = min(ans, goal - x - nums0[k-1])\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(2^(N/2))`\\nSpace complexity `O(2^(N/2))`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        def fn(nums):\\n            ans = {0}\\n            for x in nums: \\n                ans |= {x + y for y in ans}\\n            return ans \\n        \\n        nums0 = sorted(fn(nums[:len(nums)//2]))\\n        \\n        ans = inf\\n        for x in fn(nums[len(nums)//2:]): \\n            k = bisect_left(nums0, goal - x)\\n            if k < len(nums0): ans = min(ans, nums0[k] + x - goal)\\n            if 0 < k: ans = min(ans, goal - x - nums0[k-1])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053584,
                "title": "c-meet-in-the-middle-binary-search-with-detailed-explanation",
                "content": "#### Idea\\n\\nIdea is simple, we enumerate `[0, N/2)`, `[N/2, N)` by brute-force algorithm.\\nFor each sum `s`  in s1, we find the nearest `goal - s` sum in s2 by using binary-search strategy.\\nThen we get the answer.\\n\\n#### Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        const int n = nums.size();\\n\\n        int ans = abs(goal);\\n        vector<int> s1 = {0}, s2 = {0};\\n        \\n        for (int i = 0; i < (n / 2); i++) {\\n            const int v = s1.size();\\n            for (int t = 0; t < v; t++) {\\n                s1.push_back(s1[t] + nums[i]);\\n            }\\n        }\\n        \\n        for (int i = (n / 2); i < n; i++) {\\n            const int v = s2.size();\\n            for (int t = 0; t < v; t++) {\\n                s2.push_back(s2[t] + nums[i]);\\n            }\\n        }\\n        \\n        set<int> ss2(s2.begin(), s2.end());\\n        for (int x : s1) {\\n            const int y = goal - x;\\n            auto it = ss2.lower_bound(y);\\n    \\n            if (it != ss2.end()) {\\n                ans = min(ans, abs(goal - (x + *it)));\\n\\n                auto it3 = it;\\n                it3++;\\n                if (it3 != ss2.end()) {\\n                    ans = min(ans, abs(goal - (x + *it3)));\\n                }\\n            }\\n            \\n            if (it != ss2.begin()) {\\n                auto it2 = it;\\n                it2--;\\n\\n                ans = min(ans, abs(goal - (x + *it2)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Analysis\\nTC: O(N*2^(N/2))\\nSC: O(2^(N/2))",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        const int n = nums.size();\\n\\n        int ans = abs(goal);\\n        vector<int> s1 = {0}, s2 = {0};\\n        \\n        for (int i = 0; i < (n / 2); i++) {\\n            const int v = s1.size();\\n            for (int t = 0; t < v; t++) {\\n                s1.push_back(s1[t] + nums[i]);\\n            }\\n        }\\n        \\n        for (int i = (n / 2); i < n; i++) {\\n            const int v = s2.size();\\n            for (int t = 0; t < v; t++) {\\n                s2.push_back(s2[t] + nums[i]);\\n            }\\n        }\\n        \\n        set<int> ss2(s2.begin(), s2.end());\\n        for (int x : s1) {\\n            const int y = goal - x;\\n            auto it = ss2.lower_bound(y);\\n    \\n            if (it != ss2.end()) {\\n                ans = min(ans, abs(goal - (x + *it)));\\n\\n                auto it3 = it;\\n                it3++;\\n                if (it3 != ss2.end()) {\\n                    ans = min(ans, abs(goal - (x + *it3)));\\n                }\\n            }\\n            \\n            if (it != ss2.begin()) {\\n                auto it2 = it;\\n                it2--;\\n\\n                ans = min(ans, abs(goal - (x + *it2)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759737,
                "title": "c-dfs-without-binary-search-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&arr , int idx , int limit , int total , vector<int>&sums)\\n    {\\n        if(idx == limit)\\n        {\\n            sums.push_back(total) ; \\n            return ; \\n        }\\n        solve(arr , idx+1 , limit , total , sums) ; \\n        solve(arr , idx+1 , limit , total + arr[idx] , sums) ;\\n    }\\n    \\n    void search(vector<int>&left , vector<int>&right , int &ans , int target)\\n    {\\n        int l = 0 ; \\n        int r = right.size()-1 ; \\n        while(l < left.size() && r >= 0)\\n        {\\n            int ss = left[l] + right[r] ; \\n            ans = min(ans , abs(target - ss)) ; \\n            if(ss < target) l++ ; \\n            else if(ss > target) r-- ; \\n            else break ; \\n        }\\n    }\\n    int minAbsDifference(vector<int>& arr, int target) {\\n        int n = arr.size() ; \\n        int ans = INT_MAX ; \\n        vector<int>left , right ; \\n        solve(arr , 0 , n/2+1 , 0 , left) ; \\n        solve(arr , n/2+1 , n , 0 , right) ; \\n        \\n        for(int i = 0 ; i<left.size() ; i++)\\n        {\\n            ans = min(ans , abs(target - left[i])) ; \\n        }\\n        for(int i = 0 ; i < right.size() ; i++)\\n        {\\n            ans = min(ans , abs(target - right[i])) ; \\n        }\\n        \\n        sort(left.begin() , left.end()) ;\\n        sort(right.begin() , right.end()) ; \\n        search(left , right , ans , target) ; \\n        return ans ; \\n        \\n    }\\n};",
                "solutionTags": [
                    "Two Pointers",
                    "Depth-First Search",
                    "Recursion",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(vector<int>&arr , int idx , int limit , int total , vector<int>&sums)\\n    {\\n        if(idx == limit)\\n        {\\n            sums.push_back(total) ; \\n            return ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1053563,
                "title": "java-two-sum-o-2-n-2",
                "content": "divide the n nums into two n/2 group.\\ncalculate all combination sum of first group. Put them into treemap.\\ncalculte all combination sum of secod group. For each sum, find the best number sum_prev in first group that  sum+sum_prev is closest to goal.\\ntime complexity would be n/2*2^(n/2)*lg(2^(n/2)) = n^2 * 2^(n/2)\\n\\n```\\n    private int sln1(int[] nums, int g){\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        int n = nums.length;\\n        int m = n/2;\\n        treeMap.put(0,0);\\n        for(int i = (1<<m)-1; i>0; i--){\\n            int sum = 0;\\n            for(int j = 0;j< m;j++){\\n                sum+= nums[j]*((i>>j)&1);\\n            }\\n            treeMap.put(sum, 0);\\n        }\\n        \\n        int min = Math.abs(g);\\n        for(int i = (1<<(n-m))-1; i>0;i--){\\n            int sum = 0;\\n            for(int j = 0;j< n-m;j++){\\n                sum+= nums[j+m]*((i>>j)&1);\\n            }\\n            Integer floorKey = treeMap.floorKey(g-sum);\\n            Integer ceilingKey = treeMap.ceilingKey(g-sum);\\n            if(floorKey != null) min = Math.min(min, Math.abs(sum+floorKey-g));\\n            if(ceilingKey != null) min = Math.min(min, Math.abs(sum+ceilingKey-g));\\n        }\\n\\n        Integer floorKey = treeMap.floorKey(g);\\n        Integer ceilingKey = treeMap.ceilingKey(g);\\n        if(floorKey != null) min = Math.min(min, Math.abs(floorKey-g));\\n        if(ceilingKey != null) min = Math.min(min, Math.abs(ceilingKey-g));\\n        return min;\\n    }\\n\\t\\n```\\n\\n\\nwe can also use merge sort idea to build each half sum array in sorted order. Then use two pointers approach to find the answer. In this approach the time complexity would be O(2^(n/2)) in total. Credit to @alanlzl who provided this idea.\\n```\\n    //2^(n/2)\\n    private int sln2(int[] nums, int g){\\n        int n = nums.length;\\n        \\n        List<Integer> arr1 = helper(Arrays.copyOfRange(nums, 0, n/2));\\n        List<Integer> arr2 = helper(Arrays.copyOfRange(nums, n/2, n));\\n        int n1 = arr1.size();\\n        int n2 = arr2.size();\\n        int res = Integer.MAX_VALUE;\\n        \\n        int l = 0; int r = n2-1;\\n        while(l<n1 && r>=0){\\n            int sum = arr1.get(l)+arr2.get(r);\\n            res = Math.min(res, Math.abs(sum-g));\\n            if(sum>g){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<Integer> helper(int[] nums){\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        for(int i = 0;i< nums.length;i++){\\n            List<Integer> list2 = new ArrayList<>();\\n            for(int j1=0,j2=0; j1<list.size() || j2<list.size(); ){\\n                int v1 = j1<list.size()? list.get(j1): Integer.MAX_VALUE;\\n                int v2 = j2<list.size()? list.get(j2)+nums[i]: Integer.MAX_VALUE;\\n                if(v1< v2) {\\n                    list2.add(v1);\\n                    j1++;\\n                }else{\\n                    list2.add(v2);\\n                    j2++;\\n                } \\n            }\\n            list = list2;\\n        }\\n        return list;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int sln1(int[] nums, int g){\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        int n = nums.length;\\n        int m = n/2;\\n        treeMap.put(0,0);\\n        for(int i = (1<<m)-1; i>0; i--){\\n            int sum = 0;\\n            for(int j = 0;j< m;j++){\\n                sum+= nums[j]*((i>>j)&1);\\n            }\\n            treeMap.put(sum, 0);\\n        }\\n        \\n        int min = Math.abs(g);\\n        for(int i = (1<<(n-m))-1; i>0;i--){\\n            int sum = 0;\\n            for(int j = 0;j< n-m;j++){\\n                sum+= nums[j+m]*((i>>j)&1);\\n            }\\n            Integer floorKey = treeMap.floorKey(g-sum);\\n            Integer ceilingKey = treeMap.ceilingKey(g-sum);\\n            if(floorKey != null) min = Math.min(min, Math.abs(sum+floorKey-g));\\n            if(ceilingKey != null) min = Math.min(min, Math.abs(sum+ceilingKey-g));\\n        }\\n\\n        Integer floorKey = treeMap.floorKey(g);\\n        Integer ceilingKey = treeMap.ceilingKey(g);\\n        if(floorKey != null) min = Math.min(min, Math.abs(floorKey-g));\\n        if(ceilingKey != null) min = Math.min(min, Math.abs(ceilingKey-g));\\n        return min;\\n    }\\n\\t\\n```\n```\\n    //2^(n/2)\\n    private int sln2(int[] nums, int g){\\n        int n = nums.length;\\n        \\n        List<Integer> arr1 = helper(Arrays.copyOfRange(nums, 0, n/2));\\n        List<Integer> arr2 = helper(Arrays.copyOfRange(nums, n/2, n));\\n        int n1 = arr1.size();\\n        int n2 = arr2.size();\\n        int res = Integer.MAX_VALUE;\\n        \\n        int l = 0; int r = n2-1;\\n        while(l<n1 && r>=0){\\n            int sum = arr1.get(l)+arr2.get(r);\\n            res = Math.min(res, Math.abs(sum-g));\\n            if(sum>g){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<Integer> helper(int[] nums){\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        for(int i = 0;i< nums.length;i++){\\n            List<Integer> list2 = new ArrayList<>();\\n            for(int j1=0,j2=0; j1<list.size() || j2<list.size(); ){\\n                int v1 = j1<list.size()? list.get(j1): Integer.MAX_VALUE;\\n                int v2 = j2<list.size()? list.get(j2)+nums[i]: Integer.MAX_VALUE;\\n                if(v1< v2) {\\n                    list2.add(v1);\\n                    j1++;\\n                }else{\\n                    list2.add(v2);\\n                    j2++;\\n                } \\n            }\\n            list = list2;\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268942,
                "title": "c-commented-code-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053657,
                "title": "c-clean-code-with-explanation",
                "content": "- The length of the array is 40, so taking every subset will take O(2^40) which is not acceptable\\n- We use an algorithm called meet in the middle which divides this into 2 arrays (each of max size 20 - about 1e6 - very manageable) and then merges them intelligently\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Generate sums of all possible subsets of a given array\\n    vector<int> gen_subsets(vector<int> &a) {\\n        int n = a.size(), i, j;\\n        vector<int> ret;\\n        for(i = 0; i < (1<<n); i++) {\\n            int sum = 0;\\n            for(j=0; j<n; j++)\\n                if(i & (1 << j))\\n                    sum += a[j];\\n            ret.emplace_back(sum);\\n        }\\n        sort(ret.begin(), ret.end());\\n        return ret;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size(), i, j;\\n\\t\\t\\n\\t\\t// Split array in half and generate sum subarrays for each of them\\t\\t\\n\\t\\tvector<int> half1, half2;   \\n        for(i=0; i<n/2; i++) \\n            half1.emplace_back(nums[i]);\\n        for(; i<n; i++) \\n            half2.emplace_back(nums[i]);\\n        vector<int> a = gen_subsets(half1);\\n        vector<int> b = gen_subsets(half2);\\n        int ret = 2e9;\\n\\t\\t\\n\\t\\t// For each element in a, find the closest elements in b (just over or just under) such that their sum is as close to target as possible\\n\\t\\t// Earlier iterations were prone to time limit exceeded. A minor change fixed it. Problem setter needs to be less *nal, ideally.\\n        for(i=0; i<a.size(); i++) {   \\n            j = lower_bound(b.begin(), b.end(), goal - a[i]) - b.begin();\\n            if(j > 0)\\n                ret = min(ret, abs(goal - b[j - 1] - a[i]));\\n            if(j < b.size())\\n                ret = min(ret, abs(goal - b[j] - a[i]));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Generate sums of all possible subsets of a given array\\n    vector<int> gen_subsets(vector<int> &a) {\\n        int n = a.size(), i, j;\\n        vector<int> ret;\\n        for(i = 0; i < (1<<n); i++) {\\n            int sum = 0;\\n            for(j=0; j<n; j++)\\n                if(i & (1 << j))\\n                    sum += a[j];\\n            ret.emplace_back(sum);\\n        }\\n        sort(ret.begin(), ret.end());\\n        return ret;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size(), i, j;\\n\\t\\t\\n\\t\\t// Split array in half and generate sum subarrays for each of them\\t\\t\\n\\t\\tvector<int> half1, half2;   \\n        for(i=0; i<n/2; i++) \\n            half1.emplace_back(nums[i]);\\n        for(; i<n; i++) \\n            half2.emplace_back(nums[i]);\\n        vector<int> a = gen_subsets(half1);\\n        vector<int> b = gen_subsets(half2);\\n        int ret = 2e9;\\n\\t\\t\\n\\t\\t// For each element in a, find the closest elements in b (just over or just under) such that their sum is as close to target as possible\\n\\t\\t// Earlier iterations were prone to time limit exceeded. A minor change fixed it. Problem setter needs to be less *nal, ideally.\\n        for(i=0; i<a.size(); i++) {   \\n            j = lower_bound(b.begin(), b.end(), goal - a[i]) - b.begin();\\n            if(j > 0)\\n                ret = min(ret, abs(goal - b[j - 1] - a[i]));\\n            if(j < b.size())\\n                ret = min(ret, abs(goal - b[j] - a[i]));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400544,
                "title": "python-meet-in-the-middle-detailed-thoughts-explanation",
                "content": "Sharing some of my fundamental learnings / observations.\\n1. When the constraints are low, for example - length of the array is `<=40`, my initial thought process was to brute-force.\\n2. When brute-force doesn\\'t work, and ends up giving us TLE, then - we can think about \"Meet in the Middle\" approach\\n\\nBefore going into the \"Meet-in-the-Middle\" approach, let\\'s first try to understand some subproblems clearly, even when we bruteforce. \\n\\nThoughts leading to the solution:\\n\\n1. First, I need to select the elements, that I need to be part of the subsequence.\\n2. For which I need to figure out the various combinations of elements to pick and choose.\\n\\nOne of the techniques, I use to pick combination of elements, as part of a subsquence is to use \"BitMask\"\\n\\nConsider the following function below:\\n\\n```\\nclass Solution:\\n    def get_subset_sums(self, A: List[int]):\\n        result = set()\\n        n = len(A)\\n        limit = 1 << n\\n        # Going through all the combinations generated\\n        for msk in range(limit):\\n            s = 0\\n            # Going through the length of the array\\n            for j in range(0, n):\\n                # Check if the i\\'th bit is set, to choose the element from the array\\n                if msk & (1 << j):\\n                    s += A[j]\\n            result.add(s)\\n        return result\\n```\\n\\nIn the above function, I have added comments for clarity, but we are really doing in simple terms is:\\n1. Let\\'s say the array consists of 3 elements; `A = [1, 2, 3]`\\n2. The total number of combinations is 2^3 = 8\\n3. This can be represented in binary.\\n\\n```\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n```\\n\\n1. Here in the above binary representations, each binary number is telling us what number to pick from the array, thus giving us all possible subsequences.\\n2. Hence in the function `get_subset_sums` we merely check if the i\\'th bit is set, and if it is, include it when computing the sum of the subsequence.\\n3. Hence, for a given input array - the function gives us all possible subsequence sums.\\n3. Okay? - Now can we go over all the various sub-sequences, and see which is closest to `goal`? We can, but this will result in `TLE`\\n4. Now to optimize, this - here, we think about the \"Meet in the Middle\" approach.\\n\\nMeet in the Middle Approach:\\n1. Here, we decide to split the I/P array into 2 parts. Let\\'s say A1 and A2\\n2. Now, let\\'s get the subsequence sums for A1, and A2 calling the `get_subset_sums` function above.\\n2. Let x be the sum we select from s1\\n3. Let y be the sum we select from s2\\n4. So x + y = sum - where-in the `sum` should be as close to the `goal` as possible.\\n\\nTaking some smart approaches.\\n1. Hence for every value \\'y\\' in s2, we search for a value \\'x\\' in s1 such that x + y is almost goal  \\n2. This `search` can be implemented using binary search.\\n\\nHence the entire solution looks as follows:\\n\\n```\\nclass Solution:\\n    def get_subset_sums(self, A: List[int]):\\n        result = set()\\n        n = len(A)\\n        limit = (1 << n)\\n        # Going through all the combinations generated\\n        for msk in range(limit):\\n            s = 0\\n            # Going through the length of the array\\n            for j in range(0, n):\\n                # Check if the i\\'th bit is set, to choose the element from the array\\n                if msk & (1 << j):\\n                    s += A[j]\\n            result.add(s)\\n        return result\\n            \\n        \\n    def minAbsDifference(self, A: List[int], goal: int) -> int:        \\n        n = len(A)\\n        half = n >> 1\\n        A1, A2 = A[ :half], A[half:]\\n        s1, s2 = self.get_subset_sums(A1), self.get_subset_sums(A2)\\n        s2 = sorted(s2)\\n\\n        \\n        # Note: s1, s2 are representations of what elements we are selecting from A1, A2\\n        # let x be the sum we select from s1\\n        # let y be the sum we select from s2\\n        # So x + y = sum should be as close to the goal as possible\\n        #   x (s1) + y (s2) == sum\\n        # so that - abs(sum - goal) is as minimum as possible\\n        \\n        # Hence for every value \\'y\\' in s2, we search for a value \\'x\\' in s1\\n        # such that x + y is almost goal  - only then sum-goal is as small as possible.\\n        # So we search \"goal-y\" in s1\\n        \\n        ans = float(\\'inf\\')\\n                \\n        for s in s1:\\n            remain = goal - s\\n\\t\\t\\t# binary search for the value in s2 that\\'s closest to the remaining value\\n            i2 = bisect_left(s2,remain)\\n            if i2 < len(s2):\\n                ans = min(ans, abs(remain - s2[i2]))\\n            if i2 > 0:\\n                ans=min(ans,abs(remain- s2[i2-1]))\\n        return ans\\n```\\nSubmission Link: https://leetcode.com/submissions/detail/768998569/\\n\\nAfter thoughts:\\n\\n1. Looking at other solutions in the discuss section, the `get_subset_sums` function can be written much faster and nicer.\\n\\nFor example:\\n```\\ndef fn(nums):\\n\\tans = {0}\\n\\tfor x in nums: \\n\\t\\tans |= {x + y for y in ans}\\n\\treturn ans \\n```\\n2. Also the OJ limits are a bit tight for this question, when I submitted my same solution that got `AC`, sometimes I get `TLE`, sometimes I get `AC` \\n3. Nevertheless, I thought sharing my whole thought process here might be useful. \\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def get_subset_sums(self, A: List[int]):\\n        result = set()\\n        n = len(A)\\n        limit = 1 << n\\n        # Going through all the combinations generated\\n        for msk in range(limit):\\n            s = 0\\n            # Going through the length of the array\\n            for j in range(0, n):\\n                # Check if the i\\'th bit is set, to choose the element from the array\\n                if msk & (1 << j):\\n                    s += A[j]\\n            result.add(s)\\n        return result\\n```\n```\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n```\n```\\nclass Solution:\\n    def get_subset_sums(self, A: List[int]):\\n        result = set()\\n        n = len(A)\\n        limit = (1 << n)\\n        # Going through all the combinations generated\\n        for msk in range(limit):\\n            s = 0\\n            # Going through the length of the array\\n            for j in range(0, n):\\n                # Check if the i\\'th bit is set, to choose the element from the array\\n                if msk & (1 << j):\\n                    s += A[j]\\n            result.add(s)\\n        return result\\n            \\n        \\n    def minAbsDifference(self, A: List[int], goal: int) -> int:        \\n        n = len(A)\\n        half = n >> 1\\n        A1, A2 = A[ :half], A[half:]\\n        s1, s2 = self.get_subset_sums(A1), self.get_subset_sums(A2)\\n        s2 = sorted(s2)\\n\\n        \\n        # Note: s1, s2 are representations of what elements we are selecting from A1, A2\\n        # let x be the sum we select from s1\\n        # let y be the sum we select from s2\\n        # So x + y = sum should be as close to the goal as possible\\n        #   x (s1) + y (s2) == sum\\n        # so that - abs(sum - goal) is as minimum as possible\\n        \\n        # Hence for every value \\'y\\' in s2, we search for a value \\'x\\' in s1\\n        # such that x + y is almost goal  - only then sum-goal is as small as possible.\\n        # So we search \"goal-y\" in s1\\n        \\n        ans = float(\\'inf\\')\\n                \\n        for s in s1:\\n            remain = goal - s\\n\\t\\t\\t# binary search for the value in s2 that\\'s closest to the remaining value\\n            i2 = bisect_left(s2,remain)\\n            if i2 < len(s2):\\n                ans = min(ans, abs(remain - s2[i2]))\\n            if i2 > 0:\\n                ans=min(ans,abs(remain- s2[i2-1]))\\n        return ans\\n```\n```\\ndef fn(nums):\\n\\tans = {0}\\n\\tfor x in nums: \\n\\t\\tans |= {x + y for y in ans}\\n\\treturn ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876240,
                "title": "java-full-explanation",
                "content": "# Approach:\\n* We have to choose a subsequence of nums whose sum of elements is the closest possible to goal.\\n* The naive approach is to find all subseq and then check which is closest to goal.\\n* But time complexity of this approach is 2^n ( given n E [ 1 , 40 ] ) , hence , we will face TLE.\\n* But , if in any way , we could reduce n to n/2 , then it will work. Meet-in-the-middle algorithm does exactly that.\\n* We divide the array into two possibly equal parts.\\n* We find the sum of elements of all possible subsequences of part1 and part2 separately .\\n* Eg: nums: { 5 , -7 , 3 , 5 }\\n        part1 : { 5 , -7 }\\n\\t\\t\\t\\tpart2 : { 3 , 5 } \\n\\t\\t\\t\\tsubseq of part1 : { {} , {5} , {-7} , { 5, -7 } }\\n\\t\\t\\t\\tsubseq of part2 : { {} , {3} , {5} , {3 , 5 } }\\n\\t\\t\\t\\tsum1 : [ 0 , 5 , -7 , -2 ] // sum1 = ArrayList storing sum of all elements of all possible subseq. of part1.\\n\\t\\t\\t\\tsum2 : [ 0 , 3 , 5 , 8 ]  // sum2 = ArrayList storing sum of all elements of all possible subseq. of part2.\\n* If we add a value of sum1 with a value of sum2 , we get a sum that is sum of subseq of nums . \\n* We use two pointer technique to find the sum closest to goal.\\nEg : nums  : { 5 , -7 , 3 , 5 }\\n       \\tsum1 : [ 0 , 5 , -7 , -2 ]\\n\\t\\t\\t\\tsum2 : [ 0 , 3 , 5 , 8 ]\\n\\t\\t\\t\\tWe can see that -2 (from sum1) + 8 (from sum2) = 6 (goal)\\n\\t\\t\\t\\tThe corresponding subseq is { 5 , -7 , 3 , 5 }.\\n\\t\\t\\t\\t**Two pointer technique :**\\n\\t\\t\\t\\t\\tsum1 : [ -7 , -2 , 0 , 5 ]\\n\\t\\t\\t\\t\\tsum2 : [ 0 , 3 , 5 , 8 ]\\n1. \\t\\t low = 0 ( points to the first index of sum1)\\n\\t\\t\\t\\thigh = 3 ( points to the last index of sum2)\\n\\t\\t\\t\\tgoal = 6\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsum = sum1.get(low) + sum2.get(high) = 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t1 < goal , so low++\\n\\t\\t\\t\\t\\n2.     low = 1 & high = 3\\n        sum = sum1.get(low) + sum2.get(high) = 6\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsum==goal , return 0\\n\\t\\t\\t\\t\\n**CODE:**\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal)\\n    {\\n         //splitting the array , nums, into 2 parts\\n    \\tint part1[] = new int[nums.length/2];\\n    \\tint part2[] = new int[nums.length-part1.length];\\n    \\tint k = 0;\\n    \\tfor(int i=0;i<part1.length;i++)\\n    \\t{\\n    \\t\\tpart1[i] = nums[i];\\n    \\t\\tk++;\\n    \\t}\\n    \\tfor(int i=0 ; i<part2.length ; i++)\\n    \\t{\\n    \\t\\tpart2[i] = nums[k];\\n    \\t\\tk++;\\n    \\t}\\n    \\tArrayList<Integer> sum1=new ArrayList<>(); // stores the sum of all subseq of part1\\n    \\tArrayList<Integer> sum2=new ArrayList<>(); //stores the sum of all subseq of part2\\n    \\t//fills sum1 & sum2 ,  i.e add the sum of elements of all possible subseq of part1 into sum1 &\\n    \\t//add the sum of elements of all possible subseq of part2 into sum2\\n        addSum(sum1,part1,0,0);\\n        addSum(sum2,part2,0,0);\\n        //sorting the two lists \\n        Collections.sort(sum1);\\n        Collections.sort(sum2);\\n        \\n        int low  = 0;\\n        int high = sum2.size()-1;\\n        int res = Integer.MAX_VALUE;\\n        while(low < sum1.size() && high >= 0)\\n        {\\n             int sum = sum1.get(low)+sum2.get(high);\\n             res = Math.min(res,Math.abs(sum-goal));\\n              if(sum > goal)\\n             {\\n            \\t high--;\\n             }\\n             else if(sum==goal)\\n             {\\n                 return 0;\\n             }\\n             else\\n             {\\n            \\t low++;\\n             }\\n           \\n        }\\n        \\n        return res;\\n    }\\n    private void addSum(ArrayList<Integer> sumlist, int[] part,int sum,int si) \\n\\t{\\n\\t\\tif(si>=part.length)\\n\\t\\t{\\n\\t\\t\\tsumlist.add(sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t//include\\n\\t\\taddSum(sumlist,part,sum+part[si],si+1);\\n\\t\\t//exclude\\n\\t\\taddSum(sumlist,part,sum,si+1);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal)\\n    {\\n         //splitting the array , nums, into 2 parts\\n    \\tint part1[] = new int[nums.length/2];\\n    \\tint part2[] = new int[nums.length-part1.length];\\n    \\tint k = 0;\\n    \\tfor(int i=0;i<part1.length;i++)\\n    \\t{\\n    \\t\\tpart1[i] = nums[i];\\n    \\t\\tk++;\\n    \\t}\\n    \\tfor(int i=0 ; i<part2.length ; i++)\\n    \\t{\\n    \\t\\tpart2[i] = nums[k];\\n    \\t\\tk++;\\n    \\t}\\n    \\tArrayList<Integer> sum1=new ArrayList<>(); // stores the sum of all subseq of part1\\n    \\tArrayList<Integer> sum2=new ArrayList<>(); //stores the sum of all subseq of part2\\n    \\t//fills sum1 & sum2 ,  i.e add the sum of elements of all possible subseq of part1 into sum1 &\\n    \\t//add the sum of elements of all possible subseq of part2 into sum2\\n        addSum(sum1,part1,0,0);\\n        addSum(sum2,part2,0,0);\\n        //sorting the two lists \\n        Collections.sort(sum1);\\n        Collections.sort(sum2);\\n        \\n        int low  = 0;\\n        int high = sum2.size()-1;\\n        int res = Integer.MAX_VALUE;\\n        while(low < sum1.size() && high >= 0)\\n        {\\n             int sum = sum1.get(low)+sum2.get(high);\\n             res = Math.min(res,Math.abs(sum-goal));\\n              if(sum > goal)\\n             {\\n            \\t high--;\\n             }\\n             else if(sum==goal)\\n             {\\n                 return 0;\\n             }\\n             else\\n             {\\n            \\t low++;\\n             }\\n           \\n        }\\n        \\n        return res;\\n    }\\n    private void addSum(ArrayList<Integer> sumlist, int[] part,int sum,int si) \\n\\t{\\n\\t\\tif(si>=part.length)\\n\\t\\t{\\n\\t\\t\\tsumlist.add(sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t//include\\n\\t\\taddSum(sumlist,part,sum+part[si],si+1);\\n\\t\\t//exclude\\n\\t\\taddSum(sumlist,part,sum,si+1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208003,
                "title": "c-lower-bound-meet-in-the-middle-solution-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int posSum = 0, negSum = 0;\\n        for (auto num : nums) {\\n            if (num > 0) posSum += num;\\n            else negSum += num;\\n        }\\n        if (goal <= negSum) return negSum - goal;\\n        if (goal >= posSum) return goal - posSum;\\n\\n        vector<int> subsetSum1 = {0}, subsetSum2 = {0};\\n\\n        for (int i = 0; i < (n / 2); i++) {\\n            const int v = subsetSum1.size();\\n            for (int t = 0; t < v; t++) {\\n                subsetSum1.push_back(subsetSum1[t] + nums[i]);\\n            }\\n        }\\n\\n        for (int i = (n / 2); i < n; i++) {\\n            const int v = subsetSum2.size();\\n            for (int t = 0; t < v; t++) {\\n                subsetSum2.push_back(subsetSum2[t] + nums[i]);\\n            }\\n        }\\n\\n        sort(subsetSum2.begin(), subsetSum2.end());\\n\\n        int ans = INT_MAX;\\n        for (auto sum : subsetSum1) {\\n            auto it = lower_bound(subsetSum2.begin(), subsetSum2.end(), goal - sum);\\n            if (it != subsetSum2.end()) {\\n                ans = min(ans, abs(goal - (sum + *it)));\\n                auto it2 = it;\\n                it2++;\\n                if (it2 != subsetSum2.end())\\n                    ans = min(ans, abs(goal - (sum + *it2)));\\n            }\\n            if (it != subsetSum2.begin()) {\\n                ans = min(ans, abs(goal - (sum + * (--it))));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int posSum = 0, negSum = 0;\\n        for (auto num : nums) {\\n            if (num > 0) posSum += num;\\n            else negSum += num;\\n        }\\n        if (goal <= negSum) return negSum - goal;\\n        if (goal >= posSum) return goal - posSum;\\n\\n        vector<int> subsetSum1 = {0}, subsetSum2 = {0};\\n\\n        for (int i = 0; i < (n / 2); i++) {\\n            const int v = subsetSum1.size();\\n            for (int t = 0; t < v; t++) {\\n                subsetSum1.push_back(subsetSum1[t] + nums[i]);\\n            }\\n        }\\n\\n        for (int i = (n / 2); i < n; i++) {\\n            const int v = subsetSum2.size();\\n            for (int t = 0; t < v; t++) {\\n                subsetSum2.push_back(subsetSum2[t] + nums[i]);\\n            }\\n        }\\n\\n        sort(subsetSum2.begin(), subsetSum2.end());\\n\\n        int ans = INT_MAX;\\n        for (auto sum : subsetSum1) {\\n            auto it = lower_bound(subsetSum2.begin(), subsetSum2.end(), goal - sum);\\n            if (it != subsetSum2.end()) {\\n                ans = min(ans, abs(goal - (sum + *it)));\\n                auto it2 = it;\\n                it2++;\\n                if (it2 != subsetSum2.end())\\n                    ans = min(ans, abs(goal - (sum + *it2)));\\n            }\\n            if (it != subsetSum2.begin()) {\\n                ans = min(ans, abs(goal - (sum + * (--it))));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968610,
                "title": "java-solution-with-explaination-easy-to-understand",
                "content": "1.  one naive approach to sol this question is to get all the subsequences of the array.\\n2.  but this approach will take 2^n time which will result in TLE.\\n3.  to overcome this, we need to use meet in the middle technique by dividing the array into two parts.\\n4.  After dividing, we can get maximum 20 elements in an array. now if we get all the subsequence it will take O(2^20) which is feasible.\\n5.  Thus we divide the array in two parts. And get All the subsequnce of both array in two arraylists. \\n6.  Sort both the Arraylists.\\n7.  Use Two pointer Approach to reach the solution.\\n\\nPlease find the code below to get clear idea:\\n\\n\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        if(n==1){\\n            return Math.min(Math.abs(0-goal),Math.abs(nums[0]-goal));\\n        }\\n        int mid = n/2;\\n        \\n        // Divide the array nums into two Arrays left and Right\\n        \\n        int[] left = new int[mid];\\n        int[] right = new int[n-mid];\\n        for(int i = 0; i<n; i++){\\n            if(i<mid){\\n                left[i] = nums[i];\\n            } else{\\n                right[i-mid] = nums[i];\\n            }\\n        }\\n        // Make an ArrayList and fill the arraylist with sum of All the subsequences\\n        // for left and right array\\n        \\n        // Arraylist for left array\\n        ArrayList<Integer> leftSum = getAllSum(left,0,0); \\n        \\n        // ArrayList for right Array\\n        ArrayList<Integer> rightSum = getAllSum(right,0,0);\\n        \\n        // Sort the ArrayLists to use Two pointer Approach\\n        Collections.sort(leftSum);\\n        Collections.sort(rightSum);\\n        \\n        // Call the function to get min absolute diff Using two pointer Approach\\n        return getMinVal(leftSum,rightSum,goal);\\n    }\\n    public int getMinVal(ArrayList<Integer> leftSum, ArrayList<Integer> rightSum, int tar){\\n        \\n        \\n        // This function uses two pointer Approach\\n        \\n        // invoke a min having max int value\\n        int min = Integer.MAX_VALUE;\\n        \\n        // i - index for left array\\n        int i = 0;\\n        \\n        // j - index for right array\\n        int j = rightSum.size()-1;\\n        \\n        \\n        while(i<leftSum.size()&&j>=0){\\n            int sum = leftSum.get(i)+rightSum.get(j);\\n            min = Math.min(min,Math.abs(tar-sum));\\n            \\n            // if sum is less then target we need to increase sum\\n            // we will increase index of left array as the left array is sorted\\n            // by increasing we can get larger values\\n            if(sum<tar){\\n                i++;\\n            }\\n            // Similarly if sum > tar; decrease j to get smaller values;\\n            else if(sum >tar){\\n                j--;\\n            }\\n            // if sum == tar; it\\'s the min diff; so return 0;\\n            else{\\n                return 0;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public ArrayList<Integer> getAllSum(int[] part, int idx, int sum){\\n        int n = part.length;\\n        if(idx==n){\\n            ArrayList<Integer> exc = new ArrayList<Integer>();\\n            exc.add(0);\\n            return exc;\\n        }\\n        // make an arraylist;\\n        // fill arraylist excluding current element;\\n        ArrayList<Integer> exc = getAllSum(part, idx+1, sum);\\n        \\n        int len = exc.size();\\n        // fill same array list by adding curr element into all the elements of \\n        //arraylists;\\n        for(int i =0; i<len; i++){\\n            exc.add(part[idx]+exc.get(i));\\n        }\\n        return exc;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        if(n==1){\\n            return Math.min(Math.abs(0-goal),Math.abs(nums[0]-goal));\\n        }\\n        int mid = n/2;\\n        \\n        // Divide the array nums into two Arrays left and Right\\n        \\n        int[] left = new int[mid];\\n        int[] right = new int[n-mid];\\n        for(int i = 0; i<n; i++){\\n            if(i<mid){\\n                left[i] = nums[i];\\n            } else{\\n                right[i-mid] = nums[i];\\n            }\\n        }\\n        // Make an ArrayList and fill the arraylist with sum of All the subsequences\\n        // for left and right array\\n        \\n        // Arraylist for left array\\n        ArrayList<Integer> leftSum = getAllSum(left,0,0); \\n        \\n        // ArrayList for right Array\\n        ArrayList<Integer> rightSum = getAllSum(right,0,0);\\n        \\n        // Sort the ArrayLists to use Two pointer Approach\\n        Collections.sort(leftSum);\\n        Collections.sort(rightSum);\\n        \\n        // Call the function to get min absolute diff Using two pointer Approach\\n        return getMinVal(leftSum,rightSum,goal);\\n    }\\n    public int getMinVal(ArrayList<Integer> leftSum, ArrayList<Integer> rightSum, int tar){\\n        \\n        \\n        // This function uses two pointer Approach\\n        \\n        // invoke a min having max int value\\n        int min = Integer.MAX_VALUE;\\n        \\n        // i - index for left array\\n        int i = 0;\\n        \\n        // j - index for right array\\n        int j = rightSum.size()-1;\\n        \\n        \\n        while(i<leftSum.size()&&j>=0){\\n            int sum = leftSum.get(i)+rightSum.get(j);\\n            min = Math.min(min,Math.abs(tar-sum));\\n            \\n            // if sum is less then target we need to increase sum\\n            // we will increase index of left array as the left array is sorted\\n            // by increasing we can get larger values\\n            if(sum<tar){\\n                i++;\\n            }\\n            // Similarly if sum > tar; decrease j to get smaller values;\\n            else if(sum >tar){\\n                j--;\\n            }\\n            // if sum == tar; it\\'s the min diff; so return 0;\\n            else{\\n                return 0;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public ArrayList<Integer> getAllSum(int[] part, int idx, int sum){\\n        int n = part.length;\\n        if(idx==n){\\n            ArrayList<Integer> exc = new ArrayList<Integer>();\\n            exc.add(0);\\n            return exc;\\n        }\\n        // make an arraylist;\\n        // fill arraylist excluding current element;\\n        ArrayList<Integer> exc = getAllSum(part, idx+1, sum);\\n        \\n        int len = exc.size();\\n        // fill same array list by adding curr element into all the elements of \\n        //arraylists;\\n        for(int i =0; i<len; i++){\\n            exc.add(part[idx]+exc.get(i));\\n        }\\n        return exc;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054445,
                "title": "simple-java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n    List<Integer> set1=new ArrayList<>();\\n    List<Integer> set2=new ArrayList<>();\\n    \\n    GetAllsubSequenceSum(0,(nums.length-1)/2,nums, set1, 0);\\n    GetAllsubSequenceSum(((nums.length-1)/2)+1,nums.length-1,nums, set2, 0);\\n    int min=Integer.MAX_VALUE;\\n        Collections.sort(set2);\\n        \\n        int sum=0;\\n        for(int first:set1){\\n            int remainingPart=goal-first;            \\n            int pos = Collections.binarySearch(set2, remainingPart);\\n           if(pos>=0)\\n               return 0;\\n           else{\\n               int position= -1*(pos+1);\\n               int low=position-1;\\n                if(low>=0)\\n                  min=Math.min(min, Math.abs(first+set2.get(low)-goal));\\n                if(low!=set2.size()-1)\\n                  min=Math.min(min, Math.abs(first+set2.get(position) - goal));\\n           } \\n        }  \\n    return min;\\n    \\n    }    \\n    \\n        public void GetAllsubSequenceSum(int initial, int length, int[] nums, List<Integer> data, int sum){\\n            if(initial==length+1){\\n                data.add(sum);\\n                return;\\n            }\\n            GetAllsubSequenceSum(initial+1,length,nums,data,sum+nums[initial]);\\n            GetAllsubSequenceSum(initial+1,length,nums,data,sum);\\n        }      \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n    List<Integer> set1=new ArrayList<>();\\n    List<Integer> set2=new ArrayList<>();\\n    \\n    GetAllsubSequenceSum(0,(nums.length-1)/2,nums, set1, 0);\\n    GetAllsubSequenceSum(((nums.length-1)/2)+1,nums.length-1,nums, set2, 0);\\n    int min=Integer.MAX_VALUE;\\n        Collections.sort(set2);\\n        \\n        int sum=0;\\n        for(int first:set1){\\n            int remainingPart=goal-first;            \\n            int pos = Collections.binarySearch(set2, remainingPart);\\n           if(pos>=0)\\n               return 0;\\n           else{\\n               int position= -1*(pos+1);\\n               int low=position-1;\\n                if(low>=0)\\n                  min=Math.min(min, Math.abs(first+set2.get(low)-goal));\\n                if(low!=set2.size()-1)\\n                  min=Math.min(min, Math.abs(first+set2.get(position) - goal));\\n           } \\n        }  \\n    return min;\\n    \\n    }    \\n    \\n        public void GetAllsubSequenceSum(int initial, int length, int[] nums, List<Integer> data, int sum){\\n            if(initial==length+1){\\n                data.add(sum);\\n                return;\\n            }\\n            GetAllsubSequenceSum(initial+1,length,nums,data,sum+nums[initial]);\\n            GetAllsubSequenceSum(initial+1,length,nums,data,sum);\\n        }      \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537936,
                "title": "c-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void generate(int s, int e, int total, vector<int>& nums, vector<int>& sums){\\n        if(s==e){\\n            sums.push_back(total);\\n            return;\\n        }\\n        \\n        generate(s+1, e, total, nums, sums);        \\n        generate(s+1, e, total + nums[s], nums, sums);\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size(), ans = INT_MAX;\\n        vector<int> left, right;\\n        \\n        generate(0, n/2+1, 0, nums, left);        \\n        generate(n/2+1, n, 0, nums, right);\\n        \\n        for(int& x : left)\\n            ans = min(ans, abs(x - goal));\\n        for(int& x : right)\\n            ans = min(ans, abs(x - goal));\\n        \\n        sort(begin(left), end(left));        \\n        sort(begin(right), end(right));\\n        \\n        int l = 0, r = right.size() - 1;\\n        \\n        while(l<left.size() && r>=0){\\n            int s = left[l] + right[r];\\n            ans = min(ans, abs(s - goal));\\n            if(s<goal) l++;\\n            else if(s>goal) r--;\\n            else break;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void generate(int s, int e, int total, vector<int>& nums, vector<int>& sums){\\n        if(s==e){\\n            sums.push_back(total);\\n            return;\\n        }\\n        \\n        generate(s+1, e, total, nums, sums);        \\n        generate(s+1, e, total + nums[s], nums, sums);\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size(), ans = INT_MAX;\\n        vector<int> left, right;\\n        \\n        generate(0, n/2+1, 0, nums, left);        \\n        generate(n/2+1, n, 0, nums, right);\\n        \\n        for(int& x : left)\\n            ans = min(ans, abs(x - goal));\\n        for(int& x : right)\\n            ans = min(ans, abs(x - goal));\\n        \\n        sort(begin(left), end(left));        \\n        sort(begin(right), end(right));\\n        \\n        int l = 0, r = right.size() - 1;\\n        \\n        while(l<left.size() && r>=0){\\n            int s = left[l] + right[r];\\n            ans = min(ans, abs(s - goal));\\n            if(s<goal) l++;\\n            else if(s>goal) r--;\\n            else break;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053603,
                "title": "c-passed-python-tle-cut-in-half-and-then-brute-force-o-n-2-n",
                "content": "The length of `nums` is no more than 40. If we brute force all subsets, it will cost `2^40` searches.\\nBut if we cut `nums` in half and search each of them, each half just cost  `2^20` which sounds feasible.\\n\\nThen we put all subsets\\' sum of the first half in `A` and those of second half in `B`.\\nThen `for(x : A)`, we use binary search `goal-x` in B to find the closest match for `goal-x` in B.\\nThen we just keep searching and keep minimize the diff.\\n```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int na = n>>1; \\n        vector<int> A, B;\\n        int N = 1<<na;\\n        for(int x = 0; x < N; x++)\\n        {\\n            int s = 0;\\n            for(int i = 0; i < na; i++) if(x>>i&1)\\n                s += nums[i];\\n            A.push_back(s);\\n        }\\n        N = 1<<(n-na);\\n        for(int x = 0; x < N; x++)\\n        {\\n            int s = 0;\\n            for(int i = na; i < n; i++) if(x>>(i-na)&1)\\n                s += nums[i];\\n            B.push_back(s);\\n        }\\n        sort(B.begin(), B.end());\\n        int diff = 0x7fffffff;\\n        int nb = B.size();\\n        for(int x : A)\\n        {\\n            int y = goal-x;\\n            int i = lower_bound(B.begin(), B.end(), y) - B.begin();\\n            if(i) diff = min(diff, abs(B[i-1]-y));\\n            if(i < nb) diff = min(diff, abs(B[i]-y));\\n            if(!diff) return 0;\\n        }\\n        return diff; \\n    }\\n};\\n```\\nTime complexity is `O(NlogN)` where `N = 2**(n/2)`. So it\\'s `O(n*2**(n/2))`\\nAnd as always (in brute force case) `python` gave me a TLE while same implementaion in `C++` passed.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int na = n>>1; \\n        vector<int> A, B;\\n        int N = 1<<na;\\n        for(int x = 0; x < N; x++)\\n        {\\n            int s = 0;\\n            for(int i = 0; i < na; i++) if(x>>i&1)\\n                s += nums[i];\\n            A.push_back(s);\\n        }\\n        N = 1<<(n-na);\\n        for(int x = 0; x < N; x++)\\n        {\\n            int s = 0;\\n            for(int i = na; i < n; i++) if(x>>(i-na)&1)\\n                s += nums[i];\\n            B.push_back(s);\\n        }\\n        sort(B.begin(), B.end());\\n        int diff = 0x7fffffff;\\n        int nb = B.size();\\n        for(int x : A)\\n        {\\n            int y = goal-x;\\n            int i = lower_bound(B.begin(), B.end(), y) - B.begin();\\n            if(i) diff = min(diff, abs(B[i-1]-y));\\n            if(i < nb) diff = min(diff, abs(B[i]-y));\\n            if(!diff) return 0;\\n        }\\n        return diff; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121152,
                "title": "meet-in-middle-with-bitmask-c-easy-to-understand",
                "content": "The naive solution is to check all possible subsequences. This works in O(2^n).\\n\\nDivide the array into two parts of nearly is equal size.\\n\\nConsider all subsets of one part and make a list of all possible subset sums and sort this list.\\nConsider all subsets of the other part, and for each one, let its sum = x, do binary search to get the nearest possible value to goal - x in the first part.\\n\\n\\nTime Complexity :    O(N*2^(N/2))\\nSpace Complexity :   O(2^(N/2))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n         int n=nums.size();\\n        \\n//Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)B.push_back(nums[i]);\\n\\n//Step 2: Find all possible subset sums of A and B\\n     auto find=[&](vector<int>&v,vector<int>&res)\\n       {\\n           int n=v.size();   \\n          for(int i=0;i<(1<<n);i++)\\n           {   \\n               int sum=0;\\n               for(int j=0;j<n;j++)\\n               {\\n                   if(i&(1<<j)){sum+=v[j];}\\n               }\\n               res.push_back(sum);\\n           }\\n       };\\n        \\n        vector<int>sumA,sumB;\\n        find(A,sumA);\\n        find(B,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n//Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        for(auto s:sumA){\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n         int n=nums.size();\\n        \\n//Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)B.push_back(nums[i]);\\n\\n//Step 2: Find all possible subset sums of A and B\\n     auto find=[&](vector<int>&v,vector<int>&res)\\n       {\\n           int n=v.size();   \\n          for(int i=0;i<(1<<n);i++)\\n           {   \\n               int sum=0;\\n               for(int j=0;j<n;j++)\\n               {\\n                   if(i&(1<<j)){sum+=v[j];}\\n               }\\n               res.push_back(sum);\\n           }\\n       };\\n        \\n        vector<int>sumA,sumB;\\n        find(A,sumA);\\n        find(B,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n//Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        for(auto s:sumA){\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964600,
                "title": "typescript-divide-halves-two-pointer-solution",
                "content": "```ts\\nfunction* sums(nums: number[], depth: number = 0): Generator<number> {\\n    if (depth === nums.length) {\\n        yield 0;\\n        return;\\n    }\\n\\n    for (const sum of sums(nums, depth + 1)) {\\n        yield sum;\\n        yield sum + nums[depth];\\n    }\\n}\\n\\nfunction uniqueSums(nums: number[]): Set<number> {\\n    return new Set(sums(nums));\\n}\\n\\nfunction minAbsDifference(nums: number[], goal: number): number {\\n    // Split nums into two halves, and get their unique sums\\n    const [left, right] = [nums.slice(0, nums.length / 2), nums.slice(nums.length / 2)]\\n        .map(half => Array.from(uniqueSums(half)));\\n\\n    // Sort left sums smallest-to-largest, right sums largest-to-smallest\\n    left.sort((a, b) => a - b);\\n    right.sort((a, b) => b - a);\\n\\n    // Function to get the sum at pointers l2, r2\\n    const getSum = (l2: number, r2: number) => l2 < left.length && r2 < right.length ? Math.abs(left[l2] + right[r2] - goal) : Infinity;\\n\\n    // Maintain a pointer `l` into the left subarray and `r` into the right subarray\\n    let l = 0;\\n    let r = 0;\\n\\n    // Grab the sums at (l, r) as the initial best option\\n    let best = getSum(l, r);\\n\\n    // Until we reach the end of both arrays,\\n    while (l < left.length - 1 || r < right.length - 1) {\\n        // Calculate both possible sums\\n        const sumL = getSum(l + 1, r);\\n        const sumR = getSum(l, r + 1);\\n\\n        // Choose whichever is better\\n        if (sumL < sumR) {\\n            l++;\\n        } else {\\n            r++;\\n        }\\n\\n        // Store it as best\\n        best = Math.min(best, sumL, sumR);\\n    }\\n\\n    return best;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction* sums(nums: number[], depth: number = 0): Generator<number> {\\n    if (depth === nums.length) {\\n        yield 0;\\n        return;\\n    }\\n\\n    for (const sum of sums(nums, depth + 1)) {\\n        yield sum;\\n        yield sum + nums[depth];\\n    }\\n}\\n\\nfunction uniqueSums(nums: number[]): Set<number> {\\n    return new Set(sums(nums));\\n}\\n\\nfunction minAbsDifference(nums: number[], goal: number): number {\\n    // Split nums into two halves, and get their unique sums\\n    const [left, right] = [nums.slice(0, nums.length / 2), nums.slice(nums.length / 2)]\\n        .map(half => Array.from(uniqueSums(half)));\\n\\n    // Sort left sums smallest-to-largest, right sums largest-to-smallest\\n    left.sort((a, b) => a - b);\\n    right.sort((a, b) => b - a);\\n\\n    // Function to get the sum at pointers l2, r2\\n    const getSum = (l2: number, r2: number) => l2 < left.length && r2 < right.length ? Math.abs(left[l2] + right[r2] - goal) : Infinity;\\n\\n    // Maintain a pointer `l` into the left subarray and `r` into the right subarray\\n    let l = 0;\\n    let r = 0;\\n\\n    // Grab the sums at (l, r) as the initial best option\\n    let best = getSum(l, r);\\n\\n    // Until we reach the end of both arrays,\\n    while (l < left.length - 1 || r < right.length - 1) {\\n        // Calculate both possible sums\\n        const sumL = getSum(l + 1, r);\\n        const sumR = getSum(l, r + 1);\\n\\n        // Choose whichever is better\\n        if (sumL < sumR) {\\n            l++;\\n        } else {\\n            r++;\\n        }\\n\\n        // Store it as best\\n        best = Math.min(best, sumL, sumR);\\n    }\\n\\n    return best;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274297,
                "title": "c-simple-approach-meet-in-the-middle-algorithm-o-n-2-n-2",
                "content": "```\\n// Naive: try out all subsets and check. Time - O(N.2^N) \\n// Optimized approach: use meet in the middle algo\\n/*This problem can be solved using meet in the middle algorithm*/\\n/*\\nApproach:\\nstep 1: divide the array into 2 equal parts\\nstep 2: find the sum of all subsets for the divided 2 arrays separetly and store it in sub1 and sub2 arrays(using bit manip technique)\\nstep 3: sort the sub2 array(Second array) to perform binary search\\nstep 4: Now first of all, find a new target for every element of sub1(target = goal-sub1[i]). So as to remove a sum in the first half\\nstep 5: for every new target find a nearest sum in the sub2 using binary search and find the diff with it(sub2[mid]) to get min_diff\\nstep 6: perform binary search and find the mininum\\nTotal time : O(2^n/2 (sum of nums1) + 2^n/2 (sum of num2) + 2^(n/2)(log2 2^(n/2)) == (n/2)*2^(n/2)  (for sorting 2^(n/2) elements)\\n+ 2^(n/2)log2 (2^n/2) == (n/2)*2^(n/2) (for performing binary search on 2^(n/2) elements for 2^(n/2)) => O(n*(2^(n/2))\\nso, O(n*(2^(n/2)) < O(N.2^N)\\n*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\nvector<int> findSums(vector<int>& arr){\\n  int n = arr.size(),c = 0,sum;\\n vector<int> res((1<<n),0); \\n  for(int i = 0 ;i < (1<< n); i++){\\n    sum = 0;\\n    for(int j = 0; j < n ; j++){\\n     if(i & (1 << j)){\\n      sum += arr[j]; \\n     }\\n    }\\n    res[c++] = sum;\\n  }\\n  return res;\\n}\\nint minAbsDifference(vector<int>& nums, int goal){\\n int n = nums.size();\\n  vector<int> nums1, nums2;\\n  for(int i = 0; i < n/2; i++) nums1.push_back(nums[i]);\\n  for(int i = n/2; i < n ; i++) nums2.push_back(nums[i]);\\n  vector<int> sub1 = findSums(nums1), sub2 = findSums(nums2);\\n  \\n  sort(sub2.begin(),sub2.end());\\n  int min_diff = INT_MAX;\\n  for(int i = 0; i < sub1.size() ; i++){\\n   int target = goal-sub1[i];\\n    int low = 0, high = sub2.size()-1;\\n    while(low <= high){\\n     int mid = low + (high-low)/2;\\n      min_diff = min(min_diff, abs(target-sub2[mid]));\\n      if(sub2[mid] == target){\\n       break; \\n      }else if(target < sub2[mid]){\\n       high = mid-1;\\n      }else{\\n       low = mid+1; \\n      }\\n    }\\n  }\\n  return min_diff;\\n}\\n\\nint main(){\\nios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n  cout.tie(NULL);\\n  int n, goal;\\n  vector<int> nums;\\n  cin >> n >>  goal;\\n  for(int i = 0; i < n ; i++){\\n   int x;\\n    cin >> x;\\n    nums.push_back(x);\\n  }\\n  cout << minAbsDifference(nums,goal) << \"\\\\n\";\\n  return 0; \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Naive: try out all subsets and check. Time - O(N.2^N) \\n// Optimized approach: use meet in the middle algo\\n/*This problem can be solved using meet in the middle algorithm*/\\n/*\\nApproach:\\nstep 1: divide the array into 2 equal parts\\nstep 2: find the sum of all subsets for the divided 2 arrays separetly and store it in sub1 and sub2 arrays(using bit manip technique)\\nstep 3: sort the sub2 array(Second array) to perform binary search\\nstep 4: Now first of all, find a new target for every element of sub1(target = goal-sub1[i]). So as to remove a sum in the first half\\nstep 5: for every new target find a nearest sum in the sub2 using binary search and find the diff with it(sub2[mid]) to get min_diff\\nstep 6: perform binary search and find the mininum\\nTotal time : O(2^n/2 (sum of nums1) + 2^n/2 (sum of num2) + 2^(n/2)(log2 2^(n/2)) == (n/2)*2^(n/2)  (for sorting 2^(n/2) elements)\\n+ 2^(n/2)log2 (2^n/2) == (n/2)*2^(n/2) (for performing binary search on 2^(n/2) elements for 2^(n/2)) => O(n*(2^(n/2))\\nso, O(n*(2^(n/2)) < O(N.2^N)\\n*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\nvector<int> findSums(vector<int>& arr){\\n  int n = arr.size(),c = 0,sum;\\n vector<int> res((1<<n),0); \\n  for(int i = 0 ;i < (1<< n); i++){\\n    sum = 0;\\n    for(int j = 0; j < n ; j++){\\n     if(i & (1 << j)){\\n      sum += arr[j]; \\n     }\\n    }\\n    res[c++] = sum;\\n  }\\n  return res;\\n}\\nint minAbsDifference(vector<int>& nums, int goal){\\n int n = nums.size();\\n  vector<int> nums1, nums2;\\n  for(int i = 0; i < n/2; i++) nums1.push_back(nums[i]);\\n  for(int i = n/2; i < n ; i++) nums2.push_back(nums[i]);\\n  vector<int> sub1 = findSums(nums1), sub2 = findSums(nums2);\\n  \\n  sort(sub2.begin(),sub2.end());\\n  int min_diff = INT_MAX;\\n  for(int i = 0; i < sub1.size() ; i++){\\n   int target = goal-sub1[i];\\n    int low = 0, high = sub2.size()-1;\\n    while(low <= high){\\n     int mid = low + (high-low)/2;\\n      min_diff = min(min_diff, abs(target-sub2[mid]));\\n      if(sub2[mid] == target){\\n       break; \\n      }else if(target < sub2[mid]){\\n       high = mid-1;\\n      }else{\\n       low = mid+1; \\n      }\\n    }\\n  }\\n  return min_diff;\\n}\\n\\nint main(){\\nios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n  cout.tie(NULL);\\n  int n, goal;\\n  vector<int> nums;\\n  cin >> n >>  goal;\\n  for(int i = 0; i < n ; i++){\\n   int x;\\n    cin >> x;\\n    nums.push_back(x);\\n  }\\n  cout << minAbsDifference(nums,goal) << \"\\\\n\";\\n  return 0; \\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1057251,
                "title": "c-meet-in-the-middle-two-sum-beats-96",
                "content": "Brute force would be to calculate all the possible subsequence sums and find the one closest to the target number. This would take O(2^n) time and space.\\n\\nThe \"trick\" to the problem is to realize that although O(2^n) is large, O(2^(n/2)) is substantially smaller. Let `m = ceil(n/2)`. We find the subsequence sums for the left and right halves, each taking O(2^m) time.\\n\\nFinally, if we sort the two subsequence sums, we can look for the best total subseq sum in a rather clean fashion without searching. If we start from the smallest subseq sum in the left half and the largest subseq sum in the right half, anytime the sum is too small, we increment the left pointer, and vice versa. This also takes O(2^m).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> subSequenceSums(vector<int>::iterator start,\\n                                vector<int>::iterator end)\\n    {\\n        // find all the subsequence sums O(2^m)\\n        vector<int> sums;\\n        sums.push_back(0);\\n        for (auto it = start; it!=end; ++it){\\n            int sz = sums.size();\\n            for (int i=0; i<sz; ++i){\\n                sums.push_back(*it + sums[i]);\\n            }\\n        }\\n        sort(sums.begin(),sums.end());\\n        sums.erase(unique(sums.begin(),sums.end()),sums.end());\\n        return sums;\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int m = n/2;\\n        vector<int> left = subSequenceSums(nums.begin(),next(nums.begin(),m));\\n        vector<int> right = subSequenceSums(next(nums.begin(),m), nums.end());\\n        \\n        // O(2^m)\\n        int i = 0, j = right.size() - 1;\\n        int best = abs(goal);\\n        while (i<left.size() && j>=0){\\n            int store = left[i] + right[j];\\n            best = min(best, abs(store - goal));\\n            if (store == goal) break;\\n            else if (store > goal) --j;\\n            else ++i;\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> subSequenceSums(vector<int>::iterator start,\\n                                vector<int>::iterator end)\\n    {\\n        // find all the subsequence sums O(2^m)\\n        vector<int> sums;\\n        sums.push_back(0);\\n        for (auto it = start; it!=end; ++it){\\n            int sz = sums.size();\\n            for (int i=0; i<sz; ++i){\\n                sums.push_back(*it + sums[i]);\\n            }\\n        }\\n        sort(sums.begin(),sums.end());\\n        sums.erase(unique(sums.begin(),sums.end()),sums.end());\\n        return sums;\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int m = n/2;\\n        vector<int> left = subSequenceSums(nums.begin(),next(nums.begin(),m));\\n        vector<int> right = subSequenceSums(next(nums.begin(),m), nums.end());\\n        \\n        // O(2^m)\\n        int i = 0, j = right.size() - 1;\\n        int best = abs(goal);\\n        while (i<left.size() && j>=0){\\n            int store = left[i] + right[j];\\n            best = min(best, abs(store - goal));\\n            if (store == goal) break;\\n            else if (store > goal) --j;\\n            else ++i;\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055825,
                "title": "rust-o-n-2-n-2-with-explanation",
                "content": "In a nutshell\\n1. Find all possible sums in left and right halves of the given Vec\\n2. For each sum in the right half search best sum in the left\\n3. Find the minimum \\n----\\n# 1. Subsequence sums\\nFirst, lets define a function that takes a slice and produces a vector of its unique subsequence sums\\n```rust\\nfn sums(nums: &[i32]) -> Vec<i32> {\\n    let mut res: HashSet<_> = once(0).collect();\\n    for &e in nums {\\n        let new: Vec<_> = res.iter().map(|&x| x + e).collect();\\n        res.extend(new);\\n    }\\n    res.into_iter().collect()\\n}\\n```\\nwe start from a singleton set, that contains only the sum for the empty subsequence\\n```rust\\n    let mut res: HashSet<_> = once(0).collect();\\n```\\nthen for each number we construct all possible sums of it with previously seen numbers \\n```rust\\n        let new: Vec<_> = res.iter().map(|&x| x + e).collect();\\n```\\nand add these sums to our aggregation\\n```rust\\n        res.extend(new);\\n```\\nFinally we convert our set to `Vec`\\n```rust\\n    res.into_iter().collect()\\n```\\n----\\n# 2. Search for best match\\nNext step - having a sorted `Vec`, how we find number the closest to given \\n```rust\\nfn best_difference(elems: &[i32], x: i32) -> i32 {\\n    match elems.binary_search(&x) {\\n        Ok(_) => 0,\\n        Err(0) => elems[0] - x,\\n        Err(m) if m == elems.len() => x - *elems.last().unwrap(),\\n        Err(i) => (elems[i] - x).min(x - elems[i - 1]),\\n    }\\n}\\n```\\nThis function will return the best absolute difference between required number and elements in the `elems` slice\\nWe\\'ll try to find our number using binary search\\n```rust \\nelems.binary_search(&x)\\n ```\\nand match the result\\n* when the result is `Ok` we found an exact match, so diff is 0\\n  ```rust \\n  Ok(_) => 0,\\n  ```\\n* when the result is `Err(0)` all of the `elems` greater than `x` so we take difference with smallest of them\\n   ```rust\\n  Err(0) => elems[0] - x,\\n  ```\\n* when the result is `Err(elems.len())` all of the `elems` are less than `x`, so last of them is the best\\n  ```rust\\n  Err(m) if m == elems.len() => x - *elems.last().unwrap(),\\n  ```\\n* finally, when the result is somewhere in the middle we take, element before and after found index, and choose the best difference\\n  ```rust\\n   Err(i) => (elems[i] - x).min(x - elems[i - 1]),\\n  ```\\n----\\n# 3. The solution\\n```rust \\npub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {\\n    let (left, right) = nums.split_at(nums.len() / 2);\\n    let mut lsums = sums(left);\\n    let rsums = sums(right);\\n    lsums.sort();    rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n\\n    rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n}\\n```\\n\\nFirst, we split our vec to couple of roughly equal subarrays\\n```rust\\n\\t  let (left, right) = nums.split_at(nums.len() / 2);\\n```\\n\\nFind all possible sums in every half, and sort the left result\\n```rust\\n    let mut lsums = sums(left);\\n    let rsums = sums(right);\\n    lsums.sort();\\n```\\n\\nFinally for each sum in the right half we\\'ll find the best sum in the left half, and search for the minimum of those\\n```rust\\n    rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n```\\n----\\n# 4.Complexity analysis\\nFunction `sums` returns the vector of size 2^n in the worst case, and pefrorms the same amount of primitive operatins modulo constant, but since we call it on the array of size 2 ^ (ceil(n / 2)), it\\'s complexity class is O(2 ^ (n / 2))\\n\\nFunction `best_difference` do `log(n)` operation in the worst case, where n - is the size of elems, since we use a vector of size 2 ^ (n / 2) as its input, its complexity class is O(log(2 ^ (n / 2))) = O(n / 2) = O(n)\\n\\nFinally min_abs_difference calls `sums` twice and then executes `best_difference` for each of  2 ^ (n / 2) elements in the right, so it\\'s complexity is O( 2 * (2 ^ (n / 2)) + 2 ^ (n / 2) * n) = O(n * 2 ^ (n / 2))\\n\\n----\\n# 5. Full solution\\n\\n```rust\\nuse std::collections::HashSet;\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {\\n        let (left, right) = nums.split_at(nums.len() / 2);\\n        let mut lsums = sums(left);\\n        let rsums = sums(right);\\n        lsums.sort();\\n        rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n    }\\n}\\n\\nfn best_difference(elems: &[i32], x: i32) -> i32 {\\n    match elems.binary_search(&x) {\\n        Ok(_) => 0,\\n        Err(0) => elems[0] - x,\\n        Err(m) if m == elems.len() => x - *elems.last().unwrap(),\\n        Err(i) => (elems[i] - x).min(x - elems[i - 1]),\\n    }\\n}\\n\\nfn sums(nums: &[i32]) -> Vec<i32> {\\n    let mut res: HashSet<_> = once(0).collect();\\n    for &e in nums {\\n        let new: Vec<_> = res.iter().map(|&x| x + e).collect();\\n        res.extend(new);\\n    }\\n    res.into_iter().collect()\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nfn sums(nums: &[i32]) -> Vec<i32> {\\n    let mut res: HashSet<_> = once(0).collect();\\n    for &e in nums {\\n        let new: Vec<_> = res.iter().map(|&x| x + e).collect();\\n        res.extend(new);\\n    }\\n    res.into_iter().collect()\\n}\\n```\n```rust\\n    let mut res: HashSet<_> = once(0).collect();\\n```\n```rust\\n        let new: Vec<_> = res.iter().map(|&x| x + e).collect();\\n```\n```rust\\n        res.extend(new);\\n```\n```rust\\n    res.into_iter().collect()\\n```\n```rust\\nfn best_difference(elems: &[i32], x: i32) -> i32 {\\n    match elems.binary_search(&x) {\\n        Ok(_) => 0,\\n        Err(0) => elems[0] - x,\\n        Err(m) if m == elems.len() => x - *elems.last().unwrap(),\\n        Err(i) => (elems[i] - x).min(x - elems[i - 1]),\\n    }\\n}\\n```\n```rust \\nelems.binary_search(&x)\\n ```\n```rust \\n  Ok(_) => 0,\\n  ```\n```rust\\n  Err(0) => elems[0] - x,\\n  ```\n```rust\\n  Err(m) if m == elems.len() => x - *elems.last().unwrap(),\\n  ```\n```rust\\n   Err(i) => (elems[i] - x).min(x - elems[i - 1]),\\n  ```\n```rust \\npub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {\\n    let (left, right) = nums.split_at(nums.len() / 2);\\n    let mut lsums = sums(left);\\n    let rsums = sums(right);\\n    lsums.sort();    rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n\\n    rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n}\\n```\n```rust\\n\\t  let (left, right) = nums.split_at(nums.len() / 2);\\n```\n```rust\\n    let mut lsums = sums(left);\\n    let rsums = sums(right);\\n    lsums.sort();\\n```\n```rust\\n    rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n```\n```rust\\nuse std::collections::HashSet;\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {\\n        let (left, right) = nums.split_at(nums.len() / 2);\\n        let mut lsums = sums(left);\\n        let rsums = sums(right);\\n        lsums.sort();\\n        rsums.into_iter().map(|x| best_difference(&lsums, goal - x)).min().unwrap_or(goal)\\n    }\\n}\\n\\nfn best_difference(elems: &[i32], x: i32) -> i32 {\\n    match elems.binary_search(&x) {\\n        Ok(_) => 0,\\n        Err(0) => elems[0] - x,\\n        Err(m) if m == elems.len() => x - *elems.last().unwrap(),\\n        Err(i) => (elems[i] - x).min(x - elems[i - 1]),\\n    }\\n}\\n\\nfn sums(nums: &[i32]) -> Vec<i32> {\\n    let mut res: HashSet<_> = once(0).collect();\\n    for &e in nums {\\n        let new: Vec<_> = res.iter().map(|&x| x + e).collect();\\n        res.extend(new);\\n    }\\n    res.into_iter().collect()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053905,
                "title": "python-brute-force-pruning-44ms",
                "content": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n        nums.sort(key=lambda x: -abs(x))\\n        neg = [0 for _ in range(n+1)]\\n        pos = [0 for _ in range(n+1)]\\n        for i in range(n-1, -1, -1):\\n            if nums[i] < 0:\\n                neg[i] = neg[i+1] + nums[i]\\n                pos[i] = pos[i+1]\\n            else:\\n                pos[i] = pos[i+1] + nums[i]\\n                neg[i] = neg[i+1]\\n        ans = abs(goal)\\n        s = set([0])\\n        def check(a, b):\\n            if b < goal - ans or goal + ans < a:\\n                return False\\n            return True\\n        for i in range(n):\\n            sl = [x for x in s if check(x+neg[i], x+pos[i])]\\n            if len(sl) == 0:\\n                break\\n            s = set(sl)\\n            for x in sl:\\n                y = x + nums[i]\\n                if abs(y - goal) < ans:\\n                    ans = abs(y - goal)\\n                if ans == 0:\\n                    return 0\\n                s.add(y)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n        nums.sort(key=lambda x: -abs(x))\\n        neg = [0 for _ in range(n+1)]\\n        pos = [0 for _ in range(n+1)]\\n        for i in range(n-1, -1, -1):\\n            if nums[i] < 0:\\n                neg[i] = neg[i+1] + nums[i]\\n                pos[i] = pos[i+1]\\n            else:\\n                pos[i] = pos[i+1] + nums[i]\\n                neg[i] = neg[i+1]\\n        ans = abs(goal)\\n        s = set([0])\\n        def check(a, b):\\n            if b < goal - ans or goal + ans < a:\\n                return False\\n            return True\\n        for i in range(n):\\n            sl = [x for x in s if check(x+neg[i], x+pos[i])]\\n            if len(sl) == 0:\\n                break\\n            s = set(sl)\\n            for x in sl:\\n                y = x + nums[i]\\n                if abs(y - goal) < ans:\\n                    ans = abs(y - goal)\\n                if ans == 0:\\n                    return 0\\n                s.add(y)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335146,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS And Binary Search***\\n\\n* ***Time Complexity :- O((2 ^ N) *  log(2 ^ N))***\\n\\n* ***Space Complexity :- O(2 ^ N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the sum of all possible subsequence \\n    \\n    void helper(vector<int>& nums, int i, int n, int sum, vector<int>& arr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            arr.push_back(sum);\\n            \\n            return;\\n        }\\n        \\n        // inclusion part\\n        \\n        helper(nums, i + 1, n, sum + nums[i], arr);\\n        \\n        // exclusion part\\n        \\n        helper(nums, i + 1, n, sum, arr);\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        int n = nums.size();\\n        \\n        // divide the nums array into two parts\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < n / 2)\\n            {\\n                arr1.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                arr2.push_back(nums[i]);\\n            }\\n        }\\n        \\n        // sum1 will store the sum of all the possible subsequence of first half array\\n        \\n        vector<int> sum1;\\n        \\n        // sum2 will store the sum of all the possible subsequence of second half array\\n        \\n        vector<int> sum2;\\n        \\n        // generate the sum of all possible subsequence\\n        \\n        helper(arr1, 0, arr1.size(), 0, sum1);\\n        \\n        helper(arr2, 0, arr2.size(), 0, sum2);\\n        \\n        // sort the sum2 array, so that we can apply binary search\\n        \\n        sort(sum2.begin(), sum2.end());\\n        \\n        int min_diff = INT_MAX;\\n        \\n        // for each sum in sum1, find the sum in sum2 close to goal\\n        \\n        for(int i = 0; i < sum1.size(); i++)\\n        {\\n            // apply binary search on sum2 array\\n            \\n            int low = 0;\\n            \\n            int high = sum2.size() - 1;\\n            \\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                \\n                int sum = sum1[i] + sum2[mid];\\n                \\n                // in this case we can\\'t get minimum than 0\\n                \\n                if(sum == goal)\\n                    return 0;\\n                \\n                // update the min_diff\\n                \\n                min_diff = min(min_diff, abs(sum - goal));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// update the low and high pointer accordingly\\n                \\n                if(sum < goal)\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return min_diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the sum of all possible subsequence \\n    \\n    void helper(vector<int>& nums, int i, int n, int sum, vector<int>& arr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            arr.push_back(sum);\\n            \\n            return;\\n        }\\n        \\n        // inclusion part\\n        \\n        helper(nums, i + 1, n, sum + nums[i], arr);\\n        \\n        // exclusion part\\n        \\n        helper(nums, i + 1, n, sum, arr);\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        int n = nums.size();\\n        \\n        // divide the nums array into two parts\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < n / 2)\\n            {\\n                arr1.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                arr2.push_back(nums[i]);\\n            }\\n        }\\n        \\n        // sum1 will store the sum of all the possible subsequence of first half array\\n        \\n        vector<int> sum1;\\n        \\n        // sum2 will store the sum of all the possible subsequence of second half array\\n        \\n        vector<int> sum2;\\n        \\n        // generate the sum of all possible subsequence\\n        \\n        helper(arr1, 0, arr1.size(), 0, sum1);\\n        \\n        helper(arr2, 0, arr2.size(), 0, sum2);\\n        \\n        // sort the sum2 array, so that we can apply binary search\\n        \\n        sort(sum2.begin(), sum2.end());\\n        \\n        int min_diff = INT_MAX;\\n        \\n        // for each sum in sum1, find the sum in sum2 close to goal\\n        \\n        for(int i = 0; i < sum1.size(); i++)\\n        {\\n            // apply binary search on sum2 array\\n            \\n            int low = 0;\\n            \\n            int high = sum2.size() - 1;\\n            \\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                \\n                int sum = sum1[i] + sum2[mid];\\n                \\n                // in this case we can\\'t get minimum than 0\\n                \\n                if(sum == goal)\\n                    return 0;\\n                \\n                // update the min_diff\\n                \\n                min_diff = min(min_diff, abs(sum - goal));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// update the low and high pointer accordingly\\n                \\n                if(sum < goal)\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return min_diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286602,
                "title": "self-explanatory-easy-programme",
                "content": "```\\nclass Solution {\\npublic:\\n     void gen(int i , int end, int sum, vector<int>&nums, vector<int>&temp)\\n     {\\n          if(i==end) \\n          {\\n              temp.push_back(sum);\\n          return ;\\n          }\\n\\t\\t  gen(i+1,end,sum,nums,temp);\\n         gen(i+1,end,sum+nums[i],nums,temp);\\n  }\\n   int minAbsDifference(vector<int>& nums, int goal) {\\n         vector<int>s1,s2;\\n         int n =  nums.size();\\n         gen(0,n/2,0,nums,s1);\\n         gen(n/2,n,0,nums,s2);\\n          int ans = 2e9+10;\\n         for(int el:s1) ans= min(ans,abs(goal-el));// we may have got the answer in the first set\\n         for(int el:s2) ans= min(ans,abs(goal-el));// we may have got the answer in 2nd set\\n         int lo = 0;  // apply 2 pointers to have all subset combinations if we get futher more reduced values update answer\\n        sort(s1.begin(),s1.end()),sort(s2.begin(),s2.end());\\n         int hi = s2.size()-1;\\n         while(lo<s1.size() and hi>=0)\\n         {\\n             ans = min(ans,abs(goal-s1[lo]-s2[hi]));\\n              if(ans==0) return 0; // ans  == goal found\\n              if(s1[lo]+s2[hi]>goal)hi--;\\n              else lo++;\\n         }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void gen(int i , int end, int sum, vector<int>&nums, vector<int>&temp)\\n     {\\n          if(i==end) \\n          {\\n              temp.push_back(sum);\\n          return ;\\n          }\\n\\t\\t  gen(i+1,end,sum,nums,temp);\\n         gen(i+1,end,sum+nums[i],nums,temp);\\n  }\\n   int minAbsDifference(vector<int>& nums, int goal) {\\n         vector<int>s1,s2;\\n         int n =  nums.size();\\n         gen(0,n/2,0,nums,s1);\\n         gen(n/2,n,0,nums,s2);\\n          int ans = 2e9+10;\\n         for(int el:s1) ans= min(ans,abs(goal-el));// we may have got the answer in the first set\\n         for(int el:s2) ans= min(ans,abs(goal-el));// we may have got the answer in 2nd set\\n         int lo = 0;  // apply 2 pointers to have all subset combinations if we get futher more reduced values update answer\\n        sort(s1.begin(),s1.end()),sort(s2.begin(),s2.end());\\n         int hi = s2.size()-1;\\n         while(lo<s1.size() and hi>=0)\\n         {\\n             ans = min(ans,abs(goal-s1[lo]-s2[hi]));\\n              if(ans==0) return 0; // ans  == goal found\\n              if(s1[lo]+s2[hi]>goal)hi--;\\n              else lo++;\\n         }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404445,
                "title": "bitmasking-binary-search-easy-c-solution",
                "content": "Since max array size is 40,so we divide array in two parts and store value of sum of subsequences in (res 1/2) array using bitmasking .Now for each value in subsequence sum array of first part,we use binary search to find its lower bound in the subsequence sum array of other part and calculate minimum difference.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> get_array(vector<int>&a)\\n    {\\n        int n = a.size();\\n        int m = 1<<n;\\n        vector<long long>dp(m);\\n        for(int i = 0;i<m;i++)\\n        {\\n            long long ans = 0;\\n            for(int j = 0;j<=20;j++)\\n                if(i & (1<<j))\\n                    ans+=a[j];\\n            dp[i] = ans;\\n        }\\n        return dp;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size(),ans = INT_MAX;\\n        vector<int>a,b;\\n        for(int i = 0;i<n/2;i++)\\n            a.push_back(nums[i]);\\n        for(int i = n/2;i<n;i++)\\n            b.push_back(nums[i]);\\n        vector<long long>res1 = get_array(a);\\n        vector<long long>res2 = get_array(b);\\n        sort(res2.begin(),res2.end());\\n        for(int i = 0;i<res1.size();i++)\\n        {\\n            auto it = std::lower_bound(res2.begin(),res2.end(),goal - res1[i]);\\n            if(it!=res2.end())\\n            {\\n                ans = min(ans,int(abs(goal - (res1[i] + (*it)))));\\n            }\\n            if(it!=res2.begin())\\n          {\\n              it--;\\n              ans = min(ans,int(abs(goal - (res1[i] + (*it)))));\\n\\n          }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> get_array(vector<int>&a)\\n    {\\n        int n = a.size();\\n        int m = 1<<n;\\n        vector<long long>dp(m);\\n        for(int i = 0;i<m;i++)\\n        {\\n            long long ans = 0;\\n            for(int j = 0;j<=20;j++)\\n                if(i & (1<<j))\\n                    ans+=a[j];\\n            dp[i] = ans;\\n        }\\n        return dp;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size(),ans = INT_MAX;\\n        vector<int>a,b;\\n        for(int i = 0;i<n/2;i++)\\n            a.push_back(nums[i]);\\n        for(int i = n/2;i<n;i++)\\n            b.push_back(nums[i]);\\n        vector<long long>res1 = get_array(a);\\n        vector<long long>res2 = get_array(b);\\n        sort(res2.begin(),res2.end());\\n        for(int i = 0;i<res1.size();i++)\\n        {\\n            auto it = std::lower_bound(res2.begin(),res2.end(),goal - res1[i]);\\n            if(it!=res2.end())\\n            {\\n                ans = min(ans,int(abs(goal - (res1[i] + (*it)))));\\n            }\\n            if(it!=res2.begin())\\n          {\\n              it--;\\n              ans = min(ans,int(abs(goal - (res1[i] + (*it)))));\\n\\n          }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054477,
                "title": "python-3-brute-force-pruning-with-explanation",
                "content": "Basic idea, go through each number and enumerate all possible summations.\\nThree tricks:\\n1. in each round, use a set to store all possible summation, so that replications will not be calculated in latter round.\\n2. In each round, calculate the current closest number and its difference to goal. Use the difference to prune. If a summation in the set is larger than the goal, we check whether adding latter negative numbers make the summation smaller than goal + difference. If a summation is smaller than the goal, we check whethe adding the latter positive numbers can make the summation larger than goal - difference.\\n3. Sort number in descending order of abs.  So, the suffix sum of positive number and the suffix sum of negative number become smaller quickly. We might remove more number of the set. \\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # potential result\\n        cache = {0}\\n        # first consider large positive number and small negtive number\\n        nums.sort(key = lambda x: -abs(x))\\n        n = len(nums)\\n        # suffix sum for positive number\\n        pos = [0] * (n+1)\\n        # suffix sum for negtive number\\n        neg = [0] * (n+1)\\n        for i in range(n-1, -1, -1):\\n            if nums[i] < 0:\\n                neg[i] = neg[i+1] + nums[i]\\n                pos[i] = pos[i+1]\\n            else:\\n                pos[i] = pos[i+1] + nums[i]\\n                neg[i] = neg[i+1]\\n        \\n        for idx, val in enumerate(nums):\\n            newcache = set(i + val for i in cache)\\n            newcache |= cache\\n            # currently smallest difference: used to prune\\n            rst = min(abs(i - goal) for i in newcache)\\n            cache = set()\\n            for num in newcache:\\n                if num == goal: return 0\\n                elif num < goal: \\n                    # check whether a number smaller than goal can exceed lower bound\\n                    if num + pos[idx] >= goal - rst:\\n                        cache.add(num)\\n                else:\\n                    # check whether a number larger than goal can be reduced through adding latter negtive number\\n                    if num + neg[idx] <= goal + rst:\\n                        cache.add(num)\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # potential result\\n        cache = {0}\\n        # first consider large positive number and small negtive number\\n        nums.sort(key = lambda x: -abs(x))\\n        n = len(nums)\\n        # suffix sum for positive number\\n        pos = [0] * (n+1)\\n        # suffix sum for negtive number\\n        neg = [0] * (n+1)\\n        for i in range(n-1, -1, -1):\\n            if nums[i] < 0:\\n                neg[i] = neg[i+1] + nums[i]\\n                pos[i] = pos[i+1]\\n            else:\\n                pos[i] = pos[i+1] + nums[i]\\n                neg[i] = neg[i+1]\\n        \\n        for idx, val in enumerate(nums):\\n            newcache = set(i + val for i in cache)\\n            newcache |= cache\\n            # currently smallest difference: used to prune\\n            rst = min(abs(i - goal) for i in newcache)\\n            cache = set()\\n            for num in newcache:\\n                if num == goal: return 0\\n                elif num < goal: \\n                    # check whether a number smaller than goal can exceed lower bound\\n                    if num + pos[idx] >= goal - rst:\\n                        cache.add(num)\\n                else:\\n                    # check whether a number larger than goal can be reduced through adding latter negtive number\\n                    if num + neg[idx] <= goal + rst:\\n                        cache.add(num)\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053884,
                "title": "java-meet-in-the-middle-clean-code",
                "content": "* Divide the arrary into 2 parts, and for each part, compute all the possibilities into Set\\n* Add the first Set into a TreeSet, and with the values in the second Set, search out the lower and higher answers\\n* Add 0 to the set to simplify code\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        Set<Integer> set = sums(nums, 0, n/2);\\n        \\n        TreeSet<Integer> tree = new TreeSet<>(set);\\n        \\n        set = sums(nums, n/2, n);\\n        \\n        int ans = Math.abs(-goal);\\n        for (int x : set) {\\n            int y = goal - x;\\n            Integer v = tree.ceiling(y);\\n            if (v != null)\\n                ans = Math.min(ans, v - y);\\n            v = tree.floor(y);\\n            if (v != null)\\n                ans = Math.min(ans, y - v);\\n        }\\n        return ans;\\n    }\\n    \\n    Set<Integer> sums(int[] nums, int l, int r) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        for (int i = l; i < r; i++) {\\n            Set<Integer> tmp = new HashSet<>(set);\\n            for (int x : set)\\n                tmp.add(x + nums[i]);\\n            set = tmp;\\n        }\\n        return set;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        Set<Integer> set = sums(nums, 0, n/2);\\n        \\n        TreeSet<Integer> tree = new TreeSet<>(set);\\n        \\n        set = sums(nums, n/2, n);\\n        \\n        int ans = Math.abs(-goal);\\n        for (int x : set) {\\n            int y = goal - x;\\n            Integer v = tree.ceiling(y);\\n            if (v != null)\\n                ans = Math.min(ans, v - y);\\n            v = tree.floor(y);\\n            if (v != null)\\n                ans = Math.min(ans, y - v);\\n        }\\n        return ans;\\n    }\\n    \\n    Set<Integer> sums(int[] nums, int l, int r) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        for (int i = l; i < r; i++) {\\n            Set<Integer> tmp = new HashSet<>(set);\\n            for (int x : set)\\n                tmp.add(x + nums[i]);\\n            set = tmp;\\n        }\\n        return set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053804,
                "title": "java-two-parts-dfs-and-binary-search",
                "content": "\\n- We can break the nums into **two parts** for DFS, and array `q` stores all the possible sums of subsequence from the first part\\n- Then, we need to find the most appropriate sum in second half of the `nums`\\n- Sort the array `q` (since we need to find the `q[upper_bound] + second` & `q[lower_bound] + second`), find the minimum closest gap to `goal` .\\n- Thus we need to use binary search.\\n```java\\nclass Solution {\\n    public int N = 2000010;\\n    public int[] q = new int[N]; \\n    public int n, cnt, goal, ans;\\n    public int minAbsDifference(int[] nums, int _goal) {\\n        n = nums.length;\\n        goal = _goal;\\n        cnt = 0;\\n        ans = Integer.MAX_VALUE;\\n        dfs1(nums, 0, 0);\\n        Arrays.sort(q, 0, cnt);\\n        dfs2(nums, (n + 1) / 2, 0);\\n        return ans;\\n    }\\n    public void dfs1(int[] nums, int u, int s) {\\n        if (u == (n + 1) / 2) {\\n            q[cnt ++] = s;\\n            return;\\n        }\\n        dfs1(nums, u + 1, s);\\n        dfs1(nums, u + 1, s + nums[u]);\\n    }\\n    public void dfs2(int[] nums, int u, int s) {\\n        if (u == n) {\\n            // binary search\\n            int l = 0, r = cnt - 1;\\n            while (l < r) {\\n                int mid = l + r + 1 >> 1;\\n                if (q[mid] + s <= goal)\\n                    l = mid;\\n                else\\n                    r = mid - 1;\\n            }\\n            ans = Math.min(ans, Math.abs(q[r] + s - goal));\\n            // case 2\\n            if (r + 1 < cnt)\\n                ans = Math.min(ans, Math.abs(q[r + 1] + s - goal));\\n            return;\\n        }\\n        dfs2(nums, u + 1, s);\\n        dfs2(nums, u + 1, s + nums[u]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int N = 2000010;\\n    public int[] q = new int[N]; \\n    public int n, cnt, goal, ans;\\n    public int minAbsDifference(int[] nums, int _goal) {\\n        n = nums.length;\\n        goal = _goal;\\n        cnt = 0;\\n        ans = Integer.MAX_VALUE;\\n        dfs1(nums, 0, 0);\\n        Arrays.sort(q, 0, cnt);\\n        dfs2(nums, (n + 1) / 2, 0);\\n        return ans;\\n    }\\n    public void dfs1(int[] nums, int u, int s) {\\n        if (u == (n + 1) / 2) {\\n            q[cnt ++] = s;\\n            return;\\n        }\\n        dfs1(nums, u + 1, s);\\n        dfs1(nums, u + 1, s + nums[u]);\\n    }\\n    public void dfs2(int[] nums, int u, int s) {\\n        if (u == n) {\\n            // binary search\\n            int l = 0, r = cnt - 1;\\n            while (l < r) {\\n                int mid = l + r + 1 >> 1;\\n                if (q[mid] + s <= goal)\\n                    l = mid;\\n                else\\n                    r = mid - 1;\\n            }\\n            ans = Math.min(ans, Math.abs(q[r] + s - goal));\\n            // case 2\\n            if (r + 1 < cnt)\\n                ans = Math.min(ans, Math.abs(q[r + 1] + s - goal));\\n            return;\\n        }\\n        dfs2(nums, u + 1, s);\\n        dfs2(nums, u + 1, s + nums[u]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053663,
                "title": "java-smart-brute-force",
                "content": "```java\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        \\tint n = nums.length;\\n\\t\\t\\tint half = n/2;\\n\\t\\t\\tint[] left = new int[1<<half];\\n\\t\\t\\tfor(int i = 1; i < 1<<half; i++){\\n\\t\\t\\t\\tleft[i] += left[i&i-1] + nums[Integer.numberOfTrailingZeros(i)];\\n\\t\\t\\t}\\n\\t\\t\\tArrays.sort(left);\\n\\t\\t\\tint[] right = new int[1<<n-half];\\n\\t\\t\\tfor(int i = 1;i < 1<<n-half;i++){\\n\\t\\t\\t\\tright[i] += right[i&i-1] + nums[half + Integer.numberOfTrailingZeros(i)];\\n\\t\\t\\t}\\n\\t\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\t\\tfor(int v : right){\\n\\t\\t\\t\\tint i = Arrays.binarySearch(left, goal-v);\\n\\t\\t\\t\\tif(i >= 0)\\n                    return 0;\\n                i = -(i + 1);\\n\\t\\t\\t\\tif(i < left.length)\\n                    ans = Math.min(ans, Math.abs(left[i] + v - goal));\\n\\t\\t\\t\\tif(i - 1 >= 0)\\n                    ans = Math.min(ans, Math.abs(left[i-1] + v - goal));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n}\\n```\\n\\n\\n`i&i-1`  converts the least significant 1 to 0. so if `i` in binary is like `111000`, then `111000 & 110111 = 110000` \\nBecause we already calculated `left[b110000]`, we can get `left[b111000]` by  `left[b110000] + nums[3]`\\n\\n\\nExample:\\nif `n = nums.length = 5`\\n`half = 2`\\n`1 << half = 1 << 2 = b100`. we use Array `left` to store all posible sums of numers within the first half of `nums`.\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        \\tint n = nums.length;\\n\\t\\t\\tint half = n/2;\\n\\t\\t\\tint[] left = new int[1<<half];\\n\\t\\t\\tfor(int i = 1; i < 1<<half; i++){\\n\\t\\t\\t\\tleft[i] += left[i&i-1] + nums[Integer.numberOfTrailingZeros(i)];\\n\\t\\t\\t}\\n\\t\\t\\tArrays.sort(left);\\n\\t\\t\\tint[] right = new int[1<<n-half];\\n\\t\\t\\tfor(int i = 1;i < 1<<n-half;i++){\\n\\t\\t\\t\\tright[i] += right[i&i-1] + nums[half + Integer.numberOfTrailingZeros(i)];\\n\\t\\t\\t}\\n\\t\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\t\\tfor(int v : right){\\n\\t\\t\\t\\tint i = Arrays.binarySearch(left, goal-v);\\n\\t\\t\\t\\tif(i >= 0)\\n                    return 0;\\n                i = -(i + 1);\\n\\t\\t\\t\\tif(i < left.length)\\n                    ans = Math.min(ans, Math.abs(left[i] + v - goal));\\n\\t\\t\\t\\tif(i - 1 >= 0)\\n                    ans = Math.min(ans, Math.abs(left[i-1] + v - goal));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696364,
                "title": "meet-in-the-middle-easy-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nintuition is simple..meet in the middle as n=40..total subseq will be 2^40 but if we split the array into 2 i.e n=20 each we can perform the operation easily\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://www.youtube.com/watch?v=JUFHwaZjO_M&t=1633s\\nwatch this for apporach \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nyeah its a bit confusing but see i will try my best to explain\\n\\nwe are cheacking for all 2^n/2 values in a 2^n/2 array and we are using binary search so log(2^n/2) === roughly n\\n\\nthereform total time complexity= O((2^n/2 )*n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nwhats the max size of our auxilary array its O(2^n/2) right which is req space complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        vector<int > v1,v2;\\n        vector<int > vec;\\n        int n1=n/2,n2=n-n/2;\\n        for(int i =0;i<n/2;i++){\\n            v1.push_back(nums[i]);\\n        }\\n         for(int i =n/2;i<n;i++){\\n            v2.push_back(nums[i]);\\n        }\\n\\n        for(int i =0;i<(1<<n1);i++){\\n            int x=0,y=0,st=i;\\n            while(st>0){\\n                if(st&1) x+=v1[y];\\n                y++;st>>=1;\\n                \\n            }\\n            vec.push_back(x);\\n        }\\n        // for(auto val : vec) cout<<val<<endl;\\n        sort(vec.begin(),vec.end());\\n        int ans =INT_MAX;\\n\\n        for(int i =0;i<(1<<n2);i++){\\n            int x=0,y=0,st=i;\\n            while(st){\\n                if(st&1) x+=v2[y];\\n                y++;st>>=1;\\n                \\n            }\\n            int cur = goal-x;\\n            int idx= lower_bound(vec.begin(),vec.end(),cur)-vec.begin();\\n            if(idx!=vec.size())ans =min(ans , abs(cur-vec[idx]));\\n            if(idx>0) ans =min(ans , abs(cur-vec[idx-1]));\\n           \\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        vector<int > v1,v2;\\n        vector<int > vec;\\n        int n1=n/2,n2=n-n/2;\\n        for(int i =0;i<n/2;i++){\\n            v1.push_back(nums[i]);\\n        }\\n         for(int i =n/2;i<n;i++){\\n            v2.push_back(nums[i]);\\n        }\\n\\n        for(int i =0;i<(1<<n1);i++){\\n            int x=0,y=0,st=i;\\n            while(st>0){\\n                if(st&1) x+=v1[y];\\n                y++;st>>=1;\\n                \\n            }\\n            vec.push_back(x);\\n        }\\n        // for(auto val : vec) cout<<val<<endl;\\n        sort(vec.begin(),vec.end());\\n        int ans =INT_MAX;\\n\\n        for(int i =0;i<(1<<n2);i++){\\n            int x=0,y=0,st=i;\\n            while(st){\\n                if(st&1) x+=v2[y];\\n                y++;st>>=1;\\n                \\n            }\\n            int cur = goal-x;\\n            int idx= lower_bound(vec.begin(),vec.end(),cur)-vec.begin();\\n            if(idx!=vec.size())ans =min(ans , abs(cur-vec[idx]));\\n            if(idx>0) ans =min(ans , abs(cur-vec[idx-1]));\\n           \\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3678058,
                "title": "python-meet-in-the-middle-82-73",
                "content": "**Python: 82.73%**\\n\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        def elegant_get_subset_sums(nums):\\n            ans = {0}\\n            for x in nums: \\n                ans |= {x + y for y in ans}\\n            return ans \\n        \\n        # for n = 3 {000,001,010,011,..,111} = 2^3\\n\\t\\t## This is giving TLE... TC ~= O(n*2^n)\\n        def get_subset_sums(nums):\\n            n, subset_sums = len(nums), set()\\n            \\n            limit = (1 << n)    # 2^n\\n            for mask in range(limit):\\n                # if that bit is set in mask, add it to sub-set sum\\n                s = sum([nums[idx] for idx in range(0,n) if mask & (1 << idx)])\\n                \\n                subset_sums.add(s)\\n                \\n            return subset_sums\\n        \\n\\t\\t# TC = O(2^n)\\n        def get_sums(nums):\\n            n = len(nums)\\n            sums = set()\\n            \\n            def dfs(i, cur_sum):\\n                if i == n:\\n                    sums.add(cur_sum)\\n                    return\\n                \\n                dfs(i+1, cur_sum)   # skip\\n                dfs(i+1, cur_sum + nums[i]) # pick\\n                \\n            dfs(0, 0)\\n            return sums\\n        \\n        # half side sum\\n        half_part = len(nums)//2\\n        \\n        left_sub_sums = get_sums(nums[:half_part])      # elegant_get_subset_sums()\\n        right_sub_sums = sorted(get_sums(nums[half_part:]))\\n        \\n        right_n = len(right_sub_sums)\\n        \\n        ans = math.inf\\n        for num in left_sub_sums:\\n            remaining_sum = (goal - num)\\n            idx = bisect.bisect_left(right_sub_sums, remaining_sum)\\n            \\n            if idx < right_n:\\n                ans = min(ans, abs(remaining_sum - right_sub_sums[idx]))\\n            # check for the prev as well if that can give us minimal\\n            if idx > 0:\\n                ans = min(ans, abs(remaining_sum - right_sub_sums[idx-1]))\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        def elegant_get_subset_sums(nums):\\n            ans = {0}\\n            for x in nums: \\n                ans |= {x + y for y in ans}\\n            return ans \\n        \\n        # for n = 3 {000,001,010,011,..,111} = 2^3\\n\\t\\t## This is giving TLE... TC ~= O(n*2^n)\\n        def get_subset_sums(nums):\\n            n, subset_sums = len(nums), set()\\n            \\n            limit = (1 << n)    # 2^n\\n            for mask in range(limit):\\n                # if that bit is set in mask, add it to sub-set sum\\n                s = sum([nums[idx] for idx in range(0,n) if mask & (1 << idx)])\\n                \\n                subset_sums.add(s)\\n                \\n            return subset_sums\\n        \\n\\t\\t# TC = O(2^n)\\n        def get_sums(nums):\\n            n = len(nums)\\n            sums = set()\\n            \\n            def dfs(i, cur_sum):\\n                if i == n:\\n                    sums.add(cur_sum)\\n                    return\\n                \\n                dfs(i+1, cur_sum)   # skip\\n                dfs(i+1, cur_sum + nums[i]) # pick\\n                \\n            dfs(0, 0)\\n            return sums\\n        \\n        # half side sum\\n        half_part = len(nums)//2\\n        \\n        left_sub_sums = get_sums(nums[:half_part])      # elegant_get_subset_sums()\\n        right_sub_sums = sorted(get_sums(nums[half_part:]))\\n        \\n        right_n = len(right_sub_sums)\\n        \\n        ans = math.inf\\n        for num in left_sub_sums:\\n            remaining_sum = (goal - num)\\n            idx = bisect.bisect_left(right_sub_sums, remaining_sum)\\n            \\n            if idx < right_n:\\n                ans = min(ans, abs(remaining_sum - right_sub_sums[idx]))\\n            # check for the prev as well if that can give us minimal\\n            if idx > 0:\\n                ans = min(ans, abs(remaining_sum - right_sub_sums[idx-1]))\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692712,
                "title": "c-dfs-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&arr , int idx , int limit , int total , vector<int>&sums)\\n    {\\n        if(idx == limit)\\n        {\\n            sums.push_back(total) ; \\n            return ; \\n        }\\n        solve(arr , idx+1 , limit , total , sums) ; \\n        solve(arr , idx+1 , limit , total + arr[idx] , sums) ;\\n    }\\n    \\n    void search(vector<int>&left , vector<int>&right , int &ans , int target)\\n    {\\n        int l = 0 ; \\n        int r = right.size()-1 ; \\n        while(l < left.size() && r >= 0)\\n        {\\n            int ss = left[l] + right[r] ; \\n            ans = min(ans , abs(target - ss)) ; \\n            if(ss < target) l++ ; \\n            else if(ss > target) r-- ; \\n            else break ; \\n        }\\n    }\\n    int minAbsDifference(vector<int>& arr, int target) {\\n        int n = arr.size() ; \\n        int ans = INT_MAX ; \\n        vector<int>left , right ; \\n        solve(arr , 0 , n/2+1 , 0 , left) ; \\n        solve(arr , n/2+1 , n , 0 , right) ; \\n        \\n        for(int i = 0 ; i<left.size() ; i++)\\n        {\\n            ans = min(ans , abs(target - left[i])) ; \\n        }\\n        for(int i = 0 ; i < right.size() ; i++)\\n        {\\n            ans = min(ans , abs(target - right[i])) ; \\n        }\\n        \\n        sort(left.begin() , left.end()) ;\\n        sort(right.begin() , right.end()) ; \\n        search(left , right , ans , target) ; \\n        return ans ; \\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&arr , int idx , int limit , int total , vector<int>&sums)\\n    {\\n        if(idx == limit)\\n        {\\n            sums.push_back(total) ; \\n            return ; \\n        }\\n        solve(arr , idx+1 , limit , total , sums) ; \\n        solve(arr , idx+1 , limit , total + arr[idx] , sums) ;\\n    }\\n    \\n    void search(vector<int>&left , vector<int>&right , int &ans , int target)\\n    {\\n        int l = 0 ; \\n        int r = right.size()-1 ; \\n        while(l < left.size() && r >= 0)\\n        {\\n            int ss = left[l] + right[r] ; \\n            ans = min(ans , abs(target - ss)) ; \\n            if(ss < target) l++ ; \\n            else if(ss > target) r-- ; \\n            else break ; \\n        }\\n    }\\n    int minAbsDifference(vector<int>& arr, int target) {\\n        int n = arr.size() ; \\n        int ans = INT_MAX ; \\n        vector<int>left , right ; \\n        solve(arr , 0 , n/2+1 , 0 , left) ; \\n        solve(arr , n/2+1 , n , 0 , right) ; \\n        \\n        for(int i = 0 ; i<left.size() ; i++)\\n        {\\n            ans = min(ans , abs(target - left[i])) ; \\n        }\\n        for(int i = 0 ; i < right.size() ; i++)\\n        {\\n            ans = min(ans , abs(target - right[i])) ; \\n        }\\n        \\n        sort(left.begin() , left.end()) ;\\n        sort(right.begin() , right.end()) ; \\n        search(left , right , ans , target) ; \\n        return ans ; \\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340943,
                "title": "faster-easy-meet-in-the-middle-binary-search",
                "content": "The naive solution is to check all possible subsequences. This works in O(2^n).\\n\\nDivide the array into two parts of nearly is equal size.\\n\\nConsider all subsets of one part and make a list of all possible subset sums and sort this list.\\n\\nConsider all subsets of the other part, and for each one, let its sum = x, do binary search to get the nearest possible value to goal - x in the first part.\\n\\n\\n``\\nclass Solution {\\npublic:\\n    \\n    \\n    void solve(int i, int sum, vector<int>&nums, vector<int>&sums){\\n        if(i==nums.size()) {\\n            sums.push_back(sum);\\n            return;\\n        }\\n        \\n        solve(i+1,sum,nums,sums);\\n        solve(i+1,sum+nums[i],nums,sums);\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> num1;\\n        vector<int> num2;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i<n/2) num1.push_back(nums[i]);\\n            else num2.push_back(nums[i]);\\n        }\\n        \\n        vector<int> sum1;\\n        vector<int> sum2;\\n    \\n        solve(0,0,num1,sum1);\\n        solve(0,0,num2,sum2);\\n        \\n        int min_diff=INT_MAX;\\n        \\n        \\n        sort(sum2.begin(),sum2.end());\\n        \\n//         for(auto i:sum1) cout<<i<<\" \";cout<<endl;\\n//         for(auto i:sum2) cout<<i<<\" \";cout<<endl;\\n        \\n        for(auto i: sum1){\\n            int st=0,en=sum2.size()-1;\\n            while(st<=en){\\n                int mid = (st+en)/2;\\n                int sum = i+sum2[mid];\\n                if(sum==goal) return 0;\\n                // cout<<sum<<endl;\\n                min_diff = min(min_diff,abs(sum-goal));\\n                \\n                if(sum<goal){\\n                    st=mid+1;\\n                }\\n                else{\\n                    en = mid-1;\\n                }\\n            }\\n            // cout<<min_diff<<endl;\\n        }\\n        return min_diff;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    void solve(int i, int sum, vector<int>&nums, vector<int>&sums){\\n        if(i==nums.size()) {\\n            sums.push_back(sum);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1935503,
                "title": "easiest-way-to-think-two-pointer-solution",
                "content": "Total no of subsets 2^40 can give space limit exceed so I broke the vector in two parts then just generate all the subsets and after getting all the subset sums I\\'ve sorted both the set1 and set2 vector then uses simple 2 pointer to do...\\n```\\nclass Solution {\\npublic:\\n    void gen(int i,int sum,int n,vector<int> &v,vector<int> &temp){\\n        if(i==n){\\n            temp.push_back(sum);\\n            return ;\\n        }\\n        gen(i+1,sum,n,v,temp);\\n        gen(i+1,sum+v[i],n,v,temp);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> set1,set2;\\n        int n=nums.size();\\n        gen(0,0,n/2,nums,set1);\\n        gen(n/2,0,n,nums,set2);\\n        int ans=2e9;\\n        for(int &el: set1) ans=min(ans,abs(goal-el));\\n        for(int &el: set2) ans=min(ans,abs(goal-el));\\n        int lo=0,hi=set2.size()-1;\\n        sort(set1.begin(),set1.end()),sort(set2.begin(),set2.end());\\n        while(lo < set1.size() and hi>=0){\\n            int sum=set1[lo]+set2[hi];\\n            ans=min(ans,abs(goal-sum));\\n            if(ans==0)\\n                return 0;\\n            if(sum > goal) --hi;\\n            else ++lo;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gen(int i,int sum,int n,vector<int> &v,vector<int> &temp){\\n        if(i==n){\\n            temp.push_back(sum);\\n            return ;\\n        }\\n        gen(i+1,sum,n,v,temp);\\n        gen(i+1,sum+v[i],n,v,temp);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> set1,set2;\\n        int n=nums.size();\\n        gen(0,0,n/2,nums,set1);\\n        gen(n/2,0,n,nums,set2);\\n        int ans=2e9;\\n        for(int &el: set1) ans=min(ans,abs(goal-el));\\n        for(int &el: set2) ans=min(ans,abs(goal-el));\\n        int lo=0,hi=set2.size()-1;\\n        sort(set1.begin(),set1.end()),sort(set2.begin(),set2.end());\\n        while(lo < set1.size() and hi>=0){\\n            int sum=set1[lo]+set2[hi];\\n            ans=min(ans,abs(goal-sum));\\n            if(ans==0)\\n                return 0;\\n            if(sum > goal) --hi;\\n            else ++lo;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223995,
                "title": "java-solution-with-complexity-explanation",
                "content": "we can do this problem by creating all subsets and finding the sum but that takes lot complexity of O(N * 2^N)=>40 * 2^40 => 40 * 10^12 => 10^13 => 10^5 sec which is huge time so what we do is, we use meet in middle algoritm i.e we divide it into 2 arrays find subsets of both which is O(N/2 * 2^N/2) each and the we sort the second one try to find the goal/closest goal by BS complexity is like O(N/2 * 2^N/2 + N/2 * 2^N/2 + N/2 * 2^N/2 * log2^N/2 + log2^N/2) appox 10^8 so executed in les than 1 sec\\n```\\n\\nclass Solution {\\n    \\n    private void createSet(int[] set,int[] a,int n1){\\n        int sum,ind=0,n = a.length;\\n        for(int i=0;i<n1;i++){\\n            sum = 0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))>0)\\n                    sum+=a[j];\\n            }\\n            set[ind++] = sum;\\n        }\\n    }\\n    public int minAbsDifference(int[] a, int goal) {\\n        int n = a.length;\\n        int[] set1 = new int[1<<n/2];\\n        int[] set2 = new int[1<<(n-n/2)];\\n        //O(N/2*2^N/2)\\n        createSet(set1,Arrays.copyOfRange(a,0,n/2),1<<n/2);\\n        //O(N/2*2^N/2)\\n        createSet(set2,Arrays.copyOfRange(a,n/2,n),1<<(n-n/2));\\n        //O(2^N/2 * log2^N/2) => N/2*2^N/2\\n        Arrays.sort(set2);\\n        int sum=0,min = Integer.MAX_VALUE;\\n        for(int i:set1){    \\n            //log2^N/2 => N/2\\n            int posi = Arrays.binarySearch(set2, goal-i);\\n           if(posi>=0)\\n               return 0;\\n           int pos= -1*(posi+1);\\n           int low = pos-1;\\n           if(low>=0)\\n           min=Math.min(min, Math.abs(i+set2[low]-goal));\\n           if(low!=set2.length-1)\\n           min=Math.min(min, Math.abs(i+set2[pos] - goal));\\n        }  \\n    return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    private void createSet(int[] set,int[] a,int n1){\\n        int sum,ind=0,n = a.length;\\n        for(int i=0;i<n1;i++){\\n            sum = 0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))>0)\\n                    sum+=a[j];\\n            }\\n            set[ind++] = sum;\\n        }\\n    }\\n    public int minAbsDifference(int[] a, int goal) {\\n        int n = a.length;\\n        int[] set1 = new int[1<<n/2];\\n        int[] set2 = new int[1<<(n-n/2)];\\n        //O(N/2*2^N/2)\\n        createSet(set1,Arrays.copyOfRange(a,0,n/2),1<<n/2);\\n        //O(N/2*2^N/2)\\n        createSet(set2,Arrays.copyOfRange(a,n/2,n),1<<(n-n/2));\\n        //O(2^N/2 * log2^N/2) => N/2*2^N/2\\n        Arrays.sort(set2);\\n        int sum=0,min = Integer.MAX_VALUE;\\n        for(int i:set1){    \\n            //log2^N/2 => N/2\\n            int posi = Arrays.binarySearch(set2, goal-i);\\n           if(posi>=0)\\n               return 0;\\n           int pos= -1*(posi+1);\\n           int low = pos-1;\\n           if(low>=0)\\n           min=Math.min(min, Math.abs(i+set2[low]-goal));\\n           if(low!=set2.length-1)\\n           min=Math.min(min, Math.abs(i+set2[pos] - goal));\\n        }  \\n    return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058633,
                "title": "c-sliders-instead-of-binary-search-speed-99",
                "content": "As the hints indicate, we can make it in a few steps:\\n\\n1. Divide the input array into two groups with similar sizes (N/2).\\n2. Compute a super sum array of size (2^N/2) for each group of input.\\n3. Sort the two super sum arrays.\\n4. For each element in the first super sum array, run a binary search in second super sum array and find out the closest sum to goal.\\n\\nThere are a few optimizations here we can make:\\n\\na. Step 2 and 3 can be done simultaneously by a merge sort.\\nb. When running the merge sort, duplicate element can be removed to save time and space.\\nc. Instead of running a binary search, it\\'s ok to run two sliders on two super sum arrays with opposite directions. This way, time complexity of step 4 can be reduced from O(2^N/2 log(2^N/2)) to O(2^(N/2))\\n\\n```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        const int size = nums.size();\\n        if (size <= 1)\\n        {\\n            return abs(size == 0 ? goal : goal - nums[0]);\\n        }\\n\\n        const vector<int> sum1 = allSumsSorted(nums, 0, size / 2);\\n        const vector<int> sum2 = allSumsSorted(nums, size / 2, size);\\n        int min_diff = INT_MAX;\\n        int j = sum2.size() - 1;\\n        for (int v1 : sum1)\\n        {\\n            while (j > 0 && v1 + sum2[j - 1] > goal)\\n            {\\n                -- j;\\n            }\\n            int diff = abs(v1 + sum2[j] - goal);\\n            if (diff < min_diff)\\n            {\\n                if (diff == 0)\\n                {\\n                    return 0;\\n                }\\n                min_diff = diff;\\n            }\\n            if (j > 0)\\n            {\\n                diff = abs(v1 + sum2[j - 1] - goal);\\n                if (diff < min_diff)\\n                {\\n                    if (diff == 0)\\n                    {\\n                        return 0;\\n                    }\\n                    min_diff = diff;\\n                }\\n            }\\n            if (v1 + sum2[0] > goal)\\n            {\\n                break;\\n            }\\n        }\\n        return min_diff;\\n    }\\n\\nprotected:\\n    vector<int> allSumsSorted(const vector<int> &nums, int start, int end)\\n    {\\n        if (end == start)\\n        {\\n            return vector<int> { 0 };\\n        }\\n\\n        const vector<int> answer1 = allSumsSorted(nums, start, end - 1);\\n        const int last = nums[end - 1];\\n        if (last == 0)\\n        {\\n            return answer1;\\n        }\\n\\n        vector<int> answer2(answer1);\\n        for (int &a : answer2)\\n        {\\n            a += last;\\n        }\\n        const int size = answer1.size();\\n\\n        vector<int> answer(size * 2);\\n        int i = 0;\\n        int j = 0;\\n        int k = 0;\\n        while (i < size)\\n        {\\n            int diff = answer1[i] - answer2[j];\\n            if (diff == 0)\\n            {\\n                ++ i;\\n            }\\n            else if (diff < 0)\\n            {\\n                answer[k ++] = answer1[i ++];\\n            }\\n            else\\n            {\\n                answer[k ++] = answer2[j ++];\\n                if (j >= size)\\n                {\\n                    while (i < size)\\n                    {\\n                        answer[k ++] = answer1[i ++];\\n                    }\\n                    answer.resize(k);\\n                    return answer;\\n                }\\n            }\\n        }\\n        while (j < size)\\n        {\\n            answer[k ++] = answer2[j ++];\\n        }\\n        answer.resize(k);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        const int size = nums.size();\\n        if (size <= 1)\\n        {\\n            return abs(size == 0 ? goal : goal - nums[0]);\\n        }\\n\\n        const vector<int> sum1 = allSumsSorted(nums, 0, size / 2);\\n        const vector<int> sum2 = allSumsSorted(nums, size / 2, size);\\n        int min_diff = INT_MAX;\\n        int j = sum2.size() - 1;\\n        for (int v1 : sum1)\\n        {\\n            while (j > 0 && v1 + sum2[j - 1] > goal)\\n            {\\n                -- j;\\n            }\\n            int diff = abs(v1 + sum2[j] - goal);\\n            if (diff < min_diff)\\n            {\\n                if (diff == 0)\\n                {\\n                    return 0;\\n                }\\n                min_diff = diff;\\n            }\\n            if (j > 0)\\n            {\\n                diff = abs(v1 + sum2[j - 1] - goal);\\n                if (diff < min_diff)\\n                {\\n                    if (diff == 0)\\n                    {\\n                        return 0;\\n                    }\\n                    min_diff = diff;\\n                }\\n            }\\n            if (v1 + sum2[0] > goal)\\n            {\\n                break;\\n            }\\n        }\\n        return min_diff;\\n    }\\n\\nprotected:\\n    vector<int> allSumsSorted(const vector<int> &nums, int start, int end)\\n    {\\n        if (end == start)\\n        {\\n            return vector<int> { 0 };\\n        }\\n\\n        const vector<int> answer1 = allSumsSorted(nums, start, end - 1);\\n        const int last = nums[end - 1];\\n        if (last == 0)\\n        {\\n            return answer1;\\n        }\\n\\n        vector<int> answer2(answer1);\\n        for (int &a : answer2)\\n        {\\n            a += last;\\n        }\\n        const int size = answer1.size();\\n\\n        vector<int> answer(size * 2);\\n        int i = 0;\\n        int j = 0;\\n        int k = 0;\\n        while (i < size)\\n        {\\n            int diff = answer1[i] - answer2[j];\\n            if (diff == 0)\\n            {\\n                ++ i;\\n            }\\n            else if (diff < 0)\\n            {\\n                answer[k ++] = answer1[i ++];\\n            }\\n            else\\n            {\\n                answer[k ++] = answer2[j ++];\\n                if (j >= size)\\n                {\\n                    while (i < size)\\n                    {\\n                        answer[k ++] = answer1[i ++];\\n                    }\\n                    answer.resize(k);\\n                    return answer;\\n                }\\n            }\\n        }\\n        while (j < size)\\n        {\\n            answer[k ++] = answer2[j ++];\\n        }\\n        answer.resize(k);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055245,
                "title": "golang-go-meet-in-the-middle-with-unit-tests",
                "content": "```\\nfunc minAbsDifference(nums []int, goal int) int {\\n\\thalf := len(nums) / 2\\n\\t// Split nums array in two halves\\n\\ta, b := nums[0:half], nums[half:]\\n\\t// Use hash like a set to remove duplicates\\n\\tasums, bsums := make(map[int]bool), make(map[int]bool)\\n\\n\\t// Generate up to 2^n possible unique sums given n elements in arr\\n\\tvar dfs func(i int, arr []int, sums map[int]bool, cur int)\\n\\tdfs = func(i int, arr []int, sums map[int]bool, cur int) {\\n\\t\\tif i == len(arr) {\\n\\t\\t\\tsums[cur] = true\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tdfs(i+1, arr, sums, cur)\\n\\t\\tdfs(i+1, arr, sums, cur+arr[i])\\n\\t}\\n\\n\\tdfs(0, a, asums, 0)\\n\\tdfs(0, b, bsums, 0)\\n\\tarr, brr := Flatten(asums), Flatten(bsums)\\n\\t// Sort brr so we can bisect in it later\\n\\tsort.Ints(brr)\\n\\tres := math.MaxInt32\\n\\t// For each x in arr, search for y in brr so x + y is closest to goal\\n\\tfor _, x := range arr {\\n\\t\\ty := goal - x\\n\\t\\ti := sort.SearchInts(brr, y)\\n\\t\\t// If y is greater than the max in brr, i would be equal to len(brr).\\n\\t\\t// We must have the follow-up if i > 0 clause to handle this case.\\n\\t\\tif i < len(brr) {\\n\\t\\t\\tres = MinInt(res, AbsInt(y-brr[i]))\\n\\t\\t}\\n\\t\\tif i > 0 {\\n\\t\\t\\tres = MinInt(res, AbsInt(y-brr[i-1]))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc AbsInt(x int) int {\\n\\tif x >= 0 {\\n\\t\\treturn x\\n\\t}\\n\\treturn -x\\n}\\n\\nfunc MinInt(x int, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\n// Collect keys in the hash and put them in an array\\nfunc Flatten(hash map[int]bool) []int {\\n\\tkeys := make([]int, len(hash))\\n\\ti := 0\\n\\tfor k := range hash {\\n\\t\\tkeys[i] = k\\n\\t\\ti++\\n\\t}\\n\\treturn keys\\n}\\n\\nvar dataItems = []struct {\\n\\tinput  []int\\n\\tgoal   int\\n\\tresult int\\n}{\\n\\t{[]int{5, -7, 3, 5}, 6, 0},\\n\\t{[]int{7, -9, 15, -2}, -5, 1},\\n\\t{[]int{1, 2, 3}, -7, 7},\\n}\\n\\nfunc Test1755(t *testing.T) {\\n\\tfor _, item := range dataItems {\\n\\t\\tresult := minAbsDifference(item.input, item.goal)\\n\\t\\tif item.result == result {\\n\\t\\t\\tt.Log(\"PASSED\")\\n\\t\\t} else {\\n\\t\\t\\tt.Errorf(\"FAILED, expected %v but got %v\", item.result, result)\\n\\t\\t}\\n\\t}\\n}\\n",
                "solutionTags": [],
                "code": "```\\nfunc minAbsDifference(nums []int, goal int) int {\\n\\thalf := len(nums) / 2\\n\\t// Split nums array in two halves\\n\\ta, b := nums[0:half], nums[half:]\\n\\t// Use hash like a set to remove duplicates\\n\\tasums, bsums := make(map[int]bool), make(map[int]bool)\\n\\n\\t// Generate up to 2^n possible unique sums given n elements in arr\\n\\tvar dfs func(i int, arr []int, sums map[int]bool, cur int)\\n\\tdfs = func(i int, arr []int, sums map[int]bool, cur int) {\\n\\t\\tif i == len(arr) {\\n\\t\\t\\tsums[cur] = true\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tdfs(i+1, arr, sums, cur)\\n\\t\\tdfs(i+1, arr, sums, cur+arr[i])\\n\\t}\\n\\n\\tdfs(0, a, asums, 0)\\n\\tdfs(0, b, bsums, 0)\\n\\tarr, brr := Flatten(asums), Flatten(bsums)\\n\\t// Sort brr so we can bisect in it later\\n\\tsort.Ints(brr)\\n\\tres := math.MaxInt32\\n\\t// For each x in arr, search for y in brr so x + y is closest to goal\\n\\tfor _, x := range arr {\\n\\t\\ty := goal - x\\n\\t\\ti := sort.SearchInts(brr, y)\\n\\t\\t// If y is greater than the max in brr, i would be equal to len(brr).\\n\\t\\t// We must have the follow-up if i > 0 clause to handle this case.\\n\\t\\tif i < len(brr) {\\n\\t\\t\\tres = MinInt(res, AbsInt(y-brr[i]))\\n\\t\\t}\\n\\t\\tif i > 0 {\\n\\t\\t\\tres = MinInt(res, AbsInt(y-brr[i-1]))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc AbsInt(x int) int {\\n\\tif x >= 0 {\\n\\t\\treturn x\\n\\t}\\n\\treturn -x\\n}\\n\\nfunc MinInt(x int, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\n// Collect keys in the hash and put them in an array\\nfunc Flatten(hash map[int]bool) []int {\\n\\tkeys := make([]int, len(hash))\\n\\ti := 0\\n\\tfor k := range hash {\\n\\t\\tkeys[i] = k\\n\\t\\ti++\\n\\t}\\n\\treturn keys\\n}\\n\\nvar dataItems = []struct {\\n\\tinput  []int\\n\\tgoal   int\\n\\tresult int\\n}{\\n\\t{[]int{5, -7, 3, 5}, 6, 0},\\n\\t{[]int{7, -9, 15, -2}, -5, 1},\\n\\t{[]int{1, 2, 3}, -7, 7},\\n}\\n\\nfunc Test1755(t *testing.T) {\\n\\tfor _, item := range dataItems {\\n\\t\\tresult := minAbsDifference(item.input, item.goal)\\n\\t\\tif item.result == result {\\n\\t\\t\\tt.Log(\"PASSED\")\\n\\t\\t} else {\\n\\t\\t\\tt.Errorf(\"FAILED, expected %v but got %v\", item.result, result)\\n\\t\\t}\\n\\t}\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1054847,
                "title": "ruby-meet-in-the-middle",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} goal\\n# @return {Integer}\\ndef min_abs_difference(nums, goal)\\n  # Get up to 2^n possible sums given n elements in arr\\n  def dfs(i, arr, sums, cur)\\n    if i == arr.length\\n      sums << cur\\n      return\\n    end\\n    dfs(i + 1, arr, sums, cur)\\n    dfs(i + 1, arr, sums, cur + arr[i])\\n  end\\n\\n  # Half nums into two arrays\\n  half = nums.length / 2\\n  a, b = nums[0, half], nums[half, half+1]  # We need +1 if there are odd # of elements\\n  asums, bsums = Set.new, Set.new\\n  dfs(0, a, asums, 0)\\n  dfs(0, b, bsums, 0)\\n  arr, brr = asums.to_a, bsums.to_a\\n  # Sort brr so we can bisect in it later\\n  brr.sort!\\n  res = Float::INFINITY\\n  # For each x in arr, search for y in brr so x + y is closest to goal\\n  arr.each do |x|\\n    y = goal - x\\n    i = brr.bsearch_index {|z| z >= y}\\n    i = brr.length - 1 if i.nil?  # In Python this would be i == len(brr)\\n    res = [res, (y - brr[i]).abs].min\\n    res = [res, (y - brr[i - 1]).abs].min if i > 0\\n  end\\n  res\\nend",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} goal\\n# @return {Integer}\\ndef min_abs_difference(nums, goal)\\n  # Get up to 2^n possible sums given n elements in arr\\n  def dfs(i, arr, sums, cur)\\n    if i == arr.length\\n      sums << cur\\n      return\\n    end\\n    dfs(i + 1, arr, sums, cur)\\n    dfs(i + 1, arr, sums, cur + arr[i])\\n  end\\n\\n  # Half nums into two arrays\\n  half = nums.length / 2\\n  a, b = nums[0, half], nums[half, half+1]  # We need +1 if there are odd # of elements\\n  asums, bsums = Set.new, Set.new\\n  dfs(0, a, asums, 0)\\n  dfs(0, b, bsums, 0)\\n  arr, brr = asums.to_a, bsums.to_a\\n  # Sort brr so we can bisect in it later\\n  brr.sort!\\n  res = Float::INFINITY\\n  # For each x in arr, search for y in brr so x + y is closest to goal\\n  arr.each do |x|\\n    y = goal - x\\n    i = brr.bsearch_index {|z| z >= y}\\n    i = brr.length - 1 if i.nil?  # In Python this would be i == len(brr)\\n    res = [res, (y - brr[i]).abs].min\\n    res = [res, (y - brr[i - 1]).abs].min if i > 0\\n  end\\n  res\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 1054802,
                "title": "java-concise-java-solution-using-treeset-less-than-20-lines",
                "content": "```java\\n    public int minAbsDifference(int[] nums, int goal) {\\n        Set<Integer> m1 = new HashSet<>();\\n        TreeSet<Integer> m2 = new TreeSet<>();\\n        dfs(Arrays.copyOfRange(nums,0, nums.length/2),0,0, m1);\\n        dfs(Arrays.copyOfRange(nums, nums.length/2, nums.length),0,0, m2);\\n        int res = Integer.MAX_VALUE;\\n        for (int x: m1) {\\n            int y = goal - x;\\n            Integer larger = m2.ceiling(y);\\n            Integer smaller =  m2.floor(y);\\n            if (larger!=null) res = Math.min(res, larger - y);\\n            if (smaller!=null) res = Math.min(res, y - smaller);\\n        }\\n        return res;\\n    }\\n\\n    private void dfs(int[] nums, int pos, int curS, Set<Integer> memo) {\\n        if (pos == nums.length) {\\n            memo.add(curS);\\n            return;\\n        }\\n        dfs(nums, pos+1, curS+nums[pos], memo);\\n        dfs(nums, pos+1, curS, memo);\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minAbsDifference(int[] nums, int goal) {\\n        Set<Integer> m1 = new HashSet<>();\\n        TreeSet<Integer> m2 = new TreeSet<>();\\n        dfs(Arrays.copyOfRange(nums,0, nums.length/2),0,0, m1);\\n        dfs(Arrays.copyOfRange(nums, nums.length/2, nums.length),0,0, m2);\\n        int res = Integer.MAX_VALUE;\\n        for (int x: m1) {\\n            int y = goal - x;\\n            Integer larger = m2.ceiling(y);\\n            Integer smaller =  m2.floor(y);\\n            if (larger!=null) res = Math.min(res, larger - y);\\n            if (smaller!=null) res = Math.min(res, y - smaller);\\n        }\\n        return res;\\n    }\\n\\n    private void dfs(int[] nums, int pos, int curS, Set<Integer> memo) {\\n        if (pos == nums.length) {\\n            memo.add(curS);\\n            return;\\n        }\\n        dfs(nums, pos+1, curS+nums[pos], memo);\\n        dfs(nums, pos+1, curS, memo);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054580,
                "title": "python-o-n-2-n-2-meet-in-the-middle-and-2-pointers-code-with-comments",
                "content": "```\\nclass Solution:\\n    # generate all possible summation \\n    def helper(self, arr):\\n        n = len(arr)\\n        #we need to keep unique elements\\n\\t\\t#For this array (Say array nums) of size n, we have 2 ^ n subset from it (you must know some math).\\n#For this problem, n is not too large (n <= 20) so that we can utilize bitmask technique.\\n#Mask is an 32-bit integer, if i-th bit of this mask is on, it means our subset contains i-th element of nums.\\n#All mask values are in the range between 0b000...0000 (n 0\\'s)  and 0b111...1111 (n 1\\'s), so it means all masks are in the range of [0, (1 << n) - 1]\\n        ans = {0}  # initially, answer array contains 0 because of Empty subset\\n        for mask in range(1, 1 << n):\\n            ss = 0\\n            for i, val in enumerate(arr):\\n                if (1 << i) & mask:  # using bitmask to check whether subset contains the i-th element of arr or not\\n                    ss += val\\n            ans.add(ss)\\n        return list(ans)\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n      #  random.shuffle(nums)\\n        n_2 = n // 2\\n        s1, s2 = self.helper(nums[:n_2]), self.helper(nums[n_2 :])\\n        s1.sort()\\n        s2.sort()\\n        ans = abs(goal)\\n\\n        # 2 pointers to find the answer\\n        i1, i2 = 0, len(s2) - 1\\n        while i1 < len(s1) and i2 >= 0:\\n            cur = s1[i1] + s2[i2]\\n            ans = min(ans, abs(cur - goal))\\n            if cur == goal:\\n                return 0\\n            elif cur > goal:\\n                i2 -= 1\\n            else:\\n                i1 += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    # generate all possible summation \\n    def helper(self, arr):\\n        n = len(arr)\\n        #we need to keep unique elements\\n\\t\\t#For this array (Say array nums) of size n, we have 2 ^ n subset from it (you must know some math).\\n#For this problem, n is not too large (n <= 20) so that we can utilize bitmask technique.\\n#Mask is an 32-bit integer, if i-th bit of this mask is on, it means our subset contains i-th element of nums.\\n#All mask values are in the range between 0b000...0000 (n 0\\'s)  and 0b111...1111 (n 1\\'s), so it means all masks are in the range of [0, (1 << n) - 1]\\n        ans = {0}  # initially, answer array contains 0 because of Empty subset\\n        for mask in range(1, 1 << n):\\n            ss = 0\\n            for i, val in enumerate(arr):\\n                if (1 << i) & mask:  # using bitmask to check whether subset contains the i-th element of arr or not\\n                    ss += val\\n            ans.add(ss)\\n        return list(ans)\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n      #  random.shuffle(nums)\\n        n_2 = n // 2\\n        s1, s2 = self.helper(nums[:n_2]), self.helper(nums[n_2 :])\\n        s1.sort()\\n        s2.sort()\\n        ans = abs(goal)\\n\\n        # 2 pointers to find the answer\\n        i1, i2 = 0, len(s2) - 1\\n        while i1 < len(s1) and i2 >= 0:\\n            cur = s1[i1] + s2[i2]\\n            ans = min(ans, abs(cur - goal))\\n            if cur == goal:\\n                return 0\\n            elif cur > goal:\\n                i2 -= 1\\n            else:\\n                i1 += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054314,
                "title": "javascript-split-in-half-binary-search-100",
                "content": "* Split the array in half to calculate every possible sum each half can create. \\n* For each possible sum1 in the first half, binary search for the sum2 in the second half such that their sum1+sum2 is closest to GOAL\\n* ????\\n* stonks\\n\\n```\\nvar minAbsDifference = function(A, K) {\\n    let set1=new Set(),set2=new Set([-Infinity,Infinity])\\n    //split in two => A1 holds the first half, A2 holds the second half\\n    let A2=[],n=A.length,m\\n    for(let i=0;i<(n>>1);i++)\\n        A2.push(A.pop())\\n    n=A.length,m=A2.length\\n    // calculates ALL possible sums for 1 and 2 and add them to set1,set2 respectively\\n    let calcSum=(Arr,length,set)=>{\\n        for(let mask=0;mask<(1<<length);mask++){\\n            let sum=0\\n            for(let j=0;j<length;j++)\\n                if((1<<j)&mask) \\n                    sum+=Arr[j]\\n            set.add(sum)\\n        }\\n    }\\n    calcSum(A,n,set1),calcSum(A2,m,set2)\\n    set1=Array.from(set1),set2=Array.from(set2).sort((a,b)=>a-b)\\n    let result=Infinity\\n    for(let current of set1){\\n        //Binary search for the element in set2 which, when summed with the \\n        //current element of set1, is the biggest there is that is <= GOAL\\n        let lo=0,hi=set2.length-1\\n        while(lo<=hi){\\n            let mid=(lo+hi)>>1,sum=current+set2[mid]\\n            if(sum<=K)\\n                result=Math.min( Math.abs(sum-K),result),\\n                lo=mid+1\\n            else\\n                hi=mid-1\\n        }\\n        //Binary search for the element in set2 which, when summed with the \\n        //current element of set1, is the smallest there is that is >GOAL\\n        lo=0,hi=set2.length-1\\n        while(lo<=hi){\\n            let mid=(lo+hi)>>1,sum=current+set2[mid]\\n            if(sum<=K)\\n                lo=mid+1\\n            else\\n                result=Math.min( Math.abs(sum-K),result),\\n                hi=mid-1\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minAbsDifference = function(A, K) {\\n    let set1=new Set(),set2=new Set([-Infinity,Infinity])\\n    //split in two => A1 holds the first half, A2 holds the second half\\n    let A2=[],n=A.length,m\\n    for(let i=0;i<(n>>1);i++)\\n        A2.push(A.pop())\\n    n=A.length,m=A2.length\\n    // calculates ALL possible sums for 1 and 2 and add them to set1,set2 respectively\\n    let calcSum=(Arr,length,set)=>{\\n        for(let mask=0;mask<(1<<length);mask++){\\n            let sum=0\\n            for(let j=0;j<length;j++)\\n                if((1<<j)&mask) \\n                    sum+=Arr[j]\\n            set.add(sum)\\n        }\\n    }\\n    calcSum(A,n,set1),calcSum(A2,m,set2)\\n    set1=Array.from(set1),set2=Array.from(set2).sort((a,b)=>a-b)\\n    let result=Infinity\\n    for(let current of set1){\\n        //Binary search for the element in set2 which, when summed with the \\n        //current element of set1, is the biggest there is that is <= GOAL\\n        let lo=0,hi=set2.length-1\\n        while(lo<=hi){\\n            let mid=(lo+hi)>>1,sum=current+set2[mid]\\n            if(sum<=K)\\n                result=Math.min( Math.abs(sum-K),result),\\n                lo=mid+1\\n            else\\n                hi=mid-1\\n        }\\n        //Binary search for the element in set2 which, when summed with the \\n        //current element of set1, is the smallest there is that is >GOAL\\n        lo=0,hi=set2.length-1\\n        while(lo<=hi){\\n            let mid=(lo+hi)>>1,sum=current+set2[mid]\\n            if(sum<=K)\\n                lo=mid+1\\n            else\\n                result=Math.min( Math.abs(sum-K),result),\\n                hi=mid-1\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054036,
                "title": "c-nice-to-meet-you-in-the-middle-two-pointers-o-n-2-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, x, y;\\n    \\n    vector<int> getDistinctValue(vector<int>& nums, int offset, int len) {\\n        vector<int> res;\\n        for (int mask = 0; mask < (1 << len); mask++) {\\n            int sum = 0;\\n            for (int i = 0; i < len; i++) {\\n                if (mask >> i & 1) sum += nums[i + offset];\\n            }\\n            res.push_back(sum);\\n        }      \\n        sort(res.begin(), res.end());\\n        res.erase(unique(res.begin(), res.end()), res.end());\\n        return res;\\n    }\\n        \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        n = nums.size();\\n        vector<int> a = getDistinctValue(nums, 0, n / 2);\\n        vector<int> b = getDistinctValue(nums, n / 2, n - n / 2);\\n        \\n        int ptr = b.size() - 1;\\n        int ans = 2e9 + 10;\\n        \\n        for (int i = 0; i < a.size(); i++) {\\n            while (ptr >= 0 && b[ptr] + a[i] > goal) ptr -= 1;\\n            if (ptr >= 0) ans = min(ans, abs(b[ptr] + a[i] - goal));\\n            if (ptr + 1 < b.size()) ans = min(ans, abs(b[ptr + 1] + a[i] - goal));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, x, y;\\n    \\n    vector<int> getDistinctValue(vector<int>& nums, int offset, int len) {\\n        vector<int> res;\\n        for (int mask = 0; mask < (1 << len); mask++) {\\n            int sum = 0;\\n            for (int i = 0; i < len; i++) {\\n                if (mask >> i & 1) sum += nums[i + offset];\\n            }\\n            res.push_back(sum);\\n        }      \\n        sort(res.begin(), res.end());\\n        res.erase(unique(res.begin(), res.end()), res.end());\\n        return res;\\n    }\\n        \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        n = nums.size();\\n        vector<int> a = getDistinctValue(nums, 0, n / 2);\\n        vector<int> b = getDistinctValue(nums, n / 2, n - n / 2);\\n        \\n        int ptr = b.size() - 1;\\n        int ans = 2e9 + 10;\\n        \\n        for (int i = 0; i < a.size(); i++) {\\n            while (ptr >= 0 && b[ptr] + a[i] > goal) ptr -= 1;\\n            if (ptr >= 0) ans = min(ans, abs(b[ptr] + a[i] - goal));\\n            if (ptr + 1 < b.size()) ans = min(ans, abs(b[ptr + 1] + a[i] - goal));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054021,
                "title": "beginner-friendly-clean-code-meet-in-the-middle-with-sources",
                "content": "\\n```\\nfun minAbsDifference(nums: IntArray, goal: Int): Int {\\n    val n = nums.size\\n    val left = TreeSet(sums(nums, 0, n / 2))\\n    val right = sums(nums, n / 2, n)\\n    var ans = Math.abs(goal)\\n    for (x in right) {\\n        val y = goal - x // hoping to find a value as close to \\'y\\'\\n        val greaterOrEqual = left.ceiling(y) // >= y\\n        if (greaterOrEqual != null)\\n            ans = minOf(ans, greaterOrEqual - y)\\n        val lessOrEqual = left.floor(y) // <= y\\n        if (lessOrEqual != null)\\n            ans = minOf(ans, y - lessOrEqual)\\n    }\\n    return ans\\n}\\n\\nfun sums(A: IntArray, l: Int, r: Int): Set<Int> { // generate all possible sub-seq sums of Array A[l:r]\\n    var ans = HashSet<Int>()\\n    ans.add(0)\\n    for (i in l until r) {\\n        val temp = HashSet(ans)\\n        for (x in ans)\\n            temp.add(x + A[i])\\n        ans = temp\\n    }\\n    ans.remove(0)\\n    return ans\\n}\\n```\\n\\n```\\nExample: [1,2,3,4]\\n5\\n\\nLeft = [1, 2, 3] considering the left half as [1,2]\\nRight = [3, 4, 7] considering the right half as [3,4]\\n\\nAns = 0 \\nsince 1(left) + 4(right) - 5 == 0\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a7dc6995-c41d-46d0-9a9a-6eca2ab84a4b_1612682156.2465937.png)\\nSource1: https://www.baeldung.com/cs/subset-of-numbers-closest-to-target#3-meet-in-the-middle-approach\\nSource2[Video]: https://bit.ly/2YQq5Gv",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun minAbsDifference(nums: IntArray, goal: Int): Int {\\n    val n = nums.size\\n    val left = TreeSet(sums(nums, 0, n / 2))\\n    val right = sums(nums, n / 2, n)\\n    var ans = Math.abs(goal)\\n    for (x in right) {\\n        val y = goal - x // hoping to find a value as close to \\'y\\'\\n        val greaterOrEqual = left.ceiling(y) // >= y\\n        if (greaterOrEqual != null)\\n            ans = minOf(ans, greaterOrEqual - y)\\n        val lessOrEqual = left.floor(y) // <= y\\n        if (lessOrEqual != null)\\n            ans = minOf(ans, y - lessOrEqual)\\n    }\\n    return ans\\n}\\n\\nfun sums(A: IntArray, l: Int, r: Int): Set<Int> { // generate all possible sub-seq sums of Array A[l:r]\\n    var ans = HashSet<Int>()\\n    ans.add(0)\\n    for (i in l until r) {\\n        val temp = HashSet(ans)\\n        for (x in ans)\\n            temp.add(x + A[i])\\n        ans = temp\\n    }\\n    ans.remove(0)\\n    return ans\\n}\\n```\n```\\nExample: [1,2,3,4]\\n5\\n\\nLeft = [1, 2, 3] considering the left half as [1,2]\\nRight = [3, 4, 7] considering the right half as [3,4]\\n\\nAns = 0 \\nsince 1(left) + 4(right) - 5 == 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053900,
                "title": "c-meet-in-the-middle-quite-clean-and-self-understanding-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        vector<int>leftHalf{0};\\n        vector<int>rightHalf{0};\\n        int mid = n/2;\\n        for(int i=0;i<mid;i++){\\n            int sz = leftHalf.size();\\n            for(int j=0;j<sz;j++){\\n                leftHalf.push_back(leftHalf[j]+nums[i]);\\n            }\\n        }\\n        for(int i=mid;i<n;i++){\\n            int sz = rightHalf.size();\\n            for(int j=0;j<sz;j++){\\n                rightHalf.push_back(rightHalf[j]+nums[i]);\\n            }\\n        }\\n        int ans = abs(goal);\\n        sort(leftHalf.begin(),leftHalf.end());\\n        sort(rightHalf.begin(),rightHalf.end());\\n        for(int leftSum:leftHalf){\\n            int desiredRightSum = goal - leftSum;\\n            auto it = upper_bound(rightHalf.begin(),rightHalf.end(),desiredRightSum);\\n            if(it != rightHalf.end()){\\n                ans = min(ans,abs(desiredRightSum-*it));\\n            }\\n            if(it!=rightHalf.begin()){\\n                ans = min(ans,abs(desiredRightSum-*(--it)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        vector<int>leftHalf{0};\\n        vector<int>rightHalf{0};\\n        int mid = n/2;\\n        for(int i=0;i<mid;i++){\\n            int sz = leftHalf.size();\\n            for(int j=0;j<sz;j++){\\n                leftHalf.push_back(leftHalf[j]+nums[i]);\\n            }\\n        }\\n        for(int i=mid;i<n;i++){\\n            int sz = rightHalf.size();\\n            for(int j=0;j<sz;j++){\\n                rightHalf.push_back(rightHalf[j]+nums[i]);\\n            }\\n        }\\n        int ans = abs(goal);\\n        sort(leftHalf.begin(),leftHalf.end());\\n        sort(rightHalf.begin(),rightHalf.end());\\n        for(int leftSum:leftHalf){\\n            int desiredRightSum = goal - leftSum;\\n            auto it = upper_bound(rightHalf.begin(),rightHalf.end(),desiredRightSum);\\n            if(it != rightHalf.end()){\\n                ans = min(ans,abs(desiredRightSum-*it));\\n            }\\n            if(it!=rightHalf.begin()){\\n                ans = min(ans,abs(desiredRightSum-*(--it)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053632,
                "title": "c-meet-in-the-middle-o-n-2-n-2",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> s1;\\n    vector<ll> s2;\\n    void subset1(vector<int>& a, int n , ll sum,int id){\\n        if(id==n){\\n            s1.push_back(sum);\\n            return ;\\n        }    \\n        subset1(a,n,sum,id+1);\\n        subset1(a,n,sum+a[id],id+1);\\n    }\\n    void subset2(vector<int>& a, int n , ll sum,int id){\\n        if(id==n){\\n            s2.push_back(sum);\\n            return ;\\n        }  \\n        subset2(a,n,sum,id+1);\\n        subset2(a,n,sum+a[id],id+1);\\n    }\\n    ll lower(ll tar){\\n        ll s =0 , e = s2.size()-1;\\n        ll ans =0;\\n        while(s<=e){         \\n            ll mid = (s+e)/2;\\n            if(s2[mid]<=tar){\\n                s= mid+1;\\n                ans=mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }  \\n        }\\n        ans = s2[ans];\\n        return ans;\\n    }\\n    \\n    \\n      ll upper(ll tar){\\n        ll s =0 , e = s2.size()-1;\\n        ll ans =e;\\n        while(s<=e){         \\n            ll mid = (s+e)/2;\\n            if(s2[mid]>=tar){\\n                e= mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            } \\n        } \\n        ans = s2[ans];\\n        return ans;\\n    }\\n    int minAbsDifference(vector<int>& a, int k) {\\n        s1.clear();\\n        s2.clear();\\n        int half = a.size()/2;\\n        int n = a.size();\\n        subset1(a,half,0,0);\\n        subset2(a,n,0,half);\\n        sort(s1.begin(),s1.end());\\n        sort(s2.begin(),s2.end());\\n        ll ans =LLONG_MAX;\\n        for(int i=0;i<s1.size();i++){\\n            ll sum1 = s1[i];\\n            ll tar = k-s1[i];\\n            ll p = sum1 +lower(tar);\\n            ll q = sum1 +upper(tar);\\n            ll l = min(abs(p-k),abs(q-k));  \\n            ans = min(ans,l);    \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> s1;\\n    vector<ll> s2;\\n    void subset1(vector<int>& a, int n , ll sum,int id){\\n        if(id==n){\\n            s1.push_back(sum);\\n            return ;\\n        }    \\n        subset1(a,n,sum,id+1);\\n        subset1(a,n,sum+a[id],id+1);\\n    }\\n    void subset2(vector<int>& a, int n , ll sum,int id){\\n        if(id==n){\\n            s2.push_back(sum);\\n            return ;\\n        }  \\n        subset2(a,n,sum,id+1);\\n        subset2(a,n,sum+a[id],id+1);\\n    }\\n    ll lower(ll tar){\\n        ll s =0 , e = s2.size()-1;\\n        ll ans =0;\\n        while(s<=e){         \\n            ll mid = (s+e)/2;\\n            if(s2[mid]<=tar){\\n                s= mid+1;\\n                ans=mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }  \\n        }\\n        ans = s2[ans];\\n        return ans;\\n    }\\n    \\n    \\n      ll upper(ll tar){\\n        ll s =0 , e = s2.size()-1;\\n        ll ans =e;\\n        while(s<=e){         \\n            ll mid = (s+e)/2;\\n            if(s2[mid]>=tar){\\n                e= mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            } \\n        } \\n        ans = s2[ans];\\n        return ans;\\n    }\\n    int minAbsDifference(vector<int>& a, int k) {\\n        s1.clear();\\n        s2.clear();\\n        int half = a.size()/2;\\n        int n = a.size();\\n        subset1(a,half,0,0);\\n        subset2(a,n,0,half);\\n        sort(s1.begin(),s1.end());\\n        sort(s2.begin(),s2.end());\\n        ll ans =LLONG_MAX;\\n        for(int i=0;i<s1.size();i++){\\n            ll sum1 = s1[i];\\n            ll tar = k-s1[i];\\n            ll p = sum1 +lower(tar);\\n            ll q = sum1 +upper(tar);\\n            ll l = min(abs(p-k),abs(q-k));  \\n            ans = min(ans,l);    \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095620,
                "title": "c-meet-in-the-middle",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> left,right;\\n\\n    void generate_left_and_right_subset(int x, vector<int> &nums)\\n    {\\n        int n = x/2;\\n\\n        for(int i = 0;i<(1<<n);i++)\\n        {\\n            int sum = 0;\\n            for(int k = 0;k<n;k++)\\n            {\\n                int mask = 1<<k;\\n\\n                if(mask & i)\\n                {\\n                    sum+=nums[k];\\n                }\\n            }\\n\\n            left.push_back(sum);\\n        }\\n\\n        n = x/2;\\n\\n        int el = x - x/2;\\n\\n        for(int i = 0;i<(1<<el);i++)\\n        {\\n            int sum = 0;\\n            for(int k = 0;k<el;k++)\\n            {\\n                int mask = 1<<k;\\n\\n                if(mask & i)\\n                {\\n                    sum+=nums[k+n];\\n                }\\n            }\\n\\n            right.push_back(sum);\\n        }\\n    }\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        int n = nums.size();\\n\\n        generate_left_and_right_subset(n,nums);\\n\\n        sort(right.begin(),right.end());\\n\\n        int ans = INT_MAX;\\n\\n        for(auto it : left)\\n        {\\n\\n            // find closest of goal - it\\n\\n            int find = goal - it;\\n\\n            auto itr = lower_bound(right.begin(),right.end(),find);\\n\\n            // check it not to point on null\\n\\n            // if element founds its difference will be zero \\n\\n            // if not founds take minimum  of goal-(it+*itr) and goal-(it+*(itr-1))  \\n\\n            if(itr!=right.end()) ans = min(ans,abs(goal-(it+*itr)));\\n\\n            if(itr!=right.begin())\\n            {\\n                itr--;\\n                ans = min(ans,abs(goal-(it+*itr)));\\n            }\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> left,right;\\n\\n    void generate_left_and_right_subset(int x, vector<int> &nums)\\n    {\\n        int n = x/2;\\n\\n        for(int i = 0;i<(1<<n);i++)\\n        {\\n            int sum = 0;\\n            for(int k = 0;k<n;k++)\\n            {\\n                int mask = 1<<k;\\n\\n                if(mask & i)\\n                {\\n                    sum+=nums[k];\\n                }\\n            }\\n\\n            left.push_back(sum);\\n        }\\n\\n        n = x/2;\\n\\n        int el = x - x/2;\\n\\n        for(int i = 0;i<(1<<el);i++)\\n        {\\n            int sum = 0;\\n            for(int k = 0;k<el;k++)\\n            {\\n                int mask = 1<<k;\\n\\n                if(mask & i)\\n                {\\n                    sum+=nums[k+n];\\n                }\\n            }\\n\\n            right.push_back(sum);\\n        }\\n    }\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        int n = nums.size();\\n\\n        generate_left_and_right_subset(n,nums);\\n\\n        sort(right.begin(),right.end());\\n\\n        int ans = INT_MAX;\\n\\n        for(auto it : left)\\n        {\\n\\n            // find closest of goal - it\\n\\n            int find = goal - it;\\n\\n            auto itr = lower_bound(right.begin(),right.end(),find);\\n\\n            // check it not to point on null\\n\\n            // if element founds its difference will be zero \\n\\n            // if not founds take minimum  of goal-(it+*itr) and goal-(it+*(itr-1))  \\n\\n            if(itr!=right.end()) ans = min(ans,abs(goal-(it+*itr)));\\n\\n            if(itr!=right.begin())\\n            {\\n                itr--;\\n                ans = min(ans,abs(goal-(it+*itr)));\\n            }\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056494,
                "title": "fully-optimised-java-code-with-complete-explanation-intuition-and-approach",
                "content": "# Intuition\\nThis approach utilizes the \"meet in the middle\" algorithm to efficiently find the minimum absolute difference between a given goal and the sum of all possible subsets of a given array.\\n\\n# Approach\\n1. We start by generating all possible subset sums for the first and second halves of the input array `nums`.\\n\\n2. We use a recursive function `findAllSubsetSums` to compute the sums of all subsets for a given range of elements. This function populates two ArrayLists, `firstHalf` and `secondHalf`, with the sums of subsets from the first and second halves of the input array, respectively.\\n\\n3. After computing the subset sums, we sort the `firstHalf` ArrayList in ascending order.\\n\\n4. We iterate through the `secondHalf` ArrayList, and for each element `x`, we calculate the difference `diff` between the goal and `x`.\\n\\n5. We perform a binary search in the `firstHalf` ArrayList to find the index `currIndex` such that `firstHalf.get(currIndex)` is the closest sum to `diff` or the first sum greater than `diff`.\\n\\n6. We update the `minPossible` variable with the minimum absolute difference between `diff` and `firstHalf.get(currIndex)` and also consider the element before `currIndex` if it exists.\\n\\n7. Finally, we return the minimum absolute difference stored in `minPossible`.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*2^n)$$\\n  - The `findAllSubsetSums` function generates all possible subsets, resulting in a total of 2^n subsets for an array of size n.\\n  - The binary search operation takes O(log n) time, and we perform it for each element in the second half, resulting in O(n * log n) time.\\n  - The overall time complexity is O(n * 2^n).\\n\\n- Space complexity:  $$O(2^n)$$\\n  - We use two ArrayLists (`firstHalf` and `secondHalf`) to store the sums of subsets for the two halves of the input array.\\n  - The space complexity is dominated by the space required for these subsets.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int minPossible = Integer.MAX_VALUE;\\n    public void findAllSubsetSums(ArrayList<Integer> lst, int start, int end, int sum, int[] nums){\\n\\n        if(start == end) {\\n            lst.add(sum);\\n            return;\\n        }\\n       \\n       findAllSubsetSums(lst, start + 1, end, sum + nums[start], nums);\\n       findAllSubsetSums(lst, start + 1, end, sum, nums);\\n    }\\n\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        ArrayList<Integer> firstHalf = new ArrayList<>();\\n        ArrayList<Integer> secondHalf = new ArrayList<>();\\n\\n\\n        findAllSubsetSums(firstHalf, 0, n / 2, 0, nums);\\n        findAllSubsetSums(secondHalf, n / 2, n, 0, nums);\\n        Collections.sort(firstHalf);\\n\\n        for(int x : secondHalf) {\\n            int diff = goal - x;\\n            int currIndex = binarySearch(diff, firstHalf);\\n            if (currIndex < firstHalf.size()) {\\n                minPossible = Math.min(minPossible, Math.abs(diff - firstHalf.get(currIndex)));\\n            }\\n            if (currIndex > 0) {\\n                minPossible = Math.min(minPossible, Math.abs(diff - firstHalf.get(currIndex - 1)));\\n            }\\n        }\\n\\n        return minPossible;\\n    }\\n\\n    public int binarySearch(int x, List<Integer> lst) {\\n        int low = 0, high = lst.size() - 1;\\n\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (x == lst.get(mid))\\n                return mid;\\n            if (x > lst.get(mid))\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    int minPossible = Integer.MAX_VALUE;\\n    public void findAllSubsetSums(ArrayList<Integer> lst, int start, int end, int sum, int[] nums){\\n\\n        if(start == end) {\\n            lst.add(sum);\\n            return;\\n        }\\n       \\n       findAllSubsetSums(lst, start + 1, end, sum + nums[start], nums);\\n       findAllSubsetSums(lst, start + 1, end, sum, nums);\\n    }\\n\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        ArrayList<Integer> firstHalf = new ArrayList<>();\\n        ArrayList<Integer> secondHalf = new ArrayList<>();\\n\\n\\n        findAllSubsetSums(firstHalf, 0, n / 2, 0, nums);\\n        findAllSubsetSums(secondHalf, n / 2, n, 0, nums);\\n        Collections.sort(firstHalf);\\n\\n        for(int x : secondHalf) {\\n            int diff = goal - x;\\n            int currIndex = binarySearch(diff, firstHalf);\\n            if (currIndex < firstHalf.size()) {\\n                minPossible = Math.min(minPossible, Math.abs(diff - firstHalf.get(currIndex)));\\n            }\\n            if (currIndex > 0) {\\n                minPossible = Math.min(minPossible, Math.abs(diff - firstHalf.get(currIndex - 1)));\\n            }\\n        }\\n\\n        return minPossible;\\n    }\\n\\n    public int binarySearch(int x, List<Integer> lst) {\\n        int low = 0, high = lst.size() - 1;\\n\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (x == lst.get(mid))\\n                return mid;\\n            if (x > lst.get(mid))\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985774,
                "title": "c-vietnam-pro-code",
                "content": "```\\n#include <iostream>\\n#include <vector>\\n#include <algorithm> // For using std::min\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int half = n / 2;\\n        vector<int> first_half_subsets, second_half_subsets;\\n\\n        // Generate all possible subsets of the first half of the array\\n        for (int mask = 0; mask < (1 << half); ++mask) {\\n            int sum = 0;\\n            for (int i = 0; i < half; ++i) {\\n                if ((mask >> i) & 1) {\\n                    sum += nums[i];\\n                }\\n            }\\n            first_half_subsets.push_back(sum);\\n        }\\n\\n        // Generate all possible subsets of the second half of the array\\n        for (int mask = 0; mask < (1 << (n - half)); ++mask) {\\n            int sum = 0;\\n            for (int i = 0; i < n - half; ++i) {\\n                if ((mask >> i) & 1) {\\n                    sum += nums[half + i];\\n                }\\n            }\\n            second_half_subsets.push_back(sum);\\n        }\\n\\n        // Sort the second_half_subsets to perform binary search\\n        sort(second_half_subsets.begin(), second_half_subsets.end());\\n\\n        int ans = abs(goal);\\n\\n        // For each sum in the first_half_subsets, find the closest sum in the second_half_subsets\\n        for (int sum : first_half_subsets) {\\n            int target = goal - sum;\\n            auto it = lower_bound(second_half_subsets.begin(), second_half_subsets.end(), target);\\n            if (it != second_half_subsets.end()) {\\n                ans = min(ans, abs(goal - (sum + *it)));\\n            }\\n            if (it != second_half_subsets.begin()) {\\n                ans = min(ans, abs(goal - (sum + *(--it))));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <algorithm> // For using std::min\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int half = n / 2;\\n        vector<int> first_half_subsets, second_half_subsets;\\n\\n        // Generate all possible subsets of the first half of the array\\n        for (int mask = 0; mask < (1 << half); ++mask) {\\n            int sum = 0;\\n            for (int i = 0; i < half; ++i) {\\n                if ((mask >> i) & 1) {\\n                    sum += nums[i];\\n                }\\n            }\\n            first_half_subsets.push_back(sum);\\n        }\\n\\n        // Generate all possible subsets of the second half of the array\\n        for (int mask = 0; mask < (1 << (n - half)); ++mask) {\\n            int sum = 0;\\n            for (int i = 0; i < n - half; ++i) {\\n                if ((mask >> i) & 1) {\\n                    sum += nums[half + i];\\n                }\\n            }\\n            second_half_subsets.push_back(sum);\\n        }\\n\\n        // Sort the second_half_subsets to perform binary search\\n        sort(second_half_subsets.begin(), second_half_subsets.end());\\n\\n        int ans = abs(goal);\\n\\n        // For each sum in the first_half_subsets, find the closest sum in the second_half_subsets\\n        for (int sum : first_half_subsets) {\\n            int target = goal - sum;\\n            auto it = lower_bound(second_half_subsets.begin(), second_half_subsets.end(), target);\\n            if (it != second_half_subsets.end()) {\\n                ans = min(ans, abs(goal - (sum + *it)));\\n            }\\n            if (it != second_half_subsets.begin()) {\\n                ans = min(ans, abs(goal - (sum + *(--it))));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3968864,
                "title": "meet-in-the-middle-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe basic intuition is of the subset sum problem.\\nbut definitely we wont be able to do that because of n<=40.\\nSo the thought of dividing  the input into half sizes comes to mind. Hence Meet in the middle technique is there.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsolve the subset sum problem for the two different right and left parts of the array. after getting them , we know traverse all the elements of left and right subset sums and try to minimize individually and then we do the merged result using two pointer and sorted from of the two arrays.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n* 2^(n/2))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int start,int end,vector<int>&nums,vector<int>&v,int sum){\\n        if(start==end){\\n            v.push_back(sum);\\n            return;\\n        }\\n        f(start+1,end,nums,v,sum+nums[start]);\\n        f(start+1,end,nums,v,sum);\\n\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int>left,right;\\n        f(0,nums.size()/2+1,nums,left,0);\\n        f(nums.size()/2+1,nums.size(),nums,right,0);\\n        int ans=INT_MAX;\\n        for(auto &it:left){\\n           ans=min(ans,abs(goal-it));\\n        }\\n         for(auto &it:right){\\n           ans=min(ans,abs(goal-it));\\n        }\\n        sort(left.begin(),left.end());\\n        sort(right.begin(),right.end());\\n        int l=0,r=right.size()-1;\\n        while(l<left.size() && r>=0){\\n            int sum=left[l]+right[r];\\n            ans=min(ans,abs(sum-goal));\\n            if(sum>goal){\\n                r--;\\n            }\\n            else if(sum<goal) l++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int start,int end,vector<int>&nums,vector<int>&v,int sum){\\n        if(start==end){\\n            v.push_back(sum);\\n            return;\\n        }\\n        f(start+1,end,nums,v,sum+nums[start]);\\n        f(start+1,end,nums,v,sum);\\n\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int>left,right;\\n        f(0,nums.size()/2+1,nums,left,0);\\n        f(nums.size()/2+1,nums.size(),nums,right,0);\\n        int ans=INT_MAX;\\n        for(auto &it:left){\\n           ans=min(ans,abs(goal-it));\\n        }\\n         for(auto &it:right){\\n           ans=min(ans,abs(goal-it));\\n        }\\n        sort(left.begin(),left.end());\\n        sort(right.begin(),right.end());\\n        int l=0,r=right.size()-1;\\n        while(l<left.size() && r>=0){\\n            int sum=left[l]+right[r];\\n            ans=min(ans,abs(sum-goal));\\n            if(sum>goal){\\n                r--;\\n            }\\n            else if(sum<goal) l++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966070,
                "title": "c-meet-in-the-middle-binary-search",
                "content": "# Intuition\\nWe Split the given array into 2 partitions. Generate subset sums for each partition using recursion. Sort these sums, then for each sum in the first partition, find closest value in the second partition using binary search, to minimize difference from goal.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- ##### Time complexity: *O(n * 2^(n/2))*\\n\\n- ##### Space complexity: *O(2^(N/2))*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findSubsetSums(vector<int> &nums, int idx, int end, int sum, vector<int>&sumv){\\n        if(idx==end){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        findSubsetSums(nums,idx+1,end,sum+nums[idx],sumv);\\n        findSubsetSums(nums,idx+1,end,sum,sumv);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        //Divide the array into two parts\\n        vector<int> partition1(nums.begin(),nums.begin()+(n+1)/2);\\n        vector<int> partition2(nums.begin()+(n+1)/2,nums.end());\\n        \\n        //Find all the subset sums of each partition using recursion\\n        vector<int> a,b;\\n        findSubsetSums(partition1,0,partition1.size(),0,a);\\n        findSubsetSums(partition2,0,partition2.size(),0,b);\\n\\n        //Sorting the subset sums to implement Binary Search\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n\\n        //For each sum in the first partition, find closest value in the second partition using binary search, to minimize difference from goal.\\n        int ans = INT_MAX;\\n        for (int s : a) {\\n            int target = goal - s;\\n            auto it = lower_bound(b.begin(), b.end(), target);\\n            if (it != b.end()) {\\n                ans = min(ans, abs(s + *it - goal));\\n            }\\n            if (it != b.begin()) {\\n                ans = min(ans, abs(s + *(--it) - goal));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSubsetSums(vector<int> &nums, int idx, int end, int sum, vector<int>&sumv){\\n        if(idx==end){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        findSubsetSums(nums,idx+1,end,sum+nums[idx],sumv);\\n        findSubsetSums(nums,idx+1,end,sum,sumv);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        //Divide the array into two parts\\n        vector<int> partition1(nums.begin(),nums.begin()+(n+1)/2);\\n        vector<int> partition2(nums.begin()+(n+1)/2,nums.end());\\n        \\n        //Find all the subset sums of each partition using recursion\\n        vector<int> a,b;\\n        findSubsetSums(partition1,0,partition1.size(),0,a);\\n        findSubsetSums(partition2,0,partition2.size(),0,b);\\n\\n        //Sorting the subset sums to implement Binary Search\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n\\n        //For each sum in the first partition, find closest value in the second partition using binary search, to minimize difference from goal.\\n        int ans = INT_MAX;\\n        for (int s : a) {\\n            int target = goal - s;\\n            auto it = lower_bound(b.begin(), b.end(), target);\\n            if (it != b.end()) {\\n                ans = min(ans, abs(s + *it - goal));\\n            }\\n            if (it != b.begin()) {\\n                ans = min(ans, abs(s + *(--it) - goal));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963037,
                "title": "meet-in-the-middle-algorithm-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void getSubsetSum(int i, int end, int sum, vector<int> &nums, vector<int> &v){\\n        if(i == end){\\n            v.push_back(sum);\\n            return;\\n        }\\n        getSubsetSum(i+1, end, sum + nums[i], nums, v);\\n        getSubsetSum(i+1, end, sum, nums, v);\\n    }\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        if(n==1)\\n            return min(abs(goal), abs(nums[0] - goal));\\n        vector<int> left, right;\\n        getSubsetSum(0, n/2+1, 0, nums, left);\\n        getSubsetSum(n/2+1, n, 0, nums, right);\\n\\n        sort(right.begin(), right.end());\\n        int ans = INT_MAX;\\n        for(int i = 0; i < left.size(); i++){\\n            int index = lower_bound(right.begin(), right.end(), goal - left[i]) - right.begin();\\n            if(index > 0)\\n                ans = min(ans, abs(goal - left[i] - right[index - 1]));\\n            if(index < right.size())\\n                ans = min(ans, abs(goal - left[i] - right[index]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void getSubsetSum(int i, int end, int sum, vector<int> &nums, vector<int> &v){\\n        if(i == end){\\n            v.push_back(sum);\\n            return;\\n        }\\n        getSubsetSum(i+1, end, sum + nums[i], nums, v);\\n        getSubsetSum(i+1, end, sum, nums, v);\\n    }\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        if(n==1)\\n            return min(abs(goal), abs(nums[0] - goal));\\n        vector<int> left, right;\\n        getSubsetSum(0, n/2+1, 0, nums, left);\\n        getSubsetSum(n/2+1, n, 0, nums, right);\\n\\n        sort(right.begin(), right.end());\\n        int ans = INT_MAX;\\n        for(int i = 0; i < left.size(); i++){\\n            int index = lower_bound(right.begin(), right.end(), goal - left[i]) - right.begin();\\n            if(index > 0)\\n                ans = min(ans, abs(goal - left[i] - right[index - 1]));\\n            if(index < right.size())\\n                ans = min(ans, abs(goal - left[i] - right[index]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944488,
                "title": "c-meet-in-the-middle-using-lower-bound",
                "content": "`TC = O(2 ^ n) (from find) + O(n * log(n)) (from sort & lower_bound in loop), where n = N / 2`\\n`SC = O(2 * (2 ^ n)), where n = N / 2 `\\n```\\nclass Solution {\\npublic:\\n    void find(int i, int n, int sum, vector<int> &v, vector<int> &nums) {\\n        if(i == n) {\\n            v.push_back(sum); return;\\n        }\\n        find(i + 1, n, sum + nums[i], v, nums);\\n        find(i + 1, n, sum, v, nums);\\n    }\\n    int minAbsDifference(vector<int> &nums, int goal) {\\n        int n = nums.size();\\n        vector<int> v1, v2;\\n        int m = n / 2;\\n        find(0, m, 0, v1, nums);\\n        find(m, n, 0, v2, nums);\\n        sort(v2.begin(), v2.end());\\n        int ans = INT_MAX;\\n        for(auto ele : v1) {\\n            auto it = lower_bound(v2.begin(), v2.end(), (goal - ele));\\n            // No lower bound found -> last element can give the min dif with ele\\n            if(it == v2.end()) {\\n                ans = min(ans, abs(goal - (ele + *(it - 1))));\\n            } else {\\n                // Lower bound found\\n                ans = min(ans, abs(goal - (ele + *it)));\\n                // If (goal - ele) doesn\\'t exist -> *it will be next greater\\n                // but *(it - 1) can also give min dif with ele\\n                if(it != v2.begin())\\n                    ans = min(ans, abs(goal - (ele + *(it - 1))));\\n            }     \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(int i, int n, int sum, vector<int> &v, vector<int> &nums) {\\n        if(i == n) {\\n            v.push_back(sum); return;\\n        }\\n        find(i + 1, n, sum + nums[i], v, nums);\\n        find(i + 1, n, sum, v, nums);\\n    }\\n    int minAbsDifference(vector<int> &nums, int goal) {\\n        int n = nums.size();\\n        vector<int> v1, v2;\\n        int m = n / 2;\\n        find(0, m, 0, v1, nums);\\n        find(m, n, 0, v2, nums);\\n        sort(v2.begin(), v2.end());\\n        int ans = INT_MAX;\\n        for(auto ele : v1) {\\n            auto it = lower_bound(v2.begin(), v2.end(), (goal - ele));\\n            // No lower bound found -> last element can give the min dif with ele\\n            if(it == v2.end()) {\\n                ans = min(ans, abs(goal - (ele + *(it - 1))));\\n            } else {\\n                // Lower bound found\\n                ans = min(ans, abs(goal - (ele + *it)));\\n                // If (goal - ele) doesn\\'t exist -> *it will be next greater\\n                // but *(it - 1) can also give min dif with ele\\n                if(it != v2.begin())\\n                    ans = min(ans, abs(goal - (ele + *(it - 1))));\\n            }     \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853532,
                "title": "two-pointer-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can use the subset sub to check which is most close to the goal, but doing so would take us 2^n time and n = 40, so the worst case scenario would give TLE\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can partition the array into 2 arbitary array of length n/2, and generate the subset sum for each of the two parts and then calculate using two pointer which is closest to the target sum \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^(n/2)*log(N/2))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2^N/2)\\n\\n# Code\\n```\\n\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    vector<ll> subsetSum(vector<int> &nums,int l,int r){\\n        int n = r - l + 1;\\n        vector<ll> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ll sum = 0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))){\\n                    sum += nums[j+l];\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int N = n/2;\\n        vector<ll> left = subsetSum(nums,0,N-1);\\n        vector<ll> right = subsetSum(nums,N,n-1);\\n        ll ans = INT_MAX;\\n        sort(right.begin(),right.end());\\n        sort(left.begin(),left.end());\\n        for(auto v:left){\\n            \\n            int l =0,r = right.size()-1;\\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                int sum = v + right[mid];\\n                if(sum == goal)return 0;\\n                ans = min(ans,1LL*abs(sum - goal));\\n                if(sum > goal){\\n                    r = mid - 1;\\n                }else{\\n                    l = mid + 1;\\n                }\\n            }\\n            \\n        }\\n\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    vector<ll> subsetSum(vector<int> &nums,int l,int r){\\n        int n = r - l + 1;\\n        vector<ll> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ll sum = 0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))){\\n                    sum += nums[j+l];\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int N = n/2;\\n        vector<ll> left = subsetSum(nums,0,N-1);\\n        vector<ll> right = subsetSum(nums,N,n-1);\\n        ll ans = INT_MAX;\\n        sort(right.begin(),right.end());\\n        sort(left.begin(),left.end());\\n        for(auto v:left){\\n            \\n            int l =0,r = right.size()-1;\\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                int sum = v + right[mid];\\n                if(sum == goal)return 0;\\n                ans = min(ans,1LL*abs(sum - goal));\\n                if(sum > goal){\\n                    r = mid - 1;\\n                }else{\\n                    l = mid + 1;\\n                }\\n            }\\n            \\n        }\\n\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819161,
                "title": "meet-in-the-middle-no-tle-c-binary-search",
                "content": "# Approach\\nUsing Vectors and sorting them is faster than using Sets.\\nIt can be done using sets but it gives TLE.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void f(int ind, int sum,int end, vector<int> &nums, vector <int> &v ){\\n        if(ind == end){\\n            v.push_back(sum);\\n            return;\\n        }\\n\\n        f(ind+1,sum + nums[ind],end,nums,v);\\n        f(ind+1,sum,end,nums,v);\\n    }\\n\\n\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int sum = accumulate(nums.begin(), nums.end(),0);\\n        int n = nums.size();\\n        vector <int> left, right;\\n\\n        f(0,0,n/2,nums,left);\\n        f(n/2,0,n,nums,right);\\n\\n        sort(right.begin(),right.end());\\n\\n        int ans = INT_MAX;\\n        for(auto &l : left){\\n            auto r = lower_bound(right.begin(),right.end(),goal - l);\\n            if(r != right.end()){\\n                ans = min(ans,abs(goal - l - *r));\\n            }\\n\\n            if(r != right.begin()){\\n                auto prev = r;\\n                prev--;\\n                ans = min(ans,abs(goal - l - *prev));\\n            }\\n            \\n            if(ans == 0 )   return ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void f(int ind, int sum,int end, vector<int> &nums, vector <int> &v ){\\n        if(ind == end){\\n            v.push_back(sum);\\n            return;\\n        }\\n\\n        f(ind+1,sum + nums[ind],end,nums,v);\\n        f(ind+1,sum,end,nums,v);\\n    }\\n\\n\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int sum = accumulate(nums.begin(), nums.end(),0);\\n        int n = nums.size();\\n        vector <int> left, right;\\n\\n        f(0,0,n/2,nums,left);\\n        f(n/2,0,n,nums,right);\\n\\n        sort(right.begin(),right.end());\\n\\n        int ans = INT_MAX;\\n        for(auto &l : left){\\n            auto r = lower_bound(right.begin(),right.end(),goal - l);\\n            if(r != right.end()){\\n                ans = min(ans,abs(goal - l - *r));\\n            }\\n\\n            if(r != right.begin()){\\n                auto prev = r;\\n                prev--;\\n                ans = min(ans,abs(goal - l - *prev));\\n            }\\n            \\n            if(ans == 0 )   return ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804740,
                "title": "js-o-n-2-2-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minAbsDifference = function (nums, goal) {\\n  const left = [];\\n  const right = [];\\n  const N = nums.length;\\n  const n = Math.floor(N / 2); // support odd length arrays\\n\\n  const bitmask = (start, n) => {\\n    const arr = [];\\n    for (let i = 0; i < 1 << n; i++) {\\n      let sum = 0;\\n      for (let j = 0; j < n; j++) {\\n        if (i & (1 << j)) {\\n          sum += nums[j + start];\\n        }\\n      }\\n      arr.push(sum);\\n    }\\n    return arr;\\n  };\\n\\n  left.push(...bitmask(0, n)); // left array subset sum\\n  right.push(...bitmask(n, N - n)); // right array sunset sum\\n\\n  right.sort((a, b) => a - b);\\n  let ans = Number.MAX_VALUE;\\n\\n  left.forEach((leftSum) => {\\n    let low = 0;\\n    let high = right.length - 1;\\n    while (low <= high) {\\n      let mid = Math.floor(low + (high - low) / 2);\\n      const val = (leftSum + right[mid]) - goal; // value to be mininised\\n      ans = Math.min(ans, Math.abs(val));\\n      if (ans == 0) {\\n        return ans;\\n      }\\n      if (val > 0) {\\n        high = mid - 1;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n  });\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nvar minAbsDifference = function (nums, goal) {\\n  const left = [];\\n  const right = [];\\n  const N = nums.length;\\n  const n = Math.floor(N / 2); // support odd length arrays\\n\\n  const bitmask = (start, n) => {\\n    const arr = [];\\n    for (let i = 0; i < 1 << n; i++) {\\n      let sum = 0;\\n      for (let j = 0; j < n; j++) {\\n        if (i & (1 << j)) {\\n          sum += nums[j + start];\\n        }\\n      }\\n      arr.push(sum);\\n    }\\n    return arr;\\n  };\\n\\n  left.push(...bitmask(0, n)); // left array subset sum\\n  right.push(...bitmask(n, N - n)); // right array sunset sum\\n\\n  right.sort((a, b) => a - b);\\n  let ans = Number.MAX_VALUE;\\n\\n  left.forEach((leftSum) => {\\n    let low = 0;\\n    let high = right.length - 1;\\n    while (low <= high) {\\n      let mid = Math.floor(low + (high - low) / 2);\\n      const val = (leftSum + right[mid]) - goal; // value to be mininised\\n      ans = Math.min(ans, Math.abs(val));\\n      if (ans == 0) {\\n        return ans;\\n      }\\n      if (val > 0) {\\n        high = mid - 1;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n  });\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787358,
                "title": "meet-in-the-middle-technique-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(2^\\\\frac{n}{2})$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(2^\\\\frac{n}{2})$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        TreeSet<Long> left = new TreeSet<>();\\n        int mid = n / 2;\\n        for(int i = 0;i < (1 << mid);i++){\\n            long sum = 0;\\n            for(int j = 0;j < mid;j++){\\n                if(((i >> j) & 1) == 1){\\n                    sum += nums[j];\\n                }\\n            }\\n            left.add(sum);\\n        }\\n        long ans = Long.MAX_VALUE;\\n        for(int i = 0;i < (1 << (n - mid));i++){\\n            long sum = 0;\\n            for(int j = mid;j < n;j++){\\n                if(((i >> (j - mid)) & 1) == 1){\\n                    sum += nums[j];\\n                }\\n            }\\n            var lb = left.floor(goal - sum);\\n            if(lb != null) ans = Math.min(ans,goal - lb - sum);\\n            var ub = left.ceiling(goal - sum);\\n            if(ub != null) ans = Math.min(ans,ub + sum - goal);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        TreeSet<Long> left = new TreeSet<>();\\n        int mid = n / 2;\\n        for(int i = 0;i < (1 << mid);i++){\\n            long sum = 0;\\n            for(int j = 0;j < mid;j++){\\n                if(((i >> j) & 1) == 1){\\n                    sum += nums[j];\\n                }\\n            }\\n            left.add(sum);\\n        }\\n        long ans = Long.MAX_VALUE;\\n        for(int i = 0;i < (1 << (n - mid));i++){\\n            long sum = 0;\\n            for(int j = mid;j < n;j++){\\n                if(((i >> (j - mid)) & 1) == 1){\\n                    sum += nums[j];\\n                }\\n            }\\n            var lb = left.floor(goal - sum);\\n            if(lb != null) ans = Math.min(ans,goal - lb - sum);\\n            var ub = left.ceiling(goal - sum);\\n            if(ub != null) ans = Math.min(ans,ub + sum - goal);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753484,
                "title": "binary-search-bitmasking-meet-in-middle-c",
                "content": "## Intuition\\n- Since the contraint has n <= 40, finding all the subsequences as such gives TLE.\\n- So we divide the array into 2, find the subsequence sum of both the arrays and store it (In my case arrays s1 and s2), using Bitmask.\\n- Now all we got to do is find the difference of pairs of sum (one from s1 and other from s2) and store the minimum amongst them.\\n- Directly doing the above, i.e iterating through all elements in s2 for each element in s1, gives TLE.\\n- Thus we use Binary Search to effectively find the closest possible element in s2 for each element in s1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void findSubSums(vector<int> &nums, vector<int> &res){\\n        int n = nums.size();\\n        for(int i = 0; i < (1 << n); i++){\\n            int mask = i, sum = 0, y = 0;\\n            while(y < n){\\n                int set = mask & 1;\\n                mask >>= 1;\\n                if(set) sum += nums[y];\\n                y++;\\n            }\\n            res.push_back(sum);\\n        }\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int l = 0, r = goal, n = nums.size();\\n        vector<int> n1(nums.begin(), nums.begin() + (n / 2));\\n        vector<int> n2(nums.begin() + (n/2), nums.end());\\n        vector<int> s1, s2;\\n        findSubSums(n1, s1);\\n        findSubSums(n2, s2);\\n\\n        sort(s2.begin(), s2.end());\\n        int res = INT_MAX;\\n        for(int i: s1){\\n            int l = 0, r = s2.size() - 1;\\n            while(l <= r){\\n                int mid = (l + r) / 2;\\n                res = min(abs(i + s2[mid] - goal), res);\\n                if(i + s2[mid] == goal) return 0;\\n                else if(i + s2[mid] < goal){\\n                    l = mid + 1;\\n                }\\n                else r = mid - 1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSubSums(vector<int> &nums, vector<int> &res){\\n        int n = nums.size();\\n        for(int i = 0; i < (1 << n); i++){\\n            int mask = i, sum = 0, y = 0;\\n            while(y < n){\\n                int set = mask & 1;\\n                mask >>= 1;\\n                if(set) sum += nums[y];\\n                y++;\\n            }\\n            res.push_back(sum);\\n        }\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int l = 0, r = goal, n = nums.size();\\n        vector<int> n1(nums.begin(), nums.begin() + (n / 2));\\n        vector<int> n2(nums.begin() + (n/2), nums.end());\\n        vector<int> s1, s2;\\n        findSubSums(n1, s1);\\n        findSubSums(n2, s2);\\n\\n        sort(s2.begin(), s2.end());\\n        int res = INT_MAX;\\n        for(int i: s1){\\n            int l = 0, r = s2.size() - 1;\\n            while(l <= r){\\n                int mid = (l + r) / 2;\\n                res = min(abs(i + s2[mid] - goal), res);\\n                if(i + s2[mid] == goal) return 0;\\n                else if(i + s2[mid] < goal){\\n                    l = mid + 1;\\n                }\\n                else r = mid - 1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736403,
                "title": "beats-98-meet-in-the-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void check(vector<int>&ans,vector<int>& nums,int goals,int sum,int index,int end){\\n            if(index==end){\\n                ans.push_back(sum);\\n                return;\\n            }\\n\\n          \\n           check(ans ,nums,goals,sum+nums[index],index+1,end);\\n          \\n           check(ans ,nums,goals,sum,index+1,end);\\n\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int l = nums.size();\\n        vector<int>ans1;\\n        vector<int>ans2;\\n      \\n        vector<int>le;\\n       \\n        check(ans1,nums,goal,0,0,l/2);\\n        check(ans2,nums,goal,0,l/2,l);\\n        sort(ans2.begin(),ans2.end());\\n        \\n        int min =INT_MAX;\\n        for(int i =0;i<ans1.size();i++){\\n            int s,e,m;\\n            s=0;\\n            e=ans2.size()-1;\\n           \\n            while(s<=e){\\n                m = e + (s-e)/2;\\n                int sum = ans1[i]+ans2[m];\\n                if(sum==goal){\\n                    return 0;\\n                }\\n                if(min>abs(sum-goal)){\\n                    min = abs(sum-goal);\\n                }\\n                if(sum<goal){\\n                  \\n                   s= m+1;\\n                }\\n                else{\\n               e=m-1;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void check(vector<int>&ans,vector<int>& nums,int goals,int sum,int index,int end){\\n            if(index==end){\\n                ans.push_back(sum);\\n                return;\\n            }\\n\\n          \\n           check(ans ,nums,goals,sum+nums[index],index+1,end);\\n          \\n           check(ans ,nums,goals,sum,index+1,end);\\n\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int l = nums.size();\\n        vector<int>ans1;\\n        vector<int>ans2;\\n      \\n        vector<int>le;\\n       \\n        check(ans1,nums,goal,0,0,l/2);\\n        check(ans2,nums,goal,0,l/2,l);\\n        sort(ans2.begin(),ans2.end());\\n        \\n        int min =INT_MAX;\\n        for(int i =0;i<ans1.size();i++){\\n            int s,e,m;\\n            s=0;\\n            e=ans2.size()-1;\\n           \\n            while(s<=e){\\n                m = e + (s-e)/2;\\n                int sum = ans1[i]+ans2[m];\\n                if(sum==goal){\\n                    return 0;\\n                }\\n                if(min>abs(sum-goal)){\\n                    min = abs(sum-goal);\\n                }\\n                if(sum<goal){\\n                  \\n                   s= m+1;\\n                }\\n                else{\\n               e=m-1;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736224,
                "title": "beats-97-meet-in-the-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void check(vector<int>&ans,vector<int>& nums,int goals,int sum,int index){\\n            if(index==nums.size()){\\n                ans.push_back(sum);\\n                return;\\n            }\\n\\n          \\n           check(ans ,nums,goals,sum+nums[index],index+1);\\n          \\n           check(ans ,nums,goals,sum,index+1);\\n\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int l = nums.size();\\n        vector<int>ans1;\\n        vector<int>ans2;\\n      \\n        vector<int>le;\\n        vector<int>r;\\n        for(int i=0;i<=l/2;i++){\\n            le.push_back(nums[i]);\\n        }\\n        for(int i=(l/2)+1;i<nums.size();i++){\\n            r.push_back(nums[i]);\\n        }\\n        check(ans1,le,goal,0,0);\\n        check(ans2,r,goal,0,0);\\n        sort(ans2.begin(),ans2.end());\\n        \\n        int min =INT_MAX;\\n        for(int i =0;i<ans1.size();i++){\\n            int s,e,m;\\n            s=0;\\n            e=ans2.size()-1;\\n           \\n            while(s<=e){\\n                m = e + (s-e)/2;\\n                int sum = ans1[i]+ans2[m];\\n                if(sum==goal){\\n                    return 0;\\n                }\\n                if(min>abs(sum-goal)){\\n                    min = abs(sum-goal);\\n                }\\n                if(sum<goal){\\n                  \\n                   s= m+1;\\n                }\\n                else{\\n               e=m-1;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void check(vector<int>&ans,vector<int>& nums,int goals,int sum,int index){\\n            if(index==nums.size()){\\n                ans.push_back(sum);\\n                return;\\n            }\\n\\n          \\n           check(ans ,nums,goals,sum+nums[index],index+1);\\n          \\n           check(ans ,nums,goals,sum,index+1);\\n\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int l = nums.size();\\n        vector<int>ans1;\\n        vector<int>ans2;\\n      \\n        vector<int>le;\\n        vector<int>r;\\n        for(int i=0;i<=l/2;i++){\\n            le.push_back(nums[i]);\\n        }\\n        for(int i=(l/2)+1;i<nums.size();i++){\\n            r.push_back(nums[i]);\\n        }\\n        check(ans1,le,goal,0,0);\\n        check(ans2,r,goal,0,0);\\n        sort(ans2.begin(),ans2.end());\\n        \\n        int min =INT_MAX;\\n        for(int i =0;i<ans1.size();i++){\\n            int s,e,m;\\n            s=0;\\n            e=ans2.size()-1;\\n           \\n            while(s<=e){\\n                m = e + (s-e)/2;\\n                int sum = ans1[i]+ans2[m];\\n                if(sum==goal){\\n                    return 0;\\n                }\\n                if(min>abs(sum-goal)){\\n                    min = abs(sum-goal);\\n                }\\n                if(sum<goal){\\n                  \\n                   s= m+1;\\n                }\\n                else{\\n               e=m-1;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725429,
                "title": "java-recursion-memoization-meet-in-the-middle",
                "content": "# Intuition: Recursion (TLE)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int minAbsDiff = Integer.MAX_VALUE;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        recur(0, 0, goal, nums);\\n        return minAbsDiff;\\n    }\\n\\n    public void recur(int index, int currSum, int goal, int[] nums){\\n        if(index == nums.length){\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(currSum - goal));\\n            return;\\n        }\\n\\n        recur(index + 1, currSum + nums[index], goal, nums);\\n        recur(index + 1, currSum, goal, nums);\\n    }\\n}\\n```\\n\\n# Intuition: Memoization (TLE)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        Map<String, Integer> hashMap = new HashMap<>();\\n        return recur(0, 0, goal, nums, hashMap);\\n    }\\n\\n    public int recur(int index, int currSum, int goal, int[] nums, Map<String, Integer> hashMap){\\n        if(index == nums.length){\\n            return Math.abs(currSum - goal);\\n        }\\n\\n        String key = index + \"-\" + currSum;\\n        if(hashMap.containsKey(key)){\\n            return hashMap.get(key);\\n        }\\n\\n        int a = recur(index + 1, currSum + nums[index], goal, nums, hashMap);\\n        int b = recur(index + 1, currSum, goal, nums, hashMap);\\n\\n        hashMap.put(key, Math.min(a, b));\\n        return hashMap.get(key);\\n    }\\n}\\n```\\n\\n\\n# Intuition: Meet In The Middle\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O($$O(2^{n/2}.n)$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int minAbsDiff = Integer.MAX_VALUE;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int numLen = nums.length;\\n        // int minAbsDiff = Integer.MAX_VALUE;\\n        List<Integer> leftList = new ArrayList<>();\\n        List<Integer> rightList = new ArrayList<>();\\n\\n        recur(0, (numLen/2) + 1, 0, leftList, nums);\\n        recur((numLen/2) + 1, numLen, 0, rightList, nums);\\n\\n        // System.out.println(\"left: \");\\n        for(int val : leftList){\\n            // System.out.print(minAbsDiff + \" \" + Math.abs(goal - val) + \" \");\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(goal - val));\\n            // System.out.println(minAbsDiff);\\n        }\\n        \\n        // System.out.println(\"right: \");\\n        for(int val : rightList){\\n            // System.out.print(minAbsDiff + \" \" + Math.abs(goal - val) + \" \");\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(goal - val));\\n            // System.out.println(minAbsDiff);\\n        }\\n\\n        Collections.sort(leftList);\\n        Collections.sort(rightList);\\n\\n        // System.out.println(\"binary: \");\\n        search(leftList, rightList, goal);\\n\\n        return minAbsDiff;\\n    }\\n\\n    public void recur(int index, int limit, int currSum, List<Integer> sum, int[] nums){\\n        if(index == limit){\\n            sum.add(currSum);\\n            return;\\n        }\\n\\n        recur(index + 1, limit,  currSum + nums[index], sum, nums);\\n        recur(index + 1, limit, currSum, sum, nums);\\n    }\\n\\n    public void search(List<Integer> leftList, List<Integer> rightList, int goal){\\n        int left = 0;\\n        int right = rightList.size() - 1;\\n\\n        while(left < leftList.size() && right >= 0){\\n            int combinedSum = leftList.get(left) + rightList.get(right);\\n            // System.out.print(minAbsDiff + \" \" + combinedSum + \" \");\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(goal - combinedSum));\\n            // System.out.println(minAbsDiff);\\n            if(combinedSum < goal){\\n                left++;\\n            } else if (combinedSum > goal){\\n                right--;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int minAbsDiff = Integer.MAX_VALUE;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        recur(0, 0, goal, nums);\\n        return minAbsDiff;\\n    }\\n\\n    public void recur(int index, int currSum, int goal, int[] nums){\\n        if(index == nums.length){\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(currSum - goal));\\n            return;\\n        }\\n\\n        recur(index + 1, currSum + nums[index], goal, nums);\\n        recur(index + 1, currSum, goal, nums);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        Map<String, Integer> hashMap = new HashMap<>();\\n        return recur(0, 0, goal, nums, hashMap);\\n    }\\n\\n    public int recur(int index, int currSum, int goal, int[] nums, Map<String, Integer> hashMap){\\n        if(index == nums.length){\\n            return Math.abs(currSum - goal);\\n        }\\n\\n        String key = index + \"-\" + currSum;\\n        if(hashMap.containsKey(key)){\\n            return hashMap.get(key);\\n        }\\n\\n        int a = recur(index + 1, currSum + nums[index], goal, nums, hashMap);\\n        int b = recur(index + 1, currSum, goal, nums, hashMap);\\n\\n        hashMap.put(key, Math.min(a, b));\\n        return hashMap.get(key);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int minAbsDiff = Integer.MAX_VALUE;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int numLen = nums.length;\\n        // int minAbsDiff = Integer.MAX_VALUE;\\n        List<Integer> leftList = new ArrayList<>();\\n        List<Integer> rightList = new ArrayList<>();\\n\\n        recur(0, (numLen/2) + 1, 0, leftList, nums);\\n        recur((numLen/2) + 1, numLen, 0, rightList, nums);\\n\\n        // System.out.println(\"left: \");\\n        for(int val : leftList){\\n            // System.out.print(minAbsDiff + \" \" + Math.abs(goal - val) + \" \");\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(goal - val));\\n            // System.out.println(minAbsDiff);\\n        }\\n        \\n        // System.out.println(\"right: \");\\n        for(int val : rightList){\\n            // System.out.print(minAbsDiff + \" \" + Math.abs(goal - val) + \" \");\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(goal - val));\\n            // System.out.println(minAbsDiff);\\n        }\\n\\n        Collections.sort(leftList);\\n        Collections.sort(rightList);\\n\\n        // System.out.println(\"binary: \");\\n        search(leftList, rightList, goal);\\n\\n        return minAbsDiff;\\n    }\\n\\n    public void recur(int index, int limit, int currSum, List<Integer> sum, int[] nums){\\n        if(index == limit){\\n            sum.add(currSum);\\n            return;\\n        }\\n\\n        recur(index + 1, limit,  currSum + nums[index], sum, nums);\\n        recur(index + 1, limit, currSum, sum, nums);\\n    }\\n\\n    public void search(List<Integer> leftList, List<Integer> rightList, int goal){\\n        int left = 0;\\n        int right = rightList.size() - 1;\\n\\n        while(left < leftList.size() && right >= 0){\\n            int combinedSum = leftList.get(left) + rightList.get(right);\\n            // System.out.print(minAbsDiff + \" \" + combinedSum + \" \");\\n            minAbsDiff = Math.min(minAbsDiff, Math.abs(goal - combinedSum));\\n            // System.out.println(minAbsDiff);\\n            if(combinedSum < goal){\\n                left++;\\n            } else if (combinedSum > goal){\\n                right--;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715671,
                "title": "super-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int>&arr1,vector<int>&sum1,int i,int sum){\\n        if(i>=arr1.size()){\\n            sum1.push_back(sum);\\n            return;\\n        }\\n        f(arr1,sum1,i+1,sum+arr1[i]);\\n        f(arr1,sum1,i+1,sum);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n       int n=nums.size();\\n       vector<int>arr1;\\n       vector<int>arr2;\\n       for(int i=0;i<n;i++){\\n           if(i<n/2)arr1.push_back(nums[i]);\\n           else arr2.push_back(nums[i]);\\n       }\\n       vector<int>sum1;\\n       vector<int>sum2;\\n       f(arr1,sum1,0,0);\\n       f(arr2,sum2,0,0);\\n       sort(sum2.begin(),sum2.end());\\n       int ans=INT_MAX;\\n       for(auto x:sum1){\\n          int target=goal-x;\\n          auto it=lower_bound(sum2.begin(),sum2.end(),target);\\n          if(it!=sum2.end()){\\n               ans=min(ans,abs(goal-(x+*it)));\\n               auto it1=it;\\n               it1++;\\n               if(it1!=sum2.end()){\\n                   ans=min(ans,abs(goal-(x+*it1)));\\n               }\\n          }\\n          if(it!=sum2.begin()){\\n              auto it2=it;\\n              it2--;\\n              ans=min(ans,abs(goal-(x+*it2)));\\n          }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&arr1,vector<int>&sum1,int i,int sum){\\n        if(i>=arr1.size()){\\n            sum1.push_back(sum);\\n            return;\\n        }\\n        f(arr1,sum1,i+1,sum+arr1[i]);\\n        f(arr1,sum1,i+1,sum);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n       int n=nums.size();\\n       vector<int>arr1;\\n       vector<int>arr2;\\n       for(int i=0;i<n;i++){\\n           if(i<n/2)arr1.push_back(nums[i]);\\n           else arr2.push_back(nums[i]);\\n       }\\n       vector<int>sum1;\\n       vector<int>sum2;\\n       f(arr1,sum1,0,0);\\n       f(arr2,sum2,0,0);\\n       sort(sum2.begin(),sum2.end());\\n       int ans=INT_MAX;\\n       for(auto x:sum1){\\n          int target=goal-x;\\n          auto it=lower_bound(sum2.begin(),sum2.end(),target);\\n          if(it!=sum2.end()){\\n               ans=min(ans,abs(goal-(x+*it)));\\n               auto it1=it;\\n               it1++;\\n               if(it1!=sum2.end()){\\n                   ans=min(ans,abs(goal-(x+*it1)));\\n               }\\n          }\\n          if(it!=sum2.begin()){\\n              auto it2=it;\\n              it2--;\\n              ans=min(ans,abs(goal-(x+*it2)));\\n          }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683198,
                "title": "python-if-you-get-tle-with-meet-in-the-middle",
                "content": "\"[Meet in the middle](https://www.baeldung.com/cs/subset-of-numbers-closest-to-target#3-meet-in-the-middle-approach)\", you either know about it or not.\\nIf you get TLE with it, probably your subset generator for `n^20` is slow.\\n\\n![image](https://assets.leetcode.com/users/images/8bbfe685-edd1-491e-ab39-a9ba68b325a2_1687748744.3867786.png)\\n\\nSimilar problems that can be solved with the same technique:\\n* https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/\\n* https://leetcode.com/problems/tallest-billboard/\\n\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def get_subset_sums(start, size): # hi, ye15!\\n            sums = {0}\\n            for i in range(start, start + size):\\n                sums |= {nums[i] + prev for prev in sums}\\n            return sums \\n            ### TLE :(\\n            # sums = set()\\n            # for comb in range(1 << size):\\n            #     current_sum = 0\\n            #     for b in range(size):\\n            #         if comb & (1 << b):\\n            #             current_sum += nums[start + b]\\n            #     sums.add(current_sum)\\n            # return sums\\n\\n        N = len(nums)\\n        left_len = (N // 2) + N % 2\\n        right_len = N - left_len\\n        left = get_subset_sums(0, left_len)\\n        right = sorted(get_subset_sums(left_len, right_len))\\n            \\n        min_diff = float(inf)\\n        for left_sum in left:\\n            target = goal - left_sum\\n            idx = bisect_left(right, target)\\n            if idx > 0:\\n                min_diff = min(min_diff, abs(target - right[idx - 1]))\\n            if idx < len(right):\\n                min_diff = min(min_diff, abs(target - right[idx]))\\n            if min_diff == 0:\\n                break\\n            \\n        return min_diff\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def get_subset_sums(start, size): # hi, ye15!\\n            sums = {0}\\n            for i in range(start, start + size):\\n                sums |= {nums[i] + prev for prev in sums}\\n            return sums \\n            ### TLE :(\\n            # sums = set()\\n            # for comb in range(1 << size):\\n            #     current_sum = 0\\n            #     for b in range(size):\\n            #         if comb & (1 << b):\\n            #             current_sum += nums[start + b]\\n            #     sums.add(current_sum)\\n            # return sums\\n\\n        N = len(nums)\\n        left_len = (N // 2) + N % 2\\n        right_len = N - left_len\\n        left = get_subset_sums(0, left_len)\\n        right = sorted(get_subset_sums(left_len, right_len))\\n            \\n        min_diff = float(inf)\\n        for left_sum in left:\\n            target = goal - left_sum\\n            idx = bisect_left(right, target)\\n            if idx > 0:\\n                min_diff = min(min_diff, abs(target - right[idx - 1]))\\n            if idx < len(right):\\n                min_diff = min(min_diff, abs(target - right[idx]))\\n            if min_diff == 0:\\n                break\\n            \\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649742,
                "title": "java-solution-meet-in-the-middle-technique",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n\\n        if(n == 1) return Math.min(Math.abs(goal), Math.abs(nums[0]-goal));\\n\\n        int[] left = findAllSubsetSum(nums, 0, n/2-1, 0);\\n        int[] right = findAllSubsetSum(nums, n/2, n-1, n/2);\\n\\n        Arrays.sort(right);\\n\\n        int ans  = Integer.MAX_VALUE;\\n        for(int i = 0; i < left.length; i++) {\\n            int lb = lowerBound(right, goal-left[i]);\\n            \\n            ans  = Math.min(ans, Math.abs((left[i] + lb) - goal));\\n        }\\n        return Math.abs(ans);\\n    }\\n\\n    private int[] findAllSubsetSum(int[] arr, int start, int end, int offset) {\\n        int n = end-start+1;\\n        int[] ans = new int[1<<n];\\n        for(int i = 0; i < (1<<n); i++) {\\n            int sum = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((i&(1<<j)) != 0) {\\n                    sum += arr[j + offset];\\n                }\\n            }\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n\\n    private int lowerBound(int[] nums, int t) {\\n        int lo = 0, hi = nums.length-1;\\n        int ans = Integer.MAX_VALUE;\\n        int res = 0;\\n        while(lo <= hi) {\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid] == t) return nums[mid];\\n            if(nums[mid] > t) {\\n                hi = mid-1;\\n                int temp = Math.abs(nums[mid] - t);\\n                if(temp < ans) {\\n                    res = nums[mid];\\n                    ans = temp;\\n                }\\n            } else {\\n                lo = mid+1;\\n                int temp = Math.abs(nums[mid] - t);\\n                if(temp < ans) {\\n                    res = nums[mid];\\n                    ans = temp;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n} \\n```\\nPlease upvote if it\\'s helped you\\nthanks",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n\\n        if(n == 1) return Math.min(Math.abs(goal), Math.abs(nums[0]-goal));\\n\\n        int[] left = findAllSubsetSum(nums, 0, n/2-1, 0);\\n        int[] right = findAllSubsetSum(nums, n/2, n-1, n/2);\\n\\n        Arrays.sort(right);\\n\\n        int ans  = Integer.MAX_VALUE;\\n        for(int i = 0; i < left.length; i++) {\\n            int lb = lowerBound(right, goal-left[i]);\\n            \\n            ans  = Math.min(ans, Math.abs((left[i] + lb) - goal));\\n        }\\n        return Math.abs(ans);\\n    }\\n\\n    private int[] findAllSubsetSum(int[] arr, int start, int end, int offset) {\\n        int n = end-start+1;\\n        int[] ans = new int[1<<n];\\n        for(int i = 0; i < (1<<n); i++) {\\n            int sum = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((i&(1<<j)) != 0) {\\n                    sum += arr[j + offset];\\n                }\\n            }\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n\\n    private int lowerBound(int[] nums, int t) {\\n        int lo = 0, hi = nums.length-1;\\n        int ans = Integer.MAX_VALUE;\\n        int res = 0;\\n        while(lo <= hi) {\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid] == t) return nums[mid];\\n            if(nums[mid] > t) {\\n                hi = mid-1;\\n                int temp = Math.abs(nums[mid] - t);\\n                if(temp < ans) {\\n                    res = nums[mid];\\n                    ans = temp;\\n                }\\n            } else {\\n                lo = mid+1;\\n                int temp = Math.abs(nums[mid] - t);\\n                if(temp < ans) {\\n                    res = nums[mid];\\n                    ans = temp;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638167,
                "title": "c-pre-requisite-power-set-meet-in-the-middle",
                "content": "\\n# Pre-Requisites\\nTo know about POWER set method and know how to find all subsets using Bits and Bitmanipulation.\\nLower_bound which uses binary search to find an element less than or equal to\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$O(2^n)$ is not feasible in this\\nSo what if we check for  $N = n/2$ in this $O(2^N)$ will be feasible.\\nWe apply this for left and right half. And for every sum in the left half we binary search the SUM-left[i] in right array and use lower_bound for this.\\n\\n\\n\\n# Complexity\\n- Time complexity: $O(2^N *N*2) + O(2^N * log(2^N)) + O(2^N * log(2^N))$\\n- $$O(2^{N+1} *(N + \\\\log_2(2^N)))$$\\n- $$O(2^{N+1} *(N + N))$$\\n- $$O(2^{N+2} *(N))$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2^{N+1})$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int n = nums.size();\\n        int N = n/2;\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i =0;i<(1<<N);i++)\\n        {   \\n            int temp=0;\\n            for(int j =0;j<N;j++)\\n            {\\n                if((i & (1<<j))!=0) temp=temp+nums[j];\\n            }\\n            left.push_back(temp);\\n        }\\n        for(int i =0;i<(1<<(n-N));i++)\\n        {   \\n            int temp=0;\\n            for(int j =0;j<(n-N);j++)\\n            {\\n                if((i & (1<<j))!=0) temp=temp+nums[N +j];\\n            }\\n            right.push_back(temp);\\n        }\\n        sort(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i =0;i<left.size();i++)\\n        {\\n            int temp = goal-left[i];\\n            auto itr = lower_bound(right.begin(),right.end(),temp)-right.begin();\\n            if(itr<right.size())\\n            {\\n                ans=min(ans,abs(left[i]+ right[itr] -goal));\\n            }\\n            if(itr>=1)\\n            {\\n                ans=min(ans,abs(left[i]-goal + right[itr-1]));\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int n = nums.size();\\n        int N = n/2;\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i =0;i<(1<<N);i++)\\n        {   \\n            int temp=0;\\n            for(int j =0;j<N;j++)\\n            {\\n                if((i & (1<<j))!=0) temp=temp+nums[j];\\n            }\\n            left.push_back(temp);\\n        }\\n        for(int i =0;i<(1<<(n-N));i++)\\n        {   \\n            int temp=0;\\n            for(int j =0;j<(n-N);j++)\\n            {\\n                if((i & (1<<j))!=0) temp=temp+nums[N +j];\\n            }\\n            right.push_back(temp);\\n        }\\n        sort(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i =0;i<left.size();i++)\\n        {\\n            int temp = goal-left[i];\\n            auto itr = lower_bound(right.begin(),right.end(),temp)-right.begin();\\n            if(itr<right.size())\\n            {\\n                ans=min(ans,abs(left[i]+ right[itr] -goal));\\n            }\\n            if(itr>=1)\\n            {\\n                ans=min(ans,abs(left[i]-goal + right[itr-1]));\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3604888,
                "title": "java-meet-in-the-middle",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMeet in the middle technique to reduce total no of operations\\n\\n# Complexity\\n- Time complexity:O(N.2^(n/2))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2^(n/2))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        // goal ki value -10^9 to 10^9 hai to dp nhi lga sakte dp lagayenge to utna memory out aa jayege 2d me.\\n        // aur negative bhi goal ho sakta usko handle krna padega.\\n        // length of arr <=40 if we generate all subsequence tc= 2^n =2^40, greater than 1sec.\\n        // so try meet in the middle approach;\\n        int n=nums.length;\\n        if(n==1){\\n            return Math.min(Math.abs(0-goal),Math.abs(nums[0]-goal));\\n        }\\n        int m=n/2;\\n        System.out.println(n+\" \"+m);\\n        ArrayList<Integer> left=new ArrayList<>();\\n        solve(nums,0,m,left,0);\\n        ArrayList<Integer> right=new ArrayList<>();\\n        solve(nums,m,n,right,0);\\n\\n        // step 2. sort right;\\n        Collections.sort(right);\\n\\n        //step 3. search for best ans;\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<left.size();i++){\\n            int k=left.get(i);\\n            int a=BinarySearch(right,goal,k);\\n            ans=Math.min(ans,a);\\n        }\\n        return ans;\\n    }\\n    public void solve(int[] nums,int i,int n,ArrayList<Integer> list,int sum){\\n        if(i==n){\\n            list.add(sum);\\n            return ;\\n        }\\n        solve(nums,i+1,n,list,sum);\\n        solve(nums,i+1,n,list,sum+nums[i]);\\n    }\\n    int BinarySearch(ArrayList<Integer> list,int goal,int k){\\n        int l=0;\\n        int h=list.size()-1;\\n        int ans=Integer.MAX_VALUE;\\n        while(l<=h){\\n         int mid=l+(h-l)/2;\\n         int a=k+list.get(mid);\\n         int dif=Math.abs(goal-a);\\n         ans=Math.min(ans,dif);\\n         if(a<goal){\\n             l=mid+1;\\n         }\\n         else if(a>goal){\\n             h=mid-1;\\n         }\\n         else return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        // goal ki value -10^9 to 10^9 hai to dp nhi lga sakte dp lagayenge to utna memory out aa jayege 2d me.\\n        // aur negative bhi goal ho sakta usko handle krna padega.\\n        // length of arr <=40 if we generate all subsequence tc= 2^n =2^40, greater than 1sec.\\n        // so try meet in the middle approach;\\n        int n=nums.length;\\n        if(n==1){\\n            return Math.min(Math.abs(0-goal),Math.abs(nums[0]-goal));\\n        }\\n        int m=n/2;\\n        System.out.println(n+\" \"+m);\\n        ArrayList<Integer> left=new ArrayList<>();\\n        solve(nums,0,m,left,0);\\n        ArrayList<Integer> right=new ArrayList<>();\\n        solve(nums,m,n,right,0);\\n\\n        // step 2. sort right;\\n        Collections.sort(right);\\n\\n        //step 3. search for best ans;\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<left.size();i++){\\n            int k=left.get(i);\\n            int a=BinarySearch(right,goal,k);\\n            ans=Math.min(ans,a);\\n        }\\n        return ans;\\n    }\\n    public void solve(int[] nums,int i,int n,ArrayList<Integer> list,int sum){\\n        if(i==n){\\n            list.add(sum);\\n            return ;\\n        }\\n        solve(nums,i+1,n,list,sum);\\n        solve(nums,i+1,n,list,sum+nums[i]);\\n    }\\n    int BinarySearch(ArrayList<Integer> list,int goal,int k){\\n        int l=0;\\n        int h=list.size()-1;\\n        int ans=Integer.MAX_VALUE;\\n        while(l<=h){\\n         int mid=l+(h-l)/2;\\n         int a=k+list.get(mid);\\n         int dif=Math.abs(goal-a);\\n         ans=Math.min(ans,dif);\\n         if(a<goal){\\n             l=mid+1;\\n         }\\n         else if(a>goal){\\n             h=mid-1;\\n         }\\n         else return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601513,
                "title": "meet-in-the-middle-technique",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        pos = neg = 0\\n        for el in nums:\\n            if el >= 0:\\n                pos += el\\n            else:\\n                neg += el\\n        if goal >= pos:\\n            return goal - pos\\n        if goal <= neg:\\n            return neg - goal\\n        n = len(nums)\\n        k = n // 2\\n        x = [1] * max(k + 1, n - k + 1)\\n        for i in range(1, max(k + 1, n - k + 1)):\\n            x[i] = 2 * x[i - 1]\\n        sums = set()\\n        for mask in range(1 << k):\\n            s = 0\\n            for i in range(k):\\n                if mask & x[i]:\\n                    s += nums[i]\\n            sums.add(s)\\n        res = float(\\'inf\\')\\n        sums = sorted(sums)\\n        for mask in range(1 << (n - k)):\\n            s = 0\\n            for i in range(n - k):\\n                if mask & x[i]:\\n                    s += nums[k + i]\\n            i = bisect.bisect_left(sums, goal - s)\\n            if i < len(sums):\\n                res = min(res, abs(s + sums[i] - goal))\\n            if i > 0:\\n                res = min(res, abs(s + sums[i - 1] - goal))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        pos = neg = 0\\n        for el in nums:\\n            if el >= 0:\\n                pos += el\\n            else:\\n                neg += el\\n        if goal >= pos:\\n            return goal - pos\\n        if goal <= neg:\\n            return neg - goal\\n        n = len(nums)\\n        k = n // 2\\n        x = [1] * max(k + 1, n - k + 1)\\n        for i in range(1, max(k + 1, n - k + 1)):\\n            x[i] = 2 * x[i - 1]\\n        sums = set()\\n        for mask in range(1 << k):\\n            s = 0\\n            for i in range(k):\\n                if mask & x[i]:\\n                    s += nums[i]\\n            sums.add(s)\\n        res = float(\\'inf\\')\\n        sums = sorted(sums)\\n        for mask in range(1 << (n - k)):\\n            s = 0\\n            for i in range(n - k):\\n                if mask & x[i]:\\n                    s += nums[k + i]\\n            i = bisect.bisect_left(sums, goal - s)\\n            if i < len(sums):\\n                res = min(res, abs(s + sums[i] - goal))\\n            if i > 0:\\n                res = min(res, abs(s + sums[i - 1] - goal))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484169,
                "title": "golang",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"math\"\\n\\t\"sort\"\\n)\\n\\nfunc minAbsDifference(nums []int, goal int) int {\\n\\tnums = append(nums, 0)\\n\\tn := len(nums)\\n\\n\\tn1 := nums[:n/2]\\n\\tn2 := nums[n/2:]\\n\\n\\tleft := make([]int, 1<<(n/2))\\n\\tright := make([]int, 1<<(n/2))\\n\\n\\t// Subseq generation for left and right part\\n\\tfor i := 0; i < len(n1); i++ {\\n\\t\\tleft[1<<i] = n1[i]\\n\\t\\tright[1<<i] = n2[i]\\n\\t}\\n\\tfor i := 1; i < len(left); i++ {\\n\\t\\tleft[i] = left[i&(i-1)] + left[i&(-i)]\\n\\t\\tright[i] = right[i&(i-1)] + right[i&(-i)]\\n\\n\\t\\tif left[i] == goal || right[i] == goal {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n\\n\\tright = append(right, -1e10)\\n\\tright = append(right, 1e10)\\n\\tsort.Ints(right)\\n\\n\\tans := math.MaxInt\\n\\n\\t// Iterate over left and binary search for its closest brother in the right.\\n\\tfor _, leftSum := range left {\\n\\t\\tindex := sort.Search(len(right), func(x int) bool {\\n\\t\\t\\treturn (leftSum + right[x]) >= goal\\n\\t\\t})\\n\\n\\t\\tans = minI(ans, absI(goal-(leftSum+right[index])))\\n\\t\\tans = minI(ans, absI(goal-(leftSum+right[index-1])))\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n// @formatter:off\\ntype Ints interface{ int | int64 | int32 | int16 | int8 }\\ntype Floats interface{ float64 | float32 }\\ntype Numeric interface{ Ints | Floats }\\ntype Comparable interface{ Numeric | string }\\nfunc minI[T Comparable](a, b T) T { if a < b { return a }; return b }\\nfunc absI[T Numeric](a T) T { if a >= 0 { return a\\t}; return -a }\\n// @formatter:on\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"math\"\\n\\t\"sort\"\\n)\\n\\nfunc minAbsDifference(nums []int, goal int) int {\\n\\tnums = append(nums, 0)\\n\\tn := len(nums)\\n\\n\\tn1 := nums[:n/2]\\n\\tn2 := nums[n/2:]\\n\\n\\tleft := make([]int, 1<<(n/2))\\n\\tright := make([]int, 1<<(n/2))\\n\\n\\t// Subseq generation for left and right part\\n\\tfor i := 0; i < len(n1); i++ {\\n\\t\\tleft[1<<i] = n1[i]\\n\\t\\tright[1<<i] = n2[i]\\n\\t}\\n\\tfor i := 1; i < len(left); i++ {\\n\\t\\tleft[i] = left[i&(i-1)] + left[i&(-i)]\\n\\t\\tright[i] = right[i&(i-1)] + right[i&(-i)]\\n\\n\\t\\tif left[i] == goal || right[i] == goal {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n\\n\\tright = append(right, -1e10)\\n\\tright = append(right, 1e10)\\n\\tsort.Ints(right)\\n\\n\\tans := math.MaxInt\\n\\n\\t// Iterate over left and binary search for its closest brother in the right.\\n\\tfor _, leftSum := range left {\\n\\t\\tindex := sort.Search(len(right), func(x int) bool {\\n\\t\\t\\treturn (leftSum + right[x]) >= goal\\n\\t\\t})\\n\\n\\t\\tans = minI(ans, absI(goal-(leftSum+right[index])))\\n\\t\\tans = minI(ans, absI(goal-(leftSum+right[index-1])))\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n// @formatter:off\\ntype Ints interface{ int | int64 | int32 | int16 | int8 }\\ntype Floats interface{ float64 | float32 }\\ntype Numeric interface{ Ints | Floats }\\ntype Comparable interface{ Numeric | string }\\nfunc minI[T Comparable](a, b T) T { if a < b { return a }; return b }\\nfunc absI[T Numeric](a T) T { if a >= 0 { return a\\t}; return -a }\\n// @formatter:on\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3427417,
                "title": "getting-sum-of-all-subsequence-length-n-2-n-n-2-in-set1-and-set2-respectively-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void fun(int i,int n,vector<int>&nums,set<long long>&st,long long&val){\\n      if(i==n){\\n           st.insert(val);\\n          return;\\n      }\\n\\n       val+=nums[i];\\n       fun(i+1,n,nums,st,val);\\n       val-=nums[i];\\n       fun(i+1,n,nums,st,val);\\n}\\n\\n\\n\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        set<long long>st,st1;\\n        int n=nums.size();\\n        int n1=(n/2);\\n        n-=n1;\\n         long long val=0;\\n        fun(0,n,nums,st,val);\\n\\n\\n         vector<int>first;\\n        for(int i=n;i<nums.size();i++){\\n            first.push_back(nums[i]);\\n        }\\n        nums.clear();\\n        val=0;\\n        for(auto it:first)nums.push_back(it);\\n\\n        fun(0,n1,nums,st1,val);\\n\\n\\n\\n\\n        \\n        long long ans=1e18+0;\\n\\n\\n        for(auto i:st){\\n            ans=min(ans,abs(goal-i));\\n            long long val=(goal-i);\\n            auto it=st1.lower_bound(val);\\n\\n            if(it!=st1.end()){\\n                long long val1=*it;\\n                long long val2=0;\\n                if(it!=st1.begin()){\\n                    it--;\\n                    val2=*it;\\n                }\\n               ans=min({ans,abs(val-val1),abs(val-val2)});\\n            }\\n\\n            else{\\n                it--;\\n                long long val1=*it;\\n                ans=min(ans,abs(val-val1));\\n            }           \\n }\\n\\n\\n\\n\\n\\n\\n\\n  for(auto i:st1){\\n            ans=min(ans,abs(goal-i));\\n            long long val=(goal-i);\\n            auto it=st.lower_bound(val);\\n           if(it!=st.end()){\\n                long long val1=*it;\\n                long long val2=0;\\n                if(it!=st.begin()){\\n                    it--;\\n                    val2=*it;\\n                }\\n                ans=min({ans,abs(val-val1),abs(val-val2)});\\n             }\\n            else{\\n                it--;\\n               long long val1=*it;\\n                ans=min(ans,abs(val-val1));\\n            }\\n }\\n\\n\\n\\n   return ans;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void fun(int i,int n,vector<int>&nums,set<long long>&st,long long&val){\\n      if(i==n){\\n           st.insert(val);\\n          return;\\n      }\\n\\n       val+=nums[i];\\n       fun(i+1,n,nums,st,val);\\n       val-=nums[i];\\n       fun(i+1,n,nums,st,val);\\n}\\n\\n\\n\\n\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        set<long long>st,st1;\\n        int n=nums.size();\\n        int n1=(n/2);\\n        n-=n1;\\n         long long val=0;\\n        fun(0,n,nums,st,val);\\n\\n\\n         vector<int>first;\\n        for(int i=n;i<nums.size();i++){\\n            first.push_back(nums[i]);\\n        }\\n        nums.clear();\\n        val=0;\\n        for(auto it:first)nums.push_back(it);\\n\\n        fun(0,n1,nums,st1,val);\\n\\n\\n\\n\\n        \\n        long long ans=1e18+0;\\n\\n\\n        for(auto i:st){\\n            ans=min(ans,abs(goal-i));\\n            long long val=(goal-i);\\n            auto it=st1.lower_bound(val);\\n\\n            if(it!=st1.end()){\\n                long long val1=*it;\\n                long long val2=0;\\n                if(it!=st1.begin()){\\n                    it--;\\n                    val2=*it;\\n                }\\n               ans=min({ans,abs(val-val1),abs(val-val2)});\\n            }\\n\\n            else{\\n                it--;\\n                long long val1=*it;\\n                ans=min(ans,abs(val-val1));\\n            }           \\n }\\n\\n\\n\\n\\n\\n\\n\\n  for(auto i:st1){\\n            ans=min(ans,abs(goal-i));\\n            long long val=(goal-i);\\n            auto it=st.lower_bound(val);\\n           if(it!=st.end()){\\n                long long val1=*it;\\n                long long val2=0;\\n                if(it!=st.begin()){\\n                    it--;\\n                    val2=*it;\\n                }\\n                ans=min({ans,abs(val-val1),abs(val-val2)});\\n             }\\n            else{\\n                it--;\\n               long long val1=*it;\\n                ans=min(ans,abs(val-val1));\\n            }\\n }\\n\\n\\n\\n   return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380098,
                "title": "complete-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int[] part1 = new int[nums.length / 2];\\n        int[] part2 = new int[nums.length - part1.length];\\n        for(int i = 0 ; i < part1.length ; i++){\\n            part1[i] = nums[i];\\n        }\\n        for(int i = 0 ; i < part2.length ; i++){\\n            part2[i] = nums[part1.length + i];\\n        }\\n        ArrayList<Integer> list1 = new ArrayList<>();\\n        ArrayList<Integer> list2 = new ArrayList<>();\\n        getSum(part1 , 0, 0 , list1);\\n        getSum(part2 , 0 , 0 , list2);\\n\\n        Collections.sort(list1);\\n        Collections.sort(list2);\\n\\n        int low = 0;\\n        int high = list2.size()-1;\\n        int min = Integer.MAX_VALUE;\\n        \\n        while(low < list1.size() && high >= 0){\\n            int currSum = list1.get(low) + list2.get(high);\\n            min = Math.min(min , Math.abs(goal - currSum));\\n            if(goal < list1.get(low) + list2.get(high)){\\n                high--;\\n            }else if(goal > list2.get(high) + list1.get(low)){\\n                low++;\\n            }else{\\n                return 0;\\n            }\\n            \\n        }\\n        return min;\\n    }\\n\\n    public void getSum(int[] arr , int index , int sum,List<Integer> list){\\n        if(index == arr.length){\\n            list.add(sum);\\n            return;\\n        }\\n        getSum(arr,index+1,sum + arr[index],list);\\n        getSum(arr,index +1, sum,list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int[] part1 = new int[nums.length / 2];\\n        int[] part2 = new int[nums.length - part1.length];\\n        for(int i = 0 ; i < part1.length ; i++){\\n            part1[i] = nums[i];\\n        }\\n        for(int i = 0 ; i < part2.length ; i++){\\n            part2[i] = nums[part1.length + i];\\n        }\\n        ArrayList<Integer> list1 = new ArrayList<>();\\n        ArrayList<Integer> list2 = new ArrayList<>();\\n        getSum(part1 , 0, 0 , list1);\\n        getSum(part2 , 0 , 0 , list2);\\n\\n        Collections.sort(list1);\\n        Collections.sort(list2);\\n\\n        int low = 0;\\n        int high = list2.size()-1;\\n        int min = Integer.MAX_VALUE;\\n        \\n        while(low < list1.size() && high >= 0){\\n            int currSum = list1.get(low) + list2.get(high);\\n            min = Math.min(min , Math.abs(goal - currSum));\\n            if(goal < list1.get(low) + list2.get(high)){\\n                high--;\\n            }else if(goal > list2.get(high) + list1.get(low)){\\n                low++;\\n            }else{\\n                return 0;\\n            }\\n            \\n        }\\n        return min;\\n    }\\n\\n    public void getSum(int[] arr , int index , int sum,List<Integer> list){\\n        if(index == arr.length){\\n            list.add(sum);\\n            return;\\n        }\\n        getSum(arr,index+1,sum + arr[index],list);\\n        getSum(arr,index +1, sum,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324742,
                "title": "ruby-meet-in-the-middle",
                "content": "Ruby adaptation of https://leetcode.com/problems/closest-subsequence-sum/solutions/1053522/python-meet-in-the-middle/\\n\\n\\n```ruby\\n# @param {Integer[]} nums\\n# @param {Integer} goal\\n# @return {Integer}\\ndef min_abs_difference(nums, goal)\\n  min_abs_difference = goal.abs\\n\\n  # generate all possible sums of the 1st and 2nd half \\n  sums1 = sums(nums[0..(nums.count / 2 - 1)])\\n  sums2 = sums(nums[(nums.count / 2)..-1]).sort\\n\\n  # for each possible sum of the 1st half, find the sum in the 2nd half\\n  # that gives a value closest to the goal using binary search\\n  sums1.each do |sum1|\\n    remain = goal - sum1\\n    # binary search for the value in sums2 that\\'s closest to the remaining value\\n    i = sums2.bsearch_index { |sum2| remain < sum2 } || -1\\n\\n    difference = (sum1 + sums2[i] - goal).abs\\n    min_abs_difference = difference if difference < min_abs_difference\\n\\n    next if i < 1\\n\\n    difference = (sum1 + sums2[i - 1] - goal).abs\\n    min_abs_difference = difference if difference < min_abs_difference\\n  end\\n\\n  min_abs_difference\\nend\\n\\n# function that generates all possible sums of sebsequences\\ndef sums(array)\\n  sums = [0]\\n\\n  array.each do |elem|\\n    0.upto(sums.length - 1) do |i|\\n      sums.push(sums[i] + elem)\\n    end\\n  end\\n\\n  sums.uniq\\nend\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Ruby adaptation of https://leetcode.com/problems/closest-subsequence-sum/solutions/1053522/python-meet-in-the-middle/\\n\\n\\n```ruby\\n# @param {Integer[]} nums\\n# @param {Integer} goal\\n# @return {Integer}\\ndef min_abs_difference(nums, goal)\\n  min_abs_difference = goal.abs\\n\\n  # generate all possible sums of the 1st and 2nd half \\n  sums1 = sums(nums[0..(nums.count / 2 - 1)])\\n  sums2 = sums(nums[(nums.count / 2)..-1]).sort\\n\\n  # for each possible sum of the 1st half, find the sum in the 2nd half\\n  # that gives a value closest to the goal using binary search\\n  sums1.each do |sum1|\\n    remain = goal - sum1\\n    # binary search for the value in sums2 that\\'s closest to the remaining value\\n    i = sums2.bsearch_index { |sum2| remain < sum2 } || -1\\n\\n    difference = (sum1 + sums2[i] - goal).abs\\n    min_abs_difference = difference if difference < min_abs_difference\\n\\n    next if i < 1\\n\\n    difference = (sum1 + sums2[i - 1] - goal).abs\\n    min_abs_difference = difference if difference < min_abs_difference\\n  end\\n\\n  min_abs_difference\\nend\\n\\n# function that generates all possible sums of sebsequences\\ndef sums(array)\\n  sums = [0]\\n\\n  array.each do |elem|\\n    0.upto(sums.length - 1) do |i|\\n      sums.push(sums[i] + elem)\\n    end\\n  end\\n\\n  sums.uniq\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3250258,
                "title": "python-using-bitmask-and-two-pointer",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        #All the possible combination\\n        def genSorted(arr): # gen sum\\n            res = [0] * (1 << len(arr))\\n            for i in range(len(arr)):\\n                res[1 << i] = arr[i]\\n            for i in range(1, len(res)):\\n                res[i] = res[i & -i] + res[i & (i-1)]\\n            res.sort()\\n            return res\\n        \\n        one = genSorted(nums[:len(nums)//2+1])\\n        two = genSorted(nums[len(nums)//2+1:])\\n\\n        #Two Pointer\\n        ans = float(\\'inf\\')\\n        left, right = 0, len(two)-1\\n        while left < len(one) and right >= 0:\\n            val = one[left] + two[right]\\n            ans = min(abs(val - goal), ans)\\n            if val == goal:\\n                return 0\\n            if val < goal:\\n                left += 1\\n            else:\\n                right -= 1\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        #All the possible combination\\n        def genSorted(arr): # gen sum\\n            res = [0] * (1 << len(arr))\\n            for i in range(len(arr)):\\n                res[1 << i] = arr[i]\\n            for i in range(1, len(res)):\\n                res[i] = res[i & -i] + res[i & (i-1)]\\n            res.sort()\\n            return res\\n        \\n        one = genSorted(nums[:len(nums)//2+1])\\n        two = genSorted(nums[len(nums)//2+1:])\\n\\n        #Two Pointer\\n        ans = float(\\'inf\\')\\n        left, right = 0, len(two)-1\\n        while left < len(one) and right >= 0:\\n            val = one[left] + two[right]\\n            ans = min(abs(val - goal), ans)\\n            if val == goal:\\n                return 0\\n            if val < goal:\\n                left += 1\\n            else:\\n                right -= 1\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181713,
                "title": "meet-in-the-middle-by-finding-subset-sums-for-2-halves",
                "content": "# Code\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n\\n        # When goal 0 we can just choose no elements \\n        if goal == 0: return 0\\n\\n        n = len(nums)\\n        mid = n // 2\\n        # Split the list in 2 parts and then find all possible subset sums \\n        # T = O(2^n/2) to build all subset sums\\n        leftList = nums[:mid]\\n        leftSums = []\\n        rightList = nums[mid:]\\n        rightSums = []\\n\\n        # T = O(2^n/2) to build all subset sums (we only consider half list)\\n        def buildSubsetSums(usedNums, numsToChooseFrom, ind, storeIn):\\n            if ind == len(numsToChooseFrom):\\n                # We also keep elements with sum 0 to deal with cases like this where we don\\'t select nums\\n                # List: [1,2,3], Target: -7 (choosing no elements will give a sum close to goal)\\n                # We can also have cases where we want to take only 1 element from the list\\n                # so sum 0 for left and right list needs to be an option\\n                storeIn.append(sum(usedNums))\\n                return \\n\\n            usedNums.append(numsToChooseFrom[ind])\\n            buildSubsetSums(usedNums, numsToChooseFrom, ind+1, storeIn)\\n            usedNums.pop()\\n            buildSubsetSums(usedNums, numsToChooseFrom, ind+1, storeIn)\\n\\n\\n        buildSubsetSums([], leftList, 0, leftSums)\\n        buildSubsetSums([], rightList, 0, rightSums)\\n        # 2^n/2 log(2^n/2) = n/2 * 2^n/2 time to sort\\n        rightSums.sort()\\n\\n        diff = float(\\'inf\\')\\n\\n        # Loop runs 2^n/2 times and inside binary search tale n/2 time \\n        # So total time is n/2 * 2^n/2\\n        for leftSum in leftSums:\\n            complement = goal - leftSum\\n            # Bisect left takes log(2^n/2) = n/2 search time\\n            idx = bisect.bisect_left(rightSums, complement)\\n\\n            for i in [idx - 1, idx, idx + 1]:\\n                if 0 <= i < len(rightSums):\\n                    finalSum = leftSum + rightSums[i]\\n                    diff = min(diff, abs(goal - finalSum))\\n        \\n        # Over all time complexity is - n/2 * 2^n/2\\n        # 1. Making subset sums will take - 2^n/2\\n        # 2. Sorting right list takes - 2^n/2 * n/2\\n        # 3. Iterating one list and finding closest complement in other \\n        # takes n/2 * 2^n/2\\n        # Space will be O(n/2) for the list and call stack for building subset \\n        return diff\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n\\n        # When goal 0 we can just choose no elements \\n        if goal == 0: return 0\\n\\n        n = len(nums)\\n        mid = n // 2\\n        # Split the list in 2 parts and then find all possible subset sums \\n        # T = O(2^n/2) to build all subset sums\\n        leftList = nums[:mid]\\n        leftSums = []\\n        rightList = nums[mid:]\\n        rightSums = []\\n\\n        # T = O(2^n/2) to build all subset sums (we only consider half list)\\n        def buildSubsetSums(usedNums, numsToChooseFrom, ind, storeIn):\\n            if ind == len(numsToChooseFrom):\\n                # We also keep elements with sum 0 to deal with cases like this where we don\\'t select nums\\n                # List: [1,2,3], Target: -7 (choosing no elements will give a sum close to goal)\\n                # We can also have cases where we want to take only 1 element from the list\\n                # so sum 0 for left and right list needs to be an option\\n                storeIn.append(sum(usedNums))\\n                return \\n\\n            usedNums.append(numsToChooseFrom[ind])\\n            buildSubsetSums(usedNums, numsToChooseFrom, ind+1, storeIn)\\n            usedNums.pop()\\n            buildSubsetSums(usedNums, numsToChooseFrom, ind+1, storeIn)\\n\\n\\n        buildSubsetSums([], leftList, 0, leftSums)\\n        buildSubsetSums([], rightList, 0, rightSums)\\n        # 2^n/2 log(2^n/2) = n/2 * 2^n/2 time to sort\\n        rightSums.sort()\\n\\n        diff = float(\\'inf\\')\\n\\n        # Loop runs 2^n/2 times and inside binary search tale n/2 time \\n        # So total time is n/2 * 2^n/2\\n        for leftSum in leftSums:\\n            complement = goal - leftSum\\n            # Bisect left takes log(2^n/2) = n/2 search time\\n            idx = bisect.bisect_left(rightSums, complement)\\n\\n            for i in [idx - 1, idx, idx + 1]:\\n                if 0 <= i < len(rightSums):\\n                    finalSum = leftSum + rightSums[i]\\n                    diff = min(diff, abs(goal - finalSum))\\n        \\n        # Over all time complexity is - n/2 * 2^n/2\\n        # 1. Making subset sums will take - 2^n/2\\n        # 2. Sorting right list takes - 2^n/2 * n/2\\n        # 3. Iterating one list and finding closest complement in other \\n        # takes n/2 * 2^n/2\\n        # Space will be O(n/2) for the list and call stack for building subset \\n        return diff\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133802,
                "title": "c-o-n-2-n-2-meet-in-the-middle-two-pointer-bitmasking",
                "content": "# Intuition And Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNoticing listing all the possible subset sum can take at most $O(2^{40})$, which is likely getting you a TLE. However, $O(2^{20} \\\\approx 10^6)$ sounds like an acceptable complexity.\\n\\nThe intuition is to split nums into two arrays with approximatedly equal size and try to use the intermediate result to get the result of the whole problem. For example, we can list all the possible sum of them by powerset and try to add any two of these to get the sum that is close to goal. \\n\\nSince the half size of the array is not large, bitmasking can be used to represent the state of a subset. We can iterate through the state `0` to `(1<<n)-1`, computing the subset sums according to the bit states and store them in the corresponding entry in `sum1[1<<n1]`, `sum2[1<<n2]`.\\n\\nNow `sum1` stores all the possible subset sum of the first half of the array and `sum2` the second half. Sort both of the sum arrays, iterating through the first subset sum array(index `l`) and use a pointer `r` to point the first element in `sum2` such that `sum1[l] + sum[r] < goal`. Since when `l` is increasing, index `r` can only decrease. The pointer `l` will move exactly `length(sum1)` times and the pointer `r` will move at most `length(sum2)` times. Hence the two-pointers part has a time complexity linear to the size of two subset sum arrays. Then we can compute the differences `goal - (sum1[l] + sum[r])` and `(sum1[l] + sum[r+1] - goal)` with the current best difference `diff`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nGetting subset sum of the two array: $O(2^{n/2})$\\nSort the subset sums: $O(2^{n/2}\\\\log(2^{n/2})) = O(\\\\frac{n}{2}2^{n/2}) = O(n\\\\cdot 2^{n/2})$\\nTwo pointer sweeping: $O(2^{n/2})$\\n\\nTotal: $O(n\\\\cdot 2^{n/2})$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(2^{n/2})$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        // Split nums into two arrays with approximatedly\\n        // equal size, listing all the possible sum of them\\n        // using powerset\\n        int n = nums.size(), nl = n/2, nr = n- nl;\\n        int size_powerset1 = (1<<nl), size_powerset2 = (1<<nr);\\n        int sum1[size_powerset1], sum2[size_powerset2];\\n        for (int s = 0; s < size_powerset1; ++s) {\\n            int sum = 0;\\n            for (int j = 0; j < nl; ++j) {\\n                if (s & (1<<j)) {sum += nums[j];}\\n            }\\n            sum1[s] = sum;\\n        }\\n        for (int s = 0; s < size_powerset2; ++s) {\\n            int sum = 0;\\n            for (int j = 0; j < nr; ++j) {\\n                if (s & (1<<j)) {sum += nums[j+nl];}\\n            }\\n            sum2[s] = sum;\\n        }\\n\\n        // Sort the two powerset of sum\\n        ::sort(sum1, sum1+size_powerset1);\\n        ::sort(sum2, sum2+size_powerset2);\\n\\n        // use two pointers to find the closest subseq sum\\n        int bestdiff = INT_MAX;\\n        int r = size_powerset2-1;\\n        for (int l = 0; l < size_powerset1; ++l) {\\n            while (r >= 0 && sum2[r] + sum1[l] >= goal) {--r;}\\n            if (r >= 0) {\\n                int diff = abs(sum2[r] + sum1[l] - goal);\\n                if (diff < bestdiff) { bestdiff = diff; }\\n            }\\n            if (r < size_powerset2-1) {\\n                int diff = abs(sum2[r+1] + sum1[l] - goal);\\n                if (diff < bestdiff) { bestdiff = diff;}\\n            }\\n        }\\n        return bestdiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        // Split nums into two arrays with approximatedly\\n        // equal size, listing all the possible sum of them\\n        // using powerset\\n        int n = nums.size(), nl = n/2, nr = n- nl;\\n        int size_powerset1 = (1<<nl), size_powerset2 = (1<<nr);\\n        int sum1[size_powerset1], sum2[size_powerset2];\\n        for (int s = 0; s < size_powerset1; ++s) {\\n            int sum = 0;\\n            for (int j = 0; j < nl; ++j) {\\n                if (s & (1<<j)) {sum += nums[j];}\\n            }\\n            sum1[s] = sum;\\n        }\\n        for (int s = 0; s < size_powerset2; ++s) {\\n            int sum = 0;\\n            for (int j = 0; j < nr; ++j) {\\n                if (s & (1<<j)) {sum += nums[j+nl];}\\n            }\\n            sum2[s] = sum;\\n        }\\n\\n        // Sort the two powerset of sum\\n        ::sort(sum1, sum1+size_powerset1);\\n        ::sort(sum2, sum2+size_powerset2);\\n\\n        // use two pointers to find the closest subseq sum\\n        int bestdiff = INT_MAX;\\n        int r = size_powerset2-1;\\n        for (int l = 0; l < size_powerset1; ++l) {\\n            while (r >= 0 && sum2[r] + sum1[l] >= goal) {--r;}\\n            if (r >= 0) {\\n                int diff = abs(sum2[r] + sum1[l] - goal);\\n                if (diff < bestdiff) { bestdiff = diff; }\\n            }\\n            if (r < size_powerset2-1) {\\n                int diff = abs(sum2[r+1] + sum1[l] - goal);\\n                if (diff < bestdiff) { bestdiff = diff;}\\n            }\\n        }\\n        return bestdiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055382,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal)\\n    {\\n         //splitting the array , nums, into 2 parts\\n    \\tint part1[] = new int[nums.length/2];\\n    \\tint part2[] = new int[nums.length-part1.length];\\n    \\tint k = 0;\\n    \\tfor(int i=0;i<part1.length;i++)\\n    \\t{\\n    \\t\\tpart1[i] = nums[i];\\n    \\t\\tk++;\\n    \\t}\\n    \\tfor(int i=0 ; i<part2.length ; i++)\\n    \\t{\\n    \\t\\tpart2[i] = nums[k];\\n    \\t\\tk++;\\n    \\t}\\n    \\tArrayList<Integer> sum1=new ArrayList<>(); // stores the sum of all subseq of part1\\n    \\tArrayList<Integer> sum2=new ArrayList<>(); //stores the sum of all subseq of part2\\n    \\t//fills sum1 & sum2 ,  i.e add the sum of elements of all possible subseq of part1 into sum1 &\\n    \\t//add the sum of elements of all possible subseq of part2 into sum2\\n        addSum(sum1,part1,0,0);\\n        addSum(sum2,part2,0,0);\\n        //sorting the two lists \\n        Collections.sort(sum1);\\n        Collections.sort(sum2);\\n        \\n        int low  = 0;\\n        int high = sum2.size()-1;\\n        int res = Integer.MAX_VALUE;\\n        while(low < sum1.size() && high >= 0)\\n        {\\n             int sum = sum1.get(low)+sum2.get(high);\\n             res = Math.min(res,Math.abs(sum-goal));\\n              if(sum > goal)\\n             {\\n            \\t high--;\\n             }\\n             else if(sum==goal)\\n             {\\n                 return 0;\\n             }\\n             else\\n             {\\n            \\t low++;\\n             }\\n           \\n        }\\n        \\n        return res;\\n    }\\n    private void addSum(ArrayList<Integer> sumlist, int[] part,int sum,int si) \\n\\t{\\n\\t\\tif(si>=part.length)\\n\\t\\t{\\n\\t\\t\\tsumlist.add(sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t//include\\n\\t\\taddSum(sumlist,part,sum+part[si],si+1);\\n\\t\\t//exclude\\n\\t\\taddSum(sumlist,part,sum,si+1);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal)\\n    {\\n         //splitting the array , nums, into 2 parts\\n    \\tint part1[] = new int[nums.length/2];\\n    \\tint part2[] = new int[nums.length-part1.length];\\n    \\tint k = 0;\\n    \\tfor(int i=0;i<part1.length;i++)\\n    \\t{\\n    \\t\\tpart1[i] = nums[i];\\n    \\t\\tk++;\\n    \\t}\\n    \\tfor(int i=0 ; i<part2.length ; i++)\\n    \\t{\\n    \\t\\tpart2[i] = nums[k];\\n    \\t\\tk++;\\n    \\t}\\n    \\tArrayList<Integer> sum1=new ArrayList<>(); // stores the sum of all subseq of part1\\n    \\tArrayList<Integer> sum2=new ArrayList<>(); //stores the sum of all subseq of part2\\n    \\t//fills sum1 & sum2 ,  i.e add the sum of elements of all possible subseq of part1 into sum1 &\\n    \\t//add the sum of elements of all possible subseq of part2 into sum2\\n        addSum(sum1,part1,0,0);\\n        addSum(sum2,part2,0,0);\\n        //sorting the two lists \\n        Collections.sort(sum1);\\n        Collections.sort(sum2);\\n        \\n        int low  = 0;\\n        int high = sum2.size()-1;\\n        int res = Integer.MAX_VALUE;\\n        while(low < sum1.size() && high >= 0)\\n        {\\n             int sum = sum1.get(low)+sum2.get(high);\\n             res = Math.min(res,Math.abs(sum-goal));\\n              if(sum > goal)\\n             {\\n            \\t high--;\\n             }\\n             else if(sum==goal)\\n             {\\n                 return 0;\\n             }\\n             else\\n             {\\n            \\t low++;\\n             }\\n           \\n        }\\n        \\n        return res;\\n    }\\n    private void addSum(ArrayList<Integer> sumlist, int[] part,int sum,int si) \\n\\t{\\n\\t\\tif(si>=part.length)\\n\\t\\t{\\n\\t\\t\\tsumlist.add(sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t//include\\n\\t\\taddSum(sumlist,part,sum+part[si],si+1);\\n\\t\\t//exclude\\n\\t\\taddSum(sumlist,part,sum,si+1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044087,
                "title": "c-binary-search-o-2-n",
                "content": "## Full search brute force (TLE)\\n\\nFirst idea come to my mind is Brute Force because $n <= 40$ is pretty small, I can even get away with $O(n^4)$. So I made an array of set $f$ to maintain all possible $sum$. $f[i]$ holds all $sum$ candidates until $nums[i]$.\\nHere is the code for your reference\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<set<int>> f(n+1);\\n        f[0].insert(0);\\n        int ret = abs(goal);\\n        for(int i = 1;i<=n;i++) {\\n            for(auto x: f[i-1]) {\\n                int score;\\n                score = abs(x - goal);\\n                if(score < ret || x < goal || true) {\\n                    f[i].insert(x);\\n                }\\n                score = abs(nums[i-1] - goal);\\n                if(score < ret || nums[i-1] < goal) {\\n                    ret = min(ret, score);\\n                    f[i].insert(nums[i-1]);\\n                }\\n                auto sum = x + nums[i-1];\\n                score = abs(sum - goal);\\n                if(score < ret || sum < goal) {\\n                    ret = min(ret, score);\\n                    f[i].insert(sum);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nSadly this gives TLE, I can optimize it further by using only 1 sets instead of $n$ sets but I don\\'t think it\\'s would AC.\\n\\n## Intuition\\n\\nSo I changed my approach, notice that $n = 40$ so $O(2^n) = T(2^40)$ would not work, but how about $T(2^20)$? This is quite a potential solution. The idea is simple:\\n\\n- Split $nums$ into 2 array, let\\'s call them $left$ and $right$\\n- Calculate all possible $sum$ for each sub array. Sort them.\\n- For each $a$ in $left$, find $b$ so that $a+b$ is closest to $goal$. This could be done in $O(mlogm)$ with $m$ being the candidates array length $2^n$\\n- Altogether we have an $O(2^n * n)$ solution. It gives AC but I was afraid it is still slow I made a small optimization to reduce search range while traversing $right$ array.\\n\\n## Complexity\\n\\n- Time complexity: $O(2^n * n)$\\n- Space complexity: $O(2^n)$\\n\\n## Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void buildPermutation(vector<int>& nums, vector<int>& a, int i, int n) {\\n        int k = n-i;\\n        int size = (1<<k);\\n        a.resize(size,0);\\n        for(int j = 0;j<size;j++) {\\n            for(int b = 0;b<k;b++) {\\n                if((1<<b)&j) {\\n                    continue;\\n                }\\n                int next = (1<<b)|j;\\n                a[next] += nums[i+b];\\n            }\\n        }\\n        sort(a.begin(), a.end());\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int m = n/2;\\n        vector<int> left, right;\\n        buildPermutation(nums, left, 0, m);\\n        buildPermutation(nums, right, m, n);\\n        int ret = 2e9+1;\\n        int j = right.size();\\n        for(auto a: left) {\\n            int target = goal - a;\\n            j = distance(right.begin(), lower_bound(right.begin(), right.begin()+j, target));\\n            if(j < right.size()) {\\n                int b = right[j];\\n                ret = min(ret, abs(a + b - goal));\\n            }\\n            if(j != 0) {\\n                int b = right[j-1];\\n                ret = min(ret, abs(a + b - goal));\\n            }\\n            if(ret == 0) {\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<set<int>> f(n+1);\\n        f[0].insert(0);\\n        int ret = abs(goal);\\n        for(int i = 1;i<=n;i++) {\\n            for(auto x: f[i-1]) {\\n                int score;\\n                score = abs(x - goal);\\n                if(score < ret || x < goal || true) {\\n                    f[i].insert(x);\\n                }\\n                score = abs(nums[i-1] - goal);\\n                if(score < ret || nums[i-1] < goal) {\\n                    ret = min(ret, score);\\n                    f[i].insert(nums[i-1]);\\n                }\\n                auto sum = x + nums[i-1];\\n                score = abs(sum - goal);\\n                if(score < ret || sum < goal) {\\n                    ret = min(ret, score);\\n                    f[i].insert(sum);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void buildPermutation(vector<int>& nums, vector<int>& a, int i, int n) {\\n        int k = n-i;\\n        int size = (1<<k);\\n        a.resize(size,0);\\n        for(int j = 0;j<size;j++) {\\n            for(int b = 0;b<k;b++) {\\n                if((1<<b)&j) {\\n                    continue;\\n                }\\n                int next = (1<<b)|j;\\n                a[next] += nums[i+b];\\n            }\\n        }\\n        sort(a.begin(), a.end());\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        int m = n/2;\\n        vector<int> left, right;\\n        buildPermutation(nums, left, 0, m);\\n        buildPermutation(nums, right, m, n);\\n        int ret = 2e9+1;\\n        int j = right.size();\\n        for(auto a: left) {\\n            int target = goal - a;\\n            j = distance(right.begin(), lower_bound(right.begin(), right.begin()+j, target));\\n            if(j < right.size()) {\\n                int b = right[j];\\n                ret = min(ret, abs(a + b - goal));\\n            }\\n            if(j != 0) {\\n                int b = right[j-1];\\n                ret = min(ret, abs(a + b - goal));\\n            }\\n            if(ret == 0) {\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042461,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the minimum absolute difference between the sum of a subset of a given list of integers and a given goal. The intuition behind solving this problem is to use a depth-first search (DFS) algorithm to generate all possible subsets of the given list, and then use these subsets to calculate the minimum absolute difference between their sum and the given goal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used to solve this problem is to first split the given list of integers into two halves, and use DFS to generate all possible subsets of each half. Then, sort these subsets in ascending order, and use two pointers to find the minimum absolute difference between the sum of a subset from one half and a subset from the other half and the given goal.\\n\\n# Complexity\\n- Time complexity: $$O(2^{n/2})$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ndue to generating all possible subsets of each half of the list using DFS, and $$O(n/2)$$ for sorting the subsets, and $$O(n/2)$$ for finding the minimum absolute difference using the two pointers, resulting in a total time complexity of $$O(2^{n/2} + n)$$.\\n- Space complexity: $$O(2^{n/2})$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ndue to storing all possible subsets of each half of the list in memory.\\n# Code\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def dfs(nums, i, s):\\n            if i == len(nums):\\n                return [s]\\n            return dfs(nums, i + 1, s) + dfs(nums, i + 1, s + nums[i])\\n        n = len(nums)\\n        left = dfs(nums[:n // 2], 0, 0)\\n        right = dfs(nums[n // 2:], 0, 0)\\n        left.sort()\\n        right.sort()\\n        ans = float(\\'inf\\')\\n        j = len(right) - 1\\n        for x in left:\\n            while j >= 0 and x + right[j] > goal:\\n                j -= 1\\n            if j >= 0:\\n                ans = min(ans, abs(x + right[j] - goal))\\n            if j + 1 < len(right):\\n                ans = min(ans, abs(x + right[j + 1] - goal))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def dfs(nums, i, s):\\n            if i == len(nums):\\n                return [s]\\n            return dfs(nums, i + 1, s) + dfs(nums, i + 1, s + nums[i])\\n        n = len(nums)\\n        left = dfs(nums[:n // 2], 0, 0)\\n        right = dfs(nums[n // 2:], 0, 0)\\n        left.sort()\\n        right.sort()\\n        ans = float(\\'inf\\')\\n        j = len(right) - 1\\n        for x in left:\\n            while j >= 0 and x + right[j] > goal:\\n                j -= 1\\n            if j >= 0:\\n                ans = min(ans, abs(x + right[j] - goal))\\n            if j + 1 < len(right):\\n                ans = min(ans, abs(x + right[j + 1] - goal))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027003,
                "title": "c-meet-in-the-middle",
                "content": "# Complexity\\n- Time complexity: $$O(n * 2^{n/2})$$\\n- Space complexity: $$O(2^{n/2})$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinAbsDifference(int[] nums, int goal)\\n    {\\n        int n = nums.Length;\\n\\n        if (n == 1)\\n        {\\n            return Math.Min(Math.Abs(goal), Math.Abs(goal - nums[0]));\\n        }\\n\\n        var list1 = Build(nums, 0, (n - 1) / 2);\\n        var list2 = Build(nums, (n + 1) / 2, n - 1);\\n\\n        list2.Sort();\\n\\n        int min = int.MaxValue;\\n\\n        foreach (int sum1 in list1)\\n        {\\n            int start = 0;\\n            int end = list2.Count - 1;\\n\\n            int mid;\\n            while (start + 1 < end)\\n            {\\n                mid = start + (end - start) / 2;\\n\\n                if (list2[mid] <= goal - sum1)\\n                {\\n                    start = mid;\\n                }\\n                else\\n                {\\n                    end = mid;\\n                }\\n            }\\n\\n            int sum2 = list2[start];\\n            min = Math.Min(min, Math.Abs(sum1 + sum2 - goal));\\n\\n            sum2 = list2[end];\\n            min = Math.Min(min, Math.Abs(sum1 + sum2 - goal));\\n        }\\n\\n        return min;\\n    }\\n\\n    private List<int> Build(int[] nums, int l, int r)\\n    {\\n        int n = r - l + 1;\\n\\n        var list = new List<int>();\\n\\n        int sum;\\n        for (int mask = 0; mask < 1 << n; mask++)\\n        {\\n            sum = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (((mask >> i) & 1) > 0)\\n                {\\n                    sum += nums[l + i];\\n                }\\n            }\\n\\n            list.Add(sum);\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinAbsDifference(int[] nums, int goal)\\n    {\\n        int n = nums.Length;\\n\\n        if (n == 1)\\n        {\\n            return Math.Min(Math.Abs(goal), Math.Abs(goal - nums[0]));\\n        }\\n\\n        var list1 = Build(nums, 0, (n - 1) / 2);\\n        var list2 = Build(nums, (n + 1) / 2, n - 1);\\n\\n        list2.Sort();\\n\\n        int min = int.MaxValue;\\n\\n        foreach (int sum1 in list1)\\n        {\\n            int start = 0;\\n            int end = list2.Count - 1;\\n\\n            int mid;\\n            while (start + 1 < end)\\n            {\\n                mid = start + (end - start) / 2;\\n\\n                if (list2[mid] <= goal - sum1)\\n                {\\n                    start = mid;\\n                }\\n                else\\n                {\\n                    end = mid;\\n                }\\n            }\\n\\n            int sum2 = list2[start];\\n            min = Math.Min(min, Math.Abs(sum1 + sum2 - goal));\\n\\n            sum2 = list2[end];\\n            min = Math.Min(min, Math.Abs(sum1 + sum2 - goal));\\n        }\\n\\n        return min;\\n    }\\n\\n    private List<int> Build(int[] nums, int l, int r)\\n    {\\n        int n = r - l + 1;\\n\\n        var list = new List<int>();\\n\\n        int sum;\\n        for (int mask = 0; mask < 1 << n; mask++)\\n        {\\n            sum = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (((mask >> i) & 1) > 0)\\n                {\\n                    sum += nums[l + i];\\n                }\\n            }\\n\\n            list.Add(sum);\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985831,
                "title": "bitmask-meet-in-the-middle-c-simple-short-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        ll n=nums.size(),m=n/2+(n&1?1:0),answer=INT_MAX;\\n        vector<ll>container1,container2;\\n        for(ll i=0;i<(1<<m);i++){\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(i&(1LL<<j)){\\n                    sum+=nums[j];\\n                }\\n            }\\n            container1.push_back(sum);\\n        }\\n        for(ll i=0;i<(1LL<<(n/2));i++){\\n            ll sum=0;\\n            for(ll j=0;j<n/2;j++){\\n                if(i&(1LL<<j)){\\n                    sum+=nums[j+n/2+(n&1?1:0)];\\n                }\\n            }\\n            container2.push_back(sum);\\n        }\\n        sort(container2.begin(),container2.end());\\n        n=container1.size(),m=container2.size();\\n        for(ll i=0;i<n;i++){\\n            ll target=goal-container1[i];\\n            ll index=lower_bound(container2.begin(),container2.end(),target)-container2.begin();\\n            if(index==m){\\n                answer=min(answer,abs(goal-container1[i]-container2[index-1]));\\n            }\\n            else if(index==0){\\n                answer=min(answer,abs(goal-container1[i]-container2[0]));\\n            }\\n            else{\\n                answer=min(answer,abs(goal-container1[i]-container2[index]));\\n                answer=min(answer,abs(goal-container1[i]-container2[index-1]));\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        ll n=nums.size(),m=n/2+(n&1?1:0),answer=INT_MAX;\\n        vector<ll>container1,container2;\\n        for(ll i=0;i<(1<<m);i++){\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(i&(1LL<<j)){\\n                    sum+=nums[j];\\n                }\\n            }\\n            container1.push_back(sum);\\n        }\\n        for(ll i=0;i<(1LL<<(n/2));i++){\\n            ll sum=0;\\n            for(ll j=0;j<n/2;j++){\\n                if(i&(1LL<<j)){\\n                    sum+=nums[j+n/2+(n&1?1:0)];\\n                }\\n            }\\n            container2.push_back(sum);\\n        }\\n        sort(container2.begin(),container2.end());\\n        n=container1.size(),m=container2.size();\\n        for(ll i=0;i<n;i++){\\n            ll target=goal-container1[i];\\n            ll index=lower_bound(container2.begin(),container2.end(),target)-container2.begin();\\n            if(index==m){\\n                answer=min(answer,abs(goal-container1[i]-container2[index-1]));\\n            }\\n            else if(index==0){\\n                answer=min(answer,abs(goal-container1[i]-container2[0]));\\n            }\\n            else{\\n                answer=min(answer,abs(goal-container1[i]-container2[index]));\\n                answer=min(answer,abs(goal-container1[i]-container2[index-1]));\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921262,
                "title": "after-you-learn-about-meet-in-the-middle-here-is-an-extra-showing-a-way-to-sum-the-combinations",
                "content": "# Intuition\\nUsually I use backtrack to do the sums, but here is an alternative based on prefix-sum\\n\\n# Approach\\nSimilar to prefix sum, but use the \"combination\" as the index;\\n\\n# Complexity\\n- Time complexity:\\n$$O(POW(2,n/2))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/f010ee2b-0149-483c-a173-65a25cb7d317_1671274616.0475695.png)\\n\\n```java\\nclass Solution {\\n\\n    public static int minAbsDifference(int[] nums, int goal) {\\n\\n        // left sum using DP\\n        int[] sumLeft = new int[1 << nums.length/2]; // there are 2^leftSize combinations\\n        // We start from 1 as the null combination is trivial and would\\n        // create a loop in the while (any AND with 0 will always be 0)\\n        for (int i = 1; i < sumLeft.length; i++) {\\n            int index = 0;\\n            while ((i & (1 << index)) == 0) index++;\\n            // sum[COMB(1101)] = nums[1] + sum[COMB(1100)]\\n            // Sums with digits 4, 3 and 1 is the sum of digits 4 and 3 plus digit 1.\\n            // Same idea as the prefix sum, but in this case the index is the combination.\\n            sumLeft[i] = nums[index] + sumLeft[i ^ (1 << index)];\\n        }\\n\\n        // right sum using DP\\n        int[] sumRight = new int[1 << nums.length-nums.length/2]; // there are 2^(totalSize-leftSize) combinations\\n        for (int i = 1; i < sumRight.length; i++) {\\n            int index = 0;\\n            while ((i & (1 << index)) == 0) index++;\\n            sumRight[i] = nums[index + nums.length/2] + sumRight[i ^ (1 << (index))];\\n        }\\n\\n        Arrays.sort(sumLeft);\\n        Arrays.sort(sumRight);\\n\\n        int min = Integer.MAX_VALUE;\\n        int a = 0;\\n        int b = sumRight.length - 1;\\n        while (a<sumLeft.length && b>-1) {\\n            int sum=sumLeft[a]+sumRight[b];\\n            min = Math.min(min, Math.abs(sum - goal));\\n            if (sum == goal) return 0;\\n            else if (sum > goal) b--;\\n            else a++;\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n# Backtrack alternative for comparision\\n![image.png](https://assets.leetcode.com/users/images/249b15c8-b7dc-49bc-890d-8f531a044432_1671275716.955563.png)\\n\\n```java\\nclass Solution {\\n    int[] nums;\\n    int index=0;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        if(nums.length==1) return Math.min(Math.abs(goal),Math.abs(goal-nums[0]));\\n        this.nums=nums;\\n        int[] l = new int[1 << (nums.length/2)];\\n        int[] r = new int[1 << (nums.length - nums.length/2)];\\n        sums(0,nums.length/2-1,0,l);\\n        index=0;\\n        sums(nums.length/2,nums.length-1,0,r);\\n\\n        Arrays.sort(l);\\n        Arrays.sort(r);\\n\\n        int a=0, b=r.length-1;\\n        int min = Integer.MAX_VALUE;\\n        while(a<l.length&&b>-1) {\\n            int la=l[a], rb=r[b];\\n            min=Math.min(min,Math.abs(goal-la-rb));\\n            if(la+rb>goal) b--;\\n            else if(la+rb<goal) a++;\\n            else return 0;\\n        }\\n        return min;\\n    }\\n\\n   void sums(int i, int j, int sum, int[] l) {\\n        if(i>j) {\\n            l[index++]=sum;\\n            return;\\n        }\\n        sums(i+1,j,sum,l);\\n        sums(i+1,j,sum+nums[i],l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n\\n    public static int minAbsDifference(int[] nums, int goal) {\\n\\n        // left sum using DP\\n        int[] sumLeft = new int[1 << nums.length/2]; // there are 2^leftSize combinations\\n        // We start from 1 as the null combination is trivial and would\\n        // create a loop in the while (any AND with 0 will always be 0)\\n        for (int i = 1; i < sumLeft.length; i++) {\\n            int index = 0;\\n            while ((i & (1 << index)) == 0) index++;\\n            // sum[COMB(1101)] = nums[1] + sum[COMB(1100)]\\n            // Sums with digits 4, 3 and 1 is the sum of digits 4 and 3 plus digit 1.\\n            // Same idea as the prefix sum, but in this case the index is the combination.\\n            sumLeft[i] = nums[index] + sumLeft[i ^ (1 << index)];\\n        }\\n\\n        // right sum using DP\\n        int[] sumRight = new int[1 << nums.length-nums.length/2]; // there are 2^(totalSize-leftSize) combinations\\n        for (int i = 1; i < sumRight.length; i++) {\\n            int index = 0;\\n            while ((i & (1 << index)) == 0) index++;\\n            sumRight[i] = nums[index + nums.length/2] + sumRight[i ^ (1 << (index))];\\n        }\\n\\n        Arrays.sort(sumLeft);\\n        Arrays.sort(sumRight);\\n\\n        int min = Integer.MAX_VALUE;\\n        int a = 0;\\n        int b = sumRight.length - 1;\\n        while (a<sumLeft.length && b>-1) {\\n            int sum=sumLeft[a]+sumRight[b];\\n            min = Math.min(min, Math.abs(sum - goal));\\n            if (sum == goal) return 0;\\n            else if (sum > goal) b--;\\n            else a++;\\n        }\\n        return min;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int[] nums;\\n    int index=0;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        if(nums.length==1) return Math.min(Math.abs(goal),Math.abs(goal-nums[0]));\\n        this.nums=nums;\\n        int[] l = new int[1 << (nums.length/2)];\\n        int[] r = new int[1 << (nums.length - nums.length/2)];\\n        sums(0,nums.length/2-1,0,l);\\n        index=0;\\n        sums(nums.length/2,nums.length-1,0,r);\\n\\n        Arrays.sort(l);\\n        Arrays.sort(r);\\n\\n        int a=0, b=r.length-1;\\n        int min = Integer.MAX_VALUE;\\n        while(a<l.length&&b>-1) {\\n            int la=l[a], rb=r[b];\\n            min=Math.min(min,Math.abs(goal-la-rb));\\n            if(la+rb>goal) b--;\\n            else if(la+rb<goal) a++;\\n            else return 0;\\n        }\\n        return min;\\n    }\\n\\n   void sums(int i, int j, int sum, int[] l) {\\n        if(i>j) {\\n            l[index++]=sum;\\n            return;\\n        }\\n        sums(i+1,j,sum,l);\\n        sums(i+1,j,sum+nums[i],l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873570,
                "title": "python-simple-meet-in-the-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        def dfs(nums):\\n            ans = {0}\\n\\n            for i in nums:\\n                ans |= {i+j for j in ans}\\n            return ans\\n\\n        ans1 = dfs(nums[:len(nums)//2])\\n        ans2 = sorted(dfs(nums[len(nums)//2:]))\\n\\n        min_diff = float(\"inf\")\\n\\n        for i in ans1:\\n            target = goal-i\\n            \\n            idx = bisect_left(ans2,target)\\n\\n            if idx<len(ans2):\\n                min_diff = min(min_diff,abs(target-ans2[idx]))\\n            if idx>0:\\n                min_diff = min(min_diff,abs(target-ans2[idx-1]))\\n\\n        return min_diff\\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        def dfs(nums):\\n            ans = {0}\\n\\n            for i in nums:\\n                ans |= {i+j for j in ans}\\n            return ans\\n\\n        ans1 = dfs(nums[:len(nums)//2])\\n        ans2 = sorted(dfs(nums[len(nums)//2:]))\\n\\n        min_diff = float(\"inf\")\\n\\n        for i in ans1:\\n            target = goal-i\\n            \\n            idx = bisect_left(ans2,target)\\n\\n            if idx<len(ans2):\\n                min_diff = min(min_diff,abs(target-ans2[idx]))\\n            if idx>0:\\n                min_diff = min(min_diff,abs(target-ans2[idx-1]))\\n\\n        return min_diff\\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822897,
                "title": "bitmasking-meet-in-the-middle-binary-search-akash-kumar-terror-musky",
                "content": "I have divided array into two parts by taking care of the constraint. since n=40. so in the worst case our half would be 20. then we take two array left and right which will hold the sum of all the subset. which means we can either take x element from the left array and remaing element from the right array. since we have to minimise the absolute distance between goal then i brute force on the left array and search for the target=goal-left[i] in the right subarray.\\nfor searching in right we need just closer value to the target so that total sum would be minimised. that\\'s why I have apply binary search.\\n\\nBelow Is the implementation of my logic.\\n```\\nclass Solution {\\npublic:\\nvector<long long> Combinational_Sum(vector<int> &nums, int n, int base){\\n       \\n        long long mask=pow(2,n)-1;\\n        vector<long long> temp;\\n        for(long long i=0;i<=mask;i++)\\n        {\\n            long long sum=0LL;\\n            for(long long bit=0;bit<n;bit++)\\n            {\\n                long long shift=1<<bit;\\n                if(shift&i)\\n                sum+=nums[bit+base];\\n                \\n            }\\n            temp.push_back(sum);\\n        }\\n        \\n        return temp;\\n    }\\n int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        // sort(nums.begin(),nums.end());\\n        vector<long long> left,right;\\n        int ls=nums.size()/2,rs=nums.size()-ls;\\n        left=Combinational_Sum(nums,ls,0);right=Combinational_Sum(nums,rs,ls);\\n        sort(right.begin(),right.end());\\n    \\n        long long ans=1e18;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            long long key=goal-left[i],prev=goal,curr=goal,optimal;\\n            //it will give the next greater or equal value to the key.\\n            long long lb=lower_bound(right.begin(),right.end(),key)-right.begin();\\n            \\n            if(right.size()==1)\\n             prev=curr=right[0];\\n            else\\n            {\\n                if(lb==0)\\n                    prev=curr=right[lb];\\n                else\\n                    prev=right[lb-1],curr=(lb!=right.size()?right[lb]:prev);\\n            }\\n        \\n            long long ans1=abs(goal-(left[i]+prev)),ans2=abs(goal-(left[i]+curr));\\n            \\n            optimal=min(ans1,ans2);\\n            ans=min(optimal,ans);\\n           \\n            \\n        }\\n     return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> Combinational_Sum(vector<int> &nums, int n, int base){\\n       \\n        long long mask=pow(2,n)-1;\\n        vector<long long> temp;\\n        for(long long i=0;i<=mask;i++)\\n        {\\n            long long sum=0LL;\\n            for(long long bit=0;bit<n;bit++)\\n            {\\n                long long shift=1<<bit;\\n                if(shift&i)\\n                sum+=nums[bit+base];\\n                \\n            }\\n            temp.push_back(sum);\\n        }\\n        \\n        return temp;\\n    }\\n int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        // sort(nums.begin(),nums.end());\\n        vector<long long> left,right;\\n        int ls=nums.size()/2,rs=nums.size()-ls;\\n        left=Combinational_Sum(nums,ls,0);right=Combinational_Sum(nums,rs,ls);\\n        sort(right.begin(),right.end());\\n    \\n        long long ans=1e18;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            long long key=goal-left[i],prev=goal,curr=goal,optimal;\\n            //it will give the next greater or equal value to the key.\\n            long long lb=lower_bound(right.begin(),right.end(),key)-right.begin();\\n            \\n            if(right.size()==1)\\n             prev=curr=right[0];\\n            else\\n            {\\n                if(lb==0)\\n                    prev=curr=right[lb];\\n                else\\n                    prev=right[lb-1],curr=(lb!=right.size()?right[lb]:prev);\\n            }\\n        \\n            long long ans1=abs(goal-(left[i]+prev)),ans2=abs(goal-(left[i]+curr));\\n            \\n            optimal=min(ans1,ans2);\\n            ans=min(optimal,ans);\\n           \\n            \\n        }\\n     return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818506,
                "title": "python-easy-to-read-and-understand-binary-search",
                "content": "**BRUTE-FORCE**\\n```\\nclass Solution:\\n    # @lru_cache\\n    def solve(self, nums, i, sums, path, goal):\\n        if i == len(nums):\\n            # print(path, sums)\\n            self.res = min(self.res, abs(sums - goal))\\n            return\\n        self.solve(nums, i + 1, sums + nums[i], path + [nums[i]], goal)\\n        self.solve(nums, i + 1, sums, path, goal)\\n\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        self.res = float(\"inf\")\\n        self.solve(nums, 0, 0, [], goal)\\n        return self.res\\n```\\n\\n**BInARY-SEARCH**\\n```\\nclass Solution:\\n    def solve(self, nums, i, val, sums):\\n        if i == len(nums):\\n            sums.append(val)\\n            return\\n        self.solve(nums, i+1, val+nums[i], sums)\\n        self.solve(nums, i+1, val, sums)\\n        \\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n        sum1, sum2 = [], []\\n        self.solve(nums[:n//2], 0, 0, sum1)\\n        self.solve(nums[n//2:], 0, 0, sum2)\\n        \\n        sum2 = sorted(sum2)\\n        #print(sum1, sum2)\\n        n2 = len(sum2)\\n        ans = float(\"inf\")\\n        for s in sum1:\\n            rem = goal-s\\n            i = bisect_left(sum2, rem)\\n            if i < n2:\\n                ans = min(ans, abs(rem-sum2[i]))\\n            if i > 0:\\n                ans = min(ans, abs(rem-sum2[i-1]))\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    # @lru_cache\\n    def solve(self, nums, i, sums, path, goal):\\n        if i == len(nums):\\n            # print(path, sums)\\n            self.res = min(self.res, abs(sums - goal))\\n            return\\n        self.solve(nums, i + 1, sums + nums[i], path + [nums[i]], goal)\\n        self.solve(nums, i + 1, sums, path, goal)\\n\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        self.res = float(\"inf\")\\n        self.solve(nums, 0, 0, [], goal)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767248,
                "title": "java-solution-using-meet-in-the-middle-approach",
                "content": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int size = (nums.length + 1) / 2;\\n        int set1[] = new int[size];\\n        int set2[] = new int[size];\\n        for(int i=0;i<nums.length;i++){\\n            if(i < size){\\n                set1[i] = nums[i];\\n            }else{\\n                set2[i-size] = nums[i];\\n            }\\n        }\\n        List<Integer> perm1 = generateAllPermutation(set1);\\n        List<Integer> perm2 = generateAllPermutation(set2);\\n        Collections.sort(perm2);\\n        int ans = Integer.MAX_VALUE;\\n        for(int num : perm1){\\n            int find = goal - num;\\n            int search = Collections.binarySearch(perm2,find);\\n            if(search >= 0){\\n                return 0;\\n            }\\n            int idx = -(search + 1);\\n            if(idx < perm2.size()){\\n                ans = Math.min(ans, Math.abs(find-perm2.get(idx)));    \\n            }\\n            idx--;\\n            if(idx >= 0) \\n                ans = Math.min(ans, Math.abs(find-perm2.get(idx)));    \\n        }\\n        return ans;        \\n    }\\n    \\n    List<Integer> generateAllPermutation(int[] set1){\\n        List<Integer> sum = new ArrayList<>();\\n        for(int i=0; i<(1<<set1.length);i++){\\n            int k = 0;\\n            int local = 0;\\n            while(k < set1.length){\\n                if((i&(1<<k)) != 0){\\n                    local += set1[k];\\n                }\\n                k++;\\n            }\\n            sum.add(local);\\n        }\\n        return sum;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int size = (nums.length + 1) / 2;\\n        int set1[] = new int[size];\\n        int set2[] = new int[size];\\n        for(int i=0;i<nums.length;i++){\\n            if(i < size){\\n                set1[i] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2759222,
                "title": "python-dfs-solution-divide-in-half",
                "content": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        sz, ans, left, right = len(nums), inf, [], []\\n        \\n        def solve(idx: int, limit: int, total: int, sums: List[int]) -> None:\\n            nonlocal nums\\n            if idx == limit:\\n                sums.append(total)\\n                return\\n            solve(idx + 1, limit, total, sums) \\n            solve(idx + 1, limit, total + nums[idx], sums)\\n        \\n        def search(left: List[int], right: List[int], target: int) -> None:\\n            nonlocal ans\\n            leftPtr, rightPtr = 0, len(right) - 1\\n            while leftPtr < len(left) and rightPtr >= 0:\\n                ss = left[leftPtr] + right[rightPtr]\\n                ans = min(ans , abs(target - ss)) ; \\n                if ss < target:\\n                    leftPtr += 1\\n                elif ss > target:\\n                    rightPtr -= 1\\n                else: break \\n        \\n        solve(0, sz // 2 + 1, 0, left) \\n        solve(sz // 2 + 1, sz, 0, right)\\n        for i in range(len(left)):\\n            ans = min(ans , abs(goal - left[i]))\\n        for i in range(len(right)):\\n            ans = min(ans , abs(goal - right[i]))\\n        left.sort(); right.sort()\\n        search(left, right, goal)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        sz, ans, left, right = len(nums), inf, [], []\\n        \\n        def solve(idx: int, limit: int, total: int, sums: List[int]) -> None:\\n            nonlocal nums\\n            if idx == limit:\\n                sums.append(total)\\n                return\\n            solve(idx + 1, limit, total, sums) \\n            solve(idx + 1, limit, total + nums[idx], sums)\\n        \\n        def search(left: List[int], right: List[int], target: int) -> None:\\n            nonlocal ans\\n            leftPtr, rightPtr = 0, len(right) - 1\\n            while leftPtr < len(left) and rightPtr >= 0:\\n                ss = left[leftPtr] + right[rightPtr]\\n                ans = min(ans , abs(target - ss)) ; \\n                if ss < target:\\n                    leftPtr += 1\\n                elif ss > target:\\n                    rightPtr -= 1\\n                else: break \\n        \\n        solve(0, sz // 2 + 1, 0, left) \\n        solve(sz // 2 + 1, sz, 0, right)\\n        for i in range(len(left)):\\n            ans = min(ans , abs(goal - left[i]))\\n        for i in range(len(right)):\\n            ans = min(ans , abs(goal - right[i]))\\n        left.sort(); right.sort()\\n        search(left, right, goal)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720845,
                "title": "scala-two-sum-approach",
                "content": "```\\nobject Solution {\\n    def minAbsDifference(nums: Array[Int], goal: Int): Int = {\\n        //If we just brute force and generate all sums of subsequences of the origial array, the time complexity would be O(2^n) which is too slow for n=40. Instead we can break the array in half and generate all possible sums of each half. For each possible sum of the 1st half, we binary seach for the sum in the 2nd half that gives the closest value to goal. Time complexity: O(n2^(n/2))\\n        import scala.collection.mutable.Set\\n        var min=java.lang.Long.MAX_VALUE //Long.MaxValue is scala type, use java.lang.Long for MAX_VALUE\\n        def genSum(i:Int=0,e:Int=nums.length/2, sum:Long=0, set:Set[Long]):Set[Long]={\\n            if (i==e)  set+=sum  //e is the STOP sign\\n            else {\\n                genSum(i+1, e, sum+nums(i),set)\\n                genSum(i+1, e, sum,set)\\n            } \\n            set\\n        }\\n        val set1=genSum(0,nums.length/2,0,Set[Long]())\\n        val arr2=genSum(nums.length/2,nums.length,0,Set[Long]()).toArray[Long].sorted\\n        object Bound extends Enumeration {\\n            type Bound=Value\\n            val Lower,Upper=Value\\n        }\\n        import Bound._\\n        //be careful that Array.search(x) does not return lower_bound or upper_bound in Scala, Array(1,2,2,2,3).search(2) returns Found(2), not Found(1)\\n        def binsearch(t:Long,bound:Bound) = {\\n            arr2.search(t) match {\\n                case i:scala.collection.Searching.InsertionPoint =>  arr2((i.insertionPoint+(if (bound==Upper) 0 else -1)).min(arr2.length-1).max(0))\\n                case f:scala.collection.Searching.Found =>  arr2(f.insertionPoint)\\n            }\\n        }\\n        for (s <- set1) { //iterate over a hash Set\\n            min=math.abs(s+binsearch(goal-s,Lower)-goal).min(math.abs(s+binsearch(goal-s,Upper)-goal)).toLong.min(min)\\n        }\\n        min.toInt\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def minAbsDifference(nums: Array[Int], goal: Int): Int = {\\n        //If we just brute force and generate all sums of subsequences of the origial array, the time complexity would be O(2^n) which is too slow for n=40. Instead we can break the array in half and generate all possible sums of each half. For each possible sum of the 1st half, we binary seach for the sum in the 2nd half that gives the closest value to goal. Time complexity: O(n2^(n/2))\\n        import scala.collection.mutable.Set\\n        var min=java.lang.Long.MAX_VALUE //Long.MaxValue is scala type, use java.lang.Long for MAX_VALUE\\n        def genSum(i:Int=0,e:Int=nums.length/2, sum:Long=0, set:Set[Long]):Set[Long]={\\n            if (i==e)  set+=sum  //e is the STOP sign\\n            else {\\n                genSum(i+1, e, sum+nums(i),set)\\n                genSum(i+1, e, sum,set)\\n            } \\n            set\\n        }\\n        val set1=genSum(0,nums.length/2,0,Set[Long]())\\n        val arr2=genSum(nums.length/2,nums.length,0,Set[Long]()).toArray[Long].sorted\\n        object Bound extends Enumeration {\\n            type Bound=Value\\n            val Lower,Upper=Value\\n        }\\n        import Bound._\\n        //be careful that Array.search(x) does not return lower_bound or upper_bound in Scala, Array(1,2,2,2,3).search(2) returns Found(2), not Found(1)\\n        def binsearch(t:Long,bound:Bound) = {\\n            arr2.search(t) match {\\n                case i:scala.collection.Searching.InsertionPoint =>  arr2((i.insertionPoint+(if (bound==Upper) 0 else -1)).min(arr2.length-1).max(0))\\n                case f:scala.collection.Searching.Found =>  arr2(f.insertionPoint)\\n            }\\n        }\\n        for (s <- set1) { //iterate over a hash Set\\n            min=math.abs(s+binsearch(goal-s,Lower)-goal).min(math.abs(s+binsearch(goal-s,Upper)-goal)).toLong.min(min)\\n        }\\n        min.toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2717579,
                "title": "c-meet-in-the-middle-binary-search",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minAbsDifference(vector<int> &nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<int> a, b;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i < n / 2)\\n                a.push_back(nums[i]);\\n            else\\n                b.push_back(nums[i]);\\n        }\\n        int n1 = b.size();\\n        n = n / 2;\\n        unordered_map<long long int, int> m1, m2;\\n        vector<long long int> v1, v2;\\n        for (int i = 0; i < (int)(1 << n); i++)\\n        {\\n            long long int sum1 = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j)))\\n                {\\n                    sum1 += a[j];\\n                }\\n            }\\n            m1[sum1]++;\\n            if(m1[sum1] == 1)\\n                v1.push_back(sum1);\\n        }\\n        for (int i = 0; i < (int)(1 << n1); i++)\\n        {\\n            long long int sum2 = 0;\\n            for (int j = 0; j < n1; j++)\\n            {\\n                if ((i & (1 << j)))\\n                {\\n                    sum2 += b[j];\\n                }\\n            }\\n            m2[sum2]++;\\n            if(m2[sum2] == 1)\\n                v2.push_back(sum2); \\n        }\\n       long long int ans = LLONG_MAX;\\n       sort(v2.begin(), v2.end());\\n       for(int i = 0; i < v1.size(); i++){\\n           int loc = lower_bound(v2.begin(), v2.end(), x - v1[i]) - v2.begin();\\n           if(loc != v2.size())\\n            ans = min(ans, abs(v1[i] + v2[loc] - x));\\n           if(loc + 1 < v2.size())\\n            ans = min(ans, abs(v1[i] + v2[loc + 1] - x));\\n           if(loc - 1 >= 0)\\n            ans = min(ans, abs(v1[i] + v2[loc - 1] - x));\\n          \\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minAbsDifference(vector<int> &nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<int> a, b;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i < n / 2)\\n                a.push_back(nums[i]);\\n            else\\n                b.push_back(nums[i]);\\n        }\\n        int n1 = b.size();\\n        n = n / 2;\\n        unordered_map<long long int, int> m1, m2;\\n        vector<long long int> v1, v2;\\n        for (int i = 0; i < (int)(1 << n); i++)\\n        {\\n            long long int sum1 = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j)))\\n                {\\n                    sum1 += a[j];\\n                }\\n            }\\n            m1[sum1]++;\\n            if(m1[sum1] == 1)\\n                v1.push_back(sum1);\\n        }\\n        for (int i = 0; i < (int)(1 << n1); i++)\\n        {\\n            long long int sum2 = 0;\\n            for (int j = 0; j < n1; j++)\\n            {\\n                if ((i & (1 << j)))\\n                {\\n                    sum2 += b[j];\\n                }\\n            }\\n            m2[sum2]++;\\n            if(m2[sum2] == 1)\\n                v2.push_back(sum2); \\n        }\\n       long long int ans = LLONG_MAX;\\n       sort(v2.begin(), v2.end());\\n       for(int i = 0; i < v1.size(); i++){\\n           int loc = lower_bound(v2.begin(), v2.end(), x - v1[i]) - v2.begin();\\n           if(loc != v2.size())\\n            ans = min(ans, abs(v1[i] + v2[loc] - x));\\n           if(loc + 1 < v2.size())\\n            ans = min(ans, abs(v1[i] + v2[loc + 1] - x));\\n           if(loc - 1 >= 0)\\n            ans = min(ans, abs(v1[i] + v2[loc - 1] - x));\\n          \\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696500,
                "title": "easy-c-meet-in-the-middle",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        void fun(vector<int> &vec, int i, int sum, vector<int> &res)\\n        {\\n            if (i == vec.size())\\n            {\\n                res.push_back(sum);\\n                return;\\n            }\\n            fun(vec, i + 1, sum, res);\\n            fun(vec, i + 1, sum + vec[i], res);\\n        }\\n    int minAbsDifference(vector<int> &nums, int goal)\\n    {\\n        vector<int> vec1;\\n        vector<int> vec2;\\n        int n = nums.size();\\n        for (int i = 0; i < n / 2; i++)\\n        {\\n            vec1.push_back(nums[i]);\\n        }\\n        for (int i = n / 2; i < n; i++)\\n        {\\n            vec2.push_back(nums[i]);\\n        }\\n        vector<int> res1;\\n        vector<int> res2;\\n\\n        fun(vec1, 0, 0, res1);\\n        fun(vec2, 0, 0, res2);\\n\\n        sort(res2.begin(), res2.end());\\n\\n        int res = INT_MAX;\\n        for (auto x: res1)\\n        {\\n            auto it = lower_bound(res2.begin(), res2.end(), goal - x);\\n            res = min(res, abs(goal - x));\\n            if (it != res2.end())\\n            {\\n                int val = x + *it;\\n                res = min(res, abs(goal - val));\\n            }\\n            if (it != res2.begin())\\n            {\\n                it--;\\n                int val = x + *it;\\n                res = min(res, abs(goal - val));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        void fun(vector<int> &vec, int i, int sum, vector<int> &res)\\n        {\\n            if (i == vec.size())\\n            {\\n                res.push_back(sum);\\n                return;\\n            }\\n            fun(vec, i + 1, sum, res);\\n            fun(vec, i + 1, sum + vec[i], res);\\n        }\\n    int minAbsDifference(vector<int> &nums, int goal)\\n    {\\n        vector<int> vec1;\\n        vector<int> vec2;\\n        int n = nums.size();\\n        for (int i = 0; i < n / 2; i++)\\n        {\\n            vec1.push_back(nums[i]);\\n        }\\n        for (int i = n / 2; i < n; i++)\\n        {\\n            vec2.push_back(nums[i]);\\n        }\\n        vector<int> res1;\\n        vector<int> res2;\\n\\n        fun(vec1, 0, 0, res1);\\n        fun(vec2, 0, 0, res2);\\n\\n        sort(res2.begin(), res2.end());\\n\\n        int res = INT_MAX;\\n        for (auto x: res1)\\n        {\\n            auto it = lower_bound(res2.begin(), res2.end(), goal - x);\\n            res = min(res, abs(goal - x));\\n            if (it != res2.end())\\n            {\\n                int val = x + *it;\\n                res = min(res, abs(goal - val));\\n            }\\n            if (it != res2.begin())\\n            {\\n                it--;\\n                int val = x + *it;\\n                res = min(res, abs(goal - val));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675498,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int getMinAbsDifference(List<Integer> l1, List<Integer> l2, int target){\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int len1 = l1.size(), len2 = l2.size();\\n        for(int i=0; i<len1; i++){\\n            int x = l1.get(i), low=0, high=len2-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                int sum = x + l2.get(mid);\\n                if(sum == target){\\n                    return 0;\\n                }\\n                else if(sum < target){\\n                    low = mid+1;\\n                    max = Math.max(max,sum);\\n                }\\n                else{\\n                    high = mid-1;\\n                    min = Math.min(min,sum);\\n                }\\n            }\\n        }\\n        int result = Math.min(Math.abs(target-min),Math.abs(max-target));\\n        return result;\\n    }\\n    \\n    public List<Integer> combinationSum(int[] nums, int low, int high){\\n        List<Integer> result = new ArrayList<>();\\n        int n = high-low+1, index=0;\\n        int[] arr = new int[n];\\n        for(int i=low; i<=high; i++){\\n            arr[index++] = nums[i];\\n        }\\n        for(int i=0; i<(1<<n); i++){\\n            int sum=0;\\n            for(int j=0; j<n; j++){\\n                if((i & (1<<j))!=0){\\n                    sum += arr[j];\\n                }\\n            }\\n            result.add(sum);\\n        }\\n        return result;\\n    }\\n    \\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        int mid = (n-1)/2;\\n        List<Integer> l1 = combinationSum(nums,0,mid);\\n        List<Integer> l2 = combinationSum(nums,mid+1,n-1);\\n        Collections.sort(l2);\\n        return getMinAbsDifference(l1,l2,goal);\\n    }\\n}\\nKindly upvote if you like this solution\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n    \\n    public int getMinAbsDifference(List<Integer> l1, List<Integer> l2, int target){\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int len1 = l1.size(), len2 = l2.size();\\n        for(int i=0; i<len1; i++){\\n            int x = l1.get(i), low=0, high=len2-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                int sum = x + l2.get(mid);\\n                if(sum == target){\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2635312,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    ll n;\\n    vi(ll)f, s;\\n    ll bs(const vi(ll)&v, ll tar){\\n        ll l=0, r=v.size()-1, ans=v.size()-1;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(v[m]>=tar){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    void getSeqSum(vi(ll)&arr, const vi(int)&v, ll start, ll end){\\n        arr.pb(0);\\n        for(ll i=start;i<end;++i){\\n            ll sz=arr.size();\\n            for(ll j=0;j<sz;++j){\\n                arr.pb(arr[j]+v[i]);\\n            }\\n        }\\n    }\\n    int minAbsDifference(vector<int>&v, int tar) {\\n        n=v.size();\\n        getSeqSum(f, v, 0, n/2), getSeqSum(s, v, n/2, n);\\n        sort(f.begin(), f.end());\\n        ll ans=LLONG_MAX;\\n        for(ll i=0;i<s.size();++i){\\n            ll in=bs(f, tar-s[i]);\\n            ans=min(ans, abs(tar-s[i]-f[in]));\\n            if(in>0){\\n                ans=min(ans, abs(tar-s[i]-f[in-1]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    ll n;\\n    vi(ll)f, s;\\n    ll bs(const vi(ll)&v, ll tar){\\n        ll l=0, r=v.size()-1, ans=v.size()-1;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(v[m]>=tar){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    void getSeqSum(vi(ll)&arr, const vi(int)&v, ll start, ll end){\\n        arr.pb(0);\\n        for(ll i=start;i<end;++i){\\n            ll sz=arr.size();\\n            for(ll j=0;j<sz;++j){\\n                arr.pb(arr[j]+v[i]);\\n            }\\n        }\\n    }\\n    int minAbsDifference(vector<int>&v, int tar) {\\n        n=v.size();\\n        getSeqSum(f, v, 0, n/2), getSeqSum(s, v, n/2, n);\\n        sort(f.begin(), f.end());\\n        ll ans=LLONG_MAX;\\n        for(ll i=0;i<s.size();++i){\\n            ll in=bs(f, tar-s[i]);\\n            ans=min(ans, abs(tar-s[i]-f[in]));\\n            if(in>0){\\n                ans=min(ans, abs(tar-s[i]-f[in-1]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631399,
                "title": "java-meet-in-the-middle",
                "content": "# class Solution {\\n    public static int closestSubSum(List<Integer> s1, List<Integer> s2, int target) {\\n        int max = Integer.MIN_VALUE,min=Integer.MAX_VALUE, len1 = s1.size(), len2 = s2.size();\\n        for (int i = 0; i < len1; i++) {\\n            int x = s1.get(i), low = 0, high = len2 - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                int sum = x + s2.get(mid);\\n                if(sum == target){\\n                    return 0;\\n                }\\n                if (sum > target) {\\n                    min = Math.min(min,sum);\\n                    high = mid - 1;\\n                } else {\\n                    max = Math.max(max,sum);\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        int res = Math.min(Math.abs(max-target),Math.abs(min-target));\\n        return res;\\n    }\\n    public static List<Integer> possibleSum(int[] nums, int low, int high, int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int totEle = (high - low) + 1, index = 0;\\n        int[] arr = new int[totEle];\\n        for (int i = low; i <= high; i++) {\\n            arr[index++] = nums[i];\\n        }\\n        for (int i = 0; i < (1 << totEle); i++) {\\n            int sum = 0;\\n            for (int j = 0; j < totEle; j++) {\\n                if ((i & (1 << j)) > 0) {\\n                    sum += arr[j];\\n                }\\n            }\\n            res.add(sum);\\n        }\\n        return res;\\n    }\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        int mid = (n-1)/2;\\n        List<Integer> s1 = possibleSum(nums, 0, mid, n);\\n        List<Integer> s2 = possibleSum(nums, mid + 1, n - 1, n);\\n        Collections.sort(s2);\\n        return closestSubSum(s1,s2,goal);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int closestSubSum(List<Integer> s1, List<Integer> s2, int target) {\\n        int max = Integer.MIN_VALUE,min=Integer.MAX_VALUE, len1 = s1.size(), len2 = s2.size();\\n        for (int i = 0; i < len1; i++) {\\n            int x = s1.get(i), low = 0, high = len2 - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                int sum = x + s2.get(mid);\\n                if(sum == target){\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2616726,
                "title": "python-meet-in-the-middle-sorting-2-pointers-no-binary-search-faster-than-80",
                "content": "```\\nclass Solution:\\n    def minAbsDifference(self, y: List[int], t: int) -> int:\\n        def f(i,s,limit):\\n            if i==limit:\\n                se.add(s)\\n                return\\n            f(i+1,s,limit)\\n            f(i+1,s+y[i],limit)\\n        se=set()\\n        n=len(y)\\n        f(0,0,n//2)\\n        x=sorted(se)\\n        se=set()\\n        f(n//2,0,n)\\n        n=len(x)\\n        ans=inf\\n        j=0\\n        for i in sorted(se,reverse=True):\\n            while j<n and x[j]+i<=t:\\n                j+=1\\n            if j!=0:\\n                ans=min(ans,abs(x[j-1]+i-t))\\n            if j!=n:\\n                ans=min(ans,abs(x[j]+i-t))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, y: List[int], t: int) -> int:\\n        def f(i,s,limit):\\n            if i==limit:\\n                se.add(s)\\n                return\\n            f(i+1,s,limit)\\n            f(i+1,s+y[i],limit)\\n        se=set()\\n        n=len(y)\\n        f(0,0,n//2)\\n        x=sorted(se)\\n        se=set()\\n        f(n//2,0,n)\\n        n=len(x)\\n        ans=inf\\n        j=0\\n        for i in sorted(se,reverse=True):\\n            while j<n and x[j]+i<=t:\\n                j+=1\\n            if j!=0:\\n                ans=min(ans,abs(x[j-1]+i-t))\\n            if j!=n:\\n                ans=min(ans,abs(x[j]+i-t))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611294,
                "title": "meet-in-middle-binarysearch-explained-python",
                "content": "```\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        #2^n subsequences, 2^40 is too large to generate all subsequences\\n        #u can also choose empty subsequence\\n        \\n        if not goal or goal in nums: return 0\\n        \\n        n = len(nums)\\n        #apply the meet in the middle algo to reduce time complexity from 2^n to 2^(n/2)\\n        #divide array in half\\n        a = nums[:n//2]; b = nums[n//2:]\\n        #now generate all possible subset sums for each array\\n        def generateSubsetSums(elements):\\n            subsets = set([0])\\n            for element in elements:\\n                subsets |= {subset + element for subset in subsets}\\n            return list(subsets)\\n        a_subsetSums = generateSubsetSums(a); b_subsetSums = generateSubsetSums(b)\\n        #now sort the subsetSums\\n        b_subsetSums.sort() #only one of them needs to be sorted\\n        #now we just need to find a pair (one from each subsetSums) thats closest to goal\\n        #double for-loop will bring the time complexity back to 2^N, so we do binary search to find the most suitable second pair element\\n        ans = abs(goal)\\n        for a_sum in a_subsetSums:\\n            #apply binary search to find most suitable pair the in the subsetSum\\n            #first binary Search is trying to find closest sum <= goal\\n            L = 0; R = len(b_subsetSums)-1\\n            while L < R:\\n                M = (L+R+1)//2\\n                if a_sum + b_subsetSums[M] <= goal:\\n                    L = M\\n                else:\\n                    R = M-1\\n            \\n            ans = min(ans, abs(goal - a_sum - b_subsetSums[L])) #abs is necesarry because for some elements it might be impossible to find a positive pair\\n            #you should also test for closest sum >= goal\\n            if L+1<len(b_subsetSums): ans = min(ans, abs(b_subsetSums[L+1] + a_sum - goal))\\n            \\n            if not ans: break\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        #2^n subsequences, 2^40 is too large to generate all subsequences\\n        #u can also choose empty subsequence\\n        \\n        if not goal or goal in nums: return 0\\n        \\n        n = len(nums)\\n        #apply the meet in the middle algo to reduce time complexity from 2^n to 2^(n/2)\\n        #divide array in half\\n        a = nums[:n//2]; b = nums[n//2:]\\n        #now generate all possible subset sums for each array\\n        def generateSubsetSums(elements):\\n            subsets = set([0])\\n            for element in elements:\\n                subsets |= {subset + element for subset in subsets}\\n            return list(subsets)\\n        a_subsetSums = generateSubsetSums(a); b_subsetSums = generateSubsetSums(b)\\n        #now sort the subsetSums\\n        b_subsetSums.sort() #only one of them needs to be sorted\\n        #now we just need to find a pair (one from each subsetSums) thats closest to goal\\n        #double for-loop will bring the time complexity back to 2^N, so we do binary search to find the most suitable second pair element\\n        ans = abs(goal)\\n        for a_sum in a_subsetSums:\\n            #apply binary search to find most suitable pair the in the subsetSum\\n            #first binary Search is trying to find closest sum <= goal\\n            L = 0; R = len(b_subsetSums)-1\\n            while L < R:\\n                M = (L+R+1)//2\\n                if a_sum + b_subsetSums[M] <= goal:\\n                    L = M\\n                else:\\n                    R = M-1\\n            \\n            ans = min(ans, abs(goal - a_sum - b_subsetSums[L])) #abs is necesarry because for some elements it might be impossible to find a positive pair\\n            #you should also test for closest sum >= goal\\n            if L+1<len(b_subsetSums): ans = min(ans, abs(b_subsetSums[L+1] + a_sum - goal))\\n            \\n            if not ans: break\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2589859,
                "title": "rust-meet-in-middle-binary-search",
                "content": "~~~\\nimpl Solution {\\n    pub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {\\n        let n = nums.len();\\n        let m1 = n / 2;\\n        let m2 = n - m1;\\n        let (sz1, sz2) = (1 << m1, 1 << m2);\\n        \\n        let (mut v1, mut v2) = (vec![0; sz1], vec![0; sz2]);\\n        \\n        for i in 0..sz1 {\\n            for k in 0..m1 {\\n                if i & (1 << k) > 0 { v1[i] += nums[k] as i64; }\\n            }\\n        }\\n        \\n        for i in 0..sz2 {\\n            for k in 0..m2 {\\n                if i & (1 << k) > 0 { v2[i] += nums[m1 + k] as i64; }\\n            }\\n        }\\n        \\n        v2.sort();\\n        \\n        let mut ret = i64::MAX;\\n        for a in v1 {\\n            let i = Self::binary_search(&v2, goal as i64 - a);\\n            ret = ret.min(i64::abs(goal as i64 - a - v2[i]));\\n            if i + 1 < v2.len() { ret = ret.min(i64::abs(goal as i64 - a - v2[i + 1])); }\\n        }\\n        \\n        ret as i32\\n    }\\n    \\n    fn binary_search(v2: &Vec<i64>, val: i64) -> usize {\\n        if val >= v2[v2.len() - 1] { return v2.len() - 1 }\\n                \\n        let (mut left, mut right) = (0, v2.len() - 1);\\n        \\n        while left < right {\\n            let mid = right - (right - left) / 2;\\n            if v2[mid] <= val { left = mid; }\\n            else              { right = mid - 1; }\\n        }\\n        \\n        left\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {\\n        let n = nums.len();\\n        let m1 = n / 2;\\n        let m2 = n - m1;\\n        let (sz1, sz2) = (1 << m1, 1 << m2);\\n        \\n        let (mut v1, mut v2) = (vec![0; sz1], vec![0; sz2]);\\n        \\n        for i in 0..sz1 {\\n            for k in 0..m1 {\\n                if i & (1 << k) > 0 { v1[i] += nums[k] as i64; }\\n            }\\n        }\\n        \\n        for i in 0..sz2 {\\n            for k in 0..m2 {\\n                if i & (1 << k) > 0 { v2[i] += nums[m1 + k] as i64; }\\n            }\\n        }\\n        \\n        v2.sort();\\n        \\n        let mut ret = i64::MAX;\\n        for a in v1 {\\n            let i = Self::binary_search(&v2, goal as i64 - a);\\n            ret = ret.min(i64::abs(goal as i64 - a - v2[i]));\\n            if i + 1 < v2.len() { ret = ret.min(i64::abs(goal as i64 - a - v2[i + 1])); }\\n        }\\n        \\n        ret as i32\\n    }\\n    \\n    fn binary_search(v2: &Vec<i64>, val: i64) -> usize {\\n        if val >= v2[v2.len() - 1] { return v2.len() - 1 }\\n                \\n        let (mut left, mut right) = (0, v2.len() - 1);\\n        \\n        while left < right {\\n            let mid = right - (right - left) / 2;\\n            if v2[mid] <= val { left = mid; }\\n            else              { right = mid - 1; }\\n        }\\n        \\n        left\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2533793,
                "title": "c-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>& ans, vector<int>& nums, int st, int end,int i,long long sum)\\n{\\n\\tif (i == end)\\n\\t{\\n\\t\\tans.push_back(sum);\\n\\t\\treturn;\\n\\t}\\n\\tsum += nums[i];\\n\\tfind(ans, nums, st, end, i + 1, sum);\\n\\tsum -= nums[i];\\n\\tfind(ans, nums, st, end, i + 1, sum);\\n}\\nint binSearch(vector<int>& nums2, int val, int goal)\\n{\\n\\tint ans=INT_MAX;\\n\\tint st = 0;\\n\\tint end = nums2.size() - 1;\\n\\tint middle = 0;\\n\\twhile (st <= end)\\n\\t{\\n\\t\\tmiddle = (st + end) / 2;\\n\\t\\tans = min(ans, abs(val + nums2[middle] - goal));\\n\\t\\tif (val + nums2[middle] == goal)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\telse if(val+nums2[middle] > goal)\\n\\t\\t{\\n\\t\\t\\tend = middle - 1;\\n\\t\\t}\\n\\t\\telse if (val + nums2[middle] < goal)\\n\\t\\t{\\n\\t\\t\\tst = middle + 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n\\t\\n}\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        \\tint s = nums.size() / 2;\\n\\tvector<int> sum1;\\n\\tfind(sum1, nums, 0, s, 0, 0);\\n\\tvector<int> sum2;\\n\\tfind(sum2, nums, s, nums.size(), s, 0);\\n\\t\\n\\tsort(sum2.begin(), sum2.end());\\n\\t//performing binary search now\\n\\n\\tint anse = abs(goal);\\n\\t\\n\\tfor (int i = 0; i < sum1.size(); i++)\\n\\t{\\n\\t\\tanse=min(anse,binSearch(sum2,sum1[i],goal));\\n\\t\\t\\n\\t}\\n\\treturn anse;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void find(vector<int>& ans, vector<int>& nums, int st, int end,int i,long long sum)\\n{\\n\\tif (i == end)\\n\\t{\\n\\t\\tans.push_back(sum);\\n\\t\\treturn;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2532350,
                "title": "c-generate-two-vectors-of-subset-sums-then-binary-search-286ms-faster-than-99-6",
                "content": "# [C++] Generate two vectors of subset sums, then binary search. \\n* 286ms, faster than 99.6%\\n* we can split the input numbers into two nearly-equal sized halves h1 and h2,\\n  and generate all subset sums v1 for h1, and do the same for h2.\\n* sort h1\\'s subset sums v1,\\n* for each value in h2\\'s subset sums v2, do a binary search of `goal - e` in v1.\\n\\n```\\nclass Solution {\\npublic:\\n    // using only vectors to generate the subset sums.\\n    int minAbsDifference(vector<int>& a, int goal) {\\n        // handle the special cases that goal is out of bound of all subset sums\\n        int maxSum = 0, minSum = 0;\\n        {\\n            for (auto e : a) {\\n                if (e > 0) {\\n                    maxSum += e;\\n                } else {\\n                    minSum += e;\\n                }\\n            }\\n        }\\n        if (goal >= maxSum) {\\n            return goal - maxSum;\\n        }\\n        if (goal <= minSum) {\\n            return minSum - goal;\\n        }\\n\\n        const int sz1 = a.size() / 2, sz2 = a.size() - sz1;\\n        vector<int> v1, v2;\\n        v1.reserve(1 << sz1);\\n        v2.reserve(1 << sz2);\\n        v1.push_back(0);\\n        v2.push_back(0);\\n\\n        // compute the all subset sums of the first half h1 of `a`.\\n        for (int i = 0; i < sz1; ++i) {\\n            const auto e = a[i];\\n            const int originalSize = v1.size();\\n            // v1\\'s existing elements are for sums that are without e.\\n            // we\\'ll add new sums that are with e.\\n            for (int j = 0; j < originalSize; ++j) {\\n                v1.push_back(e + v1[j]);\\n            }\\n        }\\n        // sort it for binary search\\n        sort(v1.begin(), v1.end());\\n        int res = INT_MAX;\\n        // find the best match of goal in v1.\\n        {\\n            // find x >= goal\\n            auto it = lower_bound(v1.begin(), v1.end(), goal);\\n            if (it != v1.end()) {\\n                res = min(res, abs(goal - *it));\\n            }\\n            if (it != v1.begin()) { // has prev()?\\n                res = min(res, abs(goal - *prev(it)));\\n            }\\n            if (res == 0) {\\n                return res;\\n            }\\n        }\\n\\n        // compute all subset sums of the second half h2 of `a`\\n        for (int i = sz1; i < a.size(); ++i) {\\n            const auto e = a[i];\\n            const int originalSize = v2.size();\\n            // v1\\'s existing elements are for sums that are without e.\\n            // we\\'ll add new sums that are with e.\\n            for (int j = 0; j < originalSize; ++j) {\\n                const int newElement = e + v2[j];\\n                v2.push_back(newElement);\\n                const int target = goal - newElement;\\n                // case a: we take only this new element.\\n\\n                // Case: we take the new element, with an element in v1:\\n                // find the target in v1 for the case that we take the new element.\\n                // because v1 has 0, this also covers the case that we take only the element from\\n                // v2.\\n                auto it = lower_bound(v1.begin(), v1.end(), target);\\n                if (it != v1.end()) {\\n                    res = min(res, abs(target - *it));\\n                }\\n                if (it != v1.begin()) { // has prev()?\\n                    res = min(res, abs(target - *prev(it)));\\n                }\\n                if (res == 0) {\\n                    return res;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // using only vectors to generate the subset sums.\\n    int minAbsDifference(vector<int>& a, int goal) {\\n        // handle the special cases that goal is out of bound of all subset sums\\n        int maxSum = 0, minSum = 0;\\n        {\\n            for (auto e : a) {\\n                if (e > 0) {\\n                    maxSum += e;\\n                } else {\\n                    minSum += e;\\n                }\\n            }\\n        }\\n        if (goal >= maxSum) {\\n            return goal - maxSum;\\n        }\\n        if (goal <= minSum) {\\n            return minSum - goal;\\n        }\\n\\n        const int sz1 = a.size() / 2, sz2 = a.size() - sz1;\\n        vector<int> v1, v2;\\n        v1.reserve(1 << sz1);\\n        v2.reserve(1 << sz2);\\n        v1.push_back(0);\\n        v2.push_back(0);\\n\\n        // compute the all subset sums of the first half h1 of `a`.\\n        for (int i = 0; i < sz1; ++i) {\\n            const auto e = a[i];\\n            const int originalSize = v1.size();\\n            // v1\\'s existing elements are for sums that are without e.\\n            // we\\'ll add new sums that are with e.\\n            for (int j = 0; j < originalSize; ++j) {\\n                v1.push_back(e + v1[j]);\\n            }\\n        }\\n        // sort it for binary search\\n        sort(v1.begin(), v1.end());\\n        int res = INT_MAX;\\n        // find the best match of goal in v1.\\n        {\\n            // find x >= goal\\n            auto it = lower_bound(v1.begin(), v1.end(), goal);\\n            if (it != v1.end()) {\\n                res = min(res, abs(goal - *it));\\n            }\\n            if (it != v1.begin()) { // has prev()?\\n                res = min(res, abs(goal - *prev(it)));\\n            }\\n            if (res == 0) {\\n                return res;\\n            }\\n        }\\n\\n        // compute all subset sums of the second half h2 of `a`\\n        for (int i = sz1; i < a.size(); ++i) {\\n            const auto e = a[i];\\n            const int originalSize = v2.size();\\n            // v1\\'s existing elements are for sums that are without e.\\n            // we\\'ll add new sums that are with e.\\n            for (int j = 0; j < originalSize; ++j) {\\n                const int newElement = e + v2[j];\\n                v2.push_back(newElement);\\n                const int target = goal - newElement;\\n                // case a: we take only this new element.\\n\\n                // Case: we take the new element, with an element in v1:\\n                // find the target in v1 for the case that we take the new element.\\n                // because v1 has 0, this also covers the case that we take only the element from\\n                // v2.\\n                auto it = lower_bound(v1.begin(), v1.end(), target);\\n                if (it != v1.end()) {\\n                    res = min(res, abs(target - *it));\\n                }\\n                if (it != v1.begin()) { // has prev()?\\n                    res = min(res, abs(target - *prev(it)));\\n                }\\n                if (res == 0) {\\n                    return res;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467927,
                "title": "c-easy-to-understand-brute-force",
                "content": "**INTUITION**\\n1. since len of input can go upto 40 so we can no way generate(2 ^ 40) possible sums.\\n2. and value of sum can range from -40(10^9) to 40(10^9 )again not possible to use sum as state for our dp .\\n3. so we can use the concept of dividing the the input into two halves and generate all the subset sums for first and secod halves 2*(2^20) is possible.\\n4. now for each sum in first half we will try find the closest sum to (goal - firstHalfSum) in the second half.\\nPFA code for better understanding .\\n```\\nclass Solution {\\nprivate:\\n    // function to generate all possible subsets.\\n    void generateSubset(int idx, int len, vector<int>& nums, int sum, vector<int>& res){\\n        if(idx == len){\\n            res.push_back(sum);\\n            return;\\n        }\\n        generateSubset(idx + 1, len, nums, sum, res);\\n        generateSubset(idx + 1, len, nums, sum + nums[idx], res);\\n    }\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int len = (int)nums.size();\\n        vector<int>left, right; // list to store subset sums of both halves\\n        generateSubset(0, len / 2, nums, 0, left);\\n        generateSubset(len/2, len, nums, 0, right);\\n        sort(right.begin(), right.end()); // sorted right halves sums to apply lower_bound\\n        int rlen = (int)right.size();\\n        int ans = 1e9;\\n        for(auto ele : left){\\n            int rem = goal - ele; // we will be finding the closest value to rem in the right halves\\n            int idx = lower_bound(right.begin(), right.end(), rem) - right.begin();\\n            if(idx > 0)ans = min(ans, abs(goal - ele - right[idx - 1]));\\n            if(idx < rlen)ans = min(ans, abs(goal - ele - right[idx]));\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // function to generate all possible subsets.\\n    void generateSubset(int idx, int len, vector<int>& nums, int sum, vector<int>& res){\\n        if(idx == len){\\n            res.push_back(sum);\\n            return;\\n        }\\n        generateSubset(idx + 1, len, nums, sum, res);\\n        generateSubset(idx + 1, len, nums, sum + nums[idx], res);\\n    }\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int len = (int)nums.size();\\n        vector<int>left, right; // list to store subset sums of both halves\\n        generateSubset(0, len / 2, nums, 0, left);\\n        generateSubset(len/2, len, nums, 0, right);\\n        sort(right.begin(), right.end()); // sorted right halves sums to apply lower_bound\\n        int rlen = (int)right.size();\\n        int ans = 1e9;\\n        for(auto ele : left){\\n            int rem = goal - ele; // we will be finding the closest value to rem in the right halves\\n            int idx = lower_bound(right.begin(), right.end(), rem) - right.begin();\\n            if(idx > 0)ans = min(ans, abs(goal - ele - right[idx - 1]));\\n            if(idx < rlen)ans = min(ans, abs(goal - ele - right[idx]));\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370518,
                "title": "c-using-hints-from-description",
                "content": "Split on two Parts.\\nGet sorted subsets sums of each part.\\nUse linear search on first and binary search on second.\\n\\n\\tpublic int MinAbsDifference(int[] nums, int goal) \\n\\t\\t{\\n\\t\\t\\tint n = nums.Length;\\n\\t\\t\\tint result = int.MaxValue;\\n\\n\\t\\t\\tvar left = new List<int>();\\n\\t\\t\\tvar right = new List<int>();\\n\\t\\t\\tfor(int i = 0; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i < n/2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft.Add(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright.Add(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar leftSum = GetSubsetSums(left);\\n\\t\\t\\tvar rightSum = GetSubsetSums(right);\\n\\n\\t\\t\\tfor(int i = 0; i < leftSum.Count; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar x  = goal - leftSum[i]; \\n\\n\\t\\t\\t\\tint min = 0;\\n\\t\\t\\t\\tint max = rightSum.Count - 1;\\n\\t\\t\\t\\twhile(min <= max)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar temp = min + (max - min)/2;\\n\\t\\t\\t\\t\\tvar value = rightSum[temp] - x;\\n\\t\\t\\t\\t\\tresult = (int) Math.Min(result, Math.Abs(value));\\n\\t\\t\\t\\t\\tif(value == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(value > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmax = temp - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmin = temp + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;    \\n\\t\\t}\\n\\n\\t\\tpublic List<long> GetSubsetSums(List<int> data)\\n\\t\\t{\\n\\t\\t\\tvar n = data.Count;\\n\\n\\t\\t\\tlong boundary = (long) Math.Pow(2, n);\\n\\n\\t\\t\\tvar result = new List<long>();\\n\\n\\t\\t\\tfor(int i = 0; i < boundary; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar temp = i;\\n\\t\\t\\t\\tlong sum = 0;\\n\\t\\t\\t\\tint counter = 0;\\n\\t\\t\\t\\twhile(temp > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(temp % 2 == 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp = temp - 1;\\n\\t\\t\\t\\t\\t\\tsum += data[counter];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t++counter;\\n\\t\\t\\t\\t\\ttemp /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.Add(sum);\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.Sort();\\n\\n\\t\\t\\treturn result;   \\n\\t\\t}",
                "solutionTags": [],
                "code": "Split on two Parts.\\nGet sorted subsets sums of each part.\\nUse linear search on first and binary search on second.\\n\\n\\tpublic int MinAbsDifference(int[] nums, int goal) \\n\\t\\t{\\n\\t\\t\\tint n = nums.Length;\\n\\t\\t\\tint result = int.MaxValue;\\n\\n\\t\\t\\tvar left = new List<int>();\\n\\t\\t\\tvar right = new List<int>();\\n\\t\\t\\tfor(int i = 0; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i < n/2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft.Add(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright.Add(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar leftSum = GetSubsetSums(left);\\n\\t\\t\\tvar rightSum = GetSubsetSums(right);\\n\\n\\t\\t\\tfor(int i = 0; i < leftSum.Count; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar x  = goal - leftSum[i]; \\n\\n\\t\\t\\t\\tint min = 0;\\n\\t\\t\\t\\tint max = rightSum.Count - 1;\\n\\t\\t\\t\\twhile(min <= max)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar temp = min + (max - min)/2;\\n\\t\\t\\t\\t\\tvar value = rightSum[temp] - x;\\n\\t\\t\\t\\t\\tresult = (int) Math.Min(result, Math.Abs(value));\\n\\t\\t\\t\\t\\tif(value == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(value > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmax = temp - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmin = temp + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;    \\n\\t\\t}\\n\\n\\t\\tpublic List<long> GetSubsetSums(List<int> data)\\n\\t\\t{\\n\\t\\t\\tvar n = data.Count;\\n\\n\\t\\t\\tlong boundary = (long) Math.Pow(2, n);\\n\\n\\t\\t\\tvar result = new List<long>();\\n\\n\\t\\t\\tfor(int i = 0; i < boundary; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar temp = i;\\n\\t\\t\\t\\tlong sum = 0;\\n\\t\\t\\t\\tint counter = 0;\\n\\t\\t\\t\\twhile(temp > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(temp % 2 == 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp = temp - 1;\\n\\t\\t\\t\\t\\t\\tsum += data[counter];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t++counter;\\n\\t\\t\\t\\t\\ttemp /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.Add(sum);\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.Sort();\\n\\n\\t\\t\\treturn result;   \\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2347262,
                "title": "simple-c-solution-iterative-approach-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    //this function stores sum of the subsequeces of provided vector into another vector\\n    void subsequenceSum(vector<int>&v,vector<long long>&store){\\n        long long ans = INT_MAX;\\n        for(int i=0;i<(1<<v.size());i++){\\n            long long sum = 0;\\n            for(int j=0;j<v.size();j++){\\n                if(i & (1<<j)) sum += v[j];\\n            }\\n           store.push_back(sum);\\n        }\\n    }\\n    \\n    //driver function\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        //divide array into two equal parts\\n        int n = nums.size();\\n        vector<int> v1,v2;\\n        for(int i=0;i<n/2;i++) v1.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++) v2.push_back(nums[i]);\\n        \\n        //declaring sum vectors for both v1 and v2\\n        vector<long long> sum1,sum2;\\n        subsequenceSum(v1,sum1);\\n        subsequenceSum(v2,sum2);\\n        \\n        //sort sum2 to apply binary search\\n        sort(sum2.begin(),sum2.end());\\n        \\n        //now for each element in sum1 find the closest element to (goal - sum1[i]) in sum2\\n        long long ans = INT_MAX;\\n        for(int i=0;i<sum1.size();i++){\\n           int low = 0,high = sum2.size() - 1;\\n           while(low<=high){\\n               int mid = low + (high - low)/2;\\n               long long sum = sum1[i] + sum2[mid];\\n               \\n               ans = min(ans,abs(goal - sum));\\n               \\n               if(sum == goal) return 0;\\n               else if(sum < goal) low = mid + 1;\\n               else high = mid - 1;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //this function stores sum of the subsequeces of provided vector into another vector\\n    void subsequenceSum(vector<int>&v,vector<long long>&store){\\n        long long ans = INT_MAX;\\n        for(int i=0;i<(1<<v.size());i++){\\n            long long sum = 0;\\n            for(int j=0;j<v.size();j++){\\n                if(i & (1<<j)) sum += v[j];\\n            }\\n           store.push_back(sum);\\n        }\\n    }\\n    \\n    //driver function\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        //divide array into two equal parts\\n        int n = nums.size();\\n        vector<int> v1,v2;\\n        for(int i=0;i<n/2;i++) v1.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++) v2.push_back(nums[i]);\\n        \\n        //declaring sum vectors for both v1 and v2\\n        vector<long long> sum1,sum2;\\n        subsequenceSum(v1,sum1);\\n        subsequenceSum(v2,sum2);\\n        \\n        //sort sum2 to apply binary search\\n        sort(sum2.begin(),sum2.end());\\n        \\n        //now for each element in sum1 find the closest element to (goal - sum1[i]) in sum2\\n        long long ans = INT_MAX;\\n        for(int i=0;i<sum1.size();i++){\\n           int low = 0,high = sum2.size() - 1;\\n           while(low<=high){\\n               int mid = low + (high - low)/2;\\n               long long sum = sum1[i] + sum2[mid];\\n               \\n               ans = min(ans,abs(goal - sum));\\n               \\n               if(sum == goal) return 0;\\n               else if(sum < goal) low = mid + 1;\\n               else high = mid - 1;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297158,
                "title": "java-cut-it-in-half-two-pointers-99-15-speed",
                "content": "Cut the array in half and then gen all the possible sum. \\nGen the sum can be done with\\n```Java\\n        for (int i = 0; i < arr.length; i++){\\n            res[1<<i]=arr[i];\\n        }\\n        for (int i = 1; i < res.length; i++){\\n            res[i]=res[i&-i]+res[i&(i-1)];\\n        }\\n```\\nSort the list, and then do 2 pointers like you would with 2 sum. \\n\\n#### Java\\n```\\n73 / 73 test cases passed.\\nStatus: Accepted\\nRuntime: 243 ms (99.15% Speed).\\n```\\n```Java\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int[] one = genSorted(Arrays.copyOfRange(nums, 0, nums.length/2+1));\\n        int[] two = genSorted(Arrays.copyOfRange(nums, nums.length/2+1, nums.length));\\n        int i = 0, j = two.length-1, ans = Integer.MAX_VALUE;\\n        while(i < one.length && j >= 0 && ans > 0){ // two pointers\\n            int val = one[i]+two[j];\\n            ans = Math.min(Math.abs(val - goal), ans);\\n            if (val>goal){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int[] genSorted(int[] arr){ // gen sum\\n        int[] res = new int[1<<arr.length];\\n        for (int i = 0; i < arr.length; i++){\\n            res[1<<i]=arr[i];\\n        }\\n        for (int i = 1; i < res.length; i++){\\n            res[i]=res[i&-i]+res[i&(i-1)];\\n        }\\n        Arrays.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```Java\\n        for (int i = 0; i < arr.length; i++){\\n            res[1<<i]=arr[i];\\n        }\\n        for (int i = 1; i < res.length; i++){\\n            res[i]=res[i&-i]+res[i&(i-1)];\\n        }\\n```\n```\\n73 / 73 test cases passed.\\nStatus: Accepted\\nRuntime: 243 ms (99.15% Speed).\\n```\n```Java\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int[] one = genSorted(Arrays.copyOfRange(nums, 0, nums.length/2+1));\\n        int[] two = genSorted(Arrays.copyOfRange(nums, nums.length/2+1, nums.length));\\n        int i = 0, j = two.length-1, ans = Integer.MAX_VALUE;\\n        while(i < one.length && j >= 0 && ans > 0){ // two pointers\\n            int val = one[i]+two[j];\\n            ans = Math.min(Math.abs(val - goal), ans);\\n            if (val>goal){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int[] genSorted(int[] arr){ // gen sum\\n        int[] res = new int[1<<arr.length];\\n        for (int i = 0; i < arr.length; i++){\\n            res[1<<i]=arr[i];\\n        }\\n        for (int i = 1; i < res.length; i++){\\n            res[i]=res[i&-i]+res[i&(i-1)];\\n        }\\n        Arrays.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285262,
                "title": "meet-in-the-middle-c-with-explanation",
                "content": "```\\n/*\\n    we know one thing:\\n    if we have to minimize |x - y|, where x can be changed (and replaced with certain given values) and y is FIXED, \\n    then the optimal way is to chose that x, which is either:\\n    1) just greater than or equal to y (use lower bound to get this)\\n    2) just smallet than y (to get this one, take the upper bound and go one step back)\\n    \\n    use meet in the middle technique to solve this problem\\n    divide the array into two halves, leftHalf and rightHalf (leftHalf is from 0 to (n/2 - 1))\\n    and (rightHalf is from (n/2 to n - 1))\\n    \\n    store all the subset sums of leftHald and rightHalf, in two arrays\\n    now we can form all the subsequence sums using these two arrays\\n    if we chose an x from leftHalf and  y from rightHalf, then (x + y) actually represents a subsequence sum of the entire array\\n    \\n    we need to minimize \\n        |goal - (x + y)| \\n        lets fix x\\n        \\n        and, \\n        |goal - x - y| = |y - (goal - x)| (just take - common)\\n        \\n        so now we need to minimize |y - (goal - x)|, so y must be replaced with someone who is either just greater than  or equal to \\n        (goal - x) or someone just smaller than (goal - x),\\n        for every x in leftSums, we can find the possible optimal answers from rightSums using binary search\\n    \\n    \\n\\n*/\\nclass Solution {\\npublic:\\n    void generateSums(int i, int end,  int sum, vector<int> &a, vector<int> &sums) {\\n        if(i == end) {\\n            sums.push_back(sum);\\n            return;\\n        }\\n        \\n        generateSums(i + 1, end, sum + a[i], a, sums);\\n        generateSums(i + 1, end, sum, a, sums);\\n    }\\n    int minAbsDifference(vector<int>& a, int goal) {\\n        int n = a.size();\\n        vector<int> leftSums, rightSums;\\n        int mid = n/2;        \\n        generateSums(0, mid, 0, a, leftSums);\\n        generateSums(mid, n, 0, a, rightSums);\\n        \\n        sort(rightSums.begin(), rightSums.end()); int ans = INT_MAX;\\n        for(int x : leftSums) {\\n            int y = goal - x;\\n            int i = lower_bound(rightSums.begin(), rightSums.end(), y) - rightSums.begin();\\n            if(i != rightSums.size()) ans = min(ans, abs(goal - (x + rightSums[i])));\\n            if(ans == 0) return ans;\\n            \\n            int j = upper_bound(rightSums.begin(), rightSums.end(), y) - rightSums.begin();\\n            j--;\\n            if(j >= 0) ans = min(ans, abs(goal - (x + rightSums[j])));\\n            if(ans == 0) return ans;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    we know one thing:\\n    if we have to minimize |x - y|, where x can be changed (and replaced with certain given values) and y is FIXED, \\n    then the optimal way is to chose that x, which is either:\\n    1) just greater than or equal to y (use lower bound to get this)\\n    2) just smallet than y (to get this one, take the upper bound and go one step back)\\n    \\n    use meet in the middle technique to solve this problem\\n    divide the array into two halves, leftHalf and rightHalf (leftHalf is from 0 to (n/2 - 1))\\n    and (rightHalf is from (n/2 to n - 1))\\n    \\n    store all the subset sums of leftHald and rightHalf, in two arrays\\n    now we can form all the subsequence sums using these two arrays\\n    if we chose an x from leftHalf and  y from rightHalf, then (x + y) actually represents a subsequence sum of the entire array\\n    \\n    we need to minimize \\n        |goal - (x + y)| \\n        lets fix x\\n        \\n        and, \\n        |goal - x - y| = |y - (goal - x)| (just take - common)\\n        \\n        so now we need to minimize |y - (goal - x)|, so y must be replaced with someone who is either just greater than  or equal to \\n        (goal - x) or someone just smaller than (goal - x),\\n        for every x in leftSums, we can find the possible optimal answers from rightSums using binary search\\n    \\n    \\n\\n*/\\nclass Solution {\\npublic:\\n    void generateSums(int i, int end,  int sum, vector<int> &a, vector<int> &sums) {\\n        if(i == end) {\\n            sums.push_back(sum);\\n            return;\\n        }\\n        \\n        generateSums(i + 1, end, sum + a[i], a, sums);\\n        generateSums(i + 1, end, sum, a, sums);\\n    }\\n    int minAbsDifference(vector<int>& a, int goal) {\\n        int n = a.size();\\n        vector<int> leftSums, rightSums;\\n        int mid = n/2;        \\n        generateSums(0, mid, 0, a, leftSums);\\n        generateSums(mid, n, 0, a, rightSums);\\n        \\n        sort(rightSums.begin(), rightSums.end()); int ans = INT_MAX;\\n        for(int x : leftSums) {\\n            int y = goal - x;\\n            int i = lower_bound(rightSums.begin(), rightSums.end(), y) - rightSums.begin();\\n            if(i != rightSums.size()) ans = min(ans, abs(goal - (x + rightSums[i])));\\n            if(ans == 0) return ans;\\n            \\n            int j = upper_bound(rightSums.begin(), rightSums.end(), y) - rightSums.begin();\\n            j--;\\n            if(j >= 0) ans = min(ans, abs(goal - (x + rightSums[j])));\\n            if(ans == 0) return ans;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237271,
                "title": "go-solution-with-explanation",
                "content": "1) split nums array in the middle\\n2) generate all possible sums from each array\\n3) sort both sum arrays\\n4) initialize a pointer at the start of the left sum, and a pointer at the end of the right sum\\n5) iterative check if abs(sum, goal) is the possible solution\\n6) increment left pointer if sum < goal, decrement right pointer if sum > goal, else return 0 if sum == goal\\n\\n```\\nfunc minAbsDifference(nums []int, goal int) int {\\n    mid := len(nums) / 2\\n    \\n    left := nums[:mid]\\n    right := nums[mid:]\\n    \\n    leftSum := getAllSum(left)\\n    rightSum := getAllSum(right)\\n    \\n    sort.Ints(leftSum)\\n    sort.Ints(rightSum)\\n    \\n    return getMinVal(leftSum, rightSum, goal)\\n}\\n\\nfunc getMinVal(leftSum, rightSum []int, goal int) int {\\n    minSoFar := math.MaxInt\\n    \\n    i := 0\\n    j := len(rightSum) - 1\\n    \\n    for i < len(leftSum) && j >= 0 {\\n        sum := leftSum[i] + rightSum[j]\\n        minSoFar = min(minSoFar, abs(goal, sum))\\n        \\n        if sum < goal {\\n            i++\\n        } else if sum > goal {\\n            j--       \\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    return minSoFar\\n}\\n\\nfunc getAllSum(nums []int) []int {\\n    n := len(nums)\\n    \\n    var res []int\\n    \\n    var iter func(idx, sumSoFar int)\\n    iter = func(idx, sumSoFar int) {\\n        if idx == n {\\n            res = append(res, sumSoFar)\\n            return\\n        }    \\n        \\n        iter(idx + 1, sumSoFar)\\n        iter(idx + 1, sumSoFar + nums[idx])\\n    }\\n    \\n    iter(0, 0)\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc abs(a, b int) int {\\n    if a < b {\\n        return b - a\\n    }\\n    return a - b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minAbsDifference(nums []int, goal int) int {\\n    mid := len(nums) / 2\\n    \\n    left := nums[:mid]\\n    right := nums[mid:]\\n    \\n    leftSum := getAllSum(left)\\n    rightSum := getAllSum(right)\\n    \\n    sort.Ints(leftSum)\\n    sort.Ints(rightSum)\\n    \\n    return getMinVal(leftSum, rightSum, goal)\\n}\\n\\nfunc getMinVal(leftSum, rightSum []int, goal int) int {\\n    minSoFar := math.MaxInt\\n    \\n    i := 0\\n    j := len(rightSum) - 1\\n    \\n    for i < len(leftSum) && j >= 0 {\\n        sum := leftSum[i] + rightSum[j]\\n        minSoFar = min(minSoFar, abs(goal, sum))\\n        \\n        if sum < goal {\\n            i++\\n        } else if sum > goal {\\n            j--       \\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    return minSoFar\\n}\\n\\nfunc getAllSum(nums []int) []int {\\n    n := len(nums)\\n    \\n    var res []int\\n    \\n    var iter func(idx, sumSoFar int)\\n    iter = func(idx, sumSoFar int) {\\n        if idx == n {\\n            res = append(res, sumSoFar)\\n            return\\n        }    \\n        \\n        iter(idx + 1, sumSoFar)\\n        iter(idx + 1, sumSoFar + nums[idx])\\n    }\\n    \\n    iter(0, 0)\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc abs(a, b int) int {\\n    if a < b {\\n        return b - a\\n    }\\n    return a - b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221208,
                "title": "optimised-mid-intersection-algorithm",
                "content": "```\\ndef minAbsDifference(self, nums: List[int], goal: int) -> int:\\n\\tpart1, part2 = nums[::2], nums[1::2]\\n\\n\\tparts_sum = [{0}, {0}]\\n\\tfor i, numbers in enumerate([part1, part2]):\\n\\t\\tfor num in numbers:\\n\\t\\t\\tparts_sum[i] |= {num + s for s in parts_sum[i]}\\n\\tpart1_sum, part2_sum = parts_sum\\n\\tpart2_sum = sorted(part2_sum)\\n\\n\\tresult = 10**10\\n\\tfor num in part1_sum:\\n\\t\\ttarget = goal - num\\n\\t\\tif part2_sum[0] - result < target < part2_sum[-1] + result:\\n\\t\\t\\tindex = bisect_left(part2_sum, target)\\n\\t\\t\\tfor i in [index-1, index]:\\n\\t\\t\\t\\tif 0 <= i < len(part2_sum):\\n\\t\\t\\t\\t\\tresult = min(result, abs(target - part2_sum[i]))\\n\\t\\t\\t\\t\\tif result == 0:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\treturn result\\n```",
                "solutionTags": [],
                "code": "```\\ndef minAbsDifference(self, nums: List[int], goal: int) -> int:\\n\\tpart1, part2 = nums[::2], nums[1::2]\\n\\n\\tparts_sum = [{0}, {0}]\\n\\tfor i, numbers in enumerate([part1, part2]):\\n\\t\\tfor num in numbers:\\n\\t\\t\\tparts_sum[i] |= {num + s for s in parts_sum[i]}\\n\\tpart1_sum, part2_sum = parts_sum\\n\\tpart2_sum = sorted(part2_sum)\\n\\n\\tresult = 10**10\\n\\tfor num in part1_sum:\\n\\t\\ttarget = goal - num\\n\\t\\tif part2_sum[0] - result < target < part2_sum[-1] + result:\\n\\t\\t\\tindex = bisect_left(part2_sum, target)\\n\\t\\t\\tfor i in [index-1, index]:\\n\\t\\t\\t\\tif 0 <= i < len(part2_sum):\\n\\t\\t\\t\\t\\tresult = min(result, abs(target - part2_sum[i]))\\n\\t\\t\\t\\t\\tif result == 0:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2162917,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # Solution - 2 set binary serach\\n        # Time - O(2^(N/2) * log(2^(N/2))\\n        # Space O(2^n)\\n        def generateSubsetSumList(st, ed):\\n            result = [0]\\n            for i in range(st, ed+1):\\n                prevLen = len(result)\\n                for j in range(prevLen):\\n                    result.append(result[j] + nums[i])\\n            return result\\n        \\n        list1 = generateSubsetSumList(0, (len(nums)) // 2)\\n        list2 = generateSubsetSumList((len(nums)) // 2 + 1, len(nums) - 1)\\n        \\n        list2.sort()\\n        \\n        closeSoFar = float(\\'infinity\\')\\n        result = float(\\'infinity\\')\\n        \\n        for i in range(len(list1)):\\n            subTarget = goal - list1[i]\\n            i = bisect_left(list2, subTarget)\\n            \\n            if i < len(list2):\\n                closeSoFar = min(closeSoFar, abs(subTarget - list2[i]))\\n                \\n            if i > 0:\\n                closeSoFar = min(closeSoFar, abs(subTarget - list2[i-1]))\\n        \\n        return closeSoFar\\n            \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # Solution - 2 set binary serach\\n        # Time - O(2^(N/2) * log(2^(N/2))\\n        # Space O(2^n)\\n        def generateSubsetSumList(st, ed):\\n            result = [0]\\n            for i in range(st, ed+1):\\n                prevLen = len(result)\\n                for j in range(prevLen):\\n                    result.append(result[j] + nums[i])\\n            return result\\n        \\n        list1 = generateSubsetSumList(0, (len(nums)) // 2)\\n        list2 = generateSubsetSumList((len(nums)) // 2 + 1, len(nums) - 1)\\n        \\n        list2.sort()\\n        \\n        closeSoFar = float(\\'infinity\\')\\n        result = float(\\'infinity\\')\\n        \\n        for i in range(len(list1)):\\n            subTarget = goal - list1[i]\\n            i = bisect_left(list2, subTarget)\\n            \\n            if i < len(list2):\\n                closeSoFar = min(closeSoFar, abs(subTarget - list2[i]))\\n                \\n            if i > 0:\\n                closeSoFar = min(closeSoFar, abs(subTarget - list2[i-1]))\\n        \\n        return closeSoFar\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148601,
                "title": "javascript-meet-in-the-middle-42-time-14-space",
                "content": "```\\nvar minAbsDifference = function(nums, goal) {\\n    let mid = Math.floor(nums.length / 2);\\n    let part1 = nums.slice(0, mid), part2 = nums.slice(mid);\\n\\n    function findSubsetSums(arr, set, idx = 0, sum = 0) {\\n        if (idx === arr.length) return set.add(sum);\\n        findSubsetSums(arr, set, idx + 1, sum);\\n        findSubsetSums(arr, set, idx + 1, sum + arr[idx]);\\n    }\\n    \\n    let sum1 = new Set(), sum2 = new Set();\\n    findSubsetSums(part1, sum1);\\n    findSubsetSums(part2, sum2);\\n    \\n    sum1 = [...sum1.values()];\\n    sum2 = [...sum2.values()];\\n    sum2.sort((a, b) => a - b);\\n\\n    let min = Infinity;\\n    for (let num1 of sum1) {\\n        let l = 0, r = sum2.length - 1;\\n        while (l <= r) {\\n            let mid = l + Math.floor((r - l) / 2);\\n            let num2 = sum2[mid];\\n            min = Math.min(min, Math.abs(num1 + num2 - goal));\\n            if (num1 + num2 < goal) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minAbsDifference = function(nums, goal) {\\n    let mid = Math.floor(nums.length / 2);\\n    let part1 = nums.slice(0, mid), part2 = nums.slice(mid);\\n\\n    function findSubsetSums(arr, set, idx = 0, sum = 0) {\\n        if (idx === arr.length) return set.add(sum);\\n        findSubsetSums(arr, set, idx + 1, sum);\\n        findSubsetSums(arr, set, idx + 1, sum + arr[idx]);\\n    }\\n    \\n    let sum1 = new Set(), sum2 = new Set();\\n    findSubsetSums(part1, sum1);\\n    findSubsetSums(part2, sum2);\\n    \\n    sum1 = [...sum1.values()];\\n    sum2 = [...sum2.values()];\\n    sum2.sort((a, b) => a - b);\\n\\n    let min = Infinity;\\n    for (let num1 of sum1) {\\n        let l = 0, r = sum2.length - 1;\\n        while (l <= r) {\\n            let mid = l + Math.floor((r - l) / 2);\\n            let num2 = sum2[mid];\\n            min = Math.min(min, Math.abs(num1 + num2 - goal));\\n            if (num1 + num2 < goal) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2122553,
                "title": "python3",
                "content": "```\\ndef minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # separate into two halves\\n        l = len(nums)\\n        x1 = (self.generateList(nums[0:l//2]))\\n        x2 = (self.generateList(nums[l//2:l]))\\n        \\n        # initiate ans with goal (suppose an empty array is selected)\\n        ans = abs(goal)\\n        for n in x2:\\n            ans = min(ans, abs(n-goal))\\n            \\n        l2 = len(x2)\\n        j = l2-1\\n        \\n        # using two pointers to get the min diffference\\n        for n in x1:\\n            ans = min(ans, abs(n-goal))\\n            if j+1<l2:\\n                ans = min(ans, abs(n+x2[j]-goal))\\n            while j>=0:\\n                ans = min(ans, abs(n+x2[j]-goal))\\n                if (n + x2[j]) > goal:\\n                    j-=1\\n                elif n + x2[j] == goal:\\n                    return 0\\n                else:\\n                    break\\n            if j<0:\\n                j = 0\\n        return ans\\n        \\n    def generateList(self, nums: List[int]) -> List[int]:\\n        a = set()\\n        for i in nums:\\n            b = set()\\n            for j in a:\\n                b.add(j+i)\\n            a = a.union(b)\\n            a.add(i)\\n        return sorted(list(a))",
                "solutionTags": [],
                "code": "```\\ndef minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        # separate into two halves\\n        l = len(nums)\\n        x1 = (self.generateList(nums[0:l//2]))\\n        x2 = (self.generateList(nums[l//2:l]))\\n        \\n        # initiate ans with goal (suppose an empty array is selected)\\n        ans = abs(goal)\\n        for n in x2:\\n            ans = min(ans, abs(n-goal))\\n            \\n        l2 = len(x2)\\n        j = l2-1\\n        \\n        # using two pointers to get the min diffference\\n        for n in x1:\\n            ans = min(ans, abs(n-goal))\\n            if j+1<l2:\\n                ans = min(ans, abs(n+x2[j]-goal))\\n            while j>=0:\\n                ans = min(ans, abs(n+x2[j]-goal))\\n                if (n + x2[j]) > goal:\\n                    j-=1\\n                elif n + x2[j] == goal:\\n                    return 0\\n                else:\\n                    break\\n            if j<0:\\n                j = 0\\n        return ans\\n        \\n    def generateList(self, nums: List[int]) -> List[int]:\\n        a = set()\\n        for i in nums:\\n            b = set()\\n            for j in a:\\n                b.add(j+i)\\n            a = a.union(b)\\n            a.add(i)\\n        return sorted(list(a))",
                "codeTag": "Python3"
            },
            {
                "id": 2115534,
                "title": "c-easy-to-understand-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums,int i,int n,vector<int> &v,int sum)\\n    {\\n        if(i==n)\\n        {\\n            v.push_back(sum);\\n            return;\\n        }\\n        solve(nums,i+1,n,v,sum+nums[i]);\\n        solve(nums,i+1,n,v,sum);\\n    }\\n    int findSmaller(vector<int> &v,int x)\\n    {\\n        int low=0;\\n        int high=v.size()-1;\\n        int ans=0;\\n        int mid;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(v[mid]<=x)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return v[ans];\\n    }\\n    int findGreater(vector<int> &v,int x)\\n    {\\n        int idx=lower_bound(v.begin(),v.end(),x)-v.begin();\\n        if(idx==v.size())\\n        return v[idx-1];\\n        return v[idx];\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n      int n=nums.size();\\n      vector<int> num1,num2;\\n      for(int i=0;i<n/2;i++)\\n      {\\n          num1.push_back(nums[i]);\\n          //cout<<nums[i]<<\" \";\\n      }\\n      cout<<endl;\\n      for(int i=n/2;i<n;i++)\\n      {\\n          num2.push_back(nums[i]);\\n          //cout<<nums[i]<<\" \";\\n      }\\n      cout<<endl;\\n      vector<int> sum1,sum2;\\n      solve(num1,0,num1.size(),sum1,0);\\n      solve(num2,0,num2.size(),sum2,0);\\n      sort(sum2.begin(),sum2.end());\\n      int ans=INT_MAX;\\n      for(auto x:sum1)\\n      {\\n          int to_find=goal-x;\\n          int x1=findSmaller(sum2,to_find);\\n          int x2=findGreater(sum2,to_find);\\n          ans=min(ans,abs(x1+x-goal));\\n          ans=min(ans,abs(x2+x-goal));\\n          if(ans==0)\\n          return 0;\\n      }\\n      return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums,int i,int n,vector<int> &v,int sum)\\n    {\\n        if(i==n)\\n        {\\n            v.push_back(sum);\\n            return;\\n        }\\n        solve(nums,i+1,n,v,sum+nums[i]);\\n        solve(nums,i+1,n,v,sum);\\n    }\\n    int findSmaller(vector<int> &v,int x)\\n    {\\n        int low=0;\\n        int high=v.size()-1;\\n        int ans=0;\\n        int mid;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(v[mid]<=x)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return v[ans];\\n    }\\n    int findGreater(vector<int> &v,int x)\\n    {\\n        int idx=lower_bound(v.begin(),v.end(),x)-v.begin();\\n        if(idx==v.size())\\n        return v[idx-1];\\n        return v[idx];\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n      int n=nums.size();\\n      vector<int> num1,num2;\\n      for(int i=0;i<n/2;i++)\\n      {\\n          num1.push_back(nums[i]);\\n          //cout<<nums[i]<<\" \";\\n      }\\n      cout<<endl;\\n      for(int i=n/2;i<n;i++)\\n      {\\n          num2.push_back(nums[i]);\\n          //cout<<nums[i]<<\" \";\\n      }\\n      cout<<endl;\\n      vector<int> sum1,sum2;\\n      solve(num1,0,num1.size(),sum1,0);\\n      solve(num2,0,num2.size(),sum2,0);\\n      sort(sum2.begin(),sum2.end());\\n      int ans=INT_MAX;\\n      for(auto x:sum1)\\n      {\\n          int to_find=goal-x;\\n          int x1=findSmaller(sum2,to_find);\\n          int x2=findGreater(sum2,to_find);\\n          ans=min(ans,abs(x1+x-goal));\\n          ans=min(ans,abs(x2+x-goal));\\n          if(ans==0)\\n          return 0;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2076281,
                "title": "java-meet-in-the-middle-treeset-subsetsum",
                "content": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        Set<Integer>ss1=new HashSet<>();\\n        TreeSet<Integer>ss2=new TreeSet<>();\\n        ss1.add(0);\\n        ss2.add(0);\\n        int n=nums.length;\\n        for(int i=0;i<n/2;i++){\\n            Set<Integer>ns=new HashSet<>(ss1);\\n            for(int e:ss1){\\n                ns.add(e+nums[i]);\\n            }\\n            ss1=ns;\\n        }\\n        for(int i=n/2;i<n;i++){\\n            TreeSet<Integer>ns=new TreeSet<>(ss2);\\n            for(int e:ss2){\\n                ns.add(e+nums[i]);\\n            }\\n            ss2=ns;\\n        }\\n        int ans=Math.abs(goal);\\n        for(int e:ss1){\\n            Integer hi=ss2.higher(goal-e-1);\\n            if(hi!=null){\\n                ans=Math.min(ans,Math.abs(goal-e-hi));\\n            }\\n            Integer lo=ss2.lower(goal-e);\\n            if(lo!=null){\\n                ans=Math.min(ans,Math.abs(goal-e-lo));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        Set<Integer>ss1=new HashSet<>();\\n        TreeSet<Integer>ss2=new TreeSet<>();\\n        ss1.add(0);\\n        ss2.add(0);\\n        int n=nums.length;\\n        for(int i=0;i<n/2;i++){\\n            Set<Integer>ns=new HashSet<>(ss1);\\n            for(int e:ss1){\\n                ns.add(e+nums[i]);\\n            }\\n            ss1=ns;\\n        }\\n        for(int i=n/2;i<n;i++){\\n            TreeSet<Integer>ns=new TreeSet<>(ss2);\\n            for(int e:ss2){\\n                ns.add(e+nums[i]);\\n            }\\n            ss2=ns;\\n        }\\n        int ans=Math.abs(goal);\\n        for(int e:ss1){\\n            Integer hi=ss2.higher(goal-e-1);\\n            if(hi!=null){\\n                ans=Math.min(ans,Math.abs(goal-e-hi));\\n            }\\n            Integer lo=ss2.lower(goal-e);\\n            if(lo!=null){\\n                ans=Math.min(ans,Math.abs(goal-e-lo));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066765,
                "title": "c-break-in-two-halves-meet-in-middle",
                "content": "* Using sets was giving TLE , so I tried using vectors and then sorted the only vector on which binary search was to be performed.\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX ;\\n    void solve(int i , int end , vector<int>& nums, vector<int>&v , int sum ){\\n        if(i > end){\\n            v.push_back(sum) ;\\n            return ;\\n        }\\n        solve(i+1,end,nums,v,sum + nums[i] ) ;\\n        solve(i+1,end,nums,v,sum) ;\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        vector<int>v1,v2 ;\\n        int n = nums.size() ;\\n        solve(0,n/2,nums,v1,0) ;\\n        solve((n/2) + 1 , n-1 ,nums,v2,0) ;\\n        \\n        sort(begin(v2),end(v2)) ;\\n        \\n        for(auto &x : v1){\\n            int target = goal - x ;\\n            auto it = upper_bound(begin(v2),end(v2),target) ;\\n            if(it == end(v2)) it = prev(it) ;\\n            ans = min(ans,abs(target - *it)) ;\\n            if(it != begin(v2)) ans = min(ans,abs(target- *prev(it))) ;\\n            if(ans == 0 ) break ; //important optimization \\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX ;\\n    void solve(int i , int end , vector<int>& nums, vector<int>&v , int sum ){\\n        if(i > end){\\n            v.push_back(sum) ;\\n            return ;\\n        }\\n        solve(i+1,end,nums,v,sum + nums[i] ) ;\\n        solve(i+1,end,nums,v,sum) ;\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        \\n        vector<int>v1,v2 ;\\n        int n = nums.size() ;\\n        solve(0,n/2,nums,v1,0) ;\\n        solve((n/2) + 1 , n-1 ,nums,v2,0) ;\\n        \\n        sort(begin(v2),end(v2)) ;\\n        \\n        for(auto &x : v1){\\n            int target = goal - x ;\\n            auto it = upper_bound(begin(v2),end(v2),target) ;\\n            if(it == end(v2)) it = prev(it) ;\\n            ans = min(ans,abs(target - *it)) ;\\n            if(it != begin(v2)) ans = min(ans,abs(target- *prev(it))) ;\\n            if(ans == 0 ) break ; //important optimization \\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915813,
                "title": "anyone-know-why-we-can-t-use-dp-similar-to-coin-change-problem",
                "content": "is it cuz we can\\'t reuse each number in the array ? and we\\'re not adding to the target but closest to the target ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1848762,
                "title": "c-divide-in-two-halves",
                "content": "```\\nclass Solution {\\npublic:\\n    void sumseq(int i,int j,int sum,vector<int>&nums,vector<int>&v)\\n    {\\n        if(i>j)\\n        {\\n            v.push_back(sum);\\n            return;\\n        }\\n        sumseq(i+1,j,sum+nums[i],nums,v);\\n        sumseq(i+1,j,sum,nums,v);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        vector<int>v1,v2;\\n        int n=nums.size(),h=n/2,res=INT_MAX;\\n        sumseq(0,h,0,nums,v1);\\n        sumseq(h+1,n-1,0,nums,v2);\\n        sort(v1.begin(),v1.end());\\n        for(auto &x:v2)\\n        {\\n            int k=goal-x;\\n            auto it=lower_bound(v1.begin(),v1.end(),k);\\n            if(it!=v1.end())\\n                res=min(res,abs(k-*(it)));\\n            if(it!=v1.begin())\\n            {\\n                it--;\\n                res=min(res,abs(k-*(it)));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void sumseq(int i,int j,int sum,vector<int>&nums,vector<int>&v)\\n    {\\n        if(i>j)\\n        {\\n            v.push_back(sum);\\n            return;\\n        }\\n        sumseq(i+1,j,sum+nums[i],nums,v);\\n        sumseq(i+1,j,sum,nums,v);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        vector<int>v1,v2;\\n        int n=nums.size(),h=n/2,res=INT_MAX;\\n        sumseq(0,h,0,nums,v1);\\n        sumseq(h+1,n-1,0,nums,v2);\\n        sort(v1.begin(),v1.end());\\n        for(auto &x:v2)\\n        {\\n            int k=goal-x;\\n            auto it=lower_bound(v1.begin(),v1.end(),k);\\n            if(it!=v1.end())\\n                res=min(res,abs(k-*(it)));\\n            if(it!=v1.begin())\\n            {\\n                it--;\\n                res=min(res,abs(k-*(it)));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714626,
                "title": "javascript-binary-search-pruning-production-ready-code",
                "content": "```\\nvar minAbsDifference = function(nums, goal) {\\n    let positive = 0, negative = 0;\\n\\n    for (const num of nums)\\n        num > 0 ? positive += num : negative += num;\\n\\n    if (goal >= positive || goal <= negative)\\n        return Math.max(goal - positive, negative - goal);\\n\\n    const n = nums.length;\\n    let sum1 = findSums(nums.slice(0, n >> 1)),\\n        sum2 = findSums(nums.slice(n >> 1));\\n\\n    sum2 = [...sum2].sort((b, a) => b - a);\\n\\n    let minimumDiff = Math.abs(goal);\\n\\n    for (const sum of sum1) {\\n        let index = findLowerBound(sum2, goal - sum);\\n\\n        minimumDiff = Math.min(minimumDiff, Math.abs(goal - sum - sum2[index]));\\n        \\n        if (index !== sum2.length - 1)\\n            minimumDiff = Math.min(minimumDiff, sum2[index + 1] + sum - goal);\\n        if (minimumDiff === 0)\\n            break;\\n    }\\n\\n    return minimumDiff;\\n};\\n\\nvar findSums = (nums) => {\\n    let sums = new Set([0]);\\n\\n    for (let i = 0; i < nums.length; i++)\\n        for (const sum of [...sums])\\n            sums.add(sum + nums[i]);\\n\\n    return sums;\\n};\\n\\nvar findLowerBound = (list, target) => {\\n    let l = 0, r = list.length - 1;\\n    \\n    while (l < r) {\\n        const mid = (l + r + 1) >> 1;\\n        if (list[mid] > target)\\n            r = mid - 1;\\n        else l = mid;\\n    }\\n\\n    return l;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minAbsDifference = function(nums, goal) {\\n    let positive = 0, negative = 0;\\n\\n    for (const num of nums)\\n        num > 0 ? positive += num : negative += num;\\n\\n    if (goal >= positive || goal <= negative)\\n        return Math.max(goal - positive, negative - goal);\\n\\n    const n = nums.length;\\n    let sum1 = findSums(nums.slice(0, n >> 1)),\\n        sum2 = findSums(nums.slice(n >> 1));\\n\\n    sum2 = [...sum2].sort((b, a) => b - a);\\n\\n    let minimumDiff = Math.abs(goal);\\n\\n    for (const sum of sum1) {\\n        let index = findLowerBound(sum2, goal - sum);\\n\\n        minimumDiff = Math.min(minimumDiff, Math.abs(goal - sum - sum2[index]));\\n        \\n        if (index !== sum2.length - 1)\\n            minimumDiff = Math.min(minimumDiff, sum2[index + 1] + sum - goal);\\n        if (minimumDiff === 0)\\n            break;\\n    }\\n\\n    return minimumDiff;\\n};\\n\\nvar findSums = (nums) => {\\n    let sums = new Set([0]);\\n\\n    for (let i = 0; i < nums.length; i++)\\n        for (const sum of [...sums])\\n            sums.add(sum + nums[i]);\\n\\n    return sums;\\n};\\n\\nvar findLowerBound = (list, target) => {\\n    let l = 0, r = list.length - 1;\\n    \\n    while (l < r) {\\n        const mid = (l + r + 1) >> 1;\\n        if (list[mid] > target)\\n            r = mid - 1;\\n        else l = mid;\\n    }\\n\\n    return l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709176,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll =long long int;\\n    vector<ll>find_subset(vector<ll>&nums)\\n    {\\n        ll n=nums.size();\\n        vector<ll>v;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            ll sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[j];\\n                }\\n            }\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        \\n        vector<ll>left,right;\\n        ll N=nums.size();\\n       \\n        for(int i=0;i<N;i++)\\n        {\\n            if(i<N/2)\\n            {\\n                left.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                right.push_back(nums[i]);\\n            }\\n        }\\n        vector<ll>left_sum=find_subset(left);\\n        vector<ll>right_sum=find_subset(right);\\n        ll ans=abs(goal);\\n        sort(left_sum.begin(),left_sum.end());\\n        sort(right_sum.begin(),right_sum.end());\\n        for(auto curr:left_sum)\\n        {\\n            int index=lower_bound(right_sum.begin(),right_sum.end(),goal-curr)-right_sum.begin();\\n            // auto it1=it;\\n            // auto it2=it;\\n            if(index>=0&&index<right_sum.size())\\n            {\\n                ans=min(ans,abs(goal-(curr+right_sum[index])));\\n            }\\n            index--;\\n            if(index>=0)\\n            {\\n                ans=min(ans,abs(goal-(curr+right_sum[index])));\\n            }\\n           \\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll =long long int;\\n    vector<ll>find_subset(vector<ll>&nums)\\n    {\\n        ll n=nums.size();\\n        vector<ll>v;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            ll sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[j];\\n                }\\n            }\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        \\n        vector<ll>left,right;\\n        ll N=nums.size();\\n       \\n        for(int i=0;i<N;i++)\\n        {\\n            if(i<N/2)\\n            {\\n                left.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                right.push_back(nums[i]);\\n            }\\n        }\\n        vector<ll>left_sum=find_subset(left);\\n        vector<ll>right_sum=find_subset(right);\\n        ll ans=abs(goal);\\n        sort(left_sum.begin(),left_sum.end());\\n        sort(right_sum.begin(),right_sum.end());\\n        for(auto curr:left_sum)\\n        {\\n            int index=lower_bound(right_sum.begin(),right_sum.end(),goal-curr)-right_sum.begin();\\n            // auto it1=it;\\n            // auto it2=it;\\n            if(index>=0&&index<right_sum.size())\\n            {\\n                ans=min(ans,abs(goal-(curr+right_sum[index])));\\n            }\\n            index--;\\n            if(index>=0)\\n            {\\n                ans=min(ans,abs(goal-(curr+right_sum[index])));\\n            }\\n           \\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699744,
                "title": "c-solution-21-lines",
                "content": "```\\npublic class Solution \\n{\\n    public int MinAbsDifference(int[] nums, int goal) \\n    {\\n        var first = AllSums(new ArraySegment<int>(nums, 0, nums.Length / 2)).OrderBy(x => x).ToArray();\\n        int best = Math.Abs(goal);\\n        foreach (int x in AllSums(new ArraySegment<int>(nums, nums.Length / 2, nums.Length - nums.Length / 2))) \\n        {\\n            int index = Array.BinarySearch(first, goal - x);\\n            if (index >= 0) return 0;\\n            int l = Math.Max(0, (~index) - 1);\\n            int r = Math.Min(first.Length - 1, ~index);\\n            best = Math.Min(best, Math.Min(Math.Abs(goal - x - first[l]), Math.Abs(goal - x - first[r])));\\n        }\\n        return best;\\n        \\n        static IEnumerable<int> AllSums(ArraySegment<int> segment) \\n        {\\n            int size = 1 << segment.Count;\\n            for (int mask = 0; mask < size; ++mask) \\n            {\\n                int sum = 0;\\n                for (int i = 0; i < segment.Count; ++i) sum += (mask & (1 << i)) == 0 ? 0 : segment[i];\\n                yield return sum;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nCooler and shorter version that unfortunately got TLE because of LINQ:\\n```\\npublic class Solution \\n{\\n    public int MinAbsDifference(int[] nums, int goal) \\n    {\\n        var first = AllSums(new ArraySegment<int>(nums, 0, nums.Length / 2)).OrderBy(x => x).ToArray();\\n\\t\\tint best = Math.Abs(goal);\\n        foreach (int x in AllSums(new ArraySegment<int>(nums, nums.Length / 2, nums.Length - nums.Length / 2))) \\n        {\\n            int index = Array.BinarySearch(first, goal - x);\\n            if (index >= 0) return 0;\\n            int l = Math.Max(0, (~index) - 1);\\n            int r = Math.Min(first.Length - 1, ~index);\\n            best = Math.Min(best, Math.Min(Math.Abs(goal - x - first[l]), Math.Abs(goal - x - first[r])));\\n        }\\n        return best;\\n        \\n        static IEnumerable<int> AllSums(ArraySegment<int> segment) \\n            => Enumerable.Range(0, 1 << segment.Count)\\n                         .Select(mask => segment.Select((x, i) => (mask & (1 << i)) == 0 ? 0 : x).Sum());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinAbsDifference(int[] nums, int goal) \\n    {\\n        var first = AllSums(new ArraySegment<int>(nums, 0, nums.Length / 2)).OrderBy(x => x).ToArray();\\n        int best = Math.Abs(goal);\\n        foreach (int x in AllSums(new ArraySegment<int>(nums, nums.Length / 2, nums.Length - nums.Length / 2))) \\n        {\\n            int index = Array.BinarySearch(first, goal - x);\\n            if (index >= 0) return 0;\\n            int l = Math.Max(0, (~index) - 1);\\n            int r = Math.Min(first.Length - 1, ~index);\\n            best = Math.Min(best, Math.Min(Math.Abs(goal - x - first[l]), Math.Abs(goal - x - first[r])));\\n        }\\n        return best;\\n        \\n        static IEnumerable<int> AllSums(ArraySegment<int> segment) \\n        {\\n            int size = 1 << segment.Count;\\n            for (int mask = 0; mask < size; ++mask) \\n            {\\n                int sum = 0;\\n                for (int i = 0; i < segment.Count; ++i) sum += (mask & (1 << i)) == 0 ? 0 : segment[i];\\n                yield return sum;\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int MinAbsDifference(int[] nums, int goal) \\n    {\\n        var first = AllSums(new ArraySegment<int>(nums, 0, nums.Length / 2)).OrderBy(x => x).ToArray();\\n\\t\\tint best = Math.Abs(goal);\\n        foreach (int x in AllSums(new ArraySegment<int>(nums, nums.Length / 2, nums.Length - nums.Length / 2))) \\n        {\\n            int index = Array.BinarySearch(first, goal - x);\\n            if (index >= 0) return 0;\\n            int l = Math.Max(0, (~index) - 1);\\n            int r = Math.Min(first.Length - 1, ~index);\\n            best = Math.Min(best, Math.Min(Math.Abs(goal - x - first[l]), Math.Abs(goal - x - first[r])));\\n        }\\n        return best;\\n        \\n        static IEnumerable<int> AllSums(ArraySegment<int> segment) \\n            => Enumerable.Range(0, 1 << segment.Count)\\n                         .Select(mask => segment.Select((x, i) => (mask & (1 << i)) == 0 ? 0 : x).Sum());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613906,
                "title": "java-meet-in-middle-technique-nothings-special",
                "content": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        HashSet<Integer> setLeft = new HashSet<>();\\n        HashSet<Integer> setRight = new HashSet<>();\\n        \\n        int n = nums.length;\\n        for(int i = 0; i <= n/2-1; i++) {\\n            backtrack(nums, 0, n/2-1, setLeft, i, nums[i]);\\n        }\\n        \\n        for(int i = n/2; i < n; i++) {\\n            backtrack(nums, n/2, n-1, setRight, i, nums[i]);\\n        }\\n\\n        setLeft.add(0);\\n        setRight.add(0);\\n        int[] left = new int[setLeft.size()];\\n        int[] right = new int[setRight.size()];\\n        int index = 0;\\n        for(Integer e : setLeft) {\\n            left[index++] = e;\\n        }\\n        \\n        index = 0;\\n        for(Integer e : setRight) {\\n            right[index++] = e;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        Arrays.sort(right);\\n        for(int e : left) {\\n            int[] found = search(right, 0, right.length-1, goal - e);\\n            ans = Math.min(ans, Math.min(\\n                Math.abs(found[0] + e - goal),\\n                Math.abs(found[1] + e - goal)\\n            ));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int[] search(int[] nums, int begin, int end, int target) {\\n        int n = nums.length;\\n        if(target <= nums[0]) return new int[] {Integer.MIN_VALUE+1, nums[0]};\\n        if(target >= nums[n-1]) return new int[] {nums[n-1], Integer.MAX_VALUE-1};\\n        \\n        while(begin <= end) {\\n            int mid = begin + (end-begin)/2;\\n            if(target >= nums[mid]) {\\n                if(target <= nums[mid+1]) {\\n                    return new int[] {nums[mid], nums[mid+1]};\\n                } else {\\n                    begin = mid + 1;\\n                }\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return new int[] {Integer.MIN_VALUE/2, Integer.MAX_VALUE/2};\\n    }\\n    \\n    void backtrack(int[] nums, int begin, int end, HashSet<Integer> list, int cur, int val) {\\n        if(cur > end) return;\\n        \\n        list.add(val);\\n        \\n        for(int i = cur+1; i <= end; i++) {\\n            backtrack(nums, begin, end, list, i, val + nums[i]);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        HashSet<Integer> setLeft = new HashSet<>();\\n        HashSet<Integer> setRight = new HashSet<>();\\n        \\n        int n = nums.length;\\n        for(int i = 0; i <= n/2-1; i++) {\\n            backtrack(nums, 0, n/2-1, setLeft, i, nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1583011,
                "title": "python",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        n = len(nums)\\n        half = len(nums) // 2\\n        sums = {0}\\n        for i in range(half, n):\\n            for s in list(sums):\\n                sums.add(nums[i] + s)\\n        sums = sorted(sums)\\n\\n        sums2 = {0}\\n        for i in range(half):\\n            for s in list(sums2):\\n                sums2.add(nums[i] + s)\\n\\n        mn = 10 ** 9\\n        for s2 in sums2:\\n            ind = bisect.bisect_left(sums, goal - s2)\\n\\n            if ind != len(sums):\\n                mn = min(mn, sums[ind] + s2 - goal)\\n            if ind != 0:\\n                mn = min(mn, goal - sums[ind - 1] - s2)\\n        return mn\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        n = len(nums)\\n        half = len(nums) // 2\\n        sums = {0}\\n        for i in range(half, n):\\n            for s in list(sums):\\n                sums.add(nums[i] + s)\\n        sums = sorted(sums)\\n\\n        sums2 = {0}\\n        for i in range(half):\\n            for s in list(sums2):\\n                sums2.add(nums[i] + s)\\n\\n        mn = 10 ** 9\\n        for s2 in sums2:\\n            ind = bisect.bisect_left(sums, goal - s2)\\n\\n            if ind != len(sums):\\n                mn = min(mn, sums[ind] + s2 - goal)\\n            if ind != 0:\\n                mn = min(mn, goal - sums[ind - 1] - s2)\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535777,
                "title": "c-divide-by-2-parts-and-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> leftSet, rightSet;\\n        int n = nums.size();\\n        generate(0, n / 2, nums, 0, leftSet);\\n        generate(n / 2, n, nums, 0, rightSet);\\n        set<int> set(leftSet.begin(), leftSet.end());\\n        int res = abs(goal);\\n        for(int x : rightSet){\\n            int target = goal - x;\\n            auto iter = set.lower_bound(target);\\n            if(iter != set.end()){\\n                res = min(res, abs(x + *iter - goal));\\n            }\\n            if(iter != set.begin()){\\n                res = min(res, abs(x + *prev(iter) - goal));\\n            }\\n        }\\n        return res;\\n    }\\nprivate:\\n    inline void generate(int pos, int stop, vector<int>& nums, int sum, vector<int>& sums) {\\n        if(pos == stop){\\n            sums.push_back(sum);\\n            return;\\n        }\\n        generate(pos + 1, stop, nums, sum, sums);\\n        generate(pos + 1, stop, nums, sum + nums[pos], sums);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> leftSet, rightSet;\\n        int n = nums.size();\\n        generate(0, n / 2, nums, 0, leftSet);\\n        generate(n / 2, n, nums, 0, rightSet);\\n        set<int> set(leftSet.begin(), leftSet.end());\\n        int res = abs(goal);\\n        for(int x : rightSet){\\n            int target = goal - x;\\n            auto iter = set.lower_bound(target);\\n            if(iter != set.end()){\\n                res = min(res, abs(x + *iter - goal));\\n            }\\n            if(iter != set.begin()){\\n                res = min(res, abs(x + *prev(iter) - goal));\\n            }\\n        }\\n        return res;\\n    }\\nprivate:\\n    inline void generate(int pos, int stop, vector<int>& nums, int sum, vector<int>& sums) {\\n        if(pos == stop){\\n            sums.push_back(sum);\\n            return;\\n        }\\n        generate(pos + 1, stop, nums, sum, sums);\\n        generate(pos + 1, stop, nums, sum + nums[pos], sums);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529224,
                "title": "partition-and-set-adt-python-solution-with-explanation",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \"\"\"\\n        As the length of nums has upper bound n = 40, a brute force way of checking the\\n        possible subsequnce sums will have time complexity 2 ** n. That is too large.\\n        The idea here is to split the nums into two halves, each has length upper bound 20.\\n        So getting all possible sums xs, ys for each part has time O(2 ** (n/2)).\\n        In the algorithm, we sorted one of xs, ys, say ys, it takes O(2 **(n/2) * log(2 **(n/2)))\\n        For each x in xs, we do binary search in ys to find nearest candidates (may need check twice, i.e,\\n        left, right of the binary insertion index), the time is again O(2 **(n/2) * log(2 **(n/2)))\\n        So overall time complexity is O(2 **(n/2) * log(2 *2(n/2))), i.e., O(n * 2 **(n/2)).\\n        \\n        \"\"\"\\n        \\n        def helper(nums):\\n            aux = {0}\\n            for x in nums:\\n                for y in aux.copy():\\n                    aux.add(x + y)\\n            return aux\\n        n = len(nums) // 2\\n        xs, ys = helper(nums[:n]), helper(nums[n:])\\n        ys = sorted(ys)\\n        res = float(\"inf\")\\n        for x in xs:\\n            target = goal - x\\n            i = bisect_left(ys, target)\\n            if i < len(ys):\\n                res = min(res, abs(target - ys[i]))\\n            if i > 0:\\n                res = min(res, abs(target - ys[i-1]))\\n        return res\\n        \\n```\\n\\nAnother Implementation in DFS format as heler function:\\n```\\nfrom bisect import bisect_left\\n\\n\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        def dfs(i, cur, array, res):\\n            if i == len(array):\\n                res.append(cur)\\n                return\\n            # including array[i]\\n            dfs(i + 1, cur, array, res)\\n            # not including array[i]\\n            dfs(i + 1, cur + array[i], array, res)\\n\\n        n = len(nums) // 2\\n        nums1, nums2 = nums[:n], nums[n:]\\n        sum1, sum2 = [], []\\n        dfs(0, 0, nums1, sum1)\\n        dfs(0, 0, nums2, sum2)\\n        sum2.sort()\\n\\n        res = float(\"inf\")\\n        for s1 in sum1:\\n            t = goal - s1\\n            i = bisect_left(sum2, t)\\n            if i < len(sum2):\\n                res = min(res, abs(t - sum2[i]))\\n            if i > 0:\\n                res = min(res, abs(t - sum2[i - 1]))\\n        return res\\n\\n\\nprint(\"Check:\")\\nobj = Solution().minAbsDifference\\nnums = [5, -7, 3, 5]\\ngoal = 6\\n\\nprint(obj(nums, goal), obj(nums, goal) == 0)\\n\\n\\nnums = [7, -9, 15, -2]\\ngoal = -5\\nprint(obj(nums, goal), obj(nums, goal) == 1)\\n\\nnums = [1, 2, 3]\\ngoal = -7\\nprint(obj(nums, goal), obj(nums, goal) == 7)\\n```\\n\\nAdded Notes: We could use either bisect_left or bisect_right, both works. The details are in the comments as below in the comparison.\\n```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \"\"\"\\n        As the length of nums has upper bound n = 40, a brute force way of checking the\\n        possible subsequnce sums will have time complexity 2 ** n. That is too large.\\n        The idea here is to split the nums into two halves, each has length upper bound 20.\\n        So getting all possible sums xs, ys for each part has time O(2 ** (n/2)).\\n        In the algorithm, we sorted one of xs, ys, say ys, it takes O(2 **(n/2) * log(2 **(n/2)))\\n        For each x in xs, we do binary search in ys to find nearest candidates (may need check twice, i.e,\\n        left, right of the binary insertion index), the time is again O(2 **(n/2) * log(2 **(n/2)))\\n        So overall time complexity is O(2 **(n/2) * log(2 *2(n/2))), i.e., O(n * 2 **(n/2)).\\n        \\n        \"\"\"\\n        \\n        def helper(nums):\\n            aux = {0}\\n            for x in nums:\\n                for y in aux.copy():\\n                    aux.add(x + y)\\n            return aux\\n        n = len(nums) // 2\\n        xs, ys = helper(nums[:n]), helper(nums[n:])\\n        ys = sorted(ys)\\n        res = float(\"inf\")\\n        for x in xs:\\n            target = goal - x\\n            # here we could use either bisect_left, or bisect_right\\n            # the point is that we need to try to compare twice if we can.\\n            # The reason is as below:\\n            # e.g. target = 6, [1, 2, 3, 5, 9]\\n            # bisect_left, we get 4, bisect_right, we also get 4\\n            # we need compare 6 with 3, 5\\n            # target = 6, [1, 2, 3, 5, 6, 9]\\n            # bisect_left, get 4, compare 6 with 6, 5; bisect_right, get 5, compare 6 with 6, 9\\n            # The dedicate thing is that: if the result of bisect_left or bisect_right are different,\\n            # it means there is element in the list, that equals the target\\n            \\n            i = bisect_right(ys, target)\\n            if i < len(ys):\\n                res = min(res, abs(target - ys[i]))\\n            if i > 0:\\n                res = min(res, abs(target - ys[i-1]))\\n        return res\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \"\"\"\\n        As the length of nums has upper bound n = 40, a brute force way of checking the\\n        possible subsequnce sums will have time complexity 2 ** n. That is too large.\\n        The idea here is to split the nums into two halves, each has length upper bound 20.\\n        So getting all possible sums xs, ys for each part has time O(2 ** (n/2)).\\n        In the algorithm, we sorted one of xs, ys, say ys, it takes O(2 **(n/2) * log(2 **(n/2)))\\n        For each x in xs, we do binary search in ys to find nearest candidates (may need check twice, i.e,\\n        left, right of the binary insertion index), the time is again O(2 **(n/2) * log(2 **(n/2)))\\n        So overall time complexity is O(2 **(n/2) * log(2 *2(n/2))), i.e., O(n * 2 **(n/2)).\\n        \\n        \"\"\"\\n        \\n        def helper(nums):\\n            aux = {0}\\n            for x in nums:\\n                for y in aux.copy():\\n                    aux.add(x + y)\\n            return aux\\n        n = len(nums) // 2\\n        xs, ys = helper(nums[:n]), helper(nums[n:])\\n        ys = sorted(ys)\\n        res = float(\"inf\")\\n        for x in xs:\\n            target = goal - x\\n            i = bisect_left(ys, target)\\n            if i < len(ys):\\n                res = min(res, abs(target - ys[i]))\\n            if i > 0:\\n                res = min(res, abs(target - ys[i-1]))\\n        return res\\n        \\n```\n```\\nfrom bisect import bisect_left\\n\\n\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        def dfs(i, cur, array, res):\\n            if i == len(array):\\n                res.append(cur)\\n                return\\n            # including array[i]\\n            dfs(i + 1, cur, array, res)\\n            # not including array[i]\\n            dfs(i + 1, cur + array[i], array, res)\\n\\n        n = len(nums) // 2\\n        nums1, nums2 = nums[:n], nums[n:]\\n        sum1, sum2 = [], []\\n        dfs(0, 0, nums1, sum1)\\n        dfs(0, 0, nums2, sum2)\\n        sum2.sort()\\n\\n        res = float(\"inf\")\\n        for s1 in sum1:\\n            t = goal - s1\\n            i = bisect_left(sum2, t)\\n            if i < len(sum2):\\n                res = min(res, abs(t - sum2[i]))\\n            if i > 0:\\n                res = min(res, abs(t - sum2[i - 1]))\\n        return res\\n\\n\\nprint(\"Check:\")\\nobj = Solution().minAbsDifference\\nnums = [5, -7, 3, 5]\\ngoal = 6\\n\\nprint(obj(nums, goal), obj(nums, goal) == 0)\\n\\n\\nnums = [7, -9, 15, -2]\\ngoal = -5\\nprint(obj(nums, goal), obj(nums, goal) == 1)\\n\\nnums = [1, 2, 3]\\ngoal = -7\\nprint(obj(nums, goal), obj(nums, goal) == 7)\\n```\n```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \"\"\"\\n        As the length of nums has upper bound n = 40, a brute force way of checking the\\n        possible subsequnce sums will have time complexity 2 ** n. That is too large.\\n        The idea here is to split the nums into two halves, each has length upper bound 20.\\n        So getting all possible sums xs, ys for each part has time O(2 ** (n/2)).\\n        In the algorithm, we sorted one of xs, ys, say ys, it takes O(2 **(n/2) * log(2 **(n/2)))\\n        For each x in xs, we do binary search in ys to find nearest candidates (may need check twice, i.e,\\n        left, right of the binary insertion index), the time is again O(2 **(n/2) * log(2 **(n/2)))\\n        So overall time complexity is O(2 **(n/2) * log(2 *2(n/2))), i.e., O(n * 2 **(n/2)).\\n        \\n        \"\"\"\\n        \\n        def helper(nums):\\n            aux = {0}\\n            for x in nums:\\n                for y in aux.copy():\\n                    aux.add(x + y)\\n            return aux\\n        n = len(nums) // 2\\n        xs, ys = helper(nums[:n]), helper(nums[n:])\\n        ys = sorted(ys)\\n        res = float(\"inf\")\\n        for x in xs:\\n            target = goal - x\\n            # here we could use either bisect_left, or bisect_right\\n            # the point is that we need to try to compare twice if we can.\\n            # The reason is as below:\\n            # e.g. target = 6, [1, 2, 3, 5, 9]\\n            # bisect_left, we get 4, bisect_right, we also get 4\\n            # we need compare 6 with 3, 5\\n            # target = 6, [1, 2, 3, 5, 6, 9]\\n            # bisect_left, get 4, compare 6 with 6, 5; bisect_right, get 5, compare 6 with 6, 9\\n            # The dedicate thing is that: if the result of bisect_left or bisect_right are different,\\n            # it means there is element in the list, that equals the target\\n            \\n            i = bisect_right(ys, target)\\n            if i < len(ys):\\n                res = min(res, abs(target - ys[i]))\\n            if i > 0:\\n                res = min(res, abs(target - ys[i-1]))\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521216,
                "title": "python-simple-and-fast-meet-in-the-middle-solution",
                "content": "So this is another meet in the middle solution. I won\\'t go into detailed explanations as others have done much better job in this forum. \\n\\nI will note though that my solution runs a bit faster than other published python solutions because of two optimisations in the binary search loop:\\n* before doing binary search within second sums array, we can check its first and last element to see if we have a chance to find better sum difference in this iteration \\n* we do early exit if we encounter target sum\\n\\n```python\\ndef minAbsDifference(self, nums: List[int], goal: int) -> int:\\n\\tpart1, part2 = nums[::2], nums[1::2]\\n\\n\\tparts_sum = [{0}, {0}]\\n\\tfor i, numbers in enumerate([part1, part2]):\\n\\t\\tfor num in numbers:\\n\\t\\t\\tparts_sum[i] |= {num + s for s in parts_sum[i]}\\n\\tpart1_sum, part2_sum = parts_sum\\n\\tpart2_sum = sorted(part2_sum)\\n\\n\\tresult = 10**10\\n\\tfor num in part1_sum:\\n\\t\\ttarget = goal - num\\n\\t\\tif part2_sum[0] - result < target < part2_sum[-1] + result:\\n\\t\\t\\tindex = bisect_left(part2_sum, target)\\n\\t\\t\\tfor i in [index-1, index]:\\n\\t\\t\\t\\tif 0 <= i < len(part2_sum):\\n\\t\\t\\t\\t\\tresult = min(result, abs(target - part2_sum[i]))\\n\\t\\t\\t\\t\\tif result == 0:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\treturn result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef minAbsDifference(self, nums: List[int], goal: int) -> int:\\n\\tpart1, part2 = nums[::2], nums[1::2]\\n\\n\\tparts_sum = [{0}, {0}]\\n\\tfor i, numbers in enumerate([part1, part2]):\\n\\t\\tfor num in numbers:\\n\\t\\t\\tparts_sum[i] |= {num + s for s in parts_sum[i]}\\n\\tpart1_sum, part2_sum = parts_sum\\n\\tpart2_sum = sorted(part2_sum)\\n\\n\\tresult = 10**10\\n\\tfor num in part1_sum:\\n\\t\\ttarget = goal - num\\n\\t\\tif part2_sum[0] - result < target < part2_sum[-1] + result:\\n\\t\\t\\tindex = bisect_left(part2_sum, target)\\n\\t\\t\\tfor i in [index-1, index]:\\n\\t\\t\\t\\tif 0 <= i < len(part2_sum):\\n\\t\\t\\t\\t\\tresult = min(result, abs(target - part2_sum[i]))\\n\\t\\t\\t\\t\\tif result == 0:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1516633,
                "title": "c-java-python-meet-in-the-middle-guaranteed-very-clean",
                "content": "**C++**\\n\\n```cpp\\nclass Solution {\\n public:\\n  int minAbsDifference(vector<int>& nums, int goal) {\\n    const int n = nums.size() / 2;\\n    const vector<int> lNums(begin(nums), begin(nums) + n);\\n    const vector<int> rNums(begin(nums) + n, end(nums));\\n\\n    int ans = INT_MAX;\\n    vector<int> lSums;\\n    vector<int> rSums;\\n\\n    dfs(lNums, 0, 0, lSums);\\n    dfs(rNums, 0, 0, rSums);\\n    sort(begin(rSums), end(rSums));\\n\\n    for (const int lSum : lSums) {\\n      const int i = firstGreaterEqual(rSums, goal - lSum);\\n      if (i < rSums.size())  // 2^n\\n        ans = min(ans, abs(goal - lSum - rSums[i]));\\n      if (i > 0)\\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]));\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  void dfs(const vector<int>& A, int i, int path, vector<int>& sums) {\\n    if (i == A.size()) {\\n      sums.push_back(path);\\n      return;\\n    }\\n    dfs(A, i + 1, path + A[i], sums);\\n    dfs(A, i + 1, path, sums);\\n  }\\n\\n  int firstGreaterEqual(const vector<int>& A, int target) {\\n    return lower_bound(begin(A), end(A), target) - begin(A);\\n  }\\n};\\n```\\n\\n**Java**\\n\\n```cpp\\nclass Solution {\\n  public int minAbsDifference(int[] nums, int goal) {\\n    final int n = nums.length / 2;\\n    final int[] lNums = Arrays.copyOfRange(nums, 0, n);\\n    final int[] rNums = Arrays.copyOfRange(nums, n, nums.length);\\n\\n    int ans = Integer.MAX_VALUE;\\n    List<Integer> lSums = new ArrayList<>();\\n    List<Integer> rSums = new ArrayList<>();\\n\\n    dfs(lNums, 0, 0, lSums);\\n    dfs(rNums, 0, 0, rSums);\\n    Collections.sort(rSums);\\n\\n    for (final int lSum : lSums) {\\n      final int i = firstGreaterEqual(rSums, goal - lSum);\\n      if (i < rSums.size()) // 2^n\\n        ans = Math.min(ans, Math.abs(goal - lSum - rSums.get(i)));\\n      if (i > 0)\\n        ans = Math.min(ans, Math.abs(goal - lSum - rSums.get(i - 1)));\\n    }\\n\\n    return ans;\\n  }\\n\\n  private void dfs(int[] A, int i, int path, List<Integer> sums) {\\n    if (i == A.length) {\\n      sums.add(path);\\n      return;\\n    }\\n    dfs(A, i + 1, path + A[i], sums);\\n    dfs(A, i + 1, path, sums);\\n  }\\n\\n  private int firstGreaterEqual(List<Integer> A, int target) {\\n    int l = 0;\\n    int r = A.size();\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (A.get(m) >= target)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n    return l;\\n  }\\n}\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n  def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n    n = len(nums) // 2\\n\\n    ans = inf\\n    lSums = []\\n    rSums = []\\n\\n    def dfs(A: List[int], i: int, path: int, sums: List[int]) -> None:\\n      if i == len(A):\\n        sums.append(path)\\n        return\\n      dfs(A, i + 1, path + A[i], sums)\\n      dfs(A, i + 1, path, sums)\\n\\n    dfs(nums[:n], 0, 0, lSums)\\n    dfs(nums[n:], 0, 0, rSums)\\n    rSums.sort()\\n\\n    for lSum in lSums:\\n      i = bisect_left(rSums, goal - lSum)\\n      if i < len(rSums):  # 2^n\\n        ans = min(ans, abs(goal - lSum - rSums[i]))\\n      if i > 0:\\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]))\\n\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n public:\\n  int minAbsDifference(vector<int>& nums, int goal) {\\n    const int n = nums.size() / 2;\\n    const vector<int> lNums(begin(nums), begin(nums) + n);\\n    const vector<int> rNums(begin(nums) + n, end(nums));\\n\\n    int ans = INT_MAX;\\n    vector<int> lSums;\\n    vector<int> rSums;\\n\\n    dfs(lNums, 0, 0, lSums);\\n    dfs(rNums, 0, 0, rSums);\\n    sort(begin(rSums), end(rSums));\\n\\n    for (const int lSum : lSums) {\\n      const int i = firstGreaterEqual(rSums, goal - lSum);\\n      if (i < rSums.size())  // 2^n\\n        ans = min(ans, abs(goal - lSum - rSums[i]));\\n      if (i > 0)\\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]));\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  void dfs(const vector<int>& A, int i, int path, vector<int>& sums) {\\n    if (i == A.size()) {\\n      sums.push_back(path);\\n      return;\\n    }\\n    dfs(A, i + 1, path + A[i], sums);\\n    dfs(A, i + 1, path, sums);\\n  }\\n\\n  int firstGreaterEqual(const vector<int>& A, int target) {\\n    return lower_bound(begin(A), end(A), target) - begin(A);\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\n  public int minAbsDifference(int[] nums, int goal) {\\n    final int n = nums.length / 2;\\n    final int[] lNums = Arrays.copyOfRange(nums, 0, n);\\n    final int[] rNums = Arrays.copyOfRange(nums, n, nums.length);\\n\\n    int ans = Integer.MAX_VALUE;\\n    List<Integer> lSums = new ArrayList<>();\\n    List<Integer> rSums = new ArrayList<>();\\n\\n    dfs(lNums, 0, 0, lSums);\\n    dfs(rNums, 0, 0, rSums);\\n    Collections.sort(rSums);\\n\\n    for (final int lSum : lSums) {\\n      final int i = firstGreaterEqual(rSums, goal - lSum);\\n      if (i < rSums.size()) // 2^n\\n        ans = Math.min(ans, Math.abs(goal - lSum - rSums.get(i)));\\n      if (i > 0)\\n        ans = Math.min(ans, Math.abs(goal - lSum - rSums.get(i - 1)));\\n    }\\n\\n    return ans;\\n  }\\n\\n  private void dfs(int[] A, int i, int path, List<Integer> sums) {\\n    if (i == A.length) {\\n      sums.add(path);\\n      return;\\n    }\\n    dfs(A, i + 1, path + A[i], sums);\\n    dfs(A, i + 1, path, sums);\\n  }\\n\\n  private int firstGreaterEqual(List<Integer> A, int target) {\\n    int l = 0;\\n    int r = A.size();\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (A.get(m) >= target)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n    return l;\\n  }\\n}\\n```\n```python\\nclass Solution:\\n  def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n    n = len(nums) // 2\\n\\n    ans = inf\\n    lSums = []\\n    rSums = []\\n\\n    def dfs(A: List[int], i: int, path: int, sums: List[int]) -> None:\\n      if i == len(A):\\n        sums.append(path)\\n        return\\n      dfs(A, i + 1, path + A[i], sums)\\n      dfs(A, i + 1, path, sums)\\n\\n    dfs(nums[:n], 0, 0, lSums)\\n    dfs(nums[n:], 0, 0, rSums)\\n    rSums.sort()\\n\\n    for lSum in lSums:\\n      i = bisect_left(rSums, goal - lSum)\\n      if i < len(rSums):  # 2^n\\n        ans = min(ans, abs(goal - lSum - rSums[i]))\\n      if i > 0:\\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]))\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483521,
                "title": "meet-in-the-middle-bitmask-binary-search-o-n-2-n-2",
                "content": "```\\n#define ll long long int\\nclass Solution {\\n    int n,pw2[22];\\npublic:\\n    vector<ll> generate(vector<ll> a){\\n        ll n=a.size(),i,j;\\n        ll mask=(1<<n)-1;\\n        vector<ll> v;\\n        for(i=0;i<=mask;i++){\\n            ll s=0;\\n            for(j=0;j<n;j++)\\n                if(i&pw2[j])\\n                    s+=a[j];\\n            v.push_back(s);    \\n        }\\n        return v;\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int t) {\\n        n=nums.size();\\n        int i,j,l=(n+1)/2;\\n        vector<ll> left,right;\\n        \\n        for(i=0;i<l;i++)\\n            left.push_back(nums[i]);\\n        for(;i<n;i++)\\n            right.push_back(nums[i]);\\n        \\n        pw2[0]=1;\\n        for(i=1;i<22;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        left=generate(left);\\n        right=generate(right);\\n        sort(right.begin(),right.end());\\n        \\n        ll mx=0,md=INT_MAX;\\n        for(auto e:left){\\n            ll rem=t-e;\\n            if(right.back()<=rem){\\n                mx=e+right.back();\\n                md=min(md,abs(mx-t));\\n            }\\n            else{\\n                int ind=lower_bound(right.begin(),right.end(),rem)-right.begin();\\n                md=min(md,abs(right[ind]+e-t));\\n                if(ind)\\n                    md=min(md,abs(right[ind-1]+e-t));\\n            }\\n        }\\n        return md;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    int n,pw2[22];\\npublic:\\n    vector<ll> generate(vector<ll> a){\\n        ll n=a.size(),i,j;\\n        ll mask=(1<<n)-1;\\n        vector<ll> v;\\n        for(i=0;i<=mask;i++){\\n            ll s=0;\\n            for(j=0;j<n;j++)\\n                if(i&pw2[j])\\n                    s+=a[j];\\n            v.push_back(s);    \\n        }\\n        return v;\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int t) {\\n        n=nums.size();\\n        int i,j,l=(n+1)/2;\\n        vector<ll> left,right;\\n        \\n        for(i=0;i<l;i++)\\n            left.push_back(nums[i]);\\n        for(;i<n;i++)\\n            right.push_back(nums[i]);\\n        \\n        pw2[0]=1;\\n        for(i=1;i<22;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        left=generate(left);\\n        right=generate(right);\\n        sort(right.begin(),right.end());\\n        \\n        ll mx=0,md=INT_MAX;\\n        for(auto e:left){\\n            ll rem=t-e;\\n            if(right.back()<=rem){\\n                mx=e+right.back();\\n                md=min(md,abs(mx-t));\\n            }\\n            else{\\n                int ind=lower_bound(right.begin(),right.end(),rem)-right.begin();\\n                md=min(md,abs(right[ind]+e-t));\\n                if(ind)\\n                    md=min(md,abs(right[ind-1]+e-t));\\n            }\\n        }\\n        return md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474162,
                "title": "dfs-tle-issue-binary-pruning-accepted",
                "content": "Since the time complexity of DFS solution is O(N^40), it incurs TLE issue.\\n```\\nclass Solution {\\npublic:\\n    \\n    int min_dif = INT_MAX;\\n    int psum;\\n    void dfs(vector<int>& nums, int idx, int goal){\\n        if (idx==nums.size()){\\n            if (abs(psum-goal)<min_dif){\\n                min_dif = abs(psum-goal);\\n            }\\n            return ;\\n        }\\n        \\n        psum += nums.at(idx);\\n        dfs(nums, idx+1, goal);\\n        psum -= nums.at(idx);\\n        \\n        dfs(nums, idx+1, goal);\\n    \\n    }\\n    \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        dfs(nums, 0, goal);\\n        \\n        \\n        return min_dif;\\n    }\\n};\\n```\\n\\nThe next solution prunes the right array by using lower_bound, and its time complexity comes to O(N^24), so it gets accepted.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void psum_gen(vector<int>& nums, int start, int end, vector<int>& v){\\n        \\n        for (int i=start; i<end; ++i){\\n            int sz = v.size();\\n            for (int j=0; j<sz; ++j){\\n                v.push_back(v.at(j) + nums.at(i));\\n            }  \\n        }\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int sz = nums.size();\\n        \\n        vector<int> left;\\n        left.reserve(1<<sz/2+1);\\n        left.push_back(0);\\n        \\n        vector<int> right;\\n        right.reserve(1<<(sz-sz/2));\\n        right.push_back(0);\\n        \\n        psum_gen(nums, 0, sz/2, left);\\n        psum_gen(nums, sz/2, sz, right);\\n        \\n        int min_dif = INT_MAX;\\n        \\n        sort(right.begin(),right.end());\\n        for (int i=0; i<left.size(); ++i){\\n            auto it = lower_bound(right.begin(), right.end(), goal-left.at(i));\\n            \\n            if (it!=right.end())\\n                min_dif = min(abs(*it+left.at(i)-goal), min_dif);\\n            if (it!=right.begin())\\n                min_dif = min(min_dif, abs(goal- *(it-1)-left.at(i)));\\n        }\\n        \\n        return min_dif;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int min_dif = INT_MAX;\\n    int psum;\\n    void dfs(vector<int>& nums, int idx, int goal){\\n        if (idx==nums.size()){\\n            if (abs(psum-goal)<min_dif){\\n                min_dif = abs(psum-goal);\\n            }\\n            return ;\\n        }\\n        \\n        psum += nums.at(idx);\\n        dfs(nums, idx+1, goal);\\n        psum -= nums.at(idx);\\n        \\n        dfs(nums, idx+1, goal);\\n    \\n    }\\n    \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        dfs(nums, 0, goal);\\n        \\n        \\n        return min_dif;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void psum_gen(vector<int>& nums, int start, int end, vector<int>& v){\\n        \\n        for (int i=start; i<end; ++i){\\n            int sz = v.size();\\n            for (int j=0; j<sz; ++j){\\n                v.push_back(v.at(j) + nums.at(i));\\n            }  \\n        }\\n    }\\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int sz = nums.size();\\n        \\n        vector<int> left;\\n        left.reserve(1<<sz/2+1);\\n        left.push_back(0);\\n        \\n        vector<int> right;\\n        right.reserve(1<<(sz-sz/2));\\n        right.push_back(0);\\n        \\n        psum_gen(nums, 0, sz/2, left);\\n        psum_gen(nums, sz/2, sz, right);\\n        \\n        int min_dif = INT_MAX;\\n        \\n        sort(right.begin(),right.end());\\n        for (int i=0; i<left.size(); ++i){\\n            auto it = lower_bound(right.begin(), right.end(), goal-left.at(i));\\n            \\n            if (it!=right.end())\\n                min_dif = min(abs(*it+left.at(i)-goal), min_dif);\\n            if (it!=right.begin())\\n                min_dif = min(min_dif, abs(goal- *(it-1)-left.at(i)));\\n        }\\n        \\n        return min_dif;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326569,
                "title": "tle-after-using-binary-search",
                "content": "\\n\\npair<int,int> search(vector<int> v , int n , int key){\\n        int start = 0 , end = n - 1 , left = -1 , right = -1;\\n        while(end >= start){\\n            int mid = (start + end)/2;\\n            if(v[mid] == key){\\n                return {mid,-1};\\n            }\\n            else if(key - v[mid] > 0){\\n                left = mid;\\n                start = mid + 1;\\n            }\\n            else if(v[mid] - key > 0){\\n                right = mid;\\n                end = mid - 1;\\n            } \\n        }\\n        return {left, right};\\n    }\\n    \\n    int sum(vector<int> v , int mask){\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            if( (mask&(1<<i)) > 0 ){\\n                ans = ans + v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        \\n        int mid = (n-1)/2;\\n        \\n        vector<int> v1 , v2;\\n        for(int i=0;i<=mid;i++) v1.push_back(nums[i]);\\n        for(int i=mid+1;i<n;i++) v2.push_back(nums[i]);\\n    \\n        \\n        vector<int> s1 , s2;\\n        int n1 = v1.size() , n2 = v2.size();\\n        for(int i=0;i<(1<<n1);i++){\\n            int t = sum(v1,i);\\n            s1.push_back(t);\\n        }\\n        for(int i=0;i<(1<<n2);i++){\\n            int t = sum(v2,i);\\n            s2.push_back(t);\\n        }\\n        \\n        sort(s2.begin() , s2.end());\\n        n1 = s1.size() , n2 = s2.size();\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n1;i++){\\n            if(ans == 0)\\n                return ans;\\n            int key = goal - s1[i];\\n            pair<int,int> p = search(s2,n2,key);\\n            int l = p.first , r = p.second;\\n            if(l == -1){\\n                ans = min(ans , abs(key));\\n            }\\n            if(l >= 0){\\n                int t = goal - (s1[i] + s2[l]);\\n                ans = min(ans , t);\\n            }\\n            if(r == -1){\\n                ans = min(ans , abs(key));\\n            }\\n            if(r >= 0){\\n                int t = s1[i] + s2[r] - goal;\\n                ans = min(ans , t);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "\\n\\npair<int,int> search(vector<int> v , int n , int key){\\n        int start = 0 , end = n - 1 , left = -1 , right = -1;\\n        while(end >= start){\\n            int mid = (start + end)/2;\\n            if(v[mid] == key){\\n                return {mid,-1};\\n            }\\n            else if(key - v[mid] > 0){\\n                left = mid;\\n                start = mid + 1;\\n            }\\n            else if(v[mid] - key > 0){\\n                right = mid;\\n                end = mid - 1;\\n            } \\n        }\\n        return {left, right};\\n    }\\n    \\n    int sum(vector<int> v , int mask){\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            if( (mask&(1<<i)) > 0 ){\\n                ans = ans + v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n = nums.size();\\n        \\n        int mid = (n-1)/2;\\n        \\n        vector<int> v1 , v2;\\n        for(int i=0;i<=mid;i++) v1.push_back(nums[i]);\\n        for(int i=mid+1;i<n;i++) v2.push_back(nums[i]);\\n    \\n        \\n        vector<int> s1 , s2;\\n        int n1 = v1.size() , n2 = v2.size();\\n        for(int i=0;i<(1<<n1);i++){\\n            int t = sum(v1,i);\\n            s1.push_back(t);\\n        }\\n        for(int i=0;i<(1<<n2);i++){\\n            int t = sum(v2,i);\\n            s2.push_back(t);\\n        }\\n        \\n        sort(s2.begin() , s2.end());\\n        n1 = s1.size() , n2 = s2.size();\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n1;i++){\\n            if(ans == 0)\\n                return ans;\\n            int key = goal - s1[i];\\n            pair<int,int> p = search(s2,n2,key);\\n            int l = p.first , r = p.second;\\n            if(l == -1){\\n                ans = min(ans , abs(key));\\n            }\\n            if(l >= 0){\\n                int t = goal - (s1[i] + s2[l]);\\n                ans = min(ans , t);\\n            }\\n            if(r == -1){\\n                ans = min(ans , abs(key));\\n            }\\n            if(r >= 0){\\n                int t = s1[i] + s2[r] - goal;\\n                ans = min(ans , t);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1278325,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinAbsDifference(int[] nums, int goal)\\n        {\\n            var data1 = new List<int>();\\n            var data2 = new List<int>();\\n            var l = nums.Length >> 1;\\n            getSum(data1, nums, 0, 0, l);\\n            getSum(data2, nums, 0, l, nums.Length);\\n            data1.Sort();\\n            data2.Sort();\\n            int i1 = 0, n1 = data1.Count, i2 = data2.Count - 1;\\n            int ans = Math.Abs(goal);\\n            while (i1 < n1 && i2 >= 0)\\n            {\\n                int num = data1[i1] + data2[i2] - goal;\\n                if (num > 0)\\n                {\\n                    i2--;\\n                    ans = Math.Min(ans, num);\\n                }\\n                else if (num < 0)\\n                {\\n                    i1++;\\n                    ans = Math.Min(ans, -num);\\n                }\\n                else\\n                    return 0;\\n            }\\n            return ans;\\n        }\\n\\n        private void getSum(List<int> col, int[] nums, int sum, int i, int end)\\n        {\\n            if (i >= end)\\n            {\\n                col.Add(sum);\\n                return;\\n            }\\n            getSum(col, nums, sum + nums[i], i + 1, end);\\n            getSum(col, nums, sum, i + 1, end);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinAbsDifference(int[] nums, int goal)\\n        {\\n            var data1 = new List<int>();\\n            var data2 = new List<int>();\\n            var l = nums.Length >> 1;\\n            getSum(data1, nums, 0, 0, l);\\n            getSum(data2, nums, 0, l, nums.Length);\\n            data1.Sort();\\n            data2.Sort();\\n            int i1 = 0, n1 = data1.Count, i2 = data2.Count - 1;\\n            int ans = Math.Abs(goal);\\n            while (i1 < n1 && i2 >= 0)\\n            {\\n                int num = data1[i1] + data2[i2] - goal;\\n                if (num > 0)\\n                {\\n                    i2--;\\n                    ans = Math.Min(ans, num);\\n                }\\n                else if (num < 0)\\n                {\\n                    i1++;\\n                    ans = Math.Min(ans, -num);\\n                }\\n                else\\n                    return 0;\\n            }\\n            return ans;\\n        }\\n\\n        private void getSum(List<int> col, int[] nums, int sum, int i, int end)\\n        {\\n            if (i >= end)\\n            {\\n                col.Add(sum);\\n                return;\\n            }\\n            getSum(col, nums, sum + nums[i], i + 1, end);\\n            getSum(col, nums, sum, i + 1, end);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148773,
                "title": "java-meet-in-the-middle-o-n-2-n-2",
                "content": "```\\n\\tpublic int minAbsDifference(int[] nums, int goal) {\\n        int n= nums.length;\\n        List<Integer> subsets1= new ArrayList<>();\\n        List<Integer> subsets2= new ArrayList<>();\\n        subsequences(nums,0,0,n/2,subsets1);\\n        subsequences(nums,0,n/2,n,subsets2);\\n        Collections.sort(subsets2);\\n        int[] closest= {Integer.MAX_VALUE};\\n        for(int num: subsets1){\\n            binarySearch(num,goal,closest,subsets2);\\n            if(closest[0]==0) return 0;\\n        }\\n        return closest[0];\\n    }\\n    public void binarySearch(int num1,int goal,int[] closest,List<Integer> subset){\\n        int left=0, right= subset.size()-1;\\n        while(left<=right){\\n            int mid= (left+right)/2;\\n            closest[0]= Math.min(closest[0],Math.abs(num1+subset.get(mid)-goal));\\n            if(num1+subset.get(mid)<goal) left= mid+1;\\n            else if(num1+subset.get(mid)>goal) right= mid-1;\\n            else return;\\n        }\\n    }\\n    public void subsequences(int[] nums,int sum,int ind,int end,List<Integer> subset){\\n        if(ind==end){\\n            subset.add(sum);\\n            return;\\n        }\\n        subsequences(nums,sum,ind+1,end,subset);\\n        subsequences(nums,sum+nums[ind],ind+1,end,subset);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minAbsDifference(int[] nums, int goal) {\\n        int n= nums.length;\\n        List<Integer> subsets1= new ArrayList<>();\\n        List<Integer> subsets2= new ArrayList<>();\\n        subsequences(nums,0,0,n/2,subsets1);\\n        subsequences(nums,0,n/2,n,subsets2);\\n        Collections.sort(subsets2);\\n        int[] closest= {Integer.MAX_VALUE};\\n        for(int num: subsets1){\\n            binarySearch(num,goal,closest,subsets2);\\n            if(closest[0]==0) return 0;\\n        }\\n        return closest[0];\\n    }\\n    public void binarySearch(int num1,int goal,int[] closest,List<Integer> subset){\\n        int left=0, right= subset.size()-1;\\n        while(left<=right){\\n            int mid= (left+right)/2;\\n            closest[0]= Math.min(closest[0],Math.abs(num1+subset.get(mid)-goal));\\n            if(num1+subset.get(mid)<goal) left= mid+1;\\n            else if(num1+subset.get(mid)>goal) right= mid-1;\\n            else return;\\n        }\\n    }\\n    public void subsequences(int[] nums,int sum,int ind,int end,List<Integer> subset){\\n        if(ind==end){\\n            subset.add(sum);\\n            return;\\n        }\\n        subsequences(nums,sum,ind+1,end,subset);\\n        subsequences(nums,sum+nums[ind],ind+1,end,subset);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1081054,
                "title": "c-o-2-n-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal){\\n        int n = nums.size(), res = INT_MAX;\\n        set<int> sum2;\\n        \\n        for(int mask = 0;mask < (1 << (n - n / 2));mask++){\\n            int s = 0;\\n            for(int i = 0, j = n / 2;i < (n - n / 2);i++, j++)\\n                if(mask & (1 << i))\\n                    s += nums[j];\\n            sum2.insert(s);\\n        }\\n        for(int mask = 0;mask < (1 << (n / 2));mask++){\\n            int s = 0;\\n            for(int i = 0;i < n / 2;i++)\\n                if(mask & (1 << i))\\n                    s += nums[i];\\n            auto it = sum2.lower_bound(goal - s);\\n            if(it != sum2.end())\\n                res = min(res, abs(s + *it - goal));\\n            if(it != sum2.begin()){\\n                it--;\\n                res = min(res, abs(s + *it - goal));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal){\\n        int n = nums.size(), res = INT_MAX;\\n        set<int> sum2;\\n        \\n        for(int mask = 0;mask < (1 << (n - n / 2));mask++){\\n            int s = 0;\\n            for(int i = 0, j = n / 2;i < (n - n / 2);i++, j++)\\n                if(mask & (1 << i))\\n                    s += nums[j];\\n            sum2.insert(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1074014,
                "title": "java-solution-divide-to-2-parts-treeset-time-o-2-n-2-log-2-n-2",
                "content": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        List<Integer> leftSum = new ArrayList<>();\\n        List<Integer> rightSum = new ArrayList<>();\\n        leftSum.add(0);\\n        rightSum.add(0);\\n        for (int i = 0; i < n / 2; i++) {\\n            int size = leftSum.size();\\n            for (int j = 0; j < size; j++) {\\n                leftSum.add(leftSum.get(j) + nums[i]);\\n            }\\n        }\\n        for (int i = n / 2; i < n; i++) {\\n            int size = rightSum.size();\\n            for (int j = 0; j < size; j++) {\\n                rightSum.add(rightSum.get(j) + nums[i]);\\n            }\\n        }\\n        TreeSet<Integer> rightSumSet = new TreeSet<>(rightSum);\\n        Set<Integer> leftSumSet = new HashSet<>(leftSum);\\n        int ans = Math.abs(goal);\\n        for (Integer a : leftSumSet) {\\n            int b = goal - a;\\n            Integer lower = rightSumSet.floor(b);\\n            Integer higher = rightSumSet.ceiling(b);\\n            if (lower != null) {\\n                ans = Math.min(ans, Math.abs(goal - a - lower));\\n            }\\n            if (higher != null) {\\n                ans = Math.min(ans, Math.abs(goal - a - higher));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        List<Integer> leftSum = new ArrayList<>();\\n        List<Integer> rightSum = new ArrayList<>();\\n        leftSum.add(0);\\n        rightSum.add(0);\\n        for (int i = 0; i < n / 2; i++) {\\n            int size = leftSum.size();\\n            for (int j = 0; j < size; j++) {\\n                leftSum.add(leftSum.get(j) + nums[i]);\\n            }\\n        }\\n        for (int i = n / 2; i < n; i++) {\\n            int size = rightSum.size();\\n            for (int j = 0; j < size; j++) {\\n                rightSum.add(rightSum.get(j) + nums[i]);\\n            }\\n        }\\n        TreeSet<Integer> rightSumSet = new TreeSet<>(rightSum);\\n        Set<Integer> leftSumSet = new HashSet<>(leftSum);\\n        int ans = Math.abs(goal);\\n        for (Integer a : leftSumSet) {\\n            int b = goal - a;\\n            Integer lower = rightSumSet.floor(b);\\n            Integer higher = rightSumSet.ceiling(b);\\n            if (lower != null) {\\n                ans = Math.min(ans, Math.abs(goal - a - lower));\\n            }\\n            if (higher != null) {\\n                ans = Math.min(ans, Math.abs(goal - a - higher));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067235,
                "title": "java-clean-meet-in-the-middle",
                "content": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        List<Integer> left = findPermutationSums(nums, 0, n / 2);\\n        List<Integer> right = findPermutationSums(nums, n / 2, n);\\n        \\n        int answer = Integer.MAX_VALUE;\\n        for (int num : left) {\\n            answer = Math.min(answer, Math.abs(goal - num));\\n        }\\n        \\n        for (int num : right) {\\n            answer = Math.min(answer, Math.abs(goal - num));\\n        }\\n        \\n        for (int num : right) {\\n            int expected = goal - num;\\n            int index = Collections.binarySearch(left, expected);\\n            \\n            if (index < 0) {\\n                index = -index - 1;\\n            }\\n            \\n            if (index < left.size()) {\\n                answer = Math.min(answer, Math.abs(left.get(index) + num - goal));\\n            }\\n            \\n            if (index > 0) {\\n                answer = Math.min(answer, Math.abs(left.get(index - 1) + num - goal));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private List<Integer> findPermutationSums(int[] arr, int start, int end) {\\n        int length = end - start;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int count = 1 << length;\\n        for (int bit = 0; bit < count; bit++) {\\n            int sum = 0;\\n            \\n            for (int cur = 0; cur < length; cur++) {\\n                if ((bit & (1 << cur)) != 0) {\\n                    sum += arr[start + cur];\\n                }\\n            }\\n            \\n            list.add(sum);\\n        }\\n        \\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        List<Integer> left = findPermutationSums(nums, 0, n / 2);\\n        List<Integer> right = findPermutationSums(nums, n / 2, n);\\n        \\n        int answer = Integer.MAX_VALUE;\\n        for (int num : left) {\\n            answer = Math.min(answer, Math.abs(goal - num));\\n        }\\n        \\n        for (int num : right) {\\n            answer = Math.min(answer, Math.abs(goal - num));\\n        }\\n        \\n        for (int num : right) {\\n            int expected = goal - num;\\n            int index = Collections.binarySearch(left, expected);\\n            \\n            if (index < 0) {\\n                index = -index - 1;\\n            }\\n            \\n            if (index < left.size()) {\\n                answer = Math.min(answer, Math.abs(left.get(index) + num - goal));\\n            }\\n            \\n            if (index > 0) {\\n                answer = Math.min(answer, Math.abs(left.get(index - 1) + num - goal));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private List<Integer> findPermutationSums(int[] arr, int start, int end) {\\n        int length = end - start;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int count = 1 << length;\\n        for (int bit = 0; bit < count; bit++) {\\n            int sum = 0;\\n            \\n            for (int cur = 0; cur < length; cur++) {\\n                if ((bit & (1 << cur)) != 0) {\\n                    sum += arr[start + cur];\\n                }\\n            }\\n            \\n            list.add(sum);\\n        }\\n        \\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064092,
                "title": "memorization-using-unordered-map-of-pairs-57-73-passed-help-needed-in-finding-error",
                "content": "I tried memorized based solution using unordered_map of pairs. 57/73 cases are passing. First example where it fails  is:\\nInput:\\n[2469,-7439,8971,-8162,-5591,-8404,7160,6127,8861,-1746,-1960,8801,1096,1848,2128,3191,72,5223,9603]\\n563282662\\nOutput:\\n563217184\\nExpected:\\n563217112\\n\\nIf anyone can help me find the mistake, it would be a great help. Thanks in adance.\\n\\n```\\n\\n#define ll long long int\\n#define pll pair<ll,ll>\\nll ans,n;\\n\\n\\nstruct hash_pair { \\n    template <class T1, class T2> \\n    size_t operator()(const pair<T1, T2>& p) const\\n    { \\n        auto hash1 = hash<T1>{}(p.first); \\n        auto hash2 = hash<T2>{}(p.second); \\n        return hash1 ^ hash2; \\n    } \\n}; \\nunordered_map<pll, int, hash_pair> vis;\\nclass Solution {\\npublic:\\n    \\n    void func(vector<int>& nums, ll goal, ll index, ll sum)\\n    {\\n        if(index>=n)\\n            return;\\n        if(vis.find({index,sum})!=vis.end())\\n            return;\\n        ll sum_incl = sum + nums[index];\\n        if(abs(sum_incl-goal)<ans)\\n        {\\n            ans = abs(sum_incl-goal);\\n        }\\n        if(abs(sum-goal)<ans)\\n        {\\n            ans = abs(sum-goal);\\n        }\\n        vis[{index,sum_incl}]++;\\n        vis[{index,sum}]++;\\n        func(nums,goal,index+1,sum_incl);\\n        func(nums,goal,index+1,sum);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        ans = abs(goal);\\n        n = nums.size();\\n        vis.clear();\\n        func(nums,goal,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define ll long long int\\n#define pll pair<ll,ll>\\nll ans,n;\\n\\n\\nstruct hash_pair { \\n    template <class T1, class T2> \\n    size_t operator()(const pair<T1, T2>& p) const\\n    { \\n        auto hash1 = hash<T1>{}(p.first); \\n        auto hash2 = hash<T2>{}(p.second); \\n        return hash1 ^ hash2; \\n    } \\n}; \\nunordered_map<pll, int, hash_pair> vis;\\nclass Solution {\\npublic:\\n    \\n    void func(vector<int>& nums, ll goal, ll index, ll sum)\\n    {\\n        if(index>=n)\\n            return;\\n        if(vis.find({index,sum})!=vis.end())\\n            return;\\n        ll sum_incl = sum + nums[index];\\n        if(abs(sum_incl-goal)<ans)\\n        {\\n            ans = abs(sum_incl-goal);\\n        }\\n        if(abs(sum-goal)<ans)\\n        {\\n            ans = abs(sum-goal);\\n        }\\n        vis[{index,sum_incl}]++;\\n        vis[{index,sum}]++;\\n        func(nums,goal,index+1,sum_incl);\\n        func(nums,goal,index+1,sum);\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        ans = abs(goal);\\n        n = nums.size();\\n        vis.clear();\\n        func(nums,goal,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058521,
                "title": "python-slow-but-passes-all-test-cases-but-more-exact-imho",
                "content": "Feel free to browse others\\' solutions on the rationale for why you\\'d want to split `nums` into two halves and use binary search to match the subsequence sums from the left side with that on the right side. The difficult part, at least to me, is writing out the binary search logic exactly such that it\\'s provably correct. I avoid using bisect.bisect_left() and bisect.bisect_right() because it\\'s often difficult to convince yourself that it indeed converges toward the right value according to the constraint. Instead I write my own, by always considering two cases: are we looking for a candidate value that is closest or equal to some lower-bound from above, or are we looking for a candidate value that is closest or equal to some upper-bound from below. Depending on the case, how we calculate the divide and conquer indexes, `low`, `mid`, and `high` are very different. I\\'ll let the code below explain. I think, to me, this is a very good problem that illustrates how to reason about binary-search correctly, instead of blindly applying bisect_left() or bisect_right().\\n\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def gen_subset_sums(nums, i, end, s, sums):\\n            if i == end:\\n                return sums.add(s)\\n            gen_subset_sums(nums, i+1, end, s, sums)\\n            gen_subset_sums(nums, i+1, end, s + nums[i], sums)\\n\\n        # First the easy part, generate the set of all possible subsequence sums we could generate\\n\\t\\t# from nums[0:n//2], we\\'ll call them `left_sums`.\\n\\t\\t# Important: 0 will be a possible subset sum generated for left_sums and right_sums. Luckily\\n        # this makes the code easier to write. (Considering the problem of generating subset sums of\\n\\t\\t# only non-empty subsequences, which would be slightly annoying)\\n        n = len(nums)\\n        left_sums = set()\\n        gen_subset_sums(nums, 0, n//2, 0, left_sums)\\n\\t\\t# Then generate the set of all possible subsequence sums we could get from nums[n//2:n]\\n\\t\\t# which we call `right_sums`\\n        right_sums = set()\\n        gen_subset_sums(nums, n//2, n, 0, right_sums)\\n        right_sums = sorted(list(right_sums))\\n        \\n\\t\\t# Now we want to match some left_sums[i] with some right_sums[j] such that \\n\\t\\t# abs(goal - (left_sums[i] + right_sums[j])) is as small as possible, the minimum difference.\\n        # Well, in the worst case we could take none of the values in nums, so the empty \\n\\t\\t# subsequence sum is 0 and the minimum difference is abs(goal)\\n        min_diff = abs(goal)    \\n        for left_sum in left_sums:\\n            # If goal <= left_sum + right_sum, then right_sum >= goal - left_sum and then we can\\n            # view goal - left_sum as the lower-bound which we want to approach from the right,\\n            # i.e. we want to find the smallest right_sum that is above or equal to the lower-bound\\n            low, high = 0, len(right_sums) - 1\\n            lower_bound = goal - left_sum\\n            while low < high:\\n                mid = (low + high) // 2\\n                if lower_bound == right_sums[mid]:\\n                    return 0\\n                if right_sums[mid] > lower_bound:\\n                    # Invariant: right_sums[high] must be the new smallest right_sum above lower_bound\\n                    high = mid\\n                else:\\n                    low = mid + 1\\n            # Either right_sums[high] was the smallest right_sum we\\'ve found, or len(right_sums) == 1,\\n            # so we\\'d still need to consider it as a candidate\\n            min_diff = min(min_diff, abs(goal - (left_sum + right_sums[high])))\\n\\n            # If goal >= left_sum + right_sum, then right_sum <= goal - left_sum and then we can view\\n            # goal - left_sum as the upper-bound which we want to approach from the left, \\n            # i.e. we want to find the largest right_sum that is below or equal to the upper-bound\\n            low, high = 0, len(right_sums) - 1\\n            upper_bound = goal - left_sum\\n            while low < high:\\n                mid = (low + high) // 2 + 1\\n                if upper_bound == right_sums[mid]:\\n                    return 0\\n                if right_sums[mid] < upper_bound:\\n                    # Invariant: right_sums[low] must be the new largest right_sum below upper_bound\\n                    low = mid\\n                else:\\n                    high = mid - 1\\n            min_diff = min(min_diff, abs(goal - (left_sum + right_sums[low])))\\n                    \\n        return min_diff\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def gen_subset_sums(nums, i, end, s, sums):\\n            if i == end:\\n                return sums.add(s)\\n            gen_subset_sums(nums, i+1, end, s, sums)\\n            gen_subset_sums(nums, i+1, end, s + nums[i], sums)\\n\\n        # First the easy part, generate the set of all possible subsequence sums we could generate\\n\\t\\t# from nums[0:n//2], we\\'ll call them `left_sums`.\\n\\t\\t# Important: 0 will be a possible subset sum generated for left_sums and right_sums. Luckily\\n        # this makes the code easier to write. (Considering the problem of generating subset sums of\\n\\t\\t# only non-empty subsequences, which would be slightly annoying)\\n        n = len(nums)\\n        left_sums = set()\\n        gen_subset_sums(nums, 0, n//2, 0, left_sums)\\n\\t\\t# Then generate the set of all possible subsequence sums we could get from nums[n//2:n]\\n\\t\\t# which we call `right_sums`\\n        right_sums = set()\\n        gen_subset_sums(nums, n//2, n, 0, right_sums)\\n        right_sums = sorted(list(right_sums))\\n        \\n\\t\\t# Now we want to match some left_sums[i] with some right_sums[j] such that \\n\\t\\t# abs(goal - (left_sums[i] + right_sums[j])) is as small as possible, the minimum difference.\\n        # Well, in the worst case we could take none of the values in nums, so the empty \\n\\t\\t# subsequence sum is 0 and the minimum difference is abs(goal)\\n        min_diff = abs(goal)    \\n        for left_sum in left_sums:\\n            # If goal <= left_sum + right_sum, then right_sum >= goal - left_sum and then we can\\n            # view goal - left_sum as the lower-bound which we want to approach from the right,\\n            # i.e. we want to find the smallest right_sum that is above or equal to the lower-bound\\n            low, high = 0, len(right_sums) - 1\\n            lower_bound = goal - left_sum\\n            while low < high:\\n                mid = (low + high) // 2\\n                if lower_bound == right_sums[mid]:\\n                    return 0\\n                if right_sums[mid] > lower_bound:\\n                    # Invariant: right_sums[high] must be the new smallest right_sum above lower_bound\\n                    high = mid\\n                else:\\n                    low = mid + 1\\n            # Either right_sums[high] was the smallest right_sum we\\'ve found, or len(right_sums) == 1,\\n            # so we\\'d still need to consider it as a candidate\\n            min_diff = min(min_diff, abs(goal - (left_sum + right_sums[high])))\\n\\n            # If goal >= left_sum + right_sum, then right_sum <= goal - left_sum and then we can view\\n            # goal - left_sum as the upper-bound which we want to approach from the left, \\n            # i.e. we want to find the largest right_sum that is below or equal to the upper-bound\\n            low, high = 0, len(right_sums) - 1\\n            upper_bound = goal - left_sum\\n            while low < high:\\n                mid = (low + high) // 2 + 1\\n                if upper_bound == right_sums[mid]:\\n                    return 0\\n                if right_sums[mid] < upper_bound:\\n                    # Invariant: right_sums[low] must be the new largest right_sum below upper_bound\\n                    low = mid\\n                else:\\n                    high = mid - 1\\n            min_diff = min(min_diff, abs(goal - (left_sum + right_sums[low])))\\n                    \\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057598,
                "title": "getting-tle-with-meet-in-the-middle-solution-can-any-one-please-help",
                "content": "```\\'\\'\\'\\nclass Solution {\\npublic:\\n    void findsum(vector<int> nums,int i,int n,vector<int> &sum,int asum){\\n            if(i>=n){\\n                sum.push_back(asum);\\n                return;\\n            }\\n            findsum(nums,i+1,n,sum,asum+nums[i]);\\n           // sum.push_back(sum1);\\n            findsum(nums,i+1,n,sum,asum);  \\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> sum1,sum2;\\n        int n=nums.size(),ans=INT_MAX;\\n        findsum(nums,0,n/2,sum1,0);\\n        findsum(nums,n/2,n,sum2,0);\\n        sort(sum1.begin(),sum1.end());\\n\\n        for(int i=0;i<sum2.size();i++){\\n            int target=goal-sum2[i];\\n            int in=upper_bound(sum1.begin(),sum1.end(),target)-sum1.begin();\\n            if(in<sum1.size()){\\n                ans=min(ans,abs(target-sum1[in]));\\n            }\\n            if(in>0){\\n                ans=min(ans,abs(target-sum1[in-1]));\\n            }\\n           // printf(\"ans becoming %d\\\\n\",ans);\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void findsum(vector<int> nums,int i,int n,vector<int> &sum,int asum){\\n            if(i>=n){\\n                sum.push_back(asum);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1056075,
                "title": "java-using-treeset-explained-time-complexity-o-2-n-2-2-n-2-log-2-n-2",
                "content": "```\\nclass Solution {\\n    \\n    Set<Long> set1;\\n    TreeSet<Long> treeSet2;\\n    long ans;\\n    \\n    public void subsetSum(long sum,int[] nums,int j,int n,boolean flag,int goal){\\n        \\n        ans = Math.min(ans,Math.abs(sum-goal));\\n        \\n        //flag to track which subset sums are we calculating\\n        if(flag)\\n            set1.add(sum);\\n        else\\n            treeSet2.add(sum);\\n        \\n        if(j > n)\\n            return;\\n        \\n        //we have 2 options either skip this element or pick this element \\n        subsetSum(sum + nums[j],nums,j+1,n,flag,goal); // pick\\n        subsetSum(sum,nums,j+1,n,flag,goal); // skip\\n        \\n    }\\n    \\n    public int minAbsDifference(int[] nums, int goal) {\\n        \\n        int n = nums.length;\\n        set1 = new HashSet<>();\\n        treeSet2 = new TreeSet<>();\\n        ans = Math.abs(goal);\\n        \\n        int mid = (n-1)/2;\\n        \\n        //for first half elements\\n        subsetSum(0,nums,0,mid,true,goal); // time complexity : O(2 raise to power n/2)\\n        \\n        // for second half\\n        subsetSum(0,nums,mid+1,n-1,false,goal); // time complexity : O(2 raise to power n/2)\\n        \\n        for(Long sum1 : set1){ //time complexity : O(2 raise to power n/2)\\n            \\n            long diffFromGoal = (goal-sum1); // to calculate if we pick this sum then how far are we from goal\\n            \\n            Long closestMin = treeSet2.floor(diffFromGoal); // time complexity :  O(log(2 raise to power n/2))\\n            Long closestMax = treeSet2.ceiling(diffFromGoal); // time complexity : O(log(2 raise to power n/2))\\n            \\n            \\n            if(closestMin != null)\\n                ans = Math.min(ans,Math.abs(goal - (sum1 + closestMin)));\\n            \\n            if(closestMax != null)\\n                ans = Math.min(ans,Math.abs(goal - (sum1 + closestMax)));\\n            \\n        }\\n        \\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Set<Long> set1;\\n    TreeSet<Long> treeSet2;\\n    long ans;\\n    \\n    public void subsetSum(long sum,int[] nums,int j,int n,boolean flag,int goal){\\n        \\n        ans = Math.min(ans,Math.abs(sum-goal));\\n        \\n        //flag to track which subset sums are we calculating\\n        if(flag)\\n            set1.add(sum);\\n        else\\n            treeSet2.add(sum);\\n        \\n        if(j > n)\\n            return;\\n        \\n        //we have 2 options either skip this element or pick this element \\n        subsetSum(sum + nums[j],nums,j+1,n,flag,goal); // pick\\n        subsetSum(sum,nums,j+1,n,flag,goal); // skip\\n        \\n    }\\n    \\n    public int minAbsDifference(int[] nums, int goal) {\\n        \\n        int n = nums.length;\\n        set1 = new HashSet<>();\\n        treeSet2 = new TreeSet<>();\\n        ans = Math.abs(goal);\\n        \\n        int mid = (n-1)/2;\\n        \\n        //for first half elements\\n        subsetSum(0,nums,0,mid,true,goal); // time complexity : O(2 raise to power n/2)\\n        \\n        // for second half\\n        subsetSum(0,nums,mid+1,n-1,false,goal); // time complexity : O(2 raise to power n/2)\\n        \\n        for(Long sum1 : set1){ //time complexity : O(2 raise to power n/2)\\n            \\n            long diffFromGoal = (goal-sum1); // to calculate if we pick this sum then how far are we from goal\\n            \\n            Long closestMin = treeSet2.floor(diffFromGoal); // time complexity :  O(log(2 raise to power n/2))\\n            Long closestMax = treeSet2.ceiling(diffFromGoal); // time complexity : O(log(2 raise to power n/2))\\n            \\n            \\n            if(closestMin != null)\\n                ans = Math.min(ans,Math.abs(goal - (sum1 + closestMin)));\\n            \\n            if(closestMax != null)\\n                ans = Math.min(ans,Math.abs(goal - (sum1 + closestMax)));\\n            \\n        }\\n        \\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055747,
                "title": "c-divide-into-two-halves",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n     int n=nums.size();\\n        ll int n1=n/2;\\n        vector<int>nums1;\\n        vector<int>nums2;\\n        for(int i=0;i<n1;i++)\\n            nums1.push_back(nums[i]);\\n        for(int i=n1;i<n;i++)\\n            nums2.push_back(nums[i]);\\n        n1=nums1.size();\\n        ll int n2=nums2.size();\\n        vector<ll int>ans;\\n          ll int minval=1e15;\\n        for(ll int i=1;i<(1LL<<n1);i++)\\n        {\\n            ll int sum=0;\\n            for(ll int j=0;j<n1;j++)\\n            {\\n                if(i & (1LL<<j))\\n                    sum+=nums1[j];\\n            }\\n            minval=min(minval,abs(goal-sum));\\n            ans.push_back(sum);\\n        }\\n      \\n        sort(ans.begin(),ans.end());\\n        for(ll int i=1;i<(1LL<<n2);i++)\\n        {\\n            ll int sum=0;\\n            for(ll int j=0;j<n2;j++)\\n            {\\n                if(i & (1LL<<j))\\n                    sum+=nums2[j];\\n            }\\n            ll int val=goal-sum;\\n            minval=min(minval,abs(val));\\n            auto it=upper_bound(ans.begin(),ans.end(),val);\\n            if(it!=ans.end())\\n                minval=min(minval,abs(val-(*it)));\\n            if(it!=ans.begin())\\n                --it;\\n            minval=min(minval,abs(val-(*it)));\\n        }\\n        minval=min(minval,abs((ll int)goal));\\n        return minval;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n     int n=nums.size();\\n        ll int n1=n/2;\\n        vector<int>nums1;\\n        vector<int>nums2;\\n        for(int i=0;i<n1;i++)\\n            nums1.push_back(nums[i]);\\n        for(int i=n1;i<n;i++)\\n            nums2.push_back(nums[i]);\\n        n1=nums1.size();\\n        ll int n2=nums2.size();\\n        vector<ll int>ans;\\n          ll int minval=1e15;\\n        for(ll int i=1;i<(1LL<<n1);i++)\\n        {\\n            ll int sum=0;\\n            for(ll int j=0;j<n1;j++)\\n            {\\n                if(i & (1LL<<j))\\n                    sum+=nums1[j];\\n            }\\n            minval=min(minval,abs(goal-sum));\\n            ans.push_back(sum);\\n        }\\n      \\n        sort(ans.begin(),ans.end());\\n        for(ll int i=1;i<(1LL<<n2);i++)\\n        {\\n            ll int sum=0;\\n            for(ll int j=0;j<n2;j++)\\n            {\\n                if(i & (1LL<<j))\\n                    sum+=nums2[j];\\n            }\\n            ll int val=goal-sum;\\n            minval=min(minval,abs(val));\\n            auto it=upper_bound(ans.begin(),ans.end(),val);\\n            if(it!=ans.end())\\n                minval=min(minval,abs(val-(*it)));\\n            if(it!=ans.begin())\\n                --it;\\n            minval=min(minval,abs(val-(*it)));\\n        }\\n        minval=min(minval,abs((ll int)goal));\\n        return minval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055677,
                "title": "simple-c-using-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        int n = nums.size();\\n        int ans = INT_MAX;\\n        vector<int> s1 = {0}, s2 = {0};\\n        for(int i = 0; i < (n/2); i++)\\n        {\\n            int len = s1.size();\\n            for(int j = 0; j < len; j++)\\n            {\\n                s1.push_back(s1[j]+nums[i]);\\n            }\\n        }\\n        for(int i = n/2 ; i < n; i++)\\n        {\\n            int len = s2.size();\\n            for(int j = 0; j < len; j++)\\n            {\\n                s2.push_back(s2[j]+nums[i]);\\n            }\\n        }\\n        \\n        int s1_size = s1.size(), s2_size = s2.size();\\n        sort(s2.begin(), s2.end());\\n        for(auto s: s1)\\n        {\\n            int rem = goal-s;\\n            int e1 = lower_bound(s2.begin(), s2.end(), rem) - s2.begin();\\n            if(e1 != s2.size())\\n            {\\n                ans = min(ans, abs(s2[e1]+s-goal));\\n            }\\n            if(e1 != 0)\\n            {\\n                ans = min(ans, abs(s2[e1-1]+s-goal));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDidnt solve this during contest, Learned about meet in the middle algo now, If anyone has any list of such different algo please let me know in commnets\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) \\n    {\\n        int n = nums.size();\\n        int ans = INT_MAX;\\n        vector<int> s1 = {0}, s2 = {0};\\n        for(int i = 0; i < (n/2); i++)\\n        {\\n            int len = s1.size();\\n            for(int j = 0; j < len; j++)\\n            {\\n                s1.push_back(s1[j]+nums[i]);\\n            }\\n        }\\n        for(int i = n/2 ; i < n; i++)\\n        {\\n            int len = s2.size();\\n            for(int j = 0; j < len; j++)\\n            {\\n                s2.push_back(s2[j]+nums[i]);\\n            }\\n        }\\n        \\n        int s1_size = s1.size(), s2_size = s2.size();\\n        sort(s2.begin(), s2.end());\\n        for(auto s: s1)\\n        {\\n            int rem = goal-s;\\n            int e1 = lower_bound(s2.begin(), s2.end(), rem) - s2.begin();\\n            if(e1 != s2.size())\\n            {\\n                ans = min(ans, abs(s2[e1]+s-goal));\\n            }\\n            if(e1 != 0)\\n            {\\n                ans = min(ans, abs(s2[e1-1]+s-goal));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055566,
                "title": "split-in-the-middle-c-binarysearch-subset-sum",
                "content": "```\\npublic int MinAbsDifference(int[] nums, int goal) {\\n        int result = int.MaxValue;\\n        \\n        List<int> sumListLeft = new List<int>();\\n        List<int> sumListRight = new List<int>();\\n        \\n        int mid = nums.Length/2;\\n        DFS(nums, 0, mid, 0, sumListLeft);\\n        DFS(nums, mid, nums.Length, 0, sumListRight);\\n        \\n        //sort the right sum list\\n        sumListRight.Sort();\\n        \\n        foreach(int leftSum in sumListLeft)\\n        {\\n            int remain = goal - leftSum;\\n            int rightSum = BinarySearchRemain(sumListRight, remain);\\n            \\n            result = Math.Min(result, Math.Abs((leftSum + rightSum) - goal));\\n        }\\n        return result;\\n    }\\n    \\n    private void DFS(int[] nums, int frIdx, int toIdx, int sum, List<int> sumList)\\n    {\\n        if(frIdx == toIdx)\\n        {\\n            sumList.Add(sum);\\n            return;\\n        }\\n        //Include\\n        DFS(nums, frIdx + 1, toIdx, sum + nums[frIdx], sumList);\\n        \\n        //exclude\\n        DFS(nums, frIdx + 1, toIdx, sum, sumList);\\n    }\\n    \\n    private int BinarySearchRemain(List<int> sumListRight, int remainSum)\\n    {\\n        int l = 0, r = sumListRight.Count - 1;\\n        while(l < r)\\n        {\\n            int m = l + (r - l)/2;\\n            if(sumListRight[m] == remainSum)\\n                return sumListRight[m];\\n            else if(sumListRight[m] > remainSum)\\n            {\\n                int midDiff = sumListRight[m] - remainSum;\\n                if(m-1 >= 0 && midDiff < Math.Abs(remainSum - sumListRight[m - 1]))\\n                    return sumListRight[m];\\n                else\\n                    r = m - 1;\\n            }\\n            else //less\\n            {\\n                int midDiff = remainSum - sumListRight[m];\\n                if(m + 1 < sumListRight.Count && midDiff < Math.Abs(remainSum - sumListRight[m + 1]))\\n                    return sumListRight[m];\\n                else\\n                    l = m + 1;\\n            }\\n        }\\n        return sumListRight[l];  //or r\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic int MinAbsDifference(int[] nums, int goal) {\\n        int result = int.MaxValue;\\n        \\n        List<int> sumListLeft = new List<int>();\\n        List<int> sumListRight = new List<int>();\\n        \\n        int mid = nums.Length/2;\\n        DFS(nums, 0, mid, 0, sumListLeft);\\n        DFS(nums, mid, nums.Length, 0, sumListRight);\\n        \\n        //sort the right sum list\\n        sumListRight.Sort();\\n        \\n        foreach(int leftSum in sumListLeft)\\n        {\\n            int remain = goal - leftSum;\\n            int rightSum = BinarySearchRemain(sumListRight, remain);\\n            \\n            result = Math.Min(result, Math.Abs((leftSum + rightSum) - goal));\\n        }\\n        return result;\\n    }\\n    \\n    private void DFS(int[] nums, int frIdx, int toIdx, int sum, List<int> sumList)\\n    {\\n        if(frIdx == toIdx)\\n        {\\n            sumList.Add(sum);\\n            return;\\n        }\\n        //Include\\n        DFS(nums, frIdx + 1, toIdx, sum + nums[frIdx], sumList);\\n        \\n        //exclude\\n        DFS(nums, frIdx + 1, toIdx, sum, sumList);\\n    }\\n    \\n    private int BinarySearchRemain(List<int> sumListRight, int remainSum)\\n    {\\n        int l = 0, r = sumListRight.Count - 1;\\n        while(l < r)\\n        {\\n            int m = l + (r - l)/2;\\n            if(sumListRight[m] == remainSum)\\n                return sumListRight[m];\\n            else if(sumListRight[m] > remainSum)\\n            {\\n                int midDiff = sumListRight[m] - remainSum;\\n                if(m-1 >= 0 && midDiff < Math.Abs(remainSum - sumListRight[m - 1]))\\n                    return sumListRight[m];\\n                else\\n                    r = m - 1;\\n            }\\n            else //less\\n            {\\n                int midDiff = remainSum - sumListRight[m];\\n                if(m + 1 < sumListRight.Count && midDiff < Math.Abs(remainSum - sumListRight[m + 1]))\\n                    return sumListRight[m];\\n                else\\n                    l = m + 1;\\n            }\\n        }\\n        return sumListRight[l];  //or r\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055432,
                "title": "java-252ms-47-4-mb-horowitz-and-sahni-s-subset-sum-comments-links",
                "content": "The problems has a wikipedia page, which has full analysis and many algorithms of different time complexity.\\nhttps://en.wikipedia.org/wiki/Subset_sum_problem#Pseudo-polynomial_time_dynamic_programming_solution\\nThe following is an solution based on Horowitz and Sahni\\'s algorithm.\\n\\nBesides,\\nI have tried \\n1. the naive one, which turned out exceeding time limit and\\n2. the pesudo-polynomial time dp solution, which turned out exceeding memory limit\\n\\nIf anyone succeed with those two approaches, please share with me your implementations, thanks!\\n```\\nclass Solution {\\n    // Horowitz and Sahni\\'s subset sum algo\\n    // time: O(2 ^ (N / 2) * (N / 2)) for construct and sort two arrays of size (2 ^ (N / 2))\\n    // memory: O(2 ^ (N / 2))\\n    int idx;\\n    int sum;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        \\n        // contscrut two arrays, where\\n        int n_first = (int)Math.pow(2, n / 2);\\n        int n_second = (int)Math.pow(2, n - n / 2);\\n        \\n        int[] first = new int[n_first];\\n        int[] second = new int[n_second];\\n        \\n        // first contains the sums of all subsets of left half of nums\\n        helper(nums, first, 0, n / 2 - 1);\\n        // second contains those of right half of nums\\n        idx = sum = 0;\\n        helper(nums, second, n / 2, n - 1);\\n        \\n        // sort them both in ascending order\\n        Arrays.sort(first);\\n        Arrays.sort(second);\\n\\n        // two-pointers taking O(2 ^ (N / 2)) time\\n        int low = 0;\\n        int high = n_second - 1;\\n        \\n        int ans = Integer.MAX_VALUE;\\n        while (low < n_first && high >= 0) {\\n            int sum = first[low] + second[high];\\n            ans = Math.min(ans, Math.abs(sum - goal));\\n            \\n            if (ans == 0) break;\\n            \\n            if (sum < goal) {\\n                low ++;\\n            } else {\\n                high --;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void helper(int[] nums, int[] arr, int start, int end) {\\n        for (int i = start; i <= end; i ++) {\\n            sum += nums[i];\\n            arr[idx ++] = sum;\\n            helper(nums, arr, i + 1, end);\\n            sum -= nums[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Horowitz and Sahni\\'s subset sum algo\\n    // time: O(2 ^ (N / 2) * (N / 2)) for construct and sort two arrays of size (2 ^ (N / 2))\\n    // memory: O(2 ^ (N / 2))\\n    int idx;\\n    int sum;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        \\n        // contscrut two arrays, where\\n        int n_first = (int)Math.pow(2, n / 2);\\n        int n_second = (int)Math.pow(2, n - n / 2);\\n        \\n        int[] first = new int[n_first];\\n        int[] second = new int[n_second];\\n        \\n        // first contains the sums of all subsets of left half of nums\\n        helper(nums, first, 0, n / 2 - 1);\\n        // second contains those of right half of nums\\n        idx = sum = 0;\\n        helper(nums, second, n / 2, n - 1);\\n        \\n        // sort them both in ascending order\\n        Arrays.sort(first);\\n        Arrays.sort(second);\\n\\n        // two-pointers taking O(2 ^ (N / 2)) time\\n        int low = 0;\\n        int high = n_second - 1;\\n        \\n        int ans = Integer.MAX_VALUE;\\n        while (low < n_first && high >= 0) {\\n            int sum = first[low] + second[high];\\n            ans = Math.min(ans, Math.abs(sum - goal));\\n            \\n            if (ans == 0) break;\\n            \\n            if (sum < goal) {\\n                low ++;\\n            } else {\\n                high --;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void helper(int[] nums, int[] arr, int start, int end) {\\n        for (int i = start; i <= end; i ++) {\\n            sum += nums[i];\\n            arr[idx ++] = sum;\\n            helper(nums, arr, i + 1, end);\\n            sum -= nums[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055154,
                "title": "python-divide-and-conquer-two-pointers",
                "content": "```\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        n = len(nums)\\n        st1 = {0}\\n        st2 = {0}\\n        for i in range(n // 2):\\n            st1 |= {x + nums[i] for x in st1}\\n        for i in range(n // 2, n):\\n            st2 |= {x + nums[i] for x in st2}\\n        st1, st2 = sorted(st1), sorted(st2)\\n        n1, n2 = len(st1), len(st2)\\n        i, j = 0, n2 - 1\\n        res = abs(goal)\\n        while i <= n1 - 1 and j >= 0:\\n            if st1[i] + st2[j] - goal > 0:\\n                res = min(res, st1[i] + st2[j] - goal)\\n                j -= 1\\n            elif st1[i] + st2[j] - goal < 0:\\n                res = min(res, goal - st1[i] - st2[j])\\n                i += 1\\n            else:\\n                return 0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        n = len(nums)\\n        st1 = {0}\\n        st2 = {0}\\n        for i in range(n // 2):\\n            st1 |= {x + nums[i] for x in st1}\\n        for i in range(n // 2, n):\\n            st2 |= {x + nums[i] for x in st2}\\n        st1, st2 = sorted(st1), sorted(st2)\\n        n1, n2 = len(st1), len(st2)\\n        i, j = 0, n2 - 1\\n        res = abs(goal)\\n        while i <= n1 - 1 and j >= 0:\\n            if st1[i] + st2[j] - goal > 0:\\n                res = min(res, st1[i] + st2[j] - goal)\\n                j -= 1\\n            elif st1[i] + st2[j] - goal < 0:\\n                res = min(res, goal - st1[i] - st2[j])\\n                i += 1\\n            else:\\n                return 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054842,
                "title": "python-knapsack-using-binary-numbers-meet-in-the-middle",
                "content": "Time complexity: O(n*2^(n/2))\\n\\n```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n        nums1 = nums[:n//2]\\n        nums2 = nums[n//2:]\\n        sums1 = []\\n        sums2 = []\\n        def prep(nums, sums):\\n            for i in range(2**len(nums)):\\n                b = bin(i)[2:].zfill(len(nums))\\n                sm = 0\\n                for j, c in enumerate(b):\\n                    if c == \\'1\\':\\n                        sm += nums[j]\\n                sums.append(sm)\\n        prep(nums1, sums1)\\n        prep(nums2, sums2)\\n        sums2.sort()\\n        ans = float(\\'inf\\')\\n        for num in sums1:\\n            target = goal - num\\n            i = bisect_left(sums2, target)\\n            if i < len(sums2):\\n                diff = abs(num + sums2[i] - goal)\\n                ans = min(ans, diff)\\n            if i > 0:\\n                diff = abs(num + sums2[i-1] - goal)\\n                ans = min(ans, diff)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        n = len(nums)\\n        nums1 = nums[:n//2]\\n        nums2 = nums[n//2:]\\n        sums1 = []\\n        sums2 = []\\n        def prep(nums, sums):\\n            for i in range(2**len(nums)):\\n                b = bin(i)[2:].zfill(len(nums))\\n                sm = 0\\n                for j, c in enumerate(b):\\n                    if c == \\'1\\':\\n                        sm += nums[j]\\n                sums.append(sm)\\n        prep(nums1, sums1)\\n        prep(nums2, sums2)\\n        sums2.sort()\\n        ans = float(\\'inf\\')\\n        for num in sums1:\\n            target = goal - num\\n            i = bisect_left(sums2, target)\\n            if i < len(sums2):\\n                diff = abs(num + sums2[i] - goal)\\n                ans = min(ans, diff)\\n            if i > 0:\\n                diff = abs(num + sums2[i-1] - goal)\\n                ans = min(ans, diff)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054748,
                "title": "java-meet-in-middle-and-treeset",
                "content": "```\\npublic int minAbsDifference(int[] nums, int t) {\\n\\tint n = nums.length;\\n\\tint[] nums1 = new int[n/2];\\n\\tint[] nums2 = new int[n-n/2];\\n\\tfor(int i = 0; i < n/2; i++) nums1[i] = nums[i];\\n\\tfor(int i = n/2; i < n; i++) nums2[i-n/2] = nums[i];\\n\\n\\tvar sums1 = new ArrayList<Integer>(); \\n\\tvar sums2 = new ArrayList<Integer>(); \\n\\n\\tdfs(0, 0, nums1, sums1);\\n\\tdfs(0, 0, nums2, sums2);\\n\\n\\tTreeSet<Integer> st2 = new TreeSet();\\n\\tfor(int s : sums2) st2.add(s);\\n\\n\\tint min = Integer.MAX_VALUE;\\n\\tfor(int s1 : sums1) {\\n\\t\\tint s2 = t-s1; // find the closest to this \\n\\t\\tif(st2.first() <= s2)\\n\\t\\t\\tmin = Math.min(min, Math.abs(s1+st2.floor(s2) - t));\\n\\t\\tif(st2.last() >= s2)\\n\\t\\t\\tmin = Math.min(min, Math.abs(s1+st2.ceiling(s2) - t));\\n\\t}\\n\\n\\treturn min;        \\n}\\nvoid dfs(int at, int s, int[] nums, ArrayList<Integer> sums) {\\n\\tif(at == nums.length) {\\n\\t\\tsums.add(s);\\n\\t\\treturn;\\n\\t}\\n\\tdfs(at+1, s, nums, sums); // dont include\\n\\tdfs(at+1, s+nums[at], nums, sums); // include\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minAbsDifference(int[] nums, int t) {\\n\\tint n = nums.length;\\n\\tint[] nums1 = new int[n/2];\\n\\tint[] nums2 = new int[n-n/2];\\n\\tfor(int i = 0; i < n/2; i++) nums1[i] = nums[i];\\n\\tfor(int i = n/2; i < n; i++) nums2[i-n/2] = nums[i];\\n\\n\\tvar sums1 = new ArrayList<Integer>(); \\n\\tvar sums2 = new ArrayList<Integer>(); \\n\\n\\tdfs(0, 0, nums1, sums1);\\n\\tdfs(0, 0, nums2, sums2);\\n\\n\\tTreeSet<Integer> st2 = new TreeSet();\\n\\tfor(int s : sums2) st2.add(s);\\n\\n\\tint min = Integer.MAX_VALUE;\\n\\tfor(int s1 : sums1) {\\n\\t\\tint s2 = t-s1; // find the closest to this \\n\\t\\tif(st2.first() <= s2)\\n\\t\\t\\tmin = Math.min(min, Math.abs(s1+st2.floor(s2) - t));\\n\\t\\tif(st2.last() >= s2)\\n\\t\\t\\tmin = Math.min(min, Math.abs(s1+st2.ceiling(s2) - t));\\n\\t}\\n\\n\\treturn min;        \\n}\\nvoid dfs(int at, int s, int[] nums, ArrayList<Integer> sums) {\\n\\tif(at == nums.length) {\\n\\t\\tsums.add(s);\\n\\t\\treturn;\\n\\t}\\n\\tdfs(at+1, s, nums, sums); // dont include\\n\\tdfs(at+1, s+nums[at], nums, sums); // include\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054520,
                "title": "branch-and-bound-solution",
                "content": "```\\nint minAbsDifference(vector<int>& nums, int goal) {\\n        sort(nums.begin(),nums.end(),[](int a,int b){\\n            return abs(a) > abs(b);  \\n        });\\n        int max_sum = 0,min_sum = 0;\\n        for(int i = 0;i < nums.size();++i){\\n            if(nums[i] > 0) max_sum += nums[i];\\n            else min_sum += nums[i];\\n        }\\n        unordered_set<int> table;\\n        table.insert(goal);\\n        int ret = INT_MAX;\\n        for(auto it1:nums){\\n            if(it1 > 0) max_sum -= it1;\\n            else min_sum -= it1;\\n            unordered_set<int> temp;\\n            for(auto it2:table){\\n                int cur = it2 - it1;\\n                if(cur >= max_sum){\\n                    //cout << cur - max_sum << \" \";\\n                    ret = min(ret,cur - max_sum);\\n                }\\n                else if( cur <= min_sum){\\n                    //cout << min_sum - cur << \" \";\\n                    ret = min(ret,min_sum - cur);\\n                }\\n                else{\\n                    temp.insert(cur);\\n                    ret = min(ret,abs(cur));\\n                }\\n                if(it2 >= max_sum){\\n                    //cout << it2 - max_sum << \" \";\\n                    ret = min(ret,it2 - max_sum);\\n                }\\n                else if(it2 <= min_sum){\\n                    //cout << min_sum - it2 << \" \";\\n                    ret = min(ret,min_sum - it2);\\n                }\\n                else{\\n                    temp.insert(it2);\\n                }\\n            }\\n            table.swap(temp);\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minAbsDifference(vector<int>& nums, int goal) {\\n        sort(nums.begin(),nums.end(),[](int a,int b){\\n            return abs(a) > abs(b);  \\n        });\\n        int max_sum = 0,min_sum = 0;\\n        for(int i = 0;i < nums.size();++i){\\n            if(nums[i] > 0) max_sum += nums[i];\\n            else min_sum += nums[i];\\n        }\\n        unordered_set<int> table;\\n        table.insert(goal);\\n        int ret = INT_MAX;\\n        for(auto it1:nums){\\n            if(it1 > 0) max_sum -= it1;\\n            else min_sum -= it1;\\n            unordered_set<int> temp;\\n            for(auto it2:table){\\n                int cur = it2 - it1;\\n                if(cur >= max_sum){\\n                    //cout << cur - max_sum << \" \";\\n                    ret = min(ret,cur - max_sum);\\n                }\\n                else if( cur <= min_sum){\\n                    //cout << min_sum - cur << \" \";\\n                    ret = min(ret,min_sum - cur);\\n                }\\n                else{\\n                    temp.insert(cur);\\n                    ret = min(ret,abs(cur));\\n                }\\n                if(it2 >= max_sum){\\n                    //cout << it2 - max_sum << \" \";\\n                    ret = min(ret,it2 - max_sum);\\n                }\\n                else if(it2 <= min_sum){\\n                    //cout << min_sum - it2 << \" \";\\n                    ret = min(ret,min_sum - it2);\\n                }\\n                else{\\n                    temp.insert(it2);\\n                }\\n            }\\n            table.swap(temp);\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1054408,
                "title": "why-am-i-getting-tle-can-someone-review",
                "content": "```\\n int minAbsDifference(vector<int>& nums, int goal) {\\n        int posSum = 0, negSum = 0, size = nums.size(), res = INT_MAX;;\\n        for(int num : nums) {\\n            if(num < 0)\\n                negSum += num;\\n            else\\n                posSum += num;\\n        }\\n        if(goal < negSum || goal > posSum)\\n            return min(abs(-goal + negSum), abs(goal - posSum));\\n        set<int> firstHalfSums, secondHalfSums;\\n        combinSums(nums, 0, 0, size/2, firstHalfSums);\\n        combinSums(nums, 0, size/2, size, secondHalfSums);\\n        for(auto itr : firstHalfSums) {\\n            int rem = goal - itr;\\n            auto itr1 = secondHalfSums.lower_bound(rem);\\n            if(itr1 != secondHalfSums.end())\\n                res = min(res, abs((*itr1) + itr - goal));\\n            if(itr1 != secondHalfSums.begin())\\n                res = min(res, abs((*prev(itr1)) + itr - goal));\\n            // Nothing better than this!\\n            if(res == 0)\\n                return 0;\\n        }\\n        return res;\\n    }\\n    \\n    void combinSums(vector<int>& nums, int sum, int indx, int end, set<int> &s) {\\n        if(indx == end) {\\n            s.insert(sum);\\n            return ;\\n        }\\n        combinSums(nums, sum, indx+1, end, s);\\n        combinSums(nums, sum + nums[indx], indx+1, end, s);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n int minAbsDifference(vector<int>& nums, int goal) {\\n        int posSum = 0, negSum = 0, size = nums.size(), res = INT_MAX;;\\n        for(int num : nums) {\\n            if(num < 0)\\n                negSum += num;\\n            else\\n                posSum += num;\\n        }\\n        if(goal < negSum || goal > posSum)\\n            return min(abs(-goal + negSum), abs(goal - posSum));\\n        set<int> firstHalfSums, secondHalfSums;\\n        combinSums(nums, 0, 0, size/2, firstHalfSums);\\n        combinSums(nums, 0, size/2, size, secondHalfSums);\\n        for(auto itr : firstHalfSums) {\\n            int rem = goal - itr;\\n            auto itr1 = secondHalfSums.lower_bound(rem);\\n            if(itr1 != secondHalfSums.end())\\n                res = min(res, abs((*itr1) + itr - goal));\\n            if(itr1 != secondHalfSums.begin())\\n                res = min(res, abs((*prev(itr1)) + itr - goal));\\n            // Nothing better than this!\\n            if(res == 0)\\n                return 0;\\n        }\\n        return res;\\n    }\\n    \\n    void combinSums(vector<int>& nums, int sum, int indx, int end, set<int> &s) {\\n        if(indx == end) {\\n            s.insert(sum);\\n            return ;\\n        }\\n        combinSums(nums, sum, indx+1, end, s);\\n        combinSums(nums, sum + nums[indx], indx+1, end, s);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1054256,
                "title": "python-knapsack",
                "content": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n       \\n        def solve(idx, nums, goal, curr_sum,dp):\\n            key = str(idx) + \"Leet\" + str(curr_sum)\\n            if key in dp:\\n                return dp[key]\\n            if idx == len(nums):\\n                return abs(curr_sum - goal)\\n            ans = min(solve(idx+1, nums, goal, curr_sum + nums[idx],dp), solve(idx+1, nums, goal, curr_sum,dp))\\n            dp[key] = ans\\n            return ans\\n        return solve(0,nums, goal, 0,dict())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n       \\n        def solve(idx, nums, goal, curr_sum,dp):\\n            key = str(idx) + \"Leet\" + str(curr_sum)\\n            if key in dp:\\n                return dp[key]\\n            if idx == len(nums):\\n                return abs(curr_sum - goal)\\n            ans = min(solve(idx+1, nums, goal, curr_sum + nums[idx],dp), solve(idx+1, nums, goal, curr_sum,dp))\\n            dp[key] = ans\\n            return ans\\n        return solve(0,nums, goal, 0,dict())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054117,
                "title": "javascript-meet-in-the-middle",
                "content": "Never encountered this kind of problem before (with such time and memory limits) but these limits make sense.\\nTried after seeing the idea on another submissions.\\n\\nOn the contest I tried a recursive combinations approach, and that failed.\\nI tried a \"DP\" approach after this, where I placed all possible sums in an array (similar to below solution), but this too got the same space limit problem. Also makes perfect sense :-)\\n\\nI figured there was something \"tricky\" we could do with these sums, but I couldn\\'t figure it out. After reading the logic behind a \"meet in the middle\" on here submission I was able to derive the rest of the algorithm from reading about the idea.\\n\\nHoping that outlining my thought process helps someone. \\n\\nSome people are saying that this might not be the intended solution, and if it\\'s not I\\'m open to hearing about it.\\n\\nI wonder if a better approch would involve further breaking down the original array, and/or sorting more of these arrays so we can run binary searches.\\n\\nedit: I guess this is the intended approach per the question hints. \\nie \"Consider all subsets of the other part, and for each one, let its sum = x, do binary search to get the nearest possible value to goal - x in the first part.\"\\n\\n```\\nvar minAbsDifference = function(nums, goal) {\\n    let min = Math.abs(goal);\\n    if(!nums.length) return min;\\n    \\n\\t// generate sums from array\\n\\t// ALSO update min here for these sums, otherwise you\\'ll need to make extra loops laters\\n    const generateSums = (a) => {\\n        let sums = [];\\n        for(let i = 0; i < a.length; i++) {\\n            const l = sums.length;\\n            for(let j = 0; j < l; j++) {\\n                sums.push(sums[j]+a[i]);\\n                min = Math.min(min, Math.abs(sums[j]+a[i]-goal))\\n\\t\\t\\t\\tif(min===0) return; // can\\'t return min from here...\\n            }\\n            sums.push(a[i]);\\n            min = Math.min(min, Math.abs(a[i]-goal))\\n\\t\\t\\tif(min===0) return;  // can\\'t return min from here...\\n        }\\n        return sums;\\n    }\\n    \\n    const n1 = nums.slice(0,Math.ceil(nums.length/2));\\n    const n2 = nums.slice(Math.ceil(nums.length/2), nums.length);\\n    const sums1 = generateSums(n1);\\n    if(min===0) return min; // these checks took off approx 150ms\\n    const sums2 = generateSums(n2);\\n    if(min===0) return min; // these checks took off approx 150ms\\n    \\n    sums2.sort((a,b)=>a-b);\\n\\t// here\\'s where the magic happens\\n\\t// we iterate through sums1, sums2 is sorted so we\\n\\t// run a binary search against it\\n    for(let i = 0; i < sums1.length; i++) {\\n        if(min===0) return min;\\n        let l = 0;\\n        let r = sums2.length;\\n        let sum;\\n        while(l<r) {\\n            const h = Math.floor((l+r)/2)\\n            sum = sums1[i]+sums2[h];\\n            min = Math.min(min, Math.abs(sum-goal));\\n            if(min===0) return min; // these checks took off approx 150ms\\n\\t\\t\\t// Dont use MATH abs here or you won\\'t know which direction to go\\n\\t\\t\\t// if less than 0 we want to go right, otherwise left\\n\\t\\t\\t// remember 0 is our optimal solution, so that\\'s our target\\n            if(sum-goal<0) {\\n                l = h+1;\\n            } else {\\n                r = h;\\n            }\\n        }\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minAbsDifference = function(nums, goal) {\\n    let min = Math.abs(goal);\\n    if(!nums.length) return min;\\n    \\n\\t// generate sums from array\\n\\t// ALSO update min here for these sums, otherwise you\\'ll need to make extra loops laters\\n    const generateSums = (a) => {\\n        let sums = [];\\n        for(let i = 0; i < a.length; i++) {\\n            const l = sums.length;\\n            for(let j = 0; j < l; j++) {\\n                sums.push(sums[j]+a[i]);\\n                min = Math.min(min, Math.abs(sums[j]+a[i]-goal))\\n\\t\\t\\t\\tif(min===0) return; // can\\'t return min from here...\\n            }\\n            sums.push(a[i]);\\n            min = Math.min(min, Math.abs(a[i]-goal))\\n\\t\\t\\tif(min===0) return;  // can\\'t return min from here...\\n        }\\n        return sums;\\n    }\\n    \\n    const n1 = nums.slice(0,Math.ceil(nums.length/2));\\n    const n2 = nums.slice(Math.ceil(nums.length/2), nums.length);\\n    const sums1 = generateSums(n1);\\n    if(min===0) return min; // these checks took off approx 150ms\\n    const sums2 = generateSums(n2);\\n    if(min===0) return min; // these checks took off approx 150ms\\n    \\n    sums2.sort((a,b)=>a-b);\\n\\t// here\\'s where the magic happens\\n\\t// we iterate through sums1, sums2 is sorted so we\\n\\t// run a binary search against it\\n    for(let i = 0; i < sums1.length; i++) {\\n        if(min===0) return min;\\n        let l = 0;\\n        let r = sums2.length;\\n        let sum;\\n        while(l<r) {\\n            const h = Math.floor((l+r)/2)\\n            sum = sums1[i]+sums2[h];\\n            min = Math.min(min, Math.abs(sum-goal));\\n            if(min===0) return min; // these checks took off approx 150ms\\n\\t\\t\\t// Dont use MATH abs here or you won\\'t know which direction to go\\n\\t\\t\\t// if less than 0 we want to go right, otherwise left\\n\\t\\t\\t// remember 0 is our optimal solution, so that\\'s our target\\n            if(sum-goal<0) {\\n                l = h+1;\\n            } else {\\n                r = h;\\n            }\\n        }\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054054,
                "title": "java-solution-binary-search",
                "content": "```java\\nlong binarySearch(List<Long> sums, long target) {\\n        int s = 0, e = sums.size() - 1;\\n        long r = sums.get(0);\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (sums.get(mid) == target) {\\n                return target;\\n            } else if (target > sums.get(mid)) {\\n                s = mid + 1;\\n            } else {\\n                e = mid - 1;\\n            }\\n            if (Math.abs(r - target) > Math.abs(sums.get(mid) - target)) {\\n                r = sums.get(mid);\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    public int minAbsDifference(int[] nums, int goal) {\\n        List<Long> sums1 = divide(nums, 0, nums.length / 2);\\n        List<Long> sums2 = divide(nums, nums.length / 2 + 1, nums.length - 1);\\n        Collections.sort(sums2);\\n        long r = 0;\\n        for (Long i : sums1) {\\n            Long v = binarySearch(sums2, goal - i);\\n            if (Math.abs(r - goal) > Math.abs(goal - v - i)) {\\n                r = v + i;\\n            }\\n        }\\n        return (int)Math.abs((r - goal));\\n    }\\n    \\n    List<Long> divide(int[] nums, int start, int end) {\\n       if (start > end) {\\n            return new ArrayList<Long>();\\n        }\\n        if (start == end) {\\n            return new ArrayList<Long>(Arrays.asList((long)nums[start], 0L));\\n        }\\n        List<Long> a = divide(nums, start, (start + end) / 2);\\n        List<Long> b = divide(nums, (start + end) / 2 + 1, end);\\n        List<Long> r = new ArrayList<>();\\n        for (int i = 0; i < a.size(); i++) {\\n            for (int j = 0; j < b.size(); j++) {\\n                r.add(a.get(i) + b.get(j));\\n            }\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\nlong binarySearch(List<Long> sums, long target) {\\n        int s = 0, e = sums.size() - 1;\\n        long r = sums.get(0);\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (sums.get(mid) == target) {\\n                return target;\\n            } else if (target > sums.get(mid)) {\\n                s = mid + 1;\\n            } else {\\n                e = mid - 1;\\n            }\\n            if (Math.abs(r - target) > Math.abs(sums.get(mid) - target)) {\\n                r = sums.get(mid);\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    public int minAbsDifference(int[] nums, int goal) {\\n        List<Long> sums1 = divide(nums, 0, nums.length / 2);\\n        List<Long> sums2 = divide(nums, nums.length / 2 + 1, nums.length - 1);\\n        Collections.sort(sums2);\\n        long r = 0;\\n        for (Long i : sums1) {\\n            Long v = binarySearch(sums2, goal - i);\\n            if (Math.abs(r - goal) > Math.abs(goal - v - i)) {\\n                r = v + i;\\n            }\\n        }\\n        return (int)Math.abs((r - goal));\\n    }\\n    \\n    List<Long> divide(int[] nums, int start, int end) {\\n       if (start > end) {\\n            return new ArrayList<Long>();\\n        }\\n        if (start == end) {\\n            return new ArrayList<Long>(Arrays.asList((long)nums[start], 0L));\\n        }\\n        List<Long> a = divide(nums, start, (start + end) / 2);\\n        List<Long> b = divide(nums, (start + end) / 2 + 1, end);\\n        List<Long> r = new ArrayList<>();\\n        for (int i = 0; i < a.size(); i++) {\\n            for (int j = 0; j < b.size(); j++) {\\n                r.add(a.get(i) + b.get(j));\\n            }\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054026,
                "title": "c-meet-in-the-middle-o-2-n-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> subsets(vector<int>&nums) {\\n        vector<int>ans;\\n        for (int i = 0; i < (1 << nums.size()); i++) {\\n            int sum = 0;\\n            for (int b = nums.size() - 1, j = 0; j < nums.size(); j++,b--) {\\n                int bm = (1 << j);\\n                if ((bm & i)) {\\n                    sum += nums[b];\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        vector<int> left,right;\\n        for (int i = 0; i < nums.size() / 2; i++) {\\n            left.push_back(nums[i]);\\n        }\\n        for (int i = nums.size() / 2; i < nums.size(); i++) {\\n            right.push_back(nums[i]);\\n        }\\n        vector<int>l = subsets(left);\\n        vector<int>r = subsets(right);\\n        sort(r.begin(),r.end());\\n        int ans = INT_MAX;\\n        \\n        for (int i = 0; i < l.size(); i++) {\\n            int x = l[i];\\n            int idx1 = upper_bound(r.begin(),r.end(),goal - x) - r.begin();\\n            \\n            if (idx1 != r.size()) {\\n                ans = min(ans,abs(x + r[idx1] - goal));\\n            }\\n            idx1--;\\n            if (idx1 != -1) {\\n                ans = min(ans,abs(x + r[idx1] - goal));\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> subsets(vector<int>&nums) {\\n        vector<int>ans;\\n        for (int i = 0; i < (1 << nums.size()); i++) {\\n            int sum = 0;\\n            for (int b = nums.size() - 1, j = 0; j < nums.size(); j++,b--) {\\n                int bm = (1 << j);\\n                if ((bm & i)) {\\n                    sum += nums[b];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1054006,
                "title": "meet-in-middle-only-test-case-68-showing-tle-c",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int>gen(vector<int>nums){\\n        set<int>s;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            set<int> temp;\\n            for(int v:s){\\n                temp.insert(v+nums[i]);\\n                temp.insert(v);\\n            }\\n            temp.insert(nums[i]);\\n            s=temp;\\n        }\\n        s.insert(0);\\n        return s;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        vector<int>A(nums.begin(),nums.begin()+(n/2)),B(nums.begin()+n/2,nums.end());\\n        \\n        set<int>F=gen(A);\\n        set<int>S=gen(B);\\n        \\n        vector<int>BB(S.begin(),S.end());\\n        \\n        int ans=abs(goal);\\n        \\n        if(F.count(goal) || S.count(goal))\\n            return 0;\\n        \\n        for(int v:F)\\n        {\\n            int remain=goal-v;\\n            int ind=lower_bound(BB.begin(),BB.end(),remain)-BB.begin();\\n            \\n            ans=min(ans,abs(remain));\\n            if(ind<BB.size()){\\n                ans=min(ans,abs(remain-BB[ind]));\\n            }\\n            if(ind>0){\\n                ans=min(ans,abs(remain-BB[ind-1]));\\n            }\\n            \\n            if(ans==0)\\n                return 0;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int>gen(vector<int>nums){\\n        set<int>s;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            set<int> temp;\\n            for(int v:s){\\n                temp.insert(v+nums[i]);\\n                temp.insert(v);\\n            }\\n            temp.insert(nums[i]);\\n            s=temp;\\n        }\\n        s.insert(0);\\n        return s;\\n    }\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        vector<int>A(nums.begin(),nums.begin()+(n/2)),B(nums.begin()+n/2,nums.end());\\n        \\n        set<int>F=gen(A);\\n        set<int>S=gen(B);\\n        \\n        vector<int>BB(S.begin(),S.end());\\n        \\n        int ans=abs(goal);\\n        \\n        if(F.count(goal) || S.count(goal))\\n            return 0;\\n        \\n        for(int v:F)\\n        {\\n            int remain=goal-v;\\n            int ind=lower_bound(BB.begin(),BB.end(),remain)-BB.begin();\\n            \\n            ans=min(ans,abs(remain));\\n            if(ind<BB.size()){\\n                ans=min(ans,abs(remain-BB[ind]));\\n            }\\n            if(ind>0){\\n                ans=min(ans,abs(remain-BB[ind-1]));\\n            }\\n            \\n            if(ans==0)\\n                return 0;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053891,
                "title": "javascript-cut-in-half-then-binary-search",
                "content": "- BruteForce + BinarySearch:  out of memory, wrong !!!\\n\\t- Reason why: the array length in JavaScript **max** is `2^32`\\n\\t- Docs:  [length - unsigned 32 bit integer ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length)\\n- cut in half\\n\\t- for every sum in Left\\n\\t- BS to find the closest in Right\\n\\n```js\\nvar minAbsDifference = function(nums, goal) {\\n    function binarySearch_upper(arr, target)\\n    {\\n        var l = 0;\\n        var r = arr.length-1;\\n        while(l<r)\\n        {\\n            var mid = Math.floor( (l+r) / 2);\\n            if(arr[mid] <= target)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n    function dfs(arr) {\\n        var s = [0]; // can select any single number\\n        for (var val of arr)\\n        {\\n            var size = s.length;\\n            for (var i= 0; i<size; i++)\\n            {\\n                s.push(s[i] + val);\\n            }\\n         }\\n         s.sort((x,y)=>x-y);\\n         return s;\\n    }\\n    var n = nums.length;\\n    var half = Math.floor(n/2);\\n    var left = dfs(nums.slice(0, half));\\n    var right = dfs(nums.slice(half, n));\\n    var res = Math.abs(goal);\\n    for(var val of left)\\n    {\\n        // find the first (right[i] + val > goal), upperbound  \\n        var i = binarySearch_upper(right, goal-val);\\n        res = Math.min(res, Math.abs(val + right[i] - goal));\\n        if( i-1>0)\\n        {\\n            res = Math.min(res, Math.abs(val + right[i-1] - goal));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minAbsDifference = function(nums, goal) {\\n    function binarySearch_upper(arr, target)\\n    {\\n        var l = 0;\\n        var r = arr.length-1;\\n        while(l<r)\\n        {\\n            var mid = Math.floor( (l+r) / 2);\\n            if(arr[mid] <= target)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n    function dfs(arr) {\\n        var s = [0]; // can select any single number\\n        for (var val of arr)\\n        {\\n            var size = s.length;\\n            for (var i= 0; i<size; i++)\\n            {\\n                s.push(s[i] + val);\\n            }\\n         }\\n         s.sort((x,y)=>x-y);\\n         return s;\\n    }\\n    var n = nums.length;\\n    var half = Math.floor(n/2);\\n    var left = dfs(nums.slice(0, half));\\n    var right = dfs(nums.slice(half, n));\\n    var res = Math.abs(goal);\\n    for(var val of left)\\n    {\\n        // find the first (right[i] + val > goal), upperbound  \\n        var i = binarySearch_upper(right, goal-val);\\n        res = Math.min(res, Math.abs(val + right[i] - goal));\\n        if( i-1>0)\\n        {\\n            res = Math.min(res, Math.abs(val + right[i-1] - goal));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053842,
                "title": "c-meet-in-the-middle-binary-search-o-2-n-2-detailed-explanation",
                "content": "**THOUGHT PROCESS**\\nlets look at the constraints -- \\n\\t**N = 40**\\n\\t**GOAL = 10^9**\\n\\t\\n```\\n\\tfirst thought that crossed my mind was that this problem is 0-1 knapsack problem whose time complexity would O(N*K) , \\n\\tand calculate what is closes possible sum, but  this possiblilty is ruled out by the fact that goal is \\n\\tvery large we wont be able to calculate this in 1 sec [ as 40*(10^9)  > 10^8 ] \\n\\t\\n\\tso i dropped above idea , now i knew that 2^40 is very large number so a direct brute force way is not \\n\\tpossible , at the last moment of the contest i was strike by the idea that we can use meet in the \\n\\tmiddle solution but was unable to fully implement it ,\\n\\tnow after reading many post about this question the solution is -- \\n\\t\\n\\twe devide the array in to two parts [ 0 , N/2 ) [ N/2 , N )\\n\\t\\n    we brute force the possible the possible sums in both half and then using binary search calculates \\n\\tthe closest subsequence sum - \\n\\t\\n\\there is the C++ clean code\\n\\t\\n\\t\\n\\n```\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& V , int T ) {\\n        vector< int > A , B ; \\n        int N = V.size();\\n        int fh = N>>1 ;   // first half \\n        int sh = N-fh ;   // second half \\n        \\n        // s - represent the subset , which we are travesing usign bit manipulation\\n        \\n        for( int s = 0 ; s < 1<<fh ; s++ )    \\n        {\\n            int sum = 0 ; \\n            for( int i = 0 ; i < fh ; i++ )\\n                if( s&(1<<i) )sum += V[i];     // notice that our i belongs to [ 0 , fh-1 ]\\n            A.push_back(sum);\\n        }\\n        \\n        \\n        for( int s = 0 ; s < 1 <<sh ; s++ )\\n        {\\n            int sum = 0 ; \\n            for( int i = 0  ; i < sh ; i++ )\\n                if( s&(1<<i) ) sum += V[i+fh] ; // notice \" i + fh \" ensures that they belog to [ fh , N-1]\\n            B.push_back(sum);\\n        }\\n        \\n        sort( B.begin() , B.end() ) ;\\n        int mn = INT_MAX ;  // min mum diff we can get \\n        for( auto x : A )\\n        {\\n            int y = T - x ; \\n            auto it = lower_bound( B.begin() , B.end() , y ) - B.begin() ; \\n            if( it == 0 ) mn = min( mn , abs( B[it] - y ) ) ;\\n            else if( it == B.size() ) mn = min( mn , abs( B[it-1] - y ) ) ; \\n            else mn = min( { mn , abs(B[it] -y ) , abs(B[it-1]-y) } );\\n            if( mn == 0 )return 0 ; // we found lowest possible \\n            // other wise keep minimizing \\n        }\\n        return mn  ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfirst thought that crossed my mind was that this problem is 0-1 knapsack problem whose time complexity would O(N*K) , \\n\\tand calculate what is closes possible sum, but  this possiblilty is ruled out by the fact that goal is \\n\\tvery large we wont be able to calculate this in 1 sec [ as 40*(10^9)  > 10^8 ] \\n\\t\\n\\tso i dropped above idea , now i knew that 2^40 is very large number so a direct brute force way is not \\n\\tpossible , at the last moment of the contest i was strike by the idea that we can use meet in the \\n\\tmiddle solution but was unable to fully implement it ,\\n\\tnow after reading many post about this question the solution is -- \\n\\t\\n\\twe devide the array in to two parts [ 0 , N/2 ) [ N/2 , N )\\n\\t\\n    we brute force the possible the possible sums in both half and then using binary search calculates \\n\\tthe closest subsequence sum - \\n\\t\\n\\there is the C++ clean code\\n\\t\\n\\t\\n\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minAbsDifference(vector<int>& V , int T ) {\\n        vector< int > A , B ; \\n        int N = V.size();\\n        int fh = N>>1 ;   // first half \\n        int sh = N-fh ;   // second half \\n        \\n        // s - represent the subset , which we are travesing usign bit manipulation\\n        \\n        for( int s = 0 ; s < 1<<fh ; s++ )    \\n        {\\n            int sum = 0 ; \\n            for( int i = 0 ; i < fh ; i++ )\\n                if( s&(1<<i) )sum += V[i];     // notice that our i belongs to [ 0 , fh-1 ]\\n            A.push_back(sum);\\n        }\\n        \\n        \\n        for( int s = 0 ; s < 1 <<sh ; s++ )\\n        {\\n            int sum = 0 ; \\n            for( int i = 0  ; i < sh ; i++ )\\n                if( s&(1<<i) ) sum += V[i+fh] ; // notice \" i + fh \" ensures that they belog to [ fh , N-1]\\n            B.push_back(sum);\\n        }\\n        \\n        sort( B.begin() , B.end() ) ;\\n        int mn = INT_MAX ;  // min mum diff we can get \\n        for( auto x : A )\\n        {\\n            int y = T - x ; \\n            auto it = lower_bound( B.begin() , B.end() , y ) - B.begin() ; \\n            if( it == 0 ) mn = min( mn , abs( B[it] - y ) ) ;\\n            else if( it == B.size() ) mn = min( mn , abs( B[it-1] - y ) ) ; \\n            else mn = min( { mn , abs(B[it] -y ) , abs(B[it-1]-y) } );\\n            if( mn == 0 )return 0 ; // we found lowest possible \\n            // other wise keep minimizing \\n        }\\n        return mn  ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053835,
                "title": "java-meet-in-the-middle-binary-search-with-explanation-clean-code",
                "content": "Bruteforce slution is O(2\\u02C6n) which fail with TLE.\\n\\nApproach Meet in the middle  allows to reduce it.\\n\\n1. Split array into two\\n2. Generate all possible sums for subsequence of elements for each of the arrays\\n3. Sort the second array\\n4. For each element of the first array, try binary search for the closest element of the second array\\n\\nBinary search here is a little modified, since out goal is to find the closesnt element (and so both left and right borders could be our target).\\n\\n\\nTime complexity: O( 2\\u02C6(n/2) log 2\\u02C6(n/2) )   =>   O(n*2\\u02C6(n/2))\\nSpace complexity: O(2\\u02C6(n/2))\\n \\n```\\n\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length, minDelta = Integer.MAX_VALUE;\\n\\n        int[] A = new int[2 << (n / 2)];\\n        int[] B = new int[2 << (n + 1) / 2];\\n\\n        gen(nums, 0,     n / 2, A);\\n        gen(nums, n / 2, n,     B);\\n\\n        Arrays.sort(B);\\n\\n        for (int candidate : A) {\\n            int delta = bs(B, goal - candidate);\\n            minDelta = Math.min(minDelta, delta);\\n        }\\n        return minDelta;\\n    }\\n\\n    private int bs(int[] arr, int goal) {\\n        int L = 0, R = arr.length - 1; // both borders are inclusive\\n\\n        while (R - L > 1) {\\n            int mid = (L + R) >>> 1;\\n            if (arr[mid] > goal) R = mid;\\n            else                 L = mid;\\n        }\\n        // either left eiter right border could be the closest\\n        return Math.min(Math.abs(goal - arr[L]), Math.abs(goal - arr[R]));\\n    }\\n\\n    // Try each val from previously generated sums and add nums[curr]\\n    // Validation on \"goal\" could be added here\\n    private void gen(int[] nums, int start, int end, int[] fill) {\\n        int idx = 1;\\n        for (int curr = start; curr < end; curr++) {\\n            int last = idx;\\n            for (int i = 0; i < last; i++) {\\n                fill[idx++] = fill[i] + nums[curr];\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length, minDelta = Integer.MAX_VALUE;\\n\\n        int[] A = new int[2 << (n / 2)];\\n        int[] B = new int[2 << (n + 1) / 2];\\n\\n        gen(nums, 0,     n / 2, A);\\n        gen(nums, n / 2, n,     B);\\n\\n        Arrays.sort(B);\\n\\n        for (int candidate : A) {\\n            int delta = bs(B, goal - candidate);\\n            minDelta = Math.min(minDelta, delta);\\n        }\\n        return minDelta;\\n    }\\n\\n    private int bs(int[] arr, int goal) {\\n        int L = 0, R = arr.length - 1; // both borders are inclusive\\n\\n        while (R - L > 1) {\\n            int mid = (L + R) >>> 1;\\n            if (arr[mid] > goal) R = mid;\\n            else                 L = mid;\\n        }\\n        // either left eiter right border could be the closest\\n        return Math.min(Math.abs(goal - arr[L]), Math.abs(goal - arr[R]));\\n    }\\n\\n    // Try each val from previously generated sums and add nums[curr]\\n    // Validation on \"goal\" could be added here\\n    private void gen(int[] nums, int start, int end, int[] fill) {\\n        int idx = 1;\\n        for (int curr = start; curr < end; curr++) {\\n            int last = idx;\\n            for (int i = 0; i < last; i++) {\\n                fill[idx++] = fill[i] + nums[curr];\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053788,
                "title": "cut-a-half-then-something-like-2-sum",
                "content": "```\\nclass Solution {\\n    void dfs(const vector<int>& v, int now, int to, int sum, vector<int>& s) {\\n        if (now >= to) {\\n            s.push_back(sum);\\n            return;\\n        }\\n        dfs(v, now + 1, to, sum, s);\\n        dfs(v, now + 1, to, sum + v[now], s);\\n    }\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        const int n = nums.size();\\n        vector<int> v1, v2;\\n        dfs(nums, 0, n >> 1, 0, v1);\\n        dfs(nums, n >> 1, n, 0, v2);\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int r = abs(goal);\\n        for (int i = 0, j = v2.size() - 1; i < v1.size() && j >= 0;) {\\n            const int temp = v1[i] + v2[j];\\n            if (temp == goal) {\\n                return 0;\\n            }\\n            if (temp > goal) {\\n                r = min(r, temp - goal);\\n                --j;\\n            } else {\\n                r = min(r, goal - temp);\\n                ++i;\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(const vector<int>& v, int now, int to, int sum, vector<int>& s) {\\n        if (now >= to) {\\n            s.push_back(sum);\\n            return;\\n        }\\n        dfs(v, now + 1, to, sum, s);\\n        dfs(v, now + 1, to, sum + v[now], s);\\n    }\\npublic:\\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        const int n = nums.size();\\n        vector<int> v1, v2;\\n        dfs(nums, 0, n >> 1, 0, v1);\\n        dfs(nums, n >> 1, n, 0, v2);\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int r = abs(goal);\\n        for (int i = 0, j = v2.size() - 1; i < v1.size() && j >= 0;) {\\n            const int temp = v1[i] + v2[j];\\n            if (temp == goal) {\\n                return 0;\\n            }\\n            if (temp > goal) {\\n                r = min(r, temp - goal);\\n                --j;\\n            } else {\\n                r = min(r, goal - temp);\\n                ++i;\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053747,
                "title": "python-easy-to-understand-solution",
                "content": "```python\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        N=len(nums)\\n        mid = N//2 \\n\\t\\t# break into two parts \\n\\t\\t\\n\\t\\tright = [0] \\n\\t\\t# this is the case where no elements from the left subarray are taken\\n        for i in range(mid,N):\\n            x = nums[i]\\n            right.extend([x+y for y in right])\\n        right.sort() #sort to find closest match in O(logN)\\n        \\n        left=[0] \\n\\t\\t# this is the case where no elements from the left subarray are taken\\n        for i in range(0,mid):\\n            x = nums[i]\\n            left.extend([x+y for y in left])\\n        \\n        ans=float(\\'inf\\')\\n        for n in left:\\n            target = goal-n\\n            loc=bisect.bisect_left(right,target) \\n            idx1 = loc \\n            idx2 = loc-1 \\n\\t\\t\\t# try this one as well since bisect_left\\n            \\n            if idx1<len(right) and abs(target-right[idx1])<ans:\\n                ans = abs(target-right[idx1])\\n            if idx2>=0 and abs(target-right[idx2])<ans:\\n                ans = abs(target-right[idx2])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        N=len(nums)\\n        mid = N//2 \\n\\t\\t# break into two parts \\n\\t\\t\\n\\t\\tright = [0] \\n\\t\\t# this is the case where no elements from the left subarray are taken\\n        for i in range(mid,N):\\n            x = nums[i]\\n            right.extend([x+y for y in right])\\n        right.sort() #sort to find closest match in O(logN)\\n        \\n        left=[0] \\n\\t\\t# this is the case where no elements from the left subarray are taken\\n        for i in range(0,mid):\\n            x = nums[i]\\n            left.extend([x+y for y in left])\\n        \\n        ans=float(\\'inf\\')\\n        for n in left:\\n            target = goal-n\\n            loc=bisect.bisect_left(right,target) \\n            idx1 = loc \\n            idx2 = loc-1 \\n\\t\\t\\t# try this one as well since bisect_left\\n            \\n            if idx1<len(right) and abs(target-right[idx1])<ans:\\n                ans = abs(target-right[idx1])\\n            if idx2>=0 and abs(target-right[idx2])<ans:\\n                ans = abs(target-right[idx2])\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565897,
                "content": [
                    {
                        "username": "sunanda690",
                        "content": "If anyone has solved please post the approach"
                    },
                    {
                        "username": "Kingash_",
                        "content": "I solved this problem with this approach:\n1) Since max length is 40 so we cant generate all possible subsequences bcz it will be (~2^40)\n2) So what we can do we can split the array into 2 half of max length 20 each. bcz we can generate all subsequences of length 20 (~2^20 = ~10^6). \n3) Store all possible subsequence sum of first half into first list and same for second half into second list.\n4) Sort the second list and do binary search on it for each element in the first half to find the closest sum near to goal.\n\nI hope i am able to explain my approach.\n\n```\nclass Solution {\n    public int minAbsDifference(int[] a, int g) {\n        List<Long> l1 = new ArrayList<>();\n        List<Long> l2 = new ArrayList<>();\n        genSS(a, 0, a.length / 2, 0L, l1);\n        genSS(a, a.length / 2, a.length, 0L, l2);\n        Collections.sort(l2);\n        long ans = Integer.MAX_VALUE;\n        for(long v : l1) {\n            long r = g - v;\n            int idx = Collections.binarySearch(l2, r);\n            idx = (idx < 0 ? -(idx + 1) : idx);\n            if(idx < l2.size()) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx) - v));\n            }\n            if(idx - 1 >= 0) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx - 1) - v));\n            }\n        }\n        return (int)ans;\n    }\n    public void genSS(int a[], int si, int li, long sum, List<Long> l) {\n        if(si == li) {\n            l.add(sum);\n            return;\n        }\n        genSS(a, si + 1, li, sum, l);\n        genSS(a, si + 1, li, sum + a[si], l);        \n    }\n}\n```"
                    },
                    {
                        "username": "hxu10",
                        "content": "If there is no solution,  but we don\\'t need to find the closest,  just as close as possible,  what we can do to handle this? like monte carlo."
                    },
                    {
                        "username": "askvij",
                        "content": "This is first time i have seen problem like this meet-in-the-middle.\\nIs this really a common problem?\\nI really liked the idea are there any similar problem to work on"
                    },
                    {
                        "username": "Shivam6070",
                        "content": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/"
                    },
                    {
                        "username": "rishabhpahuja27",
                        "content": "Was anyone able to solve it by 2 point approach?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "after generating the possible sequence sums of each half, two point approach can be used"
                    }
                ]
            },
            {
                "id": 1574937,
                "content": [
                    {
                        "username": "sunanda690",
                        "content": "If anyone has solved please post the approach"
                    },
                    {
                        "username": "Kingash_",
                        "content": "I solved this problem with this approach:\n1) Since max length is 40 so we cant generate all possible subsequences bcz it will be (~2^40)\n2) So what we can do we can split the array into 2 half of max length 20 each. bcz we can generate all subsequences of length 20 (~2^20 = ~10^6). \n3) Store all possible subsequence sum of first half into first list and same for second half into second list.\n4) Sort the second list and do binary search on it for each element in the first half to find the closest sum near to goal.\n\nI hope i am able to explain my approach.\n\n```\nclass Solution {\n    public int minAbsDifference(int[] a, int g) {\n        List<Long> l1 = new ArrayList<>();\n        List<Long> l2 = new ArrayList<>();\n        genSS(a, 0, a.length / 2, 0L, l1);\n        genSS(a, a.length / 2, a.length, 0L, l2);\n        Collections.sort(l2);\n        long ans = Integer.MAX_VALUE;\n        for(long v : l1) {\n            long r = g - v;\n            int idx = Collections.binarySearch(l2, r);\n            idx = (idx < 0 ? -(idx + 1) : idx);\n            if(idx < l2.size()) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx) - v));\n            }\n            if(idx - 1 >= 0) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx - 1) - v));\n            }\n        }\n        return (int)ans;\n    }\n    public void genSS(int a[], int si, int li, long sum, List<Long> l) {\n        if(si == li) {\n            l.add(sum);\n            return;\n        }\n        genSS(a, si + 1, li, sum, l);\n        genSS(a, si + 1, li, sum + a[si], l);        \n    }\n}\n```"
                    },
                    {
                        "username": "hxu10",
                        "content": "If there is no solution,  but we don\\'t need to find the closest,  just as close as possible,  what we can do to handle this? like monte carlo."
                    },
                    {
                        "username": "askvij",
                        "content": "This is first time i have seen problem like this meet-in-the-middle.\\nIs this really a common problem?\\nI really liked the idea are there any similar problem to work on"
                    },
                    {
                        "username": "Shivam6070",
                        "content": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/"
                    },
                    {
                        "username": "rishabhpahuja27",
                        "content": "Was anyone able to solve it by 2 point approach?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "after generating the possible sequence sums of each half, two point approach can be used"
                    }
                ]
            },
            {
                "id": 1574932,
                "content": [
                    {
                        "username": "sunanda690",
                        "content": "If anyone has solved please post the approach"
                    },
                    {
                        "username": "Kingash_",
                        "content": "I solved this problem with this approach:\n1) Since max length is 40 so we cant generate all possible subsequences bcz it will be (~2^40)\n2) So what we can do we can split the array into 2 half of max length 20 each. bcz we can generate all subsequences of length 20 (~2^20 = ~10^6). \n3) Store all possible subsequence sum of first half into first list and same for second half into second list.\n4) Sort the second list and do binary search on it for each element in the first half to find the closest sum near to goal.\n\nI hope i am able to explain my approach.\n\n```\nclass Solution {\n    public int minAbsDifference(int[] a, int g) {\n        List<Long> l1 = new ArrayList<>();\n        List<Long> l2 = new ArrayList<>();\n        genSS(a, 0, a.length / 2, 0L, l1);\n        genSS(a, a.length / 2, a.length, 0L, l2);\n        Collections.sort(l2);\n        long ans = Integer.MAX_VALUE;\n        for(long v : l1) {\n            long r = g - v;\n            int idx = Collections.binarySearch(l2, r);\n            idx = (idx < 0 ? -(idx + 1) : idx);\n            if(idx < l2.size()) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx) - v));\n            }\n            if(idx - 1 >= 0) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx - 1) - v));\n            }\n        }\n        return (int)ans;\n    }\n    public void genSS(int a[], int si, int li, long sum, List<Long> l) {\n        if(si == li) {\n            l.add(sum);\n            return;\n        }\n        genSS(a, si + 1, li, sum, l);\n        genSS(a, si + 1, li, sum + a[si], l);        \n    }\n}\n```"
                    },
                    {
                        "username": "hxu10",
                        "content": "If there is no solution,  but we don\\'t need to find the closest,  just as close as possible,  what we can do to handle this? like monte carlo."
                    },
                    {
                        "username": "askvij",
                        "content": "This is first time i have seen problem like this meet-in-the-middle.\\nIs this really a common problem?\\nI really liked the idea are there any similar problem to work on"
                    },
                    {
                        "username": "Shivam6070",
                        "content": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/"
                    },
                    {
                        "username": "rishabhpahuja27",
                        "content": "Was anyone able to solve it by 2 point approach?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "after generating the possible sequence sums of each half, two point approach can be used"
                    }
                ]
            },
            {
                "id": 1757297,
                "content": [
                    {
                        "username": "sunanda690",
                        "content": "If anyone has solved please post the approach"
                    },
                    {
                        "username": "Kingash_",
                        "content": "I solved this problem with this approach:\n1) Since max length is 40 so we cant generate all possible subsequences bcz it will be (~2^40)\n2) So what we can do we can split the array into 2 half of max length 20 each. bcz we can generate all subsequences of length 20 (~2^20 = ~10^6). \n3) Store all possible subsequence sum of first half into first list and same for second half into second list.\n4) Sort the second list and do binary search on it for each element in the first half to find the closest sum near to goal.\n\nI hope i am able to explain my approach.\n\n```\nclass Solution {\n    public int minAbsDifference(int[] a, int g) {\n        List<Long> l1 = new ArrayList<>();\n        List<Long> l2 = new ArrayList<>();\n        genSS(a, 0, a.length / 2, 0L, l1);\n        genSS(a, a.length / 2, a.length, 0L, l2);\n        Collections.sort(l2);\n        long ans = Integer.MAX_VALUE;\n        for(long v : l1) {\n            long r = g - v;\n            int idx = Collections.binarySearch(l2, r);\n            idx = (idx < 0 ? -(idx + 1) : idx);\n            if(idx < l2.size()) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx) - v));\n            }\n            if(idx - 1 >= 0) {\n                ans = Math.min(ans, Math.abs(g - l2.get(idx - 1) - v));\n            }\n        }\n        return (int)ans;\n    }\n    public void genSS(int a[], int si, int li, long sum, List<Long> l) {\n        if(si == li) {\n            l.add(sum);\n            return;\n        }\n        genSS(a, si + 1, li, sum, l);\n        genSS(a, si + 1, li, sum + a[si], l);        \n    }\n}\n```"
                    },
                    {
                        "username": "hxu10",
                        "content": "If there is no solution,  but we don\\'t need to find the closest,  just as close as possible,  what we can do to handle this? like monte carlo."
                    },
                    {
                        "username": "askvij",
                        "content": "This is first time i have seen problem like this meet-in-the-middle.\\nIs this really a common problem?\\nI really liked the idea are there any similar problem to work on"
                    },
                    {
                        "username": "Shivam6070",
                        "content": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/"
                    },
                    {
                        "username": "rishabhpahuja27",
                        "content": "Was anyone able to solve it by 2 point approach?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "after generating the possible sequence sums of each half, two point approach can be used"
                    }
                ]
            }
        ]
    }
]