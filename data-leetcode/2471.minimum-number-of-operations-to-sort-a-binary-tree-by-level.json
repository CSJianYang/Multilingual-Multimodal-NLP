[
    {
        "title": "Minimum Number of Operations to Sort a Binary Tree by Level",
        "question_content": "You are given the root of a binary tree with unique values.\nIn one operation, you can choose any two nodes at the same level and swap their values.\nReturn the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.\nThe level of a node is the number of edges along the path between it and the root node.\n&nbsp;\nExample 1:\n\nInput: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\nOutput: 3\nExplanation:\n- Swap 4 and 3. The 2nd level becomes [3,4].\n- Swap 7 and 5. The 3rd level becomes [5,6,8,7].\n- Swap 8 and 7. The 3rd level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n\nExample 2:\n\nInput: root = [1,3,2,7,6,5,4]\nOutput: 3\nExplanation:\n- Swap 3 and 2. The 2nd level becomes [2,3].\n- Swap 7 and 4. The 3rd level becomes [4,6,5,7].\n- Swap 6 and 5. The 3rd level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n\nExample 3:\n\nInput: root = [1,2,3,4,5,6]\nOutput: 0\nExplanation: Each level is already sorted in increasing order so return 0.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 105].\n\t1 <= Node.val <= 105\n\tAll the values of the tree are unique.",
        "solutions": [
            {
                "id": 2808869,
                "title": "index-array",
                "content": "We do a level-order traverse using two queues.\\n\\nFor each level, we collect values. We use an index array (`0...n - 1`) to normalize those values.\\n\\nThen, we swap indexes until all of them are in the correct position. \\n\\nThis takes O(n log n), instead of O(n ^ 2) if we search for the next smallest element.\\n\\n> Example: node values are `[7, 11, 3, 5, 2]`. \\n> The index array, after sorting, will look like this: `[3, 4, 1, 2, 0]`.\\n> We will do the following swaps:\\n> `[3, 4, 1, 2, 0]`: initial state.\\n> `[2, 4, 1, 3, 0]`: swap `3` and `2`, so `3` is in the right place (`i == ids[i]`).\\n> `[1, 4, 2, 3, 0]`: swap `2` and `1`.\\n> `[4, 1, 2, 3, 0]`: swap `1` and `4`.\\n> `[0, 1, 2, 3, 4]`: swap `4` and `0`.\\n> This approach needs up to O(n) swaps, and the overall complexity is O(sort).\\n\\n**C++**\\n```cpp\\nint minimumOperations(TreeNode* root) {\\n    int res = 0;\\n    vector<TreeNode*> q{root};\\n    while(!q.empty()) {\\n        vector<TreeNode*> q1;\\n        vector<int> vals, ids(q.size());\\n        for (auto n : q) {\\n            vals.push_back(n->val);\\n            if (n->left != nullptr)\\n                q1.push_back(n->left);\\n            if (n->right != nullptr)\\n                q1.push_back(n->right);\\n        }\\n        iota(begin(ids), end(ids), 0);\\n        sort(begin(ids), end(ids), [&](int i, int j){ return vals[i] < vals[j]; });\\n        for (int i = 0; i < ids.size(); ++i)\\n            for (; ids[i] != i; ++res)\\n                swap(ids[i], ids[ids[i]]);\\n        swap(q, q1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumOperations(TreeNode* root) {\\n    int res = 0;\\n    vector<TreeNode*> q{root};\\n    while(!q.empty()) {\\n        vector<TreeNode*> q1;\\n        vector<int> vals, ids(q.size());\\n        for (auto n : q) {\\n            vals.push_back(n->val);\\n            if (n->left != nullptr)\\n                q1.push_back(n->left);\\n            if (n->right != nullptr)\\n                q1.push_back(n->right);\\n        }\\n        iota(begin(ids), end(ids), 0);\\n        sort(begin(ids), end(ids), [&](int i, int j){ return vals[i] < vals[j]; });\\n        for (int i = 0; i < ids.size(); ++i)\\n            for (; ids[i] != i; ++res)\\n                swap(ids[i], ids[ids[i]]);\\n        swap(q, q1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808790,
                "title": "c-solution-explained-very-simple-and-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nHere the trick is to find the count of no of swap, as we can easily get the array of num at a particular level using BFS traversal.\\nSo to evaluate the no. of count in linear complexity we need to use extra space.\\nWe will add the level array to a ordered map along with its index as the value and also copy it to a secondary array \"u\".\\nNow sort array u and have the list of nums in sorted order, basically we will get to know the correct index of each element.\\nNow traverse through the original level arry(t) and check if its value is it correct index or not when in sorted form.\\n\\nIf not in sorted form then get original index of value which can be get from the map and swap the elements, so that t array will be in sorted form gradually.\\n\\n*/\\nclass Solution {\\npublic:\\n    int countSwap(vector<int>& t){\\n        int count = 0;\\n        map<int,int> mp;\\n        vector<int> u;\\n        for(int i = 0; i < t.size(); ++i){\\n            mp[t[i]] = i;\\n            u.push_back(t[i]);\\n        }\\n        sort(u.begin(), u.end());\\n        for(int i = 0; i < t.size(); ++i){\\n            if(t[i] != u[i] ){  // if not at correct place update the values in map and t array\\n                t[mp[u[i]]] = t[i];\\n                mp[t[i]] = mp[u[i]];\\n                mp[u[i]] = i;\\n                t[i] = u[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            vector<int> t;\\n            while(n--){\\n                TreeNode* node = q.front();\\n                t.push_back(node->val);\\n                q.pop();\\n                if(node->left != NULL) q.push(node->left);\\n                if(node->right != NULL) q.push(node->right);\\n            }\\n            for(auto c: t) cout<<c<<\" \"; cout<<endl;\\n            ans += countSwap(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nHere the trick is to find the count of no of swap, as we can easily get the array of num at a particular level using BFS traversal.\\nSo to evaluate the no. of count in linear complexity we need to use extra space.\\nWe will add the level array to a ordered map along with its index as the value and also copy it to a secondary array \"u\".\\nNow sort array u and have the list of nums in sorted order, basically we will get to know the correct index of each element.\\nNow traverse through the original level arry(t) and check if its value is it correct index or not when in sorted form.\\n\\nIf not in sorted form then get original index of value which can be get from the map and swap the elements, so that t array will be in sorted form gradually.\\n\\n*/\\nclass Solution {\\npublic:\\n    int countSwap(vector<int>& t){\\n        int count = 0;\\n        map<int,int> mp;\\n        vector<int> u;\\n        for(int i = 0; i < t.size(); ++i){\\n            mp[t[i]] = i;\\n            u.push_back(t[i]);\\n        }\\n        sort(u.begin(), u.end());\\n        for(int i = 0; i < t.size(); ++i){\\n            if(t[i] != u[i] ){  // if not at correct place update the values in map and t array\\n                t[mp[u[i]]] = t[i];\\n                mp[t[i]] = mp[u[i]];\\n                mp[u[i]] = i;\\n                t[i] = u[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            vector<int> t;\\n            while(n--){\\n                TreeNode* node = q.front();\\n                t.push_back(node->val);\\n                q.pop();\\n                if(node->left != NULL) q.push(node->left);\\n                if(node->right != NULL) q.push(node->right);\\n            }\\n            for(auto c: t) cout<<c<<\" \"; cout<<endl;\\n            ans += countSwap(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2808861,
                "title": "python-use-cycle-sort-to-swap-values-not-nodes-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a Breadth First Search tree level-by-level traversal with counting of permutations on each level (using cycle-sort simulation). Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** The key observation here is that we are not asked to swap nodes, just sort their values on each level. Thus, the strategy to solve this problem is as follows:\\n1. Do a level-by-level traversal using BFS and consider each layer of nodes independently.\\n2. Extract values from each layer and count the number of permutations needed to sort them.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        nodes, count = deque([root]), 0\\n        \\n        def perm(arr):                                            # this function simulates cycle sort,\\n            pos = {m:j for j,m in enumerate(sorted(arr))}         # namely, traverses every cycle in\\n            vis, tot = [0] * len(arr), 0                          # the permutation of elements and \\n            for i in range(len(arr)):                             # counts the number of swaps \\n                cnt = 0\\n                while not vis[i] and i != pos[arr[i]]:            # it is known that cycle sort is the\\n                    vis[i], i = 1, pos[arr[i]]                    # sorting algorithm with the minmal\\n                    cnt += 1                                      # number of memory operations (swaps)\\n                tot += max(0, cnt-1)                              # needed to sort an array\\n            return tot\\n                    \\n        while nodes:\\n            vals = []\\n            for _ in range(len(nodes)):                            # [1] this code performs a level-by-level\\n                n = nodes.popleft()                                #     BFS scan of the tree and extracts\\n                vals.append(n.val)                                 #     a list of values \\'vals\\' for each level\\n                if n.left  : nodes.append(n.left)\\n                if n.right : nodes.append(n.right)\\n            count += perm(vals)                                    # [2] each level is sorted independently\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        nodes, count = deque([root]), 0\\n        \\n        def perm(arr):                                            # this function simulates cycle sort,\\n            pos = {m:j for j,m in enumerate(sorted(arr))}         # namely, traverses every cycle in\\n            vis, tot = [0] * len(arr), 0                          # the permutation of elements and \\n            for i in range(len(arr)):                             # counts the number of swaps \\n                cnt = 0\\n                while not vis[i] and i != pos[arr[i]]:            # it is known that cycle sort is the\\n                    vis[i], i = 1, pos[arr[i]]                    # sorting algorithm with the minmal\\n                    cnt += 1                                      # number of memory operations (swaps)\\n                tot += max(0, cnt-1)                              # needed to sort an array\\n            return tot\\n                    \\n        while nodes:\\n            vals = []\\n            for _ in range(len(nodes)):                            # [1] this code performs a level-by-level\\n                n = nodes.popleft()                                #     BFS scan of the tree and extracts\\n                vals.append(n.val)                                 #     a list of values \\'vals\\' for each level\\n                if n.left  : nodes.append(n.left)\\n                if n.right : nodes.append(n.right)\\n            count += perm(vals)                                    # [2] each level is sorted independently\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809008,
                "title": "level-order-traversal-cyclesort",
                "content": "<b>please upvote if you like it </b>\\n\\nLet us divide this problem into two different halfs \\n\\n1. Travel levels in order\\n2. sort a level using minimum number of swaps\\n\\nTypically task 1 is what we call BFS or level order on tree\\n\\ntask2 is cycle sort\\n\\nNote :- Reposting this :( old one removed because I add learning resource to Cycle Sort\\n\\nFrom the question it is quite easy to understand that we will have to do a BFS more specifically on trees so we call it \\n`Level order Traversal`\\n\\nOrdinary Level order traversal is not going to be of any help rather <i> we need a traversal where we can distinguish between each \\nlevel</i> so we insert a `nullptr` into queue to mark the <b> end of level </b>\\n\\nCycle sort is used to solve problems where we need minimum swaps or to find missing numbers in a given range problem .\\n\\n\\n#### Solution point :- \\n\\nSo after every level we have a nullptr thus if we can get to sort the numbers at each level in minimum number of swaps i.e all we need .\\n\\nAnd one such sort that does minimum swaps or memory writes is <b>`Cycle Sort` </b> it selects a element and then solves its cyle .  \\n<hr>\\n\\n\\n\\nfor more cycle sort problems visit this post [Post](https://leetcode.com/discuss/study-guide/1902662/cyclic-sort-very-important-and-less-known-pattern)\\n<hr>\\n\\n#### Code :-\\n```c++\\nclass Solution {\\npublic:\\n    int cycleSort(vector<int>& nums)\\n    {\\n      int n = nums.size();\\n        int len = n;\\n        map<int, int> map;\\n        for (int i = 0; i < len; i++)\\n            map[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        bool visited[len];\\n        for(int i = 0; i < len ; i++) visited[i] = false;\\n        int ans = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n\\t\\t // already swapped and corrected or already present at correct pos\\n            if (visited[i] || map[nums[i]] == i)\\n                continue;\\n            int j = i, cycle_size = 0;\\n            while (!visited[j])\\n            {\\n                visited[j] = true;\\n\\t\\t\\t\\t// move to next node\\n                j = map[nums[j]];\\n                cycle_size++;\\n            }\\n            if (cycle_size > 0)\\n            {\\n\\t\\t\\t// Update answer by adding current cycle.\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// nullptr to identify end of level\\n        q.push(nullptr);\\n        vector<int> v;\\n        int ans = 0;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            if(!temp){\\n                ans += cycleSort(v);\\n\\t\\t\\t\\t// clear values of old level\\n                v.clear();\\n\\t\\t\\t\\t// if there are more elements in queue then push null to identify end else no elements are present \\n\\t\\t\\t\\t// so don\\'t push anything\\n                if(!q.empty())\\n                    q.push(nullptr);\\n            }else{\\n                v.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n`Time Complexity : O(nlogn)`\\n`Space Complexity: O(n)`\\n\\nFollow up to this problem would be :- \\n\\nWhat if adjacnecy matrix is given and when we swap the nodes its subtree also gets swapped \\n\\n(I was asked this question in Fanatics company interview 18CTC)\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int cycleSort(vector<int>& nums)\\n    {\\n      int n = nums.size();\\n        int len = n;\\n        map<int, int> map;\\n        for (int i = 0; i < len; i++)\\n            map[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        bool visited[len];\\n        for(int i = 0; i < len ; i++) visited[i] = false;\\n        int ans = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n\\t\\t // already swapped and corrected or already present at correct pos\\n            if (visited[i] || map[nums[i]] == i)\\n                continue;\\n            int j = i, cycle_size = 0;\\n            while (!visited[j])\\n            {\\n                visited[j] = true;\\n\\t\\t\\t\\t// move to next node\\n                j = map[nums[j]];\\n                cycle_size++;\\n            }\\n            if (cycle_size > 0)\\n            {\\n\\t\\t\\t// Update answer by adding current cycle.\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// nullptr to identify end of level\\n        q.push(nullptr);\\n        vector<int> v;\\n        int ans = 0;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            if(!temp){\\n                ans += cycleSort(v);\\n\\t\\t\\t\\t// clear values of old level\\n                v.clear();\\n\\t\\t\\t\\t// if there are more elements in queue then push null to identify end else no elements are present \\n\\t\\t\\t\\t// so don\\'t push anything\\n                if(!q.empty())\\n                    q.push(nullptr);\\n            }else{\\n                v.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808850,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            List<Integer> list = new ArrayList<>();\\n            while(size-- > 0) {\\n                TreeNode node = q.poll();\\n                if(node.left != null) {\\n                    q.offer(node.left);\\n                    list.add(node.left.val);\\n                }\\n                if(node.right != null) {\\n                    q.offer(node.right);\\n                    list.add(node.right.val);\\n                }\\n            }\\n            count += helper(list);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int helper(List<Integer> list) {\\n        int swaps = 0;\\n        int[] sorted = new int[list.size()];\\n        for(int i=0; i<sorted.length; i++) sorted[i] = list.get(i);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> ind = new HashMap<>();\\n        for(int i=0; i<list.size(); i++) ind.put(list.get(i), i);\\n        \\n        for(int i=0; i<list.size(); i++) {\\n            if(list.get(i) != sorted[i]) {\\n                swaps++;\\n                ind.put(list.get(i), ind.get(sorted[i]));\\n                list.set(ind.get(sorted[i]), list.get(i));\\n            }\\n        }\\n        return swaps;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            List<Integer> list = new ArrayList<>();\\n            while(size-- > 0) {\\n                TreeNode node = q.poll();\\n                if(node.left != null) {\\n                    q.offer(node.left);\\n                    list.add(node.left.val);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2812363,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we are able to get number of swaps required for elements in each level, we can solve it with bfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet elements of each element in array. \\nsort the array, put value and index of the sorted value in a map.\\nFor each element in array, check if it\\'s in the correct place, if not swap with correct index value, increase count.\\nreturn count\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int> arr) {\\n        vector<int> copy = arr;\\n        sort(copy.begin(), copy.end());\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < arr.size(); i++) mp[copy[i]] = i; \\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            while (mp[arr[i]] != i) {\\n                swap(arr[i], arr[mp[arr[i]]]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> getArray(vector<TreeNode*> arr) {\\n        vector<int> res;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res.push_back(arr[i] -> val);\\n        }\\n        return res;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        vector<TreeNode*> currentLevel, nextLevel;\\n        nextLevel.push_back(root);\\n        int count = 0;\\n        while (nextLevel.size() > 0) {\\n            swap(currentLevel, nextLevel);\\n            nextLevel.clear();\\n\\n            count += minSwaps(getArray(currentLevel));\\n            for (int i = 0; i < currentLevel.size(); i++) {\\n                if (currentLevel[i]->left) nextLevel.push_back(currentLevel[i]->left);\\n                if (currentLevel[i]->right) nextLevel.push_back(currentLevel[i]->right);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int> arr) {\\n        vector<int> copy = arr;\\n        sort(copy.begin(), copy.end());\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < arr.size(); i++) mp[copy[i]] = i; \\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            while (mp[arr[i]] != i) {\\n                swap(arr[i], arr[mp[arr[i]]]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> getArray(vector<TreeNode*> arr) {\\n        vector<int> res;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res.push_back(arr[i] -> val);\\n        }\\n        return res;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        vector<TreeNode*> currentLevel, nextLevel;\\n        nextLevel.push_back(root);\\n        int count = 0;\\n        while (nextLevel.size() > 0) {\\n            swap(currentLevel, nextLevel);\\n            nextLevel.clear();\\n\\n            count += minSwaps(getArray(currentLevel));\\n            for (int i = 0; i < currentLevel.size(); i++) {\\n                if (currentLevel[i]->left) nextLevel.push_back(currentLevel[i]->left);\\n                if (currentLevel[i]->right) nextLevel.push_back(currentLevel[i]->right);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815060,
                "title": "python-3-13-lines-bfs-w-explanation-and-example-t-m-99-77",
                "content": "Here\\'s the plan.\\n\\nFor each level:\\n\\n* Collect the node values in order in a list `level`.\\n* Attach list index to each value in `level` as a tuple.\\n* Sort the the tuple list with repect to values.\\n* Peel off the indices in order to `idx`.\\n* Count the number of steps required to restore `idx` to consecutive order.\\n\\n```\\nclass Solution:                                                             # Ex:  root = [1, 4,3, 7,6,8,5, None,None,11,None,9,None,10,None]\\n    def minimumOperations(self, root: TreeNode) -> int:                     #           _____1____\\n                                                                            #          /          \\\\\\n        ans, queue, level = 0, [root],[]                                    #         4___         3___\\n                                                                            #        /    \\\\       /    \\\\\\n        while queue :                                                       #       7     _6     8     _5\\n                                                                            #            /      /     /\\n            for node in queue:                                              #           11     9     10\\n                    if node:  level.extend([node.left, node.right])         #\\n                                                                            #  level         idx             ans\\n            arr = [(v,i) for i,v in enumerate([c.val for c in level if c])] #  \\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013           \\u2013\\u2013\\u2013\\u2013\\u2013\\n            idx = [i for _,i in sorted(arr)]                                #  [4,3]        [1,0]             1\\n                                                                            #  [7,6,8,5]    [2,1,3,0]         2\\n            for i in range(len(idx)):                                       #  [11,9,10]    [1,2,0]           2\\n                while (idx[i] != i):                                        #                               \\u2013\\u2013\\u2013\\u2013\\u2013\\n                    j = idx[i]                                              #                                 5   <--- ans\\n                    idx[i], idx[j] = idx[j], idx[i]\\n                    ans += 1\\n\\n            queue, level = level, []\\n        \\n        return ans\\n```\\n\\n[https://leetcode.com/submissions/detail/843472664/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*N*^2) / *O*(*N*).",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:                                                             # Ex:  root = [1, 4,3, 7,6,8,5, None,None,11,None,9,None,10,None]\\n    def minimumOperations(self, root: TreeNode) -> int:                     #           _____1____\\n                                                                            #          /          \\\\\\n        ans, queue, level = 0, [root],[]                                    #         4___         3___\\n                                                                            #        /    \\\\       /    \\\\\\n        while queue :                                                       #       7     _6     8     _5\\n                                                                            #            /      /     /\\n            for node in queue:                                              #           11     9     10\\n                    if node:  level.extend([node.left, node.right])         #\\n                                                                            #  level         idx             ans\\n            arr = [(v,i) for i,v in enumerate([c.val for c in level if c])] #  \\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013           \\u2013\\u2013\\u2013\\u2013\\u2013\\n            idx = [i for _,i in sorted(arr)]                                #  [4,3]        [1,0]             1\\n                                                                            #  [7,6,8,5]    [2,1,3,0]         2\\n            for i in range(len(idx)):                                       #  [11,9,10]    [1,2,0]           2\\n                while (idx[i] != i):                                        #                               \\u2013\\u2013\\u2013\\u2013\\u2013\\n                    j = idx[i]                                              #                                 5   <--- ans\\n                    idx[i], idx[j] = idx[j], idx[i]\\n                    ans += 1\\n\\n            queue, level = level, []\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810551,
                "title": "line-by-line-commented-bfs-simple-hashmap-solution",
                "content": "```java\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        return solve(root);\\n    }\\n    \\n\\t// normal Level Order Traversal\\n    int solve(TreeNode node) {\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();        // stores nodes at a particular level\\n\\t\\tqueue.add(node);                                   // add the first node to get started\\n        \\n        int count = 0;\\n        \\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tint[] arr = new int[size];                     // This stores all the node values of a particular level\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode currNode = queue.poll();          // take a node out of queue\\n\\t\\t\\t\\tif (currNode.left != null) {               // if the node has a left child\\n\\t\\t\\t\\t\\tqueue.add(currNode.left);              // add left child to queue for further processing\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (currNode.right != null) {              // if the node has a right child\\n\\t\\t\\t\\t\\tqueue.add(currNode.right);             // add right child to queue for further processing\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tarr[i] = currNode.val;                     // store the node [this node is at current level]\\n\\t\\t\\t}\\n            count += minSwaps(arr);                        // count minimum swaps to make this array sorted\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n    \\n\\t// calculating minimum swaps required to make array sorted\\n    int minSwaps(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();            // stores [a number, its index]\\n        int[] sortedArr = arr.clone();                          //  make a copy of this array\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            map.put(arr[i], i);                                 // stores [a number, its index] of original array\\n        }\\n        \\n        Arrays.sort(sortedArr);                                 // sort this copied array\\n        \\n        int swaps = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != sortedArr[i]) {                       // whenever a number is not in its correct position, swap it with correct position\\n                int index1 = map.get(sortedArr[i]);             // correct index - the number is to be swapped with this index\\n                int index2 = map.get(arr[i]);                   // wrong index - the number is currently at this index\\n                \\n\\t\\t\\t\\t// update index in map\\n                map.put(arr[i], index1);                      \\n                map.put(sortedArr[i], index2);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the numbers in original array with updated index\\n                arr[index1] = arr[i];\\n                arr[index2] = sortedArr[i];\\n                swaps++;                                        // increase swap count\\n            }\\n        }\\n        \\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        return solve(root);\\n    }\\n    \\n\\t// normal Level Order Traversal\\n    int solve(TreeNode node) {\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();        // stores nodes at a particular level\\n\\t\\tqueue.add(node);                                   // add the first node to get started\\n        \\n        int count = 0;\\n        \\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tint[] arr = new int[size];                     // This stores all the node values of a particular level\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode currNode = queue.poll();          // take a node out of queue\\n\\t\\t\\t\\tif (currNode.left != null) {               // if the node has a left child\\n\\t\\t\\t\\t\\tqueue.add(currNode.left);              // add left child to queue for further processing\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (currNode.right != null) {              // if the node has a right child\\n\\t\\t\\t\\t\\tqueue.add(currNode.right);             // add right child to queue for further processing\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tarr[i] = currNode.val;                     // store the node [this node is at current level]\\n\\t\\t\\t}\\n            count += minSwaps(arr);                        // count minimum swaps to make this array sorted\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n    \\n\\t// calculating minimum swaps required to make array sorted\\n    int minSwaps(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();            // stores [a number, its index]\\n        int[] sortedArr = arr.clone();                          //  make a copy of this array\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            map.put(arr[i], i);                                 // stores [a number, its index] of original array\\n        }\\n        \\n        Arrays.sort(sortedArr);                                 // sort this copied array\\n        \\n        int swaps = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != sortedArr[i]) {                       // whenever a number is not in its correct position, swap it with correct position\\n                int index1 = map.get(sortedArr[i]);             // correct index - the number is to be swapped with this index\\n                int index2 = map.get(arr[i]);                   // wrong index - the number is currently at this index\\n                \\n\\t\\t\\t\\t// update index in map\\n                map.put(arr[i], index1);                      \\n                map.put(sortedArr[i], index2);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the numbers in original array with updated index\\n                arr[index1] = arr[i];\\n                arr[index2] = sortedArr[i];\\n                swaps++;                                        // increase swap count\\n            }\\n        }\\n        \\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808960,
                "title": "python3-bfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        queue = deque([root])\\n        while queue: \\n            vals = []\\n            for _ in range(len(queue)): \\n                node = queue.popleft()\\n                vals.append(node.val)\\n                if node.left: queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n            mp = {x : i for i, x in enumerate(sorted(vals))}\\n            visited = [0]*len(vals)\\n            for i in range(len(vals)): \\n                cnt = 0 \\n                while not visited[i] and i != mp[vals[i]]: \\n                    visited[i] = 1\\n                    cnt += 1\\n                    i = mp[vals[i]]\\n                ans += max(0, cnt-1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        queue = deque([root])\\n        while queue: \\n            vals = []\\n            for _ in range(len(queue)): \\n                node = queue.popleft()\\n                vals.append(node.val)\\n                if node.left: queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n            mp = {x : i for i, x in enumerate(sorted(vals))}\\n            visited = [0]*len(vals)\\n            for i in range(len(vals)): \\n                cnt = 0 \\n                while not visited[i] and i != mp[vals[i]]: \\n                    visited[i] = 1\\n                    cnt += 1\\n                    i = mp[vals[i]]\\n                ans += max(0, cnt-1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810043,
                "title": "bfs-binary-search-lower-bound-c",
                "content": "```\\n int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>temp,sorted;\\n            while(size--){\\n                 auto top=q.front();\\n                 q.pop();\\n                temp.push_back(top->val);\\n                sorted.push_back(top->val);\\n                if(top->left){\\n                    q.push(top->left);\\n                }\\n                if(top->right){\\n                    q.push(top->right);\\n                }\\n            }\\n            sort(sorted.begin(),sorted.end());\\n            int n=temp.size();\\n            int i=0;\\n            while(i<n){\\n                int lind=lower_bound(sorted.begin(),sorted.end(),temp[i])-sorted.begin();\\n                if(temp[lind]==temp[i]){\\n                    i++;\\n                }\\n                else{\\n                    swap(temp[lind],temp[i]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Please upvote if you liked it.\\nThank You :)**",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>temp,sorted;\\n            while(size--){\\n                 auto top=q.front();\\n                 q.pop();\\n                temp.push_back(top->val);\\n                sorted.push_back(top->val);\\n                if(top->left){\\n                    q.push(top->left);\\n                }\\n                if(top->right){\\n                    q.push(top->right);\\n                }\\n            }\\n            sort(sorted.begin(),sorted.end());\\n            int n=temp.size();\\n            int i=0;\\n            while(i<n){\\n                int lind=lower_bound(sorted.begin(),sorted.end(),temp[i])-sorted.begin();\\n                if(temp[lind]==temp[i]){\\n                    i++;\\n                }\\n                else{\\n                    swap(temp[lind],temp[i]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809118,
                "title": "dfs-value-swap",
                "content": "```\\n\\nint ans = 0;\\nvector<vector<int>>num;\\nvoid dfs(TreeNode *root, int level){\\n\\tif(root == NULL)return;\\n\\tif(level >= num.size()){\\n\\t\\tnum.push_back({root->val});\\n\\t}\\n\\telse{\\n\\t\\tnum[level].push_back(root->val);\\n\\t}\\n\\tdfs(root->left, level+1);\\n\\tdfs(root->right, level+1);\\n}\\nint minimumOperations(TreeNode* root) {\\n\\tdfs(root, 0); // stores all the element on same depth in same vector in the order of from leftmost element to rightmost element \\n\\tfor(vector<int> &vec:num){\\n\\t\\tmap<int, int>map1; // using ordered map as traversing it is same as traversing a sorted vector\\n\\t\\tfor(int index=0;index<vec.size();index++){\\n\\t\\t\\tmap1[vec[index]] = index;\\n\\t\\t}\\n\\t\\tint index = 0;\\n\\t\\tfor(auto &pr:map1){\\n\\t\\t\\tif(pr.second != index){ // The current element is not where it should be so we swap its place with the element which is currently present on the desired position\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tmap1[vec[index]] = pr.second;\\n\\t\\t\\t\\tswap(vec[index], vec[pr.second]);\\n\\t\\t\\t\\tpr.second = index;\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nint ans = 0;\\nvector<vector<int>>num;\\nvoid dfs(TreeNode *root, int level){\\n\\tif(root == NULL)return;\\n\\tif(level >= num.size()){\\n\\t\\tnum.push_back({root->val});\\n\\t}\\n\\telse{\\n\\t\\tnum[level].push_back(root->val);\\n\\t}\\n\\tdfs(root->left, level+1);\\n\\tdfs(root->right, level+1);\\n}\\nint minimumOperations(TreeNode* root) {\\n\\tdfs(root, 0); // stores all the element on same depth in same vector in the order of from leftmost element to rightmost element \\n\\tfor(vector<int> &vec:num){\\n\\t\\tmap<int, int>map1; // using ordered map as traversing it is same as traversing a sorted vector\\n\\t\\tfor(int index=0;index<vec.size();index++){\\n\\t\\t\\tmap1[vec[index]] = index;\\n\\t\\t}\\n\\t\\tint index = 0;\\n\\t\\tfor(auto &pr:map1){\\n\\t\\t\\tif(pr.second != index){ // The current element is not where it should be so we swap its place with the element which is currently present on the desired position\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tmap1[vec[index]] = pr.second;\\n\\t\\t\\t\\tswap(vec[index], vec[pr.second]);\\n\\t\\t\\t\\tpr.second = index;\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809068,
                "title": "c-easy-level-order-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int>arr, int n)\\n    {\\n        // Create an array of\\n        // pairs where first\\n        // element is array element\\n        // and second element\\n        // is position of first element\\n        pair<int, int> arrPos[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arrPos[i].first = arr[i];\\n            arrPos[i].second = i;\\n        }\\n\\n        // Sort the array by array\\n        // element values to\\n        // get right position of\\n        // every element as second\\n        // element of pair.\\n        sort(arrPos, arrPos + n);\\n\\n        // To keep track of visited elements.\\n        // Initialize\\n        // all elements as not visited or false.\\n        vector<bool> vis(n, false);\\n\\n        // Initialize result\\n        int ans = 0;\\n\\n        // Traverse array elements\\n        for (int i = 0; i < n; i++)\\n        {\\n            // already swapped and corrected or\\n            // already present at correct pos\\n            if (vis[i] || arrPos[i].second == i)\\n                continue;\\n\\n            // find out the number of node in\\n            // this cycle and add in ans\\n            int cycle_size = 0;\\n            int j = i;\\n            while (!vis[j])\\n            {\\n                vis[j] = 1;\\n\\n                // move to next node\\n                j = arrPos[j].second;\\n                cycle_size++;\\n            }\\n\\n            // Update answer by adding current cycle.\\n            if (cycle_size > 0)\\n            {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n\\n        // Return result\\n        return ans;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int cnt=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int len;\\n        while(!q.empty()){\\n            vector<int> v;\\n            len=q.size();\\n            for(int i=0;i<len;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                v.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            cnt+=minSwaps(v,v.size());\\n        }\\n        \\n        return\\xA0cnt;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int>arr, int n)\\n    {\\n        // Create an array of\\n        // pairs where first\\n        // element is array element\\n        // and second element\\n        // is position of first element\\n        pair<int, int> arrPos[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arrPos[i].first = arr[i];\\n            arrPos[i].second = i;\\n        }\\n\\n        // Sort the array by array\\n        // element values to\\n        // get right position of\\n        // every element as second\\n        // element of pair.\\n        sort(arrPos, arrPos + n);\\n\\n        // To keep track of visited elements.\\n        // Initialize\\n        // all elements as not visited or false.\\n        vector<bool> vis(n, false);\\n\\n        // Initialize result\\n        int ans = 0;\\n\\n        // Traverse array elements\\n        for (int i = 0; i < n; i++)\\n        {\\n            // already swapped and corrected or\\n            // already present at correct pos\\n            if (vis[i] || arrPos[i].second == i)\\n                continue;\\n\\n            // find out the number of node in\\n            // this cycle and add in ans\\n            int cycle_size = 0;\\n            int j = i;\\n            while (!vis[j])\\n            {\\n                vis[j] = 1;\\n\\n                // move to next node\\n                j = arrPos[j].second;\\n                cycle_size++;\\n            }\\n\\n            // Update answer by adding current cycle.\\n            if (cycle_size > 0)\\n            {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n\\n        // Return result\\n        return ans;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int cnt=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int len;\\n        while(!q.empty()){\\n            vector<int> v;\\n            len=q.size();\\n            for(int i=0;i<len;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                v.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            cnt+=minSwaps(v,v.size());\\n        }\\n        \\n        return\\xA0cnt;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808987,
                "title": "easy-level-order-traversal-with-comments-python",
                "content": "```\\nclass Solution:\\n    def cntSwap(self,arr):\\n        \\n        n = len(arr)\\n        cnt = 0\\n        a = sorted(arr)\\n        index = {}\\n        \\n\\t\\t# store index of elements in arr\\n        for ind in range(n):\\n            index[arr[ind]] = ind\\n\\n        for ind in range(n):\\n\\t\\t\\t\\n\\t\\t\\t# If element in arr is out of position we need to swap hence increase cnt\\n            if (arr[ind] != a[ind]):\\n                cnt += 1\\n                pos = arr[ind]\\n                \\n\\t\\t\\t\\t# Replace it with element that should be at this \"ind\" in arr using a[ind]\\n                arr[ind], arr[index[a[ind]]] = arr[index[a[ind]]], arr[ind]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Update the indexes for swaped elements in \"index\"\\n                index[pos] = index[a[ind]]\\n                index[a[ind]] = ind\\n\\n        return cnt\\n    \\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        res = 0\\n        q = [root]\\n        # Level order traversal\\n        while q :\\n            \\n            level = []\\n            values = []\\n            for n in q:\\n                \\n                if n.left :\\n                    level.append(n.left)\\n                    values.append(n.left.val)\\n                \\n                if n.right :\\n                    level.append(n.right)\\n                    values.append(n.right.val)\\n            \\n            res += self.cntSwap(values)\\n            q = level\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cntSwap(self,arr):\\n        \\n        n = len(arr)\\n        cnt = 0\\n        a = sorted(arr)\\n        index = {}\\n        \\n\\t\\t# store index of elements in arr\\n        for ind in range(n):\\n            index[arr[ind]] = ind\\n\\n        for ind in range(n):\\n\\t\\t\\t\\n\\t\\t\\t# If element in arr is out of position we need to swap hence increase cnt\\n            if (arr[ind] != a[ind]):\\n                cnt += 1\\n                pos = arr[ind]\\n                \\n\\t\\t\\t\\t# Replace it with element that should be at this \"ind\" in arr using a[ind]\\n                arr[ind], arr[index[a[ind]]] = arr[index[a[ind]]], arr[ind]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Update the indexes for swaped elements in \"index\"\\n                index[pos] = index[a[ind]]\\n                index[a[ind]] = ind\\n\\n        return cnt\\n    \\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        res = 0\\n        q = [root]\\n        # Level order traversal\\n        while q :\\n            \\n            level = []\\n            values = []\\n            for n in q:\\n                \\n                if n.left :\\n                    level.append(n.left)\\n                    values.append(n.left.val)\\n                \\n                if n.right :\\n                    level.append(n.right)\\n                    values.append(n.right.val)\\n            \\n            res += self.cntSwap(values)\\n            q = level\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808857,
                "title": "simple-java-solution-using-bfs-and-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> nm=new LinkedList<>();\\n        nm.offer(root);\\n        int s=0;\\n        while(!nm.isEmpty())\\n        {\\n            int m=0,l=nm.size();\\n            List<Integer> kk=new ArrayList<>();\\n            for(int i=0;i<l;i++)\\n            {\\n                if(nm.peek().left!=null)\\n                {\\n                    nm.add(nm.peek().left);\\n                }\\n                if(nm.peek().right!=null)\\n                {\\n                    nm.add(nm.peek().right);\\n                }\\n                int f=nm.poll().val;\\n                kk.add(f);\\n            }\\n            s+=task(kk);\\n        }\\n        return s;\\n    }\\n    public int task(List<Integer> nm)\\n    {\\n        Map<Integer,Integer> kk=new HashMap<>();\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            kk.put(nm.get(i),i);\\n        }\\n        Collections.sort(nm);\\n        boolean k[]=new boolean[nm.size()];\\n        int s=0;\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            if(k[i] || kk.get(nm.get(i))==i)\\n            {\\n                continue;\\n            }\\n            int j=i,m=0;\\n            while(!k[j])\\n            {\\n                k[j]=true;\\n                j=kk.get(nm.get(j));\\n                m++;\\n            }\\n            if(m>0)\\n            {\\n                s+=m-1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> nm=new LinkedList<>();\\n        nm.offer(root);\\n        int s=0;\\n        while(!nm.isEmpty())\\n        {\\n            int m=0,l=nm.size();\\n            List<Integer> kk=new ArrayList<>();\\n            for(int i=0;i<l;i++)\\n            {\\n                if(nm.peek().left!=null)\\n                {\\n                    nm.add(nm.peek().left);\\n                }\\n                if(nm.peek().right!=null)\\n                {\\n                    nm.add(nm.peek().right);\\n                }\\n                int f=nm.poll().val;\\n                kk.add(f);\\n            }\\n            s+=task(kk);\\n        }\\n        return s;\\n    }\\n    public int task(List<Integer> nm)\\n    {\\n        Map<Integer,Integer> kk=new HashMap<>();\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            kk.put(nm.get(i),i);\\n        }\\n        Collections.sort(nm);\\n        boolean k[]=new boolean[nm.size()];\\n        int s=0;\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            if(k[i] || kk.get(nm.get(i))==i)\\n            {\\n                continue;\\n            }\\n            int j=i,m=0;\\n            while(!k[j])\\n            {\\n                k[j]=true;\\n                j=kk.get(nm.get(j));\\n                m++;\\n            }\\n            if(m>0)\\n            {\\n                s+=m-1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138005,
                "title": "not-very-short-but-easy-and-simple-c-solution-using-level-order-traversal-beats-92-13",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int exe(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int cnt=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            cnt++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return cnt;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n     int ans=0;\\n     queue<TreeNode*> q;\\n       q.push(root);\\n        if(root==NULL)\\n            return 0;\\n        \\n        while(1){\\n            int size=q.size();\\n            \\n            if(size==0)\\n                break;\\n         vector<int> res;\\n            while(size>0){\\n                TreeNode* temp = q.front();\\n          q.pop();\\n                res.push_back(temp->val);\\n                if(temp->left != NULL)\\n                    q.push(temp->left);\\n                \\n                if(temp->right!= NULL)\\n                    q.push(temp->right);\\n                \\n                size--;\\n            }\\n     ans+=exe(res);\\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int exe(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int cnt=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            cnt++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return cnt;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n     int ans=0;\\n     queue<TreeNode*> q;\\n       q.push(root);\\n        if(root==NULL)\\n            return 0;\\n        \\n        while(1){\\n            int size=q.size();\\n            \\n            if(size==0)\\n                break;\\n         vector<int> res;\\n            while(size>0){\\n                TreeNode* temp = q.front();\\n          q.pop();\\n                res.push_back(temp->val);\\n                if(temp->left != NULL)\\n                    q.push(temp->left);\\n                \\n                if(temp->right!= NULL)\\n                    q.push(temp->right);\\n                \\n                size--;\\n            }\\n     ans+=exe(res);\\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809140,
                "title": "solve-the-problem-independently-in-each-level-of-the-tree",
                "content": "# Intuition - Reduce it to a simpler version you can solve\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Find the simplest version of the problem that you can solve. \\n* Instead of dealing with trees, imaging you had to solve this problem for an array. This is a common technique with tree problems. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Make an array corresponding to every level of the tree \\n* Solve the problem independently for each level. \\n\\n# Complexity\\n- Time complexity: $$O(N \\\\log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n[GitHub](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Weekly%20Contest%20319)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int steps_for(vector <int> &A)\\n    {\\n        vector <int> sorted_A = A; \\n        sort(sorted_A.begin(), sorted_A.end());\\n        \\n        map <int, int> position;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            position[A[i]] = i;\\n        }\\n        \\n        int steps = 0;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(A[i] == sorted_A[i])\\n            {\\n                continue;\\n            }\\n            \\n            int p = position[sorted_A[i]];\\n            position[sorted_A[i]] = i;\\n            position[A[i]] = p;\\n            swap(A[i], A[p]);\\n            \\n            steps++;\\n        }\\n        return steps;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        queue <TreeNode*> Q; \\n        map <TreeNode*, int> node_level;\\n        vector <vector <int> > level; \\n        Q.push(root);\\n        node_level[root] = 0;\\n        \\n        while(!Q.empty())\\n        {\\n            TreeNode* current = Q.front();\\n            Q.pop();\\n            \\n            if(node_level[current] >= level.size())\\n            {\\n                vector <int> new_level;\\n                level.push_back(new_level);\\n            }\\n            \\n            level[node_level[current]].push_back(current->val);\\n            \\n            if(current->left != NULL)\\n            {\\n                node_level[current->left] = node_level[current] + 1;\\n                Q.push(current->left);\\n            }\\n            \\n            if(current->right != NULL)\\n            {\\n                node_level[current->right] = node_level[current] + 1;\\n                Q.push(current->right);\\n            }\\n        }\\n        \\n        int operations = 0;\\n        for(int i = 1; i < level.size() ; i++)\\n        {\\n            operations += steps_for(level[i]);\\n        }\\n        \\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int steps_for(vector <int> &A)\\n    {\\n        vector <int> sorted_A = A; \\n        sort(sorted_A.begin(), sorted_A.end());\\n        \\n        map <int, int> position;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            position[A[i]] = i;\\n        }\\n        \\n        int steps = 0;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(A[i] == sorted_A[i])\\n            {\\n                continue;\\n            }\\n            \\n            int p = position[sorted_A[i]];\\n            position[sorted_A[i]] = i;\\n            position[A[i]] = p;\\n            swap(A[i], A[p]);\\n            \\n            steps++;\\n        }\\n        return steps;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        queue <TreeNode*> Q; \\n        map <TreeNode*, int> node_level;\\n        vector <vector <int> > level; \\n        Q.push(root);\\n        node_level[root] = 0;\\n        \\n        while(!Q.empty())\\n        {\\n            TreeNode* current = Q.front();\\n            Q.pop();\\n            \\n            if(node_level[current] >= level.size())\\n            {\\n                vector <int> new_level;\\n                level.push_back(new_level);\\n            }\\n            \\n            level[node_level[current]].push_back(current->val);\\n            \\n            if(current->left != NULL)\\n            {\\n                node_level[current->left] = node_level[current] + 1;\\n                Q.push(current->left);\\n            }\\n            \\n            if(current->right != NULL)\\n            {\\n                node_level[current->right] = node_level[current] + 1;\\n                Q.push(current->right);\\n            }\\n        }\\n        \\n        int operations = 0;\\n        for(int i = 1; i < level.size() ; i++)\\n        {\\n            operations += steps_for(level[i]);\\n        }\\n        \\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826019,
                "title": "bfs-cyclic-sort-with-explanation",
                "content": "# Intuition\\nHere we have to count minimum swaps to sort the nodes in each level. \\n\\n1. So, for getting the nodes in each level, I have used `Level order traveral` and then \\n2. we will count the `min swaps` for that level\\n\\n# Approach\\nThe level order traversal is the regular level order traversal.\\n\\nThe tricky part is the sorting. For this approach, we will use `cyclic sort` i.e. if an element is not at its correct place, we will swap the element current index with the correct value.\\n\\n>Below explanation is for `int minSwaps (List<Integer> list) {}` function\\n\\nHow we do it is, we have our list of elements in `list`. This has all the elements but may not be in order.\\n\\nWe will make a copy of this `list` and sort it (`sorted`). `sorted` gives us the final arrangement but to reach to it we have to count the min number of swaps which is our ans. \\n\\nWe will iterate through every index and for an index `if list(i) != sorted(i)` then we need to swap the value index `i` with the correct element. So, we have the correct element i.e. `sorted(i)` but we need its index in `list` to swap the elements, we use `list.indexOf(correct value)` i.e. `list.indexOf(sorted.get(i))`\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int res = 0;\\n        Queue<TreeNode> q = new ArrayDeque<TreeNode>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> list = new ArrayList<Integer>();\\n            while (n-- > 0) {\\n                TreeNode curr = q.remove();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                list.add(curr.val);\\n            }\\n            res += minSwaps(list);\\n        }\\n        return res;\\n    }\\n    int minSwaps(List<Integer> list) {\\n        int swaps = 0, n = list.size();\\n        List<Integer> sorted = new ArrayList<Integer>();\\n        sorted.addAll(list);\\n        Collections.sort(sorted);\\n        for (int i = 0; i < n; i++) {\\n            if (list.get(i) != sorted.get(i)) {\\n                ++swaps;\\n                Collections.swap(list, i, list.indexOf(sorted.get(i)));\\n            }\\n        }\\n        return swaps;\\n    }\\n}\\n```\\nThe above code will give us TLE because of this line:\\n```Collections.swap(list, i, list.indexOf(sorted.get(i)));``` \\nThe reason being, `indexOf` will search using `linear-search` so the searching may take upto `O(n)` time and with the for loop the time complexity may reach ***O(n<sup>2</sup>)*** which results in TLE.\\n\\nWe can optimize the searching part by introducing a `hashmap`. The hashmap is just a copy of `list` paired with the corresponding index but using the hashmap wil reduce the searching time complexity from `O(n)` to `O(1)`. So, our overall time complexity gets reduced from ***O(n<sup>2</sup>)*** to `O(n)`\\n```\\nint minSwaps(List<Integer> list) {\\n    int swaps = 0;\\n    List<Integer> sorted = new ArrayList<Integer>();\\n    sorted.addAll(list);\\n    Collections.sort(sorted);\\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    for (int i = 0; i < list.size(); i++)\\n        map.put(list.get(i), i);\\n    for (int i = 0; i < list.size(); i++) {\\n        if (list.get(i) != sorted.get(i)) {\\n            ++swaps;\\n            int swap_index = map.get(sorted.get(i));\\n            map.put(list.get(i), swap_index);\\n            map.put(sorted.get(i), i);\\n            Collections.swap(list, i, swap_index);\\n                \\n        }\\n    }\\n    return swaps;\\n}\\n```\\n***If this solution helped you, please upvote it :)***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int res = 0;\\n        Queue<TreeNode> q = new ArrayDeque<TreeNode>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> list = new ArrayList<Integer>();\\n            while (n-- > 0) {\\n                TreeNode curr = q.remove();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                list.add(curr.val);\\n            }\\n            res += minSwaps(list);\\n        }\\n        return res;\\n    }\\n    int minSwaps(List<Integer> list) {\\n        int swaps = 0, n = list.size();\\n        List<Integer> sorted = new ArrayList<Integer>();\\n        sorted.addAll(list);\\n        Collections.sort(sorted);\\n        for (int i = 0; i < n; i++) {\\n            if (list.get(i) != sorted.get(i)) {\\n                ++swaps;\\n                Collections.swap(list, i, list.indexOf(sorted.get(i)));\\n            }\\n        }\\n        return swaps;\\n    }\\n}\\n```\n```Collections.swap(list, i, list.indexOf(sorted.get(i)));```\n```\\nint minSwaps(List<Integer> list) {\\n    int swaps = 0;\\n    List<Integer> sorted = new ArrayList<Integer>();\\n    sorted.addAll(list);\\n    Collections.sort(sorted);\\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    for (int i = 0; i < list.size(); i++)\\n        map.put(list.get(i), i);\\n    for (int i = 0; i < list.size(); i++) {\\n        if (list.get(i) != sorted.get(i)) {\\n            ++swaps;\\n            int swap_index = map.get(sorted.get(i));\\n            map.put(list.get(i), swap_index);\\n            map.put(sorted.get(i), i);\\n            Collections.swap(list, i, swap_index);\\n                \\n        }\\n    }\\n    return swaps;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808797,
                "title": "level-order-traversal-selection-sort",
                "content": "```\\npublic class Solution {\\n    public int MinimumOperations(TreeNode root) {\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        \\n        int minOps = 0;\\n        while (queue.Count > 0) {\\n            int size = queue.Count;\\n            int[] arr = new int[size];\\n            int index = 0;\\n            for (int i = 0; i < size; i++) {\\n                var currNode = queue.Dequeue();\\n                arr[index++] = currNode.val;\\n                \\n                if (currNode.left != null)\\n                    queue.Enqueue(currNode.left);\\n                \\n                if (currNode.right != null)\\n                    queue.Enqueue(currNode.right);\\n            }\\n            \\n            minOps += this.SelectionSort(arr);\\n        }\\n        \\n        return minOps;\\n    }\\n    \\n    private int SelectionSort(int[] arr) {\\n        int swapsCount = 0;\\n        \\n        for (int i = 0; i < arr.Length - 1; i++) {\\n            int minIndex = i;\\n            \\n            for (int j = i + 1; j < arr.Length; j++) {\\n                if (arr[j] < arr[minIndex])\\n                    minIndex = j;\\n            }\\n            \\n            if (minIndex != i) {\\n                int temp = arr[minIndex];\\n                arr[minIndex] = arr[i];\\n                arr[i] = temp;\\n                \\n                swapsCount++;\\n            }\\n        }\\n        \\n        return swapsCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumOperations(TreeNode root) {\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        \\n        int minOps = 0;\\n        while (queue.Count > 0) {\\n            int size = queue.Count;\\n            int[] arr = new int[size];\\n            int index = 0;\\n            for (int i = 0; i < size; i++) {\\n                var currNode = queue.Dequeue();\\n                arr[index++] = currNode.val;\\n                \\n                if (currNode.left != null)\\n                    queue.Enqueue(currNode.left);\\n                \\n                if (currNode.right != null)\\n                    queue.Enqueue(currNode.right);\\n            }\\n            \\n            minOps += this.SelectionSort(arr);\\n        }\\n        \\n        return minOps;\\n    }\\n    \\n    private int SelectionSort(int[] arr) {\\n        int swapsCount = 0;\\n        \\n        for (int i = 0; i < arr.Length - 1; i++) {\\n            int minIndex = i;\\n            \\n            for (int j = i + 1; j < arr.Length; j++) {\\n                if (arr[j] < arr[minIndex])\\n                    minIndex = j;\\n            }\\n            \\n            if (minIndex != i) {\\n                int temp = arr[minIndex];\\n                arr[minIndex] = arr[i];\\n                arr[i] = temp;\\n                \\n                swapsCount++;\\n            }\\n        }\\n        \\n        return swapsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477113,
                "title": "java-15ms-100-bfs-sort-un-sort-explanations-fast",
                "content": "**--- General description of code ---**\\n\\nThe code below determines how many pair-swaps would be needed for the nodes within each level of a tree to become sorted into ascending numerical order.  The code does this by using a **Breadth First Search (BFS)** to do a level order traversal of the tree.  The BFS processes the levels of the tree one at a time.\\n\\nFor each level of the tree, the node.val values from the nodes, are copied into a `long[]` array, along with the node\\'s left-to-right positional index (0..n) across the tree level.  The `long[]` array is sorted into ascending order.  The sorted `long[]` array is then \"**un**sorted\", using swapping of pairs, to re-create the original unsorted array.  The number of swaps to unsort the array, is also the number of swaps that would have been needed to sort the array.\\n\\nFixed length arrays work well to sort the node values on a level of the tree, because we already know the number of nodes on that level of the tree, so the array length can be correctly allocated. Also, sorting and accessing arrays of primitive types, is faster than using more complex data structures such as List class objects, or arrays of objects such as Pair.\\n\\nThe values in the `long[]` array contain both the node.val value from each node, and the original index in the array before the array was sorted.  The original index is also the index position of the node across the level of the tree.  When the nodes in the `long[]` array are sorted, each `long` in the array will preserve the index it originally came from.  For the un-sorting process by swaps, this index will allow us to restore each `long` value to its original position in the array.\\n\\nThe algorithm to **un-sort** the nodes of the array is:\\n\\n1. Begin a loop through each index `i` in the sorted array `arr`.\\n2. If index `i` is past the end of array `arr`, then done.\\n3. Set `j` to be the original un-sorted index of the value in `arr[i]`.\\n3. If `i==j` then `arr[i]` is already in its original unsorted position, so assign i=i+1 and go back to step #2.\\n4. The value in `arr[i]` is not in its original position, so swap the values in `arr[i]` and `arr[j]`, which moves the value in `arr[i]` to its original un-sorted position within array `arr`.\\n5. Keep `i` as the same index value. Because we have previously swapped a new value into `arr[i]`, that value may also need to be moved to its original un-sorted position.  So go back to step #2.\\n\\nWithin each value of the `long[]` array, the low 20 bits store the original un-sorted index into the `long[]` array.  The next higher 17 bits contain the node.val value form the node.  The complication of packing these two values into a single `long` was done to gain execution speed from working with arrays of primitive data types.\\n\\n**--- Four versions of code ---**\\n\\nThe four versions of code further below have titles and, as of August 2023, fastest runtimes:\\n\\n*  Uncommented - Simpler and best-practices.  (20ms)\\n*  Uncommented - Speed optimized.  (15ms)\\n*  Commented - Simpler and best-practices.  (20ms)\\n*  Commented - Speed optimized.  (15ms)\\n\\nThe difference between the \"simpler and best-practices\" and the \"speed optimized\" is how the Breadth First Search (BFS) list of nodes on a level are stored for level-order traversal of the tree.  \\n\\nIn the \"**simpler and best-practices**\" code, the BFS list of nodes is implemented as LinkedList.  The LinkedList can handle future leetcode problem constraint changes, such as larger tree sizes.  The LinkedList also allow the code to be simpler, and simpler code is less likely to have bugs.\\n\\nIn the \"**speed optimized**\" code, the BFS list is implemented as fixed length arrays that are staticly allocated.  The fixed length arrays produce a \"subscript out of bounds\" error if the leetcode problem constraints are changed to allow larger trees.  The arrays are also statically allocated, which gains speed because the large maximum-required-length arrays are only created and allocated once for multiple leetcode test cases, instead of non-static arrays that would be re-allocated for each leetcode test case.  The static arrays are also NOT thread-safe.  A feature of Java\\'s static arrays that is not used in the code below, is that static arrays can preserve values and data between leetcode test cases, which can be useful, or can cause difficult to diagnose bugs.\\n\\nSpeed optimized code may be needed to meet a job\\'s requirements, especially for real-time programming where hardware can force timing requirements on the software.  To meet the speed requirements, bad programming practices can help squeeze more speed from the code, as in the \"speed optimized\" version of the code below.\\n\\n**If useful, please upvote.**\\n\\n**--- Code: Uncommented - Simpler and best-practices (22ms) ---**\\n```\\nclass Solution {\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n    \\n    public int minimumOperations(TreeNode root) {\\n        LinkedList<TreeNode> bfsList = new LinkedList();\\n        bfsList.addLast(root);\\n        int swapCount = 0;\\n        \\n        while (!bfsList.isEmpty()) {\\n            int nodeCount = bfsList.size();\\n            long[] sortedNodes = new long[nodeCount];\\n            for (int i = 0; i < nodeCount; i++) {\\n                TreeNode node = bfsList.pollFirst();\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  bfsList.addLast(node.left);\\n                if (node.right != null)  bfsList.addLast(node.right);\\n            }\\n\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < nodeCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\\n**--- Code: Uncommented - Speed optimized (19ms) ---**\\n```\\nclass Solution {\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n\\n    static final int MAX_NODES_PER_LEVEL = 34465;\\n    static final TreeNode[] bfsList1 = new TreeNode[MAX_NODES_PER_LEVEL];\\n    static final TreeNode[] bfsList2 = new TreeNode[MAX_NODES_PER_LEVEL];\\n\\n    \\n    public int minimumOperations(TreeNode root) {\\n        TreeNode[] curBFS = bfsList1;\\n        TreeNode[] nextBFS = bfsList2;\\n        int curBFSCount = 0;\\n        int nextBFSCount = 0;\\n        curBFS[curBFSCount++] = root;\\n\\n        int swapCount = 0;\\n        \\n        while (curBFSCount > 0) {\\n            long[] sortedNodes = new long[curBFSCount];\\n            for (int i = 0; i < curBFSCount; i++) {\\n                TreeNode node = curBFS[i];\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  nextBFS[nextBFSCount++] = node.left;\\n                if (node.right != null)  nextBFS[nextBFSCount++] = node.right;\\n            }\\n\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < curBFSCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n            \\n            TreeNode[] temp = curBFS;\\n            curBFS = nextBFS;\\n            nextBFS = temp;\\n            curBFSCount = nextBFSCount;\\n            nextBFSCount = 0;\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\\n**--- Code: Commented - Simpler and best-practices (22ms) ---**\\n```\\nclass Solution {\\n    // Constants used to build values in long[] arrays, where the \\n    // each long value contains a node.val from a node, and the \\n    // index of that node within the current level of the Breadth-\\n    // First-Search (BFS) traversal of the tree.  For eaxmple, if \\n    // a node was the third node from the left on its tree level \\n    // (at index 2 on the tree level), and the long value built \\n    // for sorting the nodes on that level, would be: \\n    //      (node.val << SHIFT) + 2\\n    // where the \"2\" is the index position of the third node on \\n    // the current level of the tree.  The MASK constant is used \\n    // to retrieve the index value out of the long value.\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n    \\n    public int minimumOperations(TreeNode root) {\\n        LinkedList<TreeNode> bfsList = new LinkedList();\\n        bfsList.addLast(root);\\n        int swapCount = 0;\\n        \\n        // Loop through each level of the tree, until no more levels.\\n        while (!bfsList.isEmpty()) {\\n            // Number of nodes on current level of the BFS level order \\n            // traversal of the tree.  Process this many nodes from the \\n            // BFS list, then any remaining nodes in the BFS list will \\n            // be for the next level of the tree.\\n            int nodeCount = bfsList.size();\\n            // The nodes of the current tree level, sorted by each node\\'s \\n            // node.val.  After sorting, this array will tell us where \\n            // the final position of each node should be.  The long \\n            // values in this array contain the original index that this \\n            // node came from for the nodes of this level of the tree.\\n            long[] sortedNodes = new long[nodeCount];\\n            // Loop through all nodes on this level of the tree.  Obtain \\n            // the nodes from the BFS list, which will remove the current \\n            // tree level\\'s nodes from the list.  While processing the \\n            // current tree level\\'s nodes, build the next tree level\\'s \\n            // BFS list by adding the next levels nodes to the end of the \\n            // BFS list to be used next time through the `while` loop.\\n            // For the current tree level, save the node.val values in \\n            // an array, so we can sort the arrays by node.val values.\\n            for (int i = 0; i < nodeCount; i++) {\\n                TreeNode node = bfsList.pollFirst();\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  bfsList.addLast(node.left);\\n                if (node.right != null)  bfsList.addLast(node.right);\\n            }\\n\\n            // For the current tree level, loop through the array of \\n            // sorted nodes.  Modify the sorted array to try to \\n            // reconstruct the tree level\\'s original node order, by \\n            // using a series of swaps of node pairs.  The number of \\n            // swaps needed to convert the sorted array back to the \\n            // original tree node order, is the same number of swaps \\n            // that would have been needed to sort the tree nodes to \\n            // ascending order.\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < nodeCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\\n**--- Code: Commented - Speed optimized (19ms) ---**\\n```\\nclass Solution {\\n    // Constants used to build values in long[] arrays, where the \\n    // each long value contains a node.val from a node, and the \\n    // index of that node within the current level of the Breadth-\\n    // First-Search (BFS) traversal of the tree.  For eaxmple, if \\n    // a node was the third node from the left on its tree level \\n    // (at index 2 on the tree level), and the long value built \\n    // for sorting the nodes on that level, would be: \\n    //      (node.val << SHIFT) + 2\\n    // where the \"2\" is the index position of the third node on \\n    // the current level of the tree.  The MASK constant is used \\n    // to retrieve the index value out of the long value.\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n\\n    // Maximum possible number of nodes in any level of a tree:\\n    //    x = 2^(floor(log2(max_total_nodes_in_a_tree)))\\n    //    MAX_NODES_PER_LEVEL = max(x, max_total_nodes_in_a_tree - x + 1)\\n    static final int MAX_NODES_PER_LEVEL = 34465;\\n    // Breadth first search lists that save the nodes from a \\n    // single level of the tree.  One list has the nodes of the \\n    // current level, and the other list has the nodes of the \\n    // next level.  We reference these arrays through the \\n    // variables \\'curBFS\\' and \\'nextBFS\\', which allows us to \\n    // alternate which of the bfsList1 and bfsList2 variables \\n    // are current and next levels.\\n    static final TreeNode[] bfsList1 = new TreeNode[MAX_NODES_PER_LEVEL];\\n    static final TreeNode[] bfsList2 = new TreeNode[MAX_NODES_PER_LEVEL];\\n\\n    \\n    public int minimumOperations(TreeNode root) {\\n        // Variables for the Breadth-First-Search (BFS) lists of \\n        // nodes, for level-order traversing the of the tree.  \\n        // The nodes for each tree level are stored in a current level \\n        // array, and a next level array.\\n        TreeNode[] curBFS = bfsList1;\\n        TreeNode[] nextBFS = bfsList2;\\n        int curBFSCount = 0;\\n        int nextBFSCount = 0;\\n        curBFS[curBFSCount++] = root;\\n\\n        int swapCount = 0;\\n        \\n        // Loop through each level of the tree, until no more levels.\\n        while (curBFSCount > 0) {\\n            // The nodes of the current tree level, sorted by each node\\'s \\n            // node.val.  After sorting, this array will tell us where \\n            // the final position of each node should be.  The long \\n            // values in this array contain the original index that this \\n            // node came from for the nodes of this level of the tree.\\n            long[] sortedNodes = new long[curBFSCount];\\n            // Loop through all nodes on this level of the tree.  Obtain \\n            // the nodes from the BFS list.  While processing the \\n            // current tree level\\'s nodes, build the next tree level\\'s \\n            // BFS list.  For the current tree level, save the node.val \\n            // values in an array, so we can sort the arrays by \\n            // node.val values.\\n            for (int i = 0; i < curBFSCount; i++) {\\n                TreeNode node = curBFS[i];\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  nextBFS[nextBFSCount++] = node.left;\\n                if (node.right != null)  nextBFS[nextBFSCount++] = node.right;\\n            }\\n\\n            // For the current tree level, loop through the array of \\n            // sorted nodes.  Modify the sorted array to try to \\n            // reconstruct the tree level\\'s original node order, by \\n            // using a series of swaps of node pairs.  The number of \\n            // swaps needed to convert the sorted array back to the \\n            // original tree node order, is the same number of swaps \\n            // that would have been needed to sort the tree nodes to \\n            // ascending order.\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < curBFSCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n            \\n            // Make the next BFS list the current BFS list, for \\n            // the next time through the \\'while\\' loop.\\n            TreeNode[] temp = curBFS;\\n            curBFS = nextBFS;\\n            nextBFS = temp;\\n            curBFSCount = nextBFSCount;\\n            nextBFSCount = 0;\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n    \\n    public int minimumOperations(TreeNode root) {\\n        LinkedList<TreeNode> bfsList = new LinkedList();\\n        bfsList.addLast(root);\\n        int swapCount = 0;\\n        \\n        while (!bfsList.isEmpty()) {\\n            int nodeCount = bfsList.size();\\n            long[] sortedNodes = new long[nodeCount];\\n            for (int i = 0; i < nodeCount; i++) {\\n                TreeNode node = bfsList.pollFirst();\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  bfsList.addLast(node.left);\\n                if (node.right != null)  bfsList.addLast(node.right);\\n            }\\n\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < nodeCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n\\n    static final int MAX_NODES_PER_LEVEL = 34465;\\n    static final TreeNode[] bfsList1 = new TreeNode[MAX_NODES_PER_LEVEL];\\n    static final TreeNode[] bfsList2 = new TreeNode[MAX_NODES_PER_LEVEL];\\n\\n    \\n    public int minimumOperations(TreeNode root) {\\n        TreeNode[] curBFS = bfsList1;\\n        TreeNode[] nextBFS = bfsList2;\\n        int curBFSCount = 0;\\n        int nextBFSCount = 0;\\n        curBFS[curBFSCount++] = root;\\n\\n        int swapCount = 0;\\n        \\n        while (curBFSCount > 0) {\\n            long[] sortedNodes = new long[curBFSCount];\\n            for (int i = 0; i < curBFSCount; i++) {\\n                TreeNode node = curBFS[i];\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  nextBFS[nextBFSCount++] = node.left;\\n                if (node.right != null)  nextBFS[nextBFSCount++] = node.right;\\n            }\\n\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < curBFSCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n            \\n            TreeNode[] temp = curBFS;\\n            curBFS = nextBFS;\\n            nextBFS = temp;\\n            curBFSCount = nextBFSCount;\\n            nextBFSCount = 0;\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Constants used to build values in long[] arrays, where the \\n    // each long value contains a node.val from a node, and the \\n    // index of that node within the current level of the Breadth-\\n    // First-Search (BFS) traversal of the tree.  For eaxmple, if \\n    // a node was the third node from the left on its tree level \\n    // (at index 2 on the tree level), and the long value built \\n    // for sorting the nodes on that level, would be: \\n    //      (node.val << SHIFT) + 2\\n    // where the \"2\" is the index position of the third node on \\n    // the current level of the tree.  The MASK constant is used \\n    // to retrieve the index value out of the long value.\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n    \\n    public int minimumOperations(TreeNode root) {\\n        LinkedList<TreeNode> bfsList = new LinkedList();\\n        bfsList.addLast(root);\\n        int swapCount = 0;\\n        \\n        // Loop through each level of the tree, until no more levels.\\n        while (!bfsList.isEmpty()) {\\n            // Number of nodes on current level of the BFS level order \\n            // traversal of the tree.  Process this many nodes from the \\n            // BFS list, then any remaining nodes in the BFS list will \\n            // be for the next level of the tree.\\n            int nodeCount = bfsList.size();\\n            // The nodes of the current tree level, sorted by each node\\'s \\n            // node.val.  After sorting, this array will tell us where \\n            // the final position of each node should be.  The long \\n            // values in this array contain the original index that this \\n            // node came from for the nodes of this level of the tree.\\n            long[] sortedNodes = new long[nodeCount];\\n            // Loop through all nodes on this level of the tree.  Obtain \\n            // the nodes from the BFS list, which will remove the current \\n            // tree level\\'s nodes from the list.  While processing the \\n            // current tree level\\'s nodes, build the next tree level\\'s \\n            // BFS list by adding the next levels nodes to the end of the \\n            // BFS list to be used next time through the `while` loop.\\n            // For the current tree level, save the node.val values in \\n            // an array, so we can sort the arrays by node.val values.\\n            for (int i = 0; i < nodeCount; i++) {\\n                TreeNode node = bfsList.pollFirst();\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  bfsList.addLast(node.left);\\n                if (node.right != null)  bfsList.addLast(node.right);\\n            }\\n\\n            // For the current tree level, loop through the array of \\n            // sorted nodes.  Modify the sorted array to try to \\n            // reconstruct the tree level\\'s original node order, by \\n            // using a series of swaps of node pairs.  The number of \\n            // swaps needed to convert the sorted array back to the \\n            // original tree node order, is the same number of swaps \\n            // that would have been needed to sort the tree nodes to \\n            // ascending order.\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < nodeCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Constants used to build values in long[] arrays, where the \\n    // each long value contains a node.val from a node, and the \\n    // index of that node within the current level of the Breadth-\\n    // First-Search (BFS) traversal of the tree.  For eaxmple, if \\n    // a node was the third node from the left on its tree level \\n    // (at index 2 on the tree level), and the long value built \\n    // for sorting the nodes on that level, would be: \\n    //      (node.val << SHIFT) + 2\\n    // where the \"2\" is the index position of the third node on \\n    // the current level of the tree.  The MASK constant is used \\n    // to retrieve the index value out of the long value.\\n    static final int SHIFT = 20;\\n    static final int MASK = 0xFFFFF;\\n\\n    // Maximum possible number of nodes in any level of a tree:\\n    //    x = 2^(floor(log2(max_total_nodes_in_a_tree)))\\n    //    MAX_NODES_PER_LEVEL = max(x, max_total_nodes_in_a_tree - x + 1)\\n    static final int MAX_NODES_PER_LEVEL = 34465;\\n    // Breadth first search lists that save the nodes from a \\n    // single level of the tree.  One list has the nodes of the \\n    // current level, and the other list has the nodes of the \\n    // next level.  We reference these arrays through the \\n    // variables \\'curBFS\\' and \\'nextBFS\\', which allows us to \\n    // alternate which of the bfsList1 and bfsList2 variables \\n    // are current and next levels.\\n    static final TreeNode[] bfsList1 = new TreeNode[MAX_NODES_PER_LEVEL];\\n    static final TreeNode[] bfsList2 = new TreeNode[MAX_NODES_PER_LEVEL];\\n\\n    \\n    public int minimumOperations(TreeNode root) {\\n        // Variables for the Breadth-First-Search (BFS) lists of \\n        // nodes, for level-order traversing the of the tree.  \\n        // The nodes for each tree level are stored in a current level \\n        // array, and a next level array.\\n        TreeNode[] curBFS = bfsList1;\\n        TreeNode[] nextBFS = bfsList2;\\n        int curBFSCount = 0;\\n        int nextBFSCount = 0;\\n        curBFS[curBFSCount++] = root;\\n\\n        int swapCount = 0;\\n        \\n        // Loop through each level of the tree, until no more levels.\\n        while (curBFSCount > 0) {\\n            // The nodes of the current tree level, sorted by each node\\'s \\n            // node.val.  After sorting, this array will tell us where \\n            // the final position of each node should be.  The long \\n            // values in this array contain the original index that this \\n            // node came from for the nodes of this level of the tree.\\n            long[] sortedNodes = new long[curBFSCount];\\n            // Loop through all nodes on this level of the tree.  Obtain \\n            // the nodes from the BFS list.  While processing the \\n            // current tree level\\'s nodes, build the next tree level\\'s \\n            // BFS list.  For the current tree level, save the node.val \\n            // values in an array, so we can sort the arrays by \\n            // node.val values.\\n            for (int i = 0; i < curBFSCount; i++) {\\n                TreeNode node = curBFS[i];\\n                sortedNodes[i] = ((long)node.val << SHIFT) + i;\\n                if (node.left != null)  nextBFS[nextBFSCount++] = node.left;\\n                if (node.right != null)  nextBFS[nextBFSCount++] = node.right;\\n            }\\n\\n            // For the current tree level, loop through the array of \\n            // sorted nodes.  Modify the sorted array to try to \\n            // reconstruct the tree level\\'s original node order, by \\n            // using a series of swaps of node pairs.  The number of \\n            // swaps needed to convert the sorted array back to the \\n            // original tree node order, is the same number of swaps \\n            // that would have been needed to sort the tree nodes to \\n            // ascending order.\\n            Arrays.sort(sortedNodes);\\n            for (int i = 0; i < curBFSCount; i++) {\\n                int origIdx = (int)(sortedNodes[i] & MASK);\\n                if (origIdx != i) {\\n                    long temp = sortedNodes[i];\\n                    sortedNodes[i--] = sortedNodes[origIdx];\\n                    sortedNodes[origIdx] = temp;\\n                    swapCount++;\\n                }\\n            }\\n            \\n            // Make the next BFS list the current BFS list, for \\n            // the next time through the \\'while\\' loop.\\n            TreeNode[] temp = curBFS;\\n            curBFS = nextBFS;\\n            nextBFS = temp;\\n            curBFSCount = nextBFSCount;\\n            nextBFSCount = 0;\\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112405,
                "title": "python-3-bfs-union-find",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        par = {}\\n        rank = {}\\n        \\n        def ins(n1):\\n            if n1 in par:\\n                return\\n            par[n1] = n1\\n            rank[n1] = 1\\n        \\n        def find(n1):\\n            while n1 != par[n1]:\\n                par[n1] = par[par[n1]]\\n                n1 = par[n1]\\n            return n1\\n        \\n        def union(n1, n2):\\n            p1, p2 = find(n1), find(n2)\\n            if p1 == p2:\\n                return 0\\n            if rank[p1] < rank[p2]:\\n                p1, p2 = p2, p1\\n            par[p2] = p1\\n            rank[p1] += rank[p2]\\n            return 1\\n        \\n        def helper(nums):\\n            t = sorted(nums)\\n            \\n            for i, j in zip(nums, t):\\n                ins(i)\\n                ins(j)\\n                union(i, j)\\n            \\n            return sum(rank[i] - 1 for i in nums if i == find(i))\\n            \\n        \\n        q = deque( [root] )\\n        res = 0\\n        \\n        while q:\\n            level = []\\n            \\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                level.append(cur.val)\\n                \\n                if cur.left: q.append(cur.left)\\n                if cur.right: q.append(cur.right)\\n                    \\n            res += helper(level)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        par = {}\\n        rank = {}\\n        \\n        def ins(n1):\\n            if n1 in par:\\n                return\\n            par[n1] = n1\\n            rank[n1] = 1\\n        \\n        def find(n1):\\n            while n1 != par[n1]:\\n                par[n1] = par[par[n1]]\\n                n1 = par[n1]\\n            return n1\\n        \\n        def union(n1, n2):\\n            p1, p2 = find(n1), find(n2)\\n            if p1 == p2:\\n                return 0\\n            if rank[p1] < rank[p2]:\\n                p1, p2 = p2, p1\\n            par[p2] = p1\\n            rank[p1] += rank[p2]\\n            return 1\\n        \\n        def helper(nums):\\n            t = sorted(nums)\\n            \\n            for i, j in zip(nums, t):\\n                ins(i)\\n                ins(j)\\n                union(i, j)\\n            \\n            return sum(rank[i] - 1 for i in nums if i == find(i))\\n            \\n        \\n        q = deque( [root] )\\n        res = 0\\n        \\n        while q:\\n            level = []\\n            \\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                level.append(cur.val)\\n                \\n                if cur.left: q.append(cur.left)\\n                if cur.right: q.append(cur.right)\\n                    \\n            res += helper(level)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917578,
                "title": "level-order-swap-sort",
                "content": "class Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        def swp(arr):\\n            n = len(arr)\\n            ans = 0\\n            temp = arr.copy()\\n            h = {}\\n            temp.sort()\\n\\n            for i in range(n):\\n\\n                h[arr[i]] = i\\n\\n            init = 0\\n\\n            for i in range(n):\\n\\n                if (arr[i] != temp[i]):\\n                    ans += 1\\n                    init = arr[i]\\n                    arr[i], arr[h[temp[i]]] = arr[h[temp[i]]], arr[i]\\n                    h[init] = h[temp[i]]\\n                    h[temp[i]] = i\\n\\n            return ans\\n        \\n        count = 0\\n        if not root:\\n            return 0\\n        queue = [root]\\n        \\n        while queue:\\n            size = len(queue)\\n            temp = []\\n            for _ in range(size):\\n                node = queue.pop(0)\\n                temp.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            count += swp(temp)\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        def swp(arr):\\n            n = len(arr)\\n            ans = 0\\n            temp = arr.copy()\\n            h = {}",
                "codeTag": "Java"
            },
            {
                "id": 2836928,
                "title": "min-swaps-function",
                "content": "# Intuition\\nBy traversing level wise and adding them to a vector and then we can compute minimum swaps needed.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Breath-First Search to traverse the each level\\nAnd function `minSwaps` to compute minmum number of swaps needed to sort.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(nlogn)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<int>& B, int n) {\\n        vector<pair<int, int>>v(n);\\n        for(int i = 0; i < n; i++)\\n        v[i] = {B[i], i};\\t// v = {{4, 0}, {3, 1}, {8, 2}}\\n        sort(v.begin(), v.end()); // v = {{3, 1}, {4, 0}, {8, 2}}\\n\\n        int count = 0;\\n        for(int i = 0; i < n ; i++){\\n          if(v[i].second == i) continue;\\n          else{\\n            count ++;\\n            swap(v[i], v[v[i].second]);\\n            i--;\\n          }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        int size, swaps = 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        vector<int> level;\\n        int i, notM;\\n        \\n        while(!q.empty()) {\\n            size = q.size();\\n            while(size--) {\\n                root = q.front();\\n                q.pop();\\n                level.push_back(root->val);\\n                if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n            }\\n            \\n            swaps += minSwaps(level, level.size());\\n            \\n            level.clear();\\n        }\\n        \\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<int>& B, int n) {\\n        vector<pair<int, int>>v(n);\\n        for(int i = 0; i < n; i++)\\n        v[i] = {B[i], i};\\t// v = {{4, 0}, {3, 1}, {8, 2}}\\n        sort(v.begin(), v.end()); // v = {{3, 1}, {4, 0}, {8, 2}}\\n\\n        int count = 0;\\n        for(int i = 0; i < n ; i++){\\n          if(v[i].second == i) continue;\\n          else{\\n            count ++;\\n            swap(v[i], v[v[i].second]);\\n            i--;\\n          }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        int size, swaps = 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        vector<int> level;\\n        int i, notM;\\n        \\n        while(!q.empty()) {\\n            size = q.size();\\n            while(size--) {\\n                root = q.front();\\n                q.pop();\\n                level.push_back(root->val);\\n                if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n            }\\n            \\n            swaps += minSwaps(level, level.size());\\n            \\n            level.clear();\\n        }\\n        \\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828533,
                "title": "python-bfs-with-heap-priority-queue-nlogn",
                "content": "The idea is to simulate the process of bringing the smallest number you have to the current possition for each level. use heap for the minimum element and dictionary to track the index.\\n\\nExample:\\n-    i = 0\\n-\\t[50, 30, 20, 40] -> swap 50 with 20 and also swap their index and remove 20 from heap\\n-\\ti = 1\\n-\\t[20, 30, 50, 40] -> 30 is the minimum so don\\'t swap it just pop it from heap and keep going forward\\n-   i = 3\\n-   [20, 30, 50, 40]  -> swap 50 with the minimum 40 and keep going forward\\n-   i = 4\\n-   [20, 30, 40, 50] -> now the level is sorted and we have a total of 3 operation.\\n```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        minOperation = 0\\n        queue = deque([root])\\n\\n        while queue:\\n            newLevel = []\\n            # create a new level\\n            for elem in queue:\\n                if elem.left:\\n                    newLevel.append(elem.left)\\n                if elem.right:\\n                    newLevel.append(elem.right)\\n            \\n            # process cost each level I have in the queue to be sorted\\n            heap = [node.val for node in queue]\\n            heapq.heapify(heap)\\n            index = {node.val: i for i, node in enumerate(queue)}\\n\\n            # do the simulation of taking out the minumum and swapping it\\n            # if the current element is not the smallest you swap it with the smallest element\\n            # and pop from your heap\\n            for i, element in enumerate(queue):\\n                if element.val != heap[0]:\\n                    index[element.val] = index[heap[0]]\\n                    index[heap[0]] = i\\n                    queue[i], queue[index[element.val]] = queue[index[element.val]], queue[i]\\n                    minOperation += 1\\n                heapq.heappop(heap)\\n            \\n            queue = newLevel\\n\\n        return minOperation\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        minOperation = 0\\n        queue = deque([root])\\n\\n        while queue:\\n            newLevel = []\\n            # create a new level\\n            for elem in queue:\\n                if elem.left:\\n                    newLevel.append(elem.left)\\n                if elem.right:\\n                    newLevel.append(elem.right)\\n            \\n            # process cost each level I have in the queue to be sorted\\n            heap = [node.val for node in queue]\\n            heapq.heapify(heap)\\n            index = {node.val: i for i, node in enumerate(queue)}\\n\\n            # do the simulation of taking out the minumum and swapping it\\n            # if the current element is not the smallest you swap it with the smallest element\\n            # and pop from your heap\\n            for i, element in enumerate(queue):\\n                if element.val != heap[0]:\\n                    index[element.val] = index[heap[0]]\\n                    index[heap[0]] = i\\n                    queue[i], queue[index[element.val]] = queue[index[element.val]], queue[i]\\n                    minOperation += 1\\n                heapq.heappop(heap)\\n            \\n            queue = newLevel\\n\\n        return minOperation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828190,
                "title": "python-bfs-hashmap-o-nlogn-video-solution",
                "content": "You can refer to the [video solution](https://youtu.be/4XzEifpXNjU).\\n\\nSince sorting has to be done on row level, we will have to go through the tree level-wise using BFS.\\nWe will have to store all the elements for the row in an array and then sort it to find each elements sorted position.\\n\\nWe will store this sorted position for each element using a HashMap.\\n\\nWe will go through each element in the row and try to swap it at the right position if it isn\\'t already in its correct position.\\nWe might have to swap multiple numbers together in a group.\\n\\n```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        total = 0\\n        \\n        while q:\\n            row = []\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                row.append(node.val)\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            pos = {n:i for i,n in enumerate(sorted(row))}\\n            \\n            visited = set()\\n            \\n            for i in range(len(row)):\\n                index = i\\n                cnt = 0\\n                while index not in visited and pos[row[index]]!=index:\\n                    visited.add(index)\\n                    index = pos[row[index]]\\n                    cnt+=1\\n                total += max(0, cnt-1)\\n                \\n        return total",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        total = 0\\n        \\n        while q:\\n            row = []\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                row.append(node.val)\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            pos = {n:i for i,n in enumerate(sorted(row))}",
                "codeTag": "Java"
            },
            {
                "id": 2817892,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        queue = deque([root])\\n        ans = 0\\n        while len(queue)!=0:\\n            levelNode = []\\n            for k in range(len(queue)):\\n                nowNode = queue.popleft()\\n                levelNode.append(nowNode.val)\\n                if nowNode.left!=None:\\n                    queue.append(nowNode.left)\\n                if nowNode.right!=None:\\n                    queue.append(nowNode.right)\\n            \\n            levelNodeSort = sorted(levelNode)\\n            posDict = defaultdict(int)\\n            for i in range(len(levelNode)):\\n                posDict[levelNode[i]] = i\\n            for i in range(len(levelNode)):\\n                if(levelNode[i]!=levelNodeSort[i]):\\n                    replace = posDict[levelNodeSort[i]]\\n                    levelNode[replace] = levelNode[i]\\n                    posDict[levelNode[i]] = replace\\n                    levelNode[i] = levelNodeSort[i]\\n                    ans+=1\\n\\n        return ans\\n                    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        queue = deque([root])\\n        ans = 0\\n        while len(queue)!=0:\\n            levelNode = []\\n            for k in range(len(queue)):\\n                nowNode = queue.popleft()\\n                levelNode.append(nowNode.val)\\n                if nowNode.left!=None:\\n                    queue.append(nowNode.left)\\n                if nowNode.right!=None:\\n                    queue.append(nowNode.right)\\n            \\n            levelNodeSort = sorted(levelNode)\\n            posDict = defaultdict(int)\\n            for i in range(len(levelNode)):\\n                posDict[levelNode[i]] = i\\n            for i in range(len(levelNode)):\\n                if(levelNode[i]!=levelNodeSort[i]):\\n                    replace = posDict[levelNodeSort[i]]\\n                    levelNode[replace] = levelNode[i]\\n                    posDict[levelNode[i]] = replace\\n                    levelNode[i] = levelNodeSort[i]\\n                    ans+=1\\n\\n        return ans\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810646,
                "title": "java-level-order-traversal-cyclic-sort",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n\\n        int min = 0;\\n\\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            int[] arr = new int[size];\\n            int i = 0;\\n\\n            while (size-- > 0){\\n                TreeNode node = q.poll();\\n                arr[i++] = node.val;\\n\\n                if (node.left != null) q.add(node.left);\\n                if (node.right != null) q.add(node.right);\\n            }\\n\\n            min += minSwaps(arr);\\n        }\\n\\n        return min;\\n    }\\n\\n    public int minSwaps(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        Arrays.sort(nums);\\n        boolean[] visited = new boolean[n];\\n\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] || map.get(nums[i]) == i) {\\n                continue;\\n            }\\n\\n            int j = i, cycleSize = 0;\\n\\n            while (!visited[j]) {\\n                visited[j] = true;\\n                j = map.get(nums[j]);\\n                cycleSize++;\\n            }\\n\\n            if(cycleSize > 0) {\\n                ans += (cycleSize - 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(h * n * logn)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n\\n        int min = 0;\\n\\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            int[] arr = new int[size];\\n            int i = 0;\\n\\n            while (size-- > 0){\\n                TreeNode node = q.poll();\\n                arr[i++] = node.val;\\n\\n                if (node.left != null) q.add(node.left);\\n                if (node.right != null) q.add(node.right);\\n            }\\n\\n            min += minSwaps(arr);\\n        }\\n\\n        return min;\\n    }\\n\\n    public int minSwaps(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        Arrays.sort(nums);\\n        boolean[] visited = new boolean[n];\\n\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] || map.get(nums[i]) == i) {\\n                continue;\\n            }\\n\\n            int j = i, cycleSize = 0;\\n\\n            while (!visited[j]) {\\n                visited[j] = true;\\n                j = map.get(nums[j]);\\n                cycleSize++;\\n            }\\n\\n            if(cycleSize > 0) {\\n                ans += (cycleSize - 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(h * n * logn)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810374,
                "title": "javascript-bfs-cycle-counting-explained",
                "content": "**Solution: BFS & Cycle Counting**\\n\\nBFS level-by-level and get minimum swaps for the node values at each level.\\n\\nHow to calculate the minimum swaps to sort an array:\\n  1. Get the index of each number in its sorted position (store in a hashmap `indexes`)\\n  2. For each `nums[i]`, store the number we need to swap with to place `nums[i]` in its sorted position (store in a hashmap `next`)\\n  3. Find the size of each cycle.\\n  4. Get the total sum of each (`cycle size - 1`).\\n\\nWhy sum of (`cycle size - 1`) is correct:\\n*   If cycle size = `1`, we don\\'t need any swaps.\\n*   If cycle size = `2`, we only need 1 swap.\\n*   If cycle size = `3`, we need 2 swaps.\\n\\n  --- **Main Proof** ---\\n*   Starting from the smallest number in the cycle, swap each `nums[i]` (where `nums[i]` is in the cycle) into its sorted position.\\n*   Since the number is now in the correct position, it is no longer in the cycle and this leaves us with a cycle of size (`n - 1`), where `n = the previous size of the cycle`.\\n\\t*   The edge from `nums[i]` -> correct position is now replaced with a new edge coming from the number we swapped with.\\n\\n`n = number of nodes in the tree`\\nTime Complexity: `O(n log(n))` 1581ms\\nSpace Complexity: `O(n)` 129MB\\n```\\nvar minimumOperations = function(root) {\\n  let queue = [root], ans = 0;\\n  while (queue.length)  {\\n    let next = [];\\n    ans += minSwaps(queue.map(node => node.val));\\n    while (queue.length) {\\n      let node = queue.shift();\\n      if (node.left) next.push(node.left);\\n      if (node.right) next.push(node.right);\\n    }\\n    queue = next;\\n  } \\n  return ans;\\n};\\n\\nfunction minSwaps(nums) {\\n  let sorted = [...nums].sort((a, b) => a - b);\\n  let indexes = sorted.reduce((memo, num, idx) => {\\n    memo[num] = idx;\\n    return memo;\\n  }, {});\\n\\n  let next = {};\\n  for (let num of nums) {\\n    next[num] = nums[indexes[num]];\\n  }\\n\\n  let seen = new Set(), ans = 0;\\n  for (let num of nums) {\\n    let cycleSize = 0, node = num;\\n    while (!seen.has(node)) {\\n      seen.add(node);\\n      node = next[node];\\n      cycleSize++;\\n    }\\n    ans += Math.max(0, cycleSize - 1);\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumOperations = function(root) {\\n  let queue = [root], ans = 0;\\n  while (queue.length)  {\\n    let next = [];\\n    ans += minSwaps(queue.map(node => node.val));\\n    while (queue.length) {\\n      let node = queue.shift();\\n      if (node.left) next.push(node.left);\\n      if (node.right) next.push(node.right);\\n    }\\n    queue = next;\\n  } \\n  return ans;\\n};\\n\\nfunction minSwaps(nums) {\\n  let sorted = [...nums].sort((a, b) => a - b);\\n  let indexes = sorted.reduce((memo, num, idx) => {\\n    memo[num] = idx;\\n    return memo;\\n  }, {});\\n\\n  let next = {};\\n  for (let num of nums) {\\n    next[num] = nums[indexes[num]];\\n  }\\n\\n  let seen = new Set(), ans = 0;\\n  for (let num of nums) {\\n    let cycleSize = 0, node = num;\\n    while (!seen.has(node)) {\\n      seen.add(node);\\n      node = next[node];\\n      cycleSize++;\\n    }\\n    ans += Math.max(0, cycleSize - 1);\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809686,
                "title": "c-unordered-map-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumOperations(TreeNode* root) {\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(root);\\n\\t\\t\\tvector<vector<int>>v;\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint l=q.size();\\n\\t\\t\\t\\tvector<int>temp;\\n\\t\\t\\t\\tfor(int i=0; i<l; i++){\\n\\t\\t\\t\\t\\troot=q.front();\\n\\t\\t\\t\\t\\ttemp.push_back(root->val);\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tif(root->left){q.push(root->left);}\\n\\t\\t\\t\\t\\tif(root->right){q.push(root->right);}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv.push_back(temp);\\n\\t\\t\\t}\\n\\t\\t\\t//for(int i=0; i<v.size(); i++){for(int j=0; j<v[i].size(); j++){cout<<v[i][j]<<\" \";}}cout<<endl;\\n\\t\\t\\tlong long int cnt=0;\\n\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\t//unordered_map<int, int>m;\\n\\t\\t\\t\\tunordered_map<int, int>m1;\\n\\t\\t\\t\\tvector<pair<int, int>>x;\\n\\t\\t\\t\\tfor(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t\\t\\tx.push_back({v[i][j], j});\\n\\t\\t\\t\\t\\t//m[v[i][j]]=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsort(x.begin(), x.end());\\n\\t\\t\\t\\tfor(int k=0; k<x.size(); k++){\\n\\t\\t\\t\\t\\t//cout<<x[k].second<<\" \"<<k<<endl;\\n\\t\\t\\t\\t\\tm1[x[k].second]=k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// for(int k=0; k<x.size(); k++){\\n\\t\\t\\t\\t//     cout<<x[k].first<<\" \"<<x[k].second<<\" \"<<m1[x[k].second]<<endl;\\n\\t\\t\\t\\t// }cout<<endl;\\n\\t\\t\\t\\tfor(int k=0; k<x.size(); k++){\\n\\t\\t\\t\\t\\t// cout<<endl;\\n\\t\\t\\t\\t\\t// cout<<x[k].first<<\" \"<<x[k].second<<\" \"<<cnt<<\" \"<<k<<endl;\\n\\t\\t\\t\\t\\t// cout<<endl;\\n\\t\\t\\t\\t\\tif(x[k].second==k){continue;}\\n\\t\\t\\t\\t\\telse{\\n\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\tint l=m1[x[k].second], r=m1[m1[x[k].second]], f2=x[r].second, f1=x[k].second, v1=m1[f1], v2=m1[f2], ind=x[k].second;\\n\\t\\t\\t\\t\\t\\t//cout<<l<<\" \"<<r<<\" \"<<f1<<\" \"<<f2<<\" \"<<v1<<\" \"<<v2<<endl;\\n\\t\\t\\t\\t\\t\\tx[r].second=f1;\\n\\t\\t\\t\\t\\t\\tx[l].second=f2;\\n\\t\\t\\t\\t\\t\\tm1[f1]=v2;\\n\\t\\t\\t\\t\\t\\tm1[f2]=v1;\\n\\t\\t\\t\\t\\t\\t//cout<<x[k].first<<\" \"<<x[k].second<<\" \"<<cnt<<\" \"<<k<<endl;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// for(int k=0; k<x.size(); k++){\\n\\t\\t\\t\\t//     cout<<x[k].first<<\" \"<<x[k].second<<\" \"<<m1[x[k].second]<<endl;\\n\\t\\t\\t\\t// }cout<<endl;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumOperations(TreeNode* root) {\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(root);\\n\\t\\t\\tvector<vector<int>>v;\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint l=q.size();\\n\\t\\t\\t\\tvector<int>temp;\\n\\t\\t\\t\\tfor(int i=0; i<l; i++){\\n\\t\\t\\t\\t\\troot=q.front();\\n\\t\\t\\t\\t\\ttemp.push_back(root->val);\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tif(root->left){q.push(root->left);}",
                "codeTag": "Java"
            },
            {
                "id": 2808877,
                "title": "java-level-order-traversal",
                "content": "```\\npublic int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int res = 0;\\n        while(!q.isEmpty()){\\n            ArrayList<Integer> list = new ArrayList<>();\\n            int count = q.size();\\n            for(int i = 0; i < count; i++){\\n                TreeNode cur = q.remove();\\n                // if(cur.left > cur.right) res++;\\n                list.add(cur.val);\\n                if(cur.left != null) q.offer(cur.left);\\n                if(cur.right != null) q.offer(cur.right);\\n            }\\n            res += minSwaps(list, list.size());\\n        }\\n        return res;\\n    }\\n    \\n    public int minSwaps(ArrayList<Integer> list, int N){\\n        int ans = 0;\\n        ArrayList<Integer> temp = new ArrayList<>(list);\\n \\n\\n        HashMap<Integer, Integer> h\\n            = new HashMap<Integer, Integer>();\\n \\n        Collections.sort(temp);\\n        for (int i = 0; i < N; i++){\\n            h.put(list.get(i), i);\\n        }\\n        for (int i = 0; i < N; i++){\\n \\n            if (list.get(i) != temp.get(i))\\n            {\\n                ans++;\\n                int init = list.get(i);\\n \\n\\n                Collections.swap(list, i, h.get(temp.get(i)));\\n \\n                h.put(init, h.get(temp.get(i)));\\n                h.put(temp.get(i), i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\npublic int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int res = 0;\\n        while(!q.isEmpty()){\\n            ArrayList<Integer> list = new ArrayList<>();\\n            int count = q.size();\\n            for(int i = 0; i < count; i++){\\n                TreeNode cur = q.remove();\\n                // if(cur.left > cur.right) res++;\\n                list.add(cur.val);\\n                if(cur.left != null) q.offer(cur.left);\\n                if(cur.right != null) q.offer(cur.right);\\n            }\\n            res += minSwaps(list, list.size());\\n        }\\n        return res;\\n    }\\n    \\n    public int minSwaps(ArrayList<Integer> list, int N){\\n        int ans = 0;\\n        ArrayList<Integer> temp = new ArrayList<>(list);\\n \\n\\n        HashMap<Integer, Integer> h\\n            = new HashMap<Integer, Integer>();\\n \\n        Collections.sort(temp);\\n        for (int i = 0; i < N; i++){\\n            h.put(list.get(i), i);\\n        }\\n        for (int i = 0; i < N; i++){\\n \\n            if (list.get(i) != temp.get(i))\\n            {\\n                ans++;\\n                int init = list.get(i);\\n \\n\\n                Collections.swap(list, i, h.get(temp.get(i)));\\n \\n                h.put(init, h.get(temp.get(i)));\\n                h.put(temp.get(i), i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984001,
                "title": "easy-and-clean-solution-in-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will use level order traversal to go through each levle of a tree from left to right. store all the values in a vector and pass tis vector in a count function.\\nin count function we will create a mapping to store the original indexes of each value. then sort the vector. then go through the array and if the new index is not equal to old index of the value then swap the values. and increment the answer by one. this will give us the min requires swaps needed to sort that array.\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void count(vector<int> &lvl){\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < lvl.size(); i++){\\n            m[lvl[i]] = i;\\n        }\\n        sort(lvl.begin(),lvl.end());\\n        int i = 0;\\n        while(i < lvl.size()){\\n            if(m[lvl[i]] != i){\\n                swap(lvl[i],lvl[m[lvl[i]]]);\\n                ans++;\\n            }\\n            else i++;\\n        }\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n\\n        while(!q.empty()){\\n            TreeNode* t = q.front();\\n            q.pop();\\n            vector<int> lvl;\\n            while(t != NULL){\\n                lvl.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n                t = q.front();\\n                q.pop();\\n            }\\n            if(!q.empty()) q.push(NULL);\\n            count(lvl);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void count(vector<int> &lvl){\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < lvl.size(); i++){\\n            m[lvl[i]] = i;\\n        }\\n        sort(lvl.begin(),lvl.end());\\n        int i = 0;\\n        while(i < lvl.size()){\\n            if(m[lvl[i]] != i){\\n                swap(lvl[i],lvl[m[lvl[i]]]);\\n                ans++;\\n            }\\n            else i++;\\n        }\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n\\n        while(!q.empty()){\\n            TreeNode* t = q.front();\\n            q.pop();\\n            vector<int> lvl;\\n            while(t != NULL){\\n                lvl.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n                t = q.front();\\n                q.pop();\\n            }\\n            if(!q.empty()) q.push(NULL);\\n            count(lvl);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983594,
                "title": "easiest-c-solution-thus-far",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans = 0;\\n        if (!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int len = q.size();\\n            vector<int> vec;\\n            while (len--) {\\n                root = q.front();\\n                q.pop();\\n                vec.push_back(root->val);\\n                if (root->left) q.push(root->left);\\n                if (root->right) q.push(root->right);\\n            }\\n            unordered_map<int, int> map;\\n            for (int i=0; i<vec.size(); i++) map[vec[i]] = i;\\n            sort(vec.begin(), vec.end());\\n            int i=0;\\n            while (i < vec.size()) {\\n                if (map[vec[i]] != i) {\\n                    swap(vec[i], vec[map[vec[i]]]);\\n                    ans++;\\n                }\\n                else i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans = 0;\\n        if (!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int len = q.size();\\n            vector<int> vec;\\n            while (len--) {\\n                root = q.front();\\n                q.pop();\\n                vec.push_back(root->val);\\n                if (root->left) q.push(root->left);\\n                if (root->right) q.push(root->right);\\n            }\\n            unordered_map<int, int> map;\\n            for (int i=0; i<vec.size(); i++) map[vec[i]] = i;\\n            sort(vec.begin(), vec.end());\\n            int i=0;\\n            while (i < vec.size()) {\\n                if (map[vec[i]] != i) {\\n                    swap(vec[i], vec[map[vec[i]]]);\\n                    ans++;\\n                }\\n                else i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344895,
                "title": "easy-c-solution-easy-to-undersatnd-bfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void swap(vector<int>& arr, int i, int j)\\n{\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\nint f(vector<int>& arr, int N)\\n{\\n    int ans = 0;\\n    vector<int> temp = arr;\\n    map<int, int> h;\\n    sort(temp.begin(), temp.end());\\n    for (int i = 0; i < N; i++) {\\n        h[arr[i]] = i;\\n    }\\n    for (int i = 0; i < N; i++) {\\n        if (arr[i] != temp[i]) {\\n            ans++;\\n            int init = arr[i];\\n            swap(arr, i, h[temp[i]]);\\n            h[init] = h[temp[i]];\\n            h[temp[i]] = i;\\n        }\\n    }\\n    return ans;\\n}\\n    int minimumOperations(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        int sum=0;\\n       queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int s = q.size();\\n            vector<int> ans;\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                ans.push_back(node->val);\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n            sum+= f(ans,ans.size());\\n            ans.clear();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void swap(vector<int>& arr, int i, int j)\\n{\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\nint f(vector<int>& arr, int N)\\n{\\n    int ans = 0;\\n    vector<int> temp = arr;\\n    map<int, int> h;\\n    sort(temp.begin(), temp.end());\\n    for (int i = 0; i < N; i++) {\\n        h[arr[i]] = i;\\n    }\\n    for (int i = 0; i < N; i++) {\\n        if (arr[i] != temp[i]) {\\n            ans++;\\n            int init = arr[i];\\n            swap(arr, i, h[temp[i]]);\\n            h[init] = h[temp[i]];\\n            h[temp[i]] = i;\\n        }\\n    }\\n    return ans;\\n}\\n    int minimumOperations(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        int sum=0;\\n       queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int s = q.size();\\n            vector<int> ans;\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                ans.push_back(node->val);\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n            sum+= f(ans,ans.size());\\n            ans.clear();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343733,
                "title": "easy-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Do level Order Traversal and then use swaps function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nswap function takes O(n*log(n))\\nLevel order Traversal O(n)\\nOverAll  O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void count_swaps(vector<int>&y,int &swaps){\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<y.size();i++){\\n            v.push_back({y[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            pair<int,int> p = v[i];\\n            int ele = p.first;\\n            int index = p.second;\\n            if(i!=index){\\n                swaps++;\\n                swap(v[i],v[index]);\\n                i--;\\n            }\\n        }\\n        return;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int swaps=0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int>y;\\n            for(int i=0;i<size;i++){\\n                TreeNode* p = q.front();\\n                y.push_back(p->val);\\n                q.pop();\\n                if(p->left){\\n                    q.push(p->left);\\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                } \\n            }\\n                //now function for swaps\\n                count_swaps(y,swaps);\\n            }\\n            return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void count_swaps(vector<int>&y,int &swaps){\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<y.size();i++){\\n            v.push_back({y[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            pair<int,int> p = v[i];\\n            int ele = p.first;\\n            int index = p.second;\\n            if(i!=index){\\n                swaps++;\\n                swap(v[i],v[index]);\\n                i--;\\n            }\\n        }\\n        return;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int swaps=0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int>y;\\n            for(int i=0;i<size;i++){\\n                TreeNode* p = q.front();\\n                y.push_back(p->val);\\n                q.pop();\\n                if(p->left){\\n                    q.push(p->left);\\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                } \\n            }\\n                //now function for swaps\\n                count_swaps(y,swaps);\\n            }\\n            return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931539,
                "title": "c-level-order-traversal-bfs-hashing-faster-than-85-easy-understanding",
                "content": "\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid swap(TreeNode* A, TreeNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\n    int minimumOperations(TreeNode* root) {\\n  \\n      queue<TreeNode*>q;\\n      q.push(root);\\n      int res = 0;\\n\\n      while(!q.empty())\\n      {\\n          int n = q.size();\\n           vector<TreeNode*>v;\\n\\n          for(int i = 0; i < n ; ++i)\\n          {\\n              auto temp = q.front();\\n              q.pop();\\n\\n              if(temp->left != NULL) q.push(temp->left);\\n              if(temp->right != NULL) q.push(temp->right);\\n\\n              v.push_back(temp);\\n          }\\n\\n          vector<int>copy;\\n          unordered_map<int,int>mpp;\\n\\n          for(auto it : v) copy.push_back(it->val);\\n          \\n          \\n          sort(copy.begin(), copy.end());\\n\\n          \\n          for(int i = 0;i < copy.size(); ++i) mpp[copy[i]] = i;\\n          \\n         \\n          for(int i = 0; i < v.size(); ++i)\\n          {\\n              if(mpp[v[i]->val] != i)\\n              {\\n                 swap(v[i], v[mpp[v[i]->val]]);\\n                 res++;\\n                 i--;\\n              }\\n          }\\n\\n      }\\n\\n      return res;  \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid swap(TreeNode* A, TreeNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\n    int minimumOperations(TreeNode* root) {\\n  \\n      queue<TreeNode*>q;\\n      q.push(root);\\n      int res = 0;\\n\\n      while(!q.empty())\\n      {\\n          int n = q.size();\\n           vector<TreeNode*>v;\\n\\n          for(int i = 0; i < n ; ++i)\\n          {\\n              auto temp = q.front();\\n              q.pop();\\n\\n              if(temp->left != NULL) q.push(temp->left);\\n              if(temp->right != NULL) q.push(temp->right);\\n\\n              v.push_back(temp);\\n          }\\n\\n          vector<int>copy;\\n          unordered_map<int,int>mpp;\\n\\n          for(auto it : v) copy.push_back(it->val);\\n          \\n          \\n          sort(copy.begin(), copy.end());\\n\\n          \\n          for(int i = 0;i < copy.size(); ++i) mpp[copy[i]] = i;\\n          \\n         \\n          for(int i = 0; i < v.size(); ++i)\\n          {\\n              if(mpp[v[i]->val] != i)\\n              {\\n                 swap(v[i], v[mpp[v[i]->val]]);\\n                 res++;\\n                 i--;\\n              }\\n          }\\n\\n      }\\n\\n      return res;  \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819119,
                "title": "c-easy-minimum-swap-to-sort-array",
                "content": "```\\nint minSwaps(vector<int>&nums)\\n\\t{\\n\\t    int n = nums.size();\\n\\t    pair<int,int> position[n];\\n\\t    \\n        // Store the Pair of (elements, indexes) in a list.\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        position[i].first = nums[i];\\n\\t        position[i].second = i;\\n\\t    }\\n\\t    \\n// Sort the array by array element values\\n\\t    sort(position, position+n);\\n\\t    \\n\\t    vector<int> visited(n, 0);\\n\\t    int nextIndex, result = 0;\\n\\t    \\n\\t    for (int j = 0; j < n; j++) {\\n// check if element is already present in correct position or already swapped\\n\\t        if (position[j].second == j || visited[j]) continue;\\n\\t        \\n\\t        int nextIndex, cycle_size = 0;\\n\\t        nextIndex = position[j].second;\\n\\n// find out the number of  node in this cycle\\t     \\n\\t        while (!visited[nextIndex]) {\\n\\t            visited[nextIndex] = 1;\\n\\t            \\n\\t            nextIndex = position[nextIndex].second; // move to next node\\n\\t            cycle_size++;\\n\\t        }\\n// last element will be moved to current  position by default\\n// so no of cycle-1 swap required to sort an array \\n\\t        result += cycle_size - 1;\\n\\t    }\\n\\t    \\n\\t    return result;\\n\\t}\\n    \\n    int minimumOperations(TreeNode* root) {\\n        int result = 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> temp;\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if (node->left) {\\n                    q.push(node->left);\\n                    temp.push_back(node->left->val);\\n                }\\n                if (node->right) {\\n                    q.push(node->right);\\n                    temp.push_back(node->right->val);\\n                }\\n            }\\n            \\n            // perform swapping to sort the vector using cycle sort \\n            result += minSwaps(temp);\\n            \\n        }\\n        \\n        return result;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(vector<int>&nums)\\n\\t{\\n\\t    int n = nums.size();\\n\\t    pair<int,int> position[n];\\n\\t    \\n        // Store the Pair of (elements, indexes) in a list.\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        position[i].first = nums[i];\\n\\t        position[i].second = i;\\n\\t    }\\n\\t    \\n// Sort the array by array element values\\n\\t    sort(position, position+n);\\n\\t    \\n\\t    vector<int> visited(n, 0);\\n\\t    int nextIndex, result = 0;\\n\\t    \\n\\t    for (int j = 0; j < n; j++) {\\n// check if element is already present in correct position or already swapped\\n\\t        if (position[j].second == j || visited[j]) continue;\\n\\t        \\n\\t        int nextIndex, cycle_size = 0;\\n\\t        nextIndex = position[j].second;\\n\\n// find out the number of  node in this cycle\\t     \\n\\t        while (!visited[nextIndex]) {\\n\\t            visited[nextIndex] = 1;\\n\\t            \\n\\t            nextIndex = position[nextIndex].second; // move to next node\\n\\t            cycle_size++;\\n\\t        }\\n// last element will be moved to current  position by default\\n// so no of cycle-1 swap required to sort an array \\n\\t        result += cycle_size - 1;\\n\\t    }\\n\\t    \\n\\t    return result;\\n\\t}\\n    \\n    int minimumOperations(TreeNode* root) {\\n        int result = 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> temp;\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if (node->left) {\\n                    q.push(node->left);\\n                    temp.push_back(node->left->val);\\n                }\\n                if (node->right) {\\n                    q.push(node->right);\\n                    temp.push_back(node->right->val);\\n                }\\n            }\\n            \\n            // perform swapping to sort the vector using cycle sort \\n            result += minSwaps(temp);\\n            \\n        }\\n        \\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816450,
                "title": "c-bfs-sorting-faster-easy-to-understand",
                "content": "* ***Using BFS && Sorting***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<int>& nums)\\n\\t{\\n\\t    int n = nums.size();\\n\\t    \\n\\t    // store the pair of {nums[i], i} in arr\\n\\t    \\n\\t    vector<pair<int, int>> arr(n);\\n\\t    \\n\\t    for(int i = 0; i < n; i++)\\n\\t    {\\n\\t        arr[i] = {nums[i], i};\\n\\t    }\\n\\t    \\n\\t    // sort the arr\\n\\t    \\n\\t    sort(arr.begin(), arr.end());\\n\\t    \\n\\t    int ans = 0;\\n\\t    \\n\\t    vector<bool> vis(n, false);\\n\\t    \\n\\t    for(int i = 0; i < n; i++)\\n\\t    {\\n\\t        // if curr number is at its correct position or number is already visted\\n\\t        \\n\\t        if(vis[i] || arr[i].second == i)\\n\\t        {\\n\\t            continue;\\n\\t        }\\n\\t        \\n\\t        // find the size of the cycle\\n\\t        \\n\\t        int j = i;\\n\\t        \\n\\t        int size = 0;\\n\\t        \\n\\t        while(vis[j] == false)\\n\\t        {\\n\\t            size++;\\n\\t            \\n\\t            vis[j] = true;\\n\\t            \\n\\t            j = arr[j].second;\\n\\t        }\\n\\t        \\n\\t        // update ans\\n\\t        \\n\\t        if(size > 1)\\n\\t        {\\n\\t            ans += size - 1;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return ans;\\n\\t}\\n    \\n    int minimumOperations(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        // apply bfs / level order traversal\\n        \\n        queue<TreeNode*> q;\\n        \\n        // push the root into queue\\n        \\n        q.push(root);\\n        \\n        int res = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            vector<int> arr;\\n            \\n            while(size--)\\n            {\\n                TreeNode* curr = q.front();\\n                \\n                q.pop();\\n                \\n                // push the element into arr\\n                \\n                arr.push_back(curr -> val);\\n                \\n                // push the left child into queue\\n                \\n                if(curr -> left)\\n                {\\n                    q.push(curr -> left);\\n                }\\n                \\n                // push the right child into queue\\n                \\n                if(curr -> right)\\n                {\\n                    q.push(curr -> right);\\n                }\\n            }\\n            \\n            // count the no. of swaps required to sort the elements of this level\\n            \\n            int count = minSwaps(arr);\\n            \\n            // update res\\n            \\n            res += count;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<int>& nums)\\n\\t{\\n\\t    int n = nums.size();\\n\\t    \\n\\t    // store the pair of {nums[i], i} in arr\\n\\t    \\n\\t    vector<pair<int, int>> arr(n);\\n\\t    \\n\\t    for(int i = 0; i < n; i++)\\n\\t    {\\n\\t        arr[i] = {nums[i], i};\\n\\t    }\\n\\t    \\n\\t    // sort the arr\\n\\t    \\n\\t    sort(arr.begin(), arr.end());\\n\\t    \\n\\t    int ans = 0;\\n\\t    \\n\\t    vector<bool> vis(n, false);\\n\\t    \\n\\t    for(int i = 0; i < n; i++)\\n\\t    {\\n\\t        // if curr number is at its correct position or number is already visted\\n\\t        \\n\\t        if(vis[i] || arr[i].second == i)\\n\\t        {\\n\\t            continue;\\n\\t        }\\n\\t        \\n\\t        // find the size of the cycle\\n\\t        \\n\\t        int j = i;\\n\\t        \\n\\t        int size = 0;\\n\\t        \\n\\t        while(vis[j] == false)\\n\\t        {\\n\\t            size++;\\n\\t            \\n\\t            vis[j] = true;\\n\\t            \\n\\t            j = arr[j].second;\\n\\t        }\\n\\t        \\n\\t        // update ans\\n\\t        \\n\\t        if(size > 1)\\n\\t        {\\n\\t            ans += size - 1;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return ans;\\n\\t}\\n    \\n    int minimumOperations(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        // apply bfs / level order traversal\\n        \\n        queue<TreeNode*> q;\\n        \\n        // push the root into queue\\n        \\n        q.push(root);\\n        \\n        int res = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            vector<int> arr;\\n            \\n            while(size--)\\n            {\\n                TreeNode* curr = q.front();\\n                \\n                q.pop();\\n                \\n                // push the element into arr\\n                \\n                arr.push_back(curr -> val);\\n                \\n                // push the left child into queue\\n                \\n                if(curr -> left)\\n                {\\n                    q.push(curr -> left);\\n                }\\n                \\n                // push the right child into queue\\n                \\n                if(curr -> right)\\n                {\\n                    q.push(curr -> right);\\n                }\\n            }\\n            \\n            // count the no. of swaps required to sort the elements of this level\\n            \\n            int count = minSwaps(arr);\\n            \\n            // update res\\n            \\n            res += count;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812866,
                "title": "bfs-sorting-java-solution",
                "content": "# Intuition\\nSorting array and finding number of swaps required to reach original position.\\n\\n# Approach\\nTraverse through the tree in level order(BFS) and store all elements of the level in an array and find minimum number or swaps required to sort by storing the original poritions of the elements and sort the pairs and check how many have changed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    \\n\\tstatic class Pair {\\n\\t\\tint v;\\n\\t\\tint id;\\n\\t\\tPair(int v, int id){\\n\\t\\t\\tthis.v = v;\\n\\t\\t\\tthis.id = id;\\n\\t\\t}\\n\\t}\\n    \\n    public int minimumOperations(TreeNode root) {\\n        int ans=0;\\n        Queue<TreeNode> bfs=new LinkedList<>();\\n        List<Integer> tmp=new LinkedList<>();\\n        if(root==null) return 0;\\n        bfs.add(root);\\n        bfs.add(null);\\n        while(!bfs.isEmpty()){\\n            TreeNode x=bfs.remove();\\n            if(x==null){\\n                bfs.add(null);\\n                ans+=minOperations(tmp);\\n                if(tmp.size()==0) return ans;\\n                tmp=new LinkedList<>();\\n            } else {\\n                if(x.left!=null) bfs.add(x.left);\\n                if(x.right!=null) bfs.add(x.right);\\n                tmp.add(x.val);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static int minOperations(List<Integer> arr){ \\n        int n=arr.size();\\n        if(n==0) return 0;\\n\\t\\tPair[] s=new Pair[n];\\n\\t\\tfor(int i=0;i<n;i++) s[i]=new Pair(arr.get(i),i);\\n\\t\\t\\n\\t\\tArrays.sort(s,(a,b)->a.v-b.v);\\n\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(i==s[i].id) continue;\\n            else{\\n                int x=s[i].id;\\n                c++;\\n                Pair tmp=s[i];\\n                s[i]=s[x];\\n                s[x]=tmp;\\n                i--;\\n            }\\n        }\\n\\t\\treturn c;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    \\n\\tstatic class Pair {\\n\\t\\tint v;\\n\\t\\tint id;\\n\\t\\tPair(int v, int id){\\n\\t\\t\\tthis.v = v;\\n\\t\\t\\tthis.id = id;\\n\\t\\t}\\n\\t}\\n    \\n    public int minimumOperations(TreeNode root) {\\n        int ans=0;\\n        Queue<TreeNode> bfs=new LinkedList<>();\\n        List<Integer> tmp=new LinkedList<>();\\n        if(root==null) return 0;\\n        bfs.add(root);\\n        bfs.add(null);\\n        while(!bfs.isEmpty()){\\n            TreeNode x=bfs.remove();\\n            if(x==null){\\n                bfs.add(null);\\n                ans+=minOperations(tmp);\\n                if(tmp.size()==0) return ans;\\n                tmp=new LinkedList<>();\\n            } else {\\n                if(x.left!=null) bfs.add(x.left);\\n                if(x.right!=null) bfs.add(x.right);\\n                tmp.add(x.val);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static int minOperations(List<Integer> arr){ \\n        int n=arr.size();\\n        if(n==0) return 0;\\n\\t\\tPair[] s=new Pair[n];\\n\\t\\tfor(int i=0;i<n;i++) s[i]=new Pair(arr.get(i),i);\\n\\t\\t\\n\\t\\tArrays.sort(s,(a,b)->a.v-b.v);\\n\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(i==s[i].id) continue;\\n            else{\\n                int x=s[i].id;\\n                c++;\\n                Pair tmp=s[i];\\n                s[i]=s[x];\\n                s[x]=tmp;\\n                i--;\\n            }\\n        }\\n\\t\\treturn c;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811390,
                "title": "beginner-friendly-simple-bfs-function-c",
                "content": "# Code\\n```q\\nclass Solution {\\npublic:\\n    int fun(vector<int> &v)\\n    {\\n        vector<pair<int,int>> vp ;\\n        int n=v.size() ;\\n        for(int i=0 ; i<n ; i++)  vp.push_back({v[i] , i}) ;\\n        sort(vp.begin() , vp.end()) ;\\n        int ct=0 ;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(i != vp[i].second)\\n            {\\n                ct++ ;\\n                swap( vp[vp[i].second] , vp[i] ) ;\\n                i-- ;\\n            }\\n        }\\n        return ct ;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0 ;\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        q.push(NULL) ;\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size() ;\\n            \\n            while(sz--)\\n            {\\n                TreeNode *cur = q.front() ;\\n                q.pop() ;\\n                if(cur == NULL)\\n                {\\n                    vector<int> v ;\\n                    queue<TreeNode*> temp ;\\n                    while(!q.empty())\\n                    {\\n                        temp.push(q.front()) ;\\n                        v.push_back(q.front()->val) ;\\n                        q.pop() ;\\n                    }\\n                    ans += fun(v) ;\\n                    q=temp ;\\n                    if(q.size() > 0) q.push(NULL) ;\\n                }\\n                else\\n                {\\n                    if(cur->left)  q.push(cur->left) ;\\n                    if(cur->right)  q.push(cur->right) ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```q\\nclass Solution {\\npublic:\\n    int fun(vector<int> &v)\\n    {\\n        vector<pair<int,int>> vp ;\\n        int n=v.size() ;\\n        for(int i=0 ; i<n ; i++)  vp.push_back({v[i] , i}) ;\\n        sort(vp.begin() , vp.end()) ;\\n        int ct=0 ;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(i != vp[i].second)\\n            {\\n                ct++ ;\\n                swap( vp[vp[i].second] , vp[i] ) ;\\n                i-- ;\\n            }\\n        }\\n        return ct ;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0 ;\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        q.push(NULL) ;\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size() ;\\n            \\n            while(sz--)\\n            {\\n                TreeNode *cur = q.front() ;\\n                q.pop() ;\\n                if(cur == NULL)\\n                {\\n                    vector<int> v ;\\n                    queue<TreeNode*> temp ;\\n                    while(!q.empty())\\n                    {\\n                        temp.push(q.front()) ;\\n                        v.push_back(q.front()->val) ;\\n                        q.pop() ;\\n                    }\\n                    ans += fun(v) ;\\n                    q=temp ;\\n                    if(q.size() > 0) q.push(NULL) ;\\n                }\\n                else\\n                {\\n                    if(cur->left)  q.push(cur->left) ;\\n                    if(cur->right)  q.push(cur->right) ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810338,
                "title": "easiest-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int> nums)\\n\\t{\\n\\t    int size=nums.size(),count=0;\\n\\t    vector<pair<int,int>> vec;\\n\\t    for(int i=0;i<size;i++)\\n\\t        vec.push_back({nums[i],i});\\n\\t    sort(vec.begin(),vec.end());\\n\\t    for(int i=0;i<size;i++){\\n\\t        while(i!=vec[i].second){\\n\\t            swap(vec[i],vec[vec[i].second]);\\n\\t            count++;\\n\\t        }\\n\\t    }\\n\\t    return count;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n        int count=0;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        while(que.size()){\\n            int size=que.size();\\n            vector<int> vec;\\n            for(int i=0;i<size;i++){\\n                TreeNode* node=que.front();\\n                que.pop();\\n                vec.push_back(node->val);\\n                if(node->left)\\n                    que.push(node->left);\\n                if(node->right)\\n                    que.push(node->right);\\n            }\\n            count+=minSwaps(vec); \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int> nums)\\n\\t{\\n\\t    int size=nums.size(),count=0;\\n\\t    vector<pair<int,int>> vec;\\n\\t    for(int i=0;i<size;i++)\\n\\t        vec.push_back({nums[i],i});\\n\\t    sort(vec.begin(),vec.end());\\n\\t    for(int i=0;i<size;i++){\\n\\t        while(i!=vec[i].second){\\n\\t            swap(vec[i],vec[vec[i].second]);\\n\\t            count++;\\n\\t        }\\n\\t    }\\n\\t    return count;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n        int count=0;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        while(que.size()){\\n            int size=que.size();\\n            vector<int> vec;\\n            for(int i=0;i<size;i++){\\n                TreeNode* node=que.front();\\n                que.pop();\\n                vec.push_back(node->val);\\n                if(node->left)\\n                    que.push(node->left);\\n                if(node->right)\\n                    que.push(node->right);\\n            }\\n            count+=minSwaps(vec); \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810243,
                "title": "c-bfs-cycle-sort-explained",
                "content": "# Intuition\\nTake out elems from every level in a vector and apply cyclic sort in it. Simple !!\\n\\n# Approach\\nI\\'m assuming that you know bfs pattern.\\nSo, after storing all the elems in a vector, sort it and store it in another vector (for comparison to know the right place they should be in). \\nNow I\\'m using a unordered map to store the right indices using sorted array.\\nAt last loop through temp array and apply cycle sort concept.\\n->Swap ith elem till the right element gets the ith position.\\n->And if the right element is at ith position increment i.\\n\\nAnd That\\'s IT!!\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n-> O(N)+ O(N) + O(N) , for map and vector and queue...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwap(vector<int>& temp, vector<int>& sorted)\\n    {\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<sorted.size();i++) \\n            m[sorted[i]]=i;\\n        int i=0;\\n        while(i<temp.size())\\n        {\\n            if(i!=m[temp[i]])\\n            {\\n                ans++;\\n                swap(temp[i],temp[m[temp[i]]]);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        //using bfs\\n        if(!root) return 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            vector<int>temp,sorted;\\n            while(sz--)\\n            {\\n                TreeNode* node=q.front(); q.pop();\\n                temp.push_back(node->val);\\n                if(node->left) {q.push(node->left); }\\n                if(node->right){ q.push(node->right);}\\n            }\\n\\n            sorted=temp;\\n            sort(sorted.begin(),sorted.end());\\n            ans+=minSwap(temp,sorted);   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwap(vector<int>& temp, vector<int>& sorted)\\n    {\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<sorted.size();i++) \\n            m[sorted[i]]=i;\\n        int i=0;\\n        while(i<temp.size())\\n        {\\n            if(i!=m[temp[i]])\\n            {\\n                ans++;\\n                swap(temp[i],temp[m[temp[i]]]);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        //using bfs\\n        if(!root) return 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            vector<int>temp,sorted;\\n            while(sz--)\\n            {\\n                TreeNode* node=q.front(); q.pop();\\n                temp.push_back(node->val);\\n                if(node->left) {q.push(node->left); }\\n                if(node->right){ q.push(node->right);}\\n            }\\n\\n            sorted=temp;\\n            sort(sorted.begin(),sorted.end());\\n            ans+=minSwap(temp,sorted);   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809662,
                "title": "javascript-bfs-greedy-690ms",
                "content": "```\\nconst minimumOperations = (root) => {\\n    let d = levelOrder_BFS(root), res = 0;\\n    for (const a of d) res += minSwapSortArray(a);\\n    return res;\\n};\\n\\nconst minSwapSortArray = (a) => {\\n    let n = a.length, b = [...a].sort((x, y) => x - y), m = new Map(), res = 0;\\n    for (let i = 0; i < n; i++) m.set(a[i], i);\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] != b[i]) {\\n            res++;\\n            let j = m.get(b[i]);\\n            m.set(a[i], j);\\n            m.set(b[i], i);\\n            [a[i], a[j]] = [a[j], a[i]];\\n        }\\n    }\\n    return res;\\n};\\n\\nconst levelOrder_BFS = (root) => {\\n    let data = [];\\n    getAllLevels(root, 0, data);\\n    return data;\\n};\\n\\nconst getAllLevels = (root, level, data) => {\\n    if (!root) return;\\n    if (level >= data.length) data.push([]);\\n    data[level].push(root.val);\\n    getAllLevels(root.left, level + 1, data);\\n    getAllLevels(root.right, level + 1, data);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst minimumOperations = (root) => {\\n    let d = levelOrder_BFS(root), res = 0;\\n    for (const a of d) res += minSwapSortArray(a);\\n    return res;\\n};\\n\\nconst minSwapSortArray = (a) => {\\n    let n = a.length, b = [...a].sort((x, y) => x - y), m = new Map(), res = 0;\\n    for (let i = 0; i < n; i++) m.set(a[i], i);\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] != b[i]) {\\n            res++;\\n            let j = m.get(b[i]);\\n            m.set(a[i], j);\\n            m.set(b[i], i);\\n            [a[i], a[j]] = [a[j], a[i]];\\n        }\\n    }\\n    return res;\\n};\\n\\nconst levelOrder_BFS = (root) => {\\n    let data = [];\\n    getAllLevels(root, 0, data);\\n    return data;\\n};\\n\\nconst getAllLevels = (root, level, data) => {\\n    if (!root) return;\\n    if (level >= data.length) data.push([]);\\n    data[level].push(root.val);\\n    getAllLevels(root.left, level + 1, data);\\n    getAllLevels(root.right, level + 1, data);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809585,
                "title": "java-bfs",
                "content": "# 1.BFS\\n```\\n\\t//1.BFS\\n    //Runtime: 58 ms, faster than 75.00% of Java online submissions for Minimum Number of Operations to Sort a Binary Tree by Level.\\n    //Memory Usage: 59 MB, less than 50.00% of Java online submissions for Minimum Number of Operations to Sort a Binary Tree by Level.\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        int count = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int len = queue.size();\\n            int[] data = new int[len];\\n            int[] dataOrderd = new int[len];\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int idx = 0;\\n            for (int i = 0; i < len; i++) {\\n                TreeNode node = queue.poll();\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n\\n                dataOrderd[idx] = node.val;\\n                data[idx] = node.val;\\n                map.put(node.val, idx);\\n                idx++;\\n            }\\n\\n            Arrays.sort(dataOrderd);\\n            for (int i = 0; i < len; i++) {\\n                if (data[i] == dataOrderd[i]) continue;\\n\\n                int j = map.get(dataOrderd[i]);\\n                int tmp = data[i];\\n                data[i] = data[j];\\n                data[j] = tmp;\\n                map.put(tmp, j);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\t//1.BFS\\n    //Runtime: 58 ms, faster than 75.00% of Java online submissions for Minimum Number of Operations to Sort a Binary Tree by Level.\\n    //Memory Usage: 59 MB, less than 50.00% of Java online submissions for Minimum Number of Operations to Sort a Binary Tree by Level.\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        int count = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int len = queue.size();\\n            int[] data = new int[len];\\n            int[] dataOrderd = new int[len];\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int idx = 0;\\n            for (int i = 0; i < len; i++) {\\n                TreeNode node = queue.poll();\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n\\n                dataOrderd[idx] = node.val;\\n                data[idx] = node.val;\\n                map.put(node.val, idx);\\n                idx++;\\n            }\\n\\n            Arrays.sort(dataOrderd);\\n            for (int i = 0; i < len; i++) {\\n                if (data[i] == dataOrderd[i]) continue;\\n\\n                int j = map.get(dataOrderd[i]);\\n                int tmp = data[i];\\n                data[i] = data[j];\\n                data[j] = tmp;\\n                map.put(tmp, j);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809435,
                "title": "simple-solution-level-order-traversal-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        vector<vector<int>> v;\\n        bool f=0;\\n        while(!q.empty()){\\n            TreeNode* x = q.front();q.pop();\\n            if(x==nullptr){\\n                if(!q.empty()) q.push(nullptr);\\n                f=0;\\n                continue;\\n            }\\n            if(x->left) q.push(x->left);\\n            if(x->right) q.push(x->right);\\n            if(!f){\\n                v.push_back({x->val});\\n            }else{\\n                v.back().push_back(x->val);\\n            }\\n            f=1;\\n        }\\n        int ans=0;\\n        for(vector<int> n:v){\\n            ans+=fun(n);\\n        }\\n        \\n        return ans;\\n    }\\n    int fun(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++){\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int s=0;\\n\\t    for(int i=0;i<n;i++){\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            s++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return s;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        vector<vector<int>> v;\\n        bool f=0;\\n        while(!q.empty()){\\n            TreeNode* x = q.front();q.pop();\\n            if(x==nullptr){\\n                if(!q.empty()) q.push(nullptr);\\n                f=0;\\n                continue;\\n            }\\n            if(x->left) q.push(x->left);\\n            if(x->right) q.push(x->right);\\n            if(!f){\\n                v.push_back({x->val});\\n            }else{\\n                v.back().push_back(x->val);\\n            }\\n            f=1;\\n        }\\n        int ans=0;\\n        for(vector<int> n:v){\\n            ans+=fun(n);\\n        }\\n        \\n        return ans;\\n    }\\n    int fun(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++){\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int s=0;\\n\\t    for(int i=0;i<n;i++){\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            s++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809408,
                "title": "easiest-c-solution-level-order-traversal-bfs",
                "content": "Here is my Solution using C++ :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t\\n        while (!q.empty()){ \\n            vector<int> lvl,srtlvl;\\n            int size= q.size();\\n            for (int i=0; i<size; i++){\\n                TreeNode* node= q.front();\\n                lvl.push_back(node->val);\\n                srtlvl.push_back(node->val);\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n                q.pop();\\n            }\\n\\t\\t\\t\\n            sort(srtlvl.begin(),srtlvl.end());\\n            for (int i=0; i<lvl.size(); i++){\\n                if (srtlvl[i]!=lvl[i]){\\n                    swap(lvl[i],lvl[find(lvl.begin(),lvl.end(),srtlvl[i])-lvl.begin()]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t\\n        while (!q.empty()){ \\n            vector<int> lvl,srtlvl;\\n            int size= q.size();\\n            for (int i=0; i<size; i++){\\n                TreeNode* node= q.front();\\n                lvl.push_back(node->val);\\n                srtlvl.push_back(node->val);\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n                q.pop();\\n            }\\n\\t\\t\\t\\n            sort(srtlvl.begin(),srtlvl.end());\\n            for (int i=0; i<lvl.size(); i++){\\n                if (srtlvl[i]!=lvl[i]){\\n                    swap(lvl[i],lvl[find(lvl.begin(),lvl.end(),srtlvl[i])-lvl.begin()]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809021,
                "title": "python-explained-o-nlogn",
                "content": "* We will find all the nodes at current level and then count minimum number of swaps required to make them sorted.\\n\\n* How to calculate minimum swaps required to make array sorted :\\n\\nmake a new array (called temp), which is the sorted form of the input array. We know that we need to transform the input array to the new array (temp) in the minimum number of swaps. Make a map that stores the elements and their corresponding index, of the input array.\\n\\n* So at each i starting from 0 to N in the given array, where N is the size of the array:\\n\\n1. If i is not in its correct position according to the sorted array, then\\n2. We will fill this position with the correct element from the hashmap we built earlier. We know the correct element which should come here is temp[i], so we look up the index of this element from the hashmap. \\n3. After swapping the required elements, we update the content of the hashmap accordingly, as temp[i] to the ith position, and arr[i] to where temp[i] was earlier.\\n\\n**complexity of above approach :**\\n* Time Complexity: O(n Log n) \\n* Auxiliary Space: O(n)\\n----------------------\\n**Level order traversal :**\\n* Time Complexity: O(n) \\n* Auxiliary Space: O(n)\\n------------------------\\n**Overall complexity :**\\n* Time Complexity: O(n log n) \\n* Auxiliary Space: O(n)\\n---------------\\n**Code**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        def minSwap(arr, n): #function to count minimum number of swaps to make array sorted\\n            ans = 0\\n            temp = arr.copy()\\n            h = {}\\n            temp.sort()\\n\\n            for i in range(n):\\n                h[arr[i]] = i\\n            init = 0\\n\\n            for i in range(n):\\n                if (arr[i] != temp[i]):\\n                    ans += 1\\n                    init = arr[i]\\n                    arr[i], arr[h[temp[i]]] = arr[h[temp[i]]], arr[i]\\n                    h[init] = h[temp[i]]\\n                    h[temp[i]] = i\\n\\n            return ans\\n        \\n        def levelorder(root, ans):\\n            if root:\\n                q = []\\n                q.append(root)\\n                \\n                while q:\\n                    sublist = [] #sublist will store all the nodes at current level in sequense.\\n                    q_len = len(q)\\n                    for node in q:\\n                        sublist.append(node.val)\\n                    ans += minSwap(sublist, len(sublist)) #count swaps required to sort current level\\n                    \\n                    while q_len > 0:\\n                        node = q.pop(0)\\n                        if node.left:\\n                            q.append(node.left)\\n                        if node.right:\\n                            q.append(node.right)\\n                        q_len -= 1\\n            return ans\\n        \\n        return levelorder(root, 0)\\n```\\n-------------------\\n\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        def minSwap(arr, n): #function to count minimum number of swaps to make array sorted\\n            ans = 0\\n            temp = arr.copy()\\n            h = {}\\n            temp.sort()\\n\\n            for i in range(n):\\n                h[arr[i]] = i\\n            init = 0\\n\\n            for i in range(n):\\n                if (arr[i] != temp[i]):\\n                    ans += 1\\n                    init = arr[i]\\n                    arr[i], arr[h[temp[i]]] = arr[h[temp[i]]], arr[i]\\n                    h[init] = h[temp[i]]\\n                    h[temp[i]] = i\\n\\n            return ans\\n        \\n        def levelorder(root, ans):\\n            if root:\\n                q = []\\n                q.append(root)\\n                \\n                while q:\\n                    sublist = [] #sublist will store all the nodes at current level in sequense.\\n                    q_len = len(q)\\n                    for node in q:\\n                        sublist.append(node.val)\\n                    ans += minSwap(sublist, len(sublist)) #count swaps required to sort current level\\n                    \\n                    while q_len > 0:\\n                        node = q.pop(0)\\n                        if node.left:\\n                            q.append(node.left)\\n                        if node.right:\\n                            q.append(node.right)\\n                        q_len -= 1\\n            return ans\\n        \\n        return levelorder(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809018,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int minSwaps(vector<int> &arr, int n){\\n        pair<int, int> arrPos[n];\\n        for (int i = 0; i < n; i++){\\n            arrPos[i].first = arr[i];\\n            arrPos[i].second = i;\\n        }\\n        sort(arrPos, arrPos + n);\\n        vector<bool> vis(n, false);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] || arrPos[i].second == i)continue;\\n            int cycle_size = 0,j = i;\\n            while(!vis[j]){\\n                vis[j] = 1;\\n                j = arrPos[j].second;\\n                cycle_size++;\\n            }\\n            if (cycle_size > 0)\\n                ans += (cycle_size - 1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ct=0;\\n        vector<vector<int>> lvl;\\n        vector<int> out;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(node == NULL){\\n                lvl.push_back(out);\\n                out.clear();\\n                if(!q.empty()) q.push(NULL);\\n            }\\n            else{\\n                out.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        for(auto _v: lvl){\\n            if(_v.empty()) continue;\\n            ct += minSwaps(_v,_v.size());\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int minSwaps(vector<int> &arr, int n){\\n        pair<int, int> arrPos[n];\\n        for (int i = 0; i < n; i++){\\n            arrPos[i].first = arr[i];\\n            arrPos[i].second = i;\\n        }\\n        sort(arrPos, arrPos + n);\\n        vector<bool> vis(n, false);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] || arrPos[i].second == i)continue;\\n            int cycle_size = 0,j = i;\\n            while(!vis[j]){\\n                vis[j] = 1;\\n                j = arrPos[j].second;\\n                cycle_size++;\\n            }\\n            if (cycle_size > 0)\\n                ans += (cycle_size - 1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ct=0;\\n        vector<vector<int>> lvl;\\n        vector<int> out;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(node == NULL){\\n                lvl.push_back(out);\\n                out.clear();\\n                if(!q.empty()) q.push(NULL);\\n            }\\n            else{\\n                out.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        for(auto _v: lvl){\\n            if(_v.empty()) continue;\\n            ct += minSwaps(_v,_v.size());\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808922,
                "title": "c-level-order-traversal-with-minimum-swap",
                "content": "class Solution {\\npublic: \\nint miniswap(vector<int>arr,int N)\\n{\\n  int ans = 0;\\n  vector<int>temp = arr;\\n  map <int, int> h;\\n \\n  sort(temp.begin(), temp.end());\\n  for (int i = 0; i < N; i++)\\n  {\\n    h[arr[i]] = i;\\n  }\\n  for (int i = 0; i < N; i++)\\n  {\\n    if (arr[i] != temp[i])\\n    {\\n      ans++;\\n      int init = arr[i];\\n      swap(arr[i], arr[h[temp[i]]]);\\n      h[init] = h[temp[i]];\\n      h[temp[i]] = i;\\n    }\\n  }\\n  return ans;\\n}\\n    \\n    int minimumOperations(TreeNode* root) {\\n        \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int ans=0;\\n        while(!(q.empty())) {\\n            int si = q.size();\\n            vector<int>l;\\n            vector<int>s;\\n            for(int j=0;j<si;j++) {\\n                 TreeNode* node = q.front();\\n                q.pop();\\n                if(node != NULL) q.push(node->left);\\n                if(node != NULL) q.push(node->right);\\n                if(node != NULL)l.push_back(node->val);\\n \\n            }\\n            ans += miniswap(l , l.size());\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic: \\nint miniswap(vector<int>arr,int N)\\n{\\n  int ans = 0;\\n  vector<int>temp = arr;\\n  map <int, int> h;\\n \\n  sort(temp.begin(), temp.end());\\n  for (int i = 0; i < N; i++)\\n  {\\n    h[arr[i]] = i;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2808911,
                "title": "map-2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level-java",
                "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        int s=0;\\n        while(!q.isEmpty())\\n        {\\n            int m=0,l=q.size();\\n            List<Integer> l1=new ArrayList<>();\\n            for(int i=0;i<l;i++)\\n            {\\n                if(q.peek().left!=null)\\n                {\\n                    q.add(q.peek().left);\\n                }\\n                if(q.peek().right!=null)\\n                {\\n                    q.add(q.peek().right);\\n                }\\n                int f=q.poll().val;\\n                l1.add(f);\\n            }\\n            s+=task(l1);\\n        }\\n        return s;\\n    }\\n    public int task(List<Integer> nm)\\n    {\\n        Map<Integer,Integer> mp=new HashMap<>();\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            mp.put(nm.get(i),i);\\n        }\\n        Collections.sort(nm);\\n        boolean k[]=new boolean[nm.size()];\\n        int s=0;\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            if(k[i] || mp.get(nm.get(i))==i)\\n            {\\n                continue;\\n            }\\n            int j=i,m=0;\\n            while(!k[j])\\n            {\\n                k[j]=true;\\n                j=mp.get(nm.get(j));\\n                m++;\\n            }\\n            if(m>0)\\n            {\\n                s+=m-1;\\n            }\\n        }\\n        return s;    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        int s=0;\\n        while(!q.isEmpty())\\n        {\\n            int m=0,l=q.size();\\n            List<Integer> l1=new ArrayList<>();\\n            for(int i=0;i<l;i++)\\n            {\\n                if(q.peek().left!=null)\\n                {\\n                    q.add(q.peek().left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2808890,
                "title": "self-understandable-problem-breakdown",
                "content": "**Problem can be broken into two parts:**\\n1. minimum swaps required to sort array\\n2. level order traversal\\n\\n```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        # minimum swaps required to swap any array\\n        def minSwaps(arr):\\n            n = len(arr)\\n            arrpos = [*enumerate(arr)]\\n            arrpos.sort(key = lambda it : it[1])\\n            vis = {k : False for k in range(n)}\\n\\n            ans = 0\\n            for i in range(n):\\n                if vis[i] or arrpos[i][0] == i:\\n                    continue\\n                cycle_size = 0\\n                j = i\\n\\n                while not vis[j]:\\n                    vis[j] = True\\n                    j = arrpos[j][0]\\n                    cycle_size += 1\\n                if cycle_size > 0:\\n                    ans += (cycle_size - 1)\\n            return ans\\n        \\n        \\n        # level order traversal of tree (level by level)\\n        queue=[root]\\n        ans=0\\n        while queue:\\n            lst=[]\\n            for i in range(len(queue)):\\n                temp=queue.pop(0)\\n                lst.append(temp.val)\\n                if temp.left:\\n                    queue.append(temp.left)\\n                if temp.right:\\n                    queue.append(temp.right)\\n            if len(lst)>1:\\n                ans+=minSwaps(lst)         # add minimum swapping required for all the array\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        # minimum swaps required to swap any array\\n        def minSwaps(arr):\\n            n = len(arr)\\n            arrpos = [*enumerate(arr)]\\n            arrpos.sort(key = lambda it : it[1])\\n            vis = {k : False for k in range(n)}\\n\\n            ans = 0\\n            for i in range(n):\\n                if vis[i] or arrpos[i][0] == i:\\n                    continue\\n                cycle_size = 0\\n                j = i\\n\\n                while not vis[j]:\\n                    vis[j] = True\\n                    j = arrpos[j][0]\\n                    cycle_size += 1\\n                if cycle_size > 0:\\n                    ans += (cycle_size - 1)\\n            return ans\\n        \\n        \\n        # level order traversal of tree (level by level)\\n        queue=[root]\\n        ans=0\\n        while queue:\\n            lst=[]\\n            for i in range(len(queue)):\\n                temp=queue.pop(0)\\n                lst.append(temp.val)\\n                if temp.left:\\n                    queue.append(temp.left)\\n                if temp.right:\\n                    queue.append(temp.right)\\n            if len(lst)>1:\\n                ans+=minSwaps(lst)         # add minimum swapping required for all the array\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808887,
                "title": "c-bfs-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> bfs;\\n        int ans=0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> temp(sz,0);\\n            for(int i=0;i<sz;i++){\\n                if(q.front()->left) q.push(q.front()->left);\\n                if(q.front()->right) q.push(q.front()->right);\\n                temp[i] = q.front()->val;\\n                q.pop();\\n            }\\n            bfs.push_back(temp);\\n        }\\n        for(int i=1;i<bfs.size();i++){\\n            map<int,int> mp;\\n            vector<int> temp = bfs[i];\\n            for(int j=0;j<temp.size();j++){\\n                mp[temp[j]]=j;\\n            }\\n            sort(temp.begin(),temp.end());\\n            vector<bool> vis(temp.size(),false);\\n            int ans1=0;\\n            for(int j=0;j<temp.size();j++){\\n                if(vis[j] || mp[temp[j]] == j) continue;\\n                int x=j,cz=0;\\n                while(!vis[x]){\\n                    vis[x] = true;\\n                    x = mp[temp[x]];\\n                    cz++;\\n                }\\n                if(cz > 0){\\n                    ans1 += (cz-1);\\n                }\\n            }\\n            ans += ans1;\\n            // cout<<ans1<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> bfs;\\n        int ans=0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> temp(sz,0);\\n            for(int i=0;i<sz;i++){\\n                if(q.front()->left) q.push(q.front()->left);\\n                if(q.front()->right) q.push(q.front()->right);\\n                temp[i] = q.front()->val;\\n                q.pop();\\n            }\\n            bfs.push_back(temp);\\n        }\\n        for(int i=1;i<bfs.size();i++){\\n            map<int,int> mp;\\n            vector<int> temp = bfs[i];\\n            for(int j=0;j<temp.size();j++){\\n                mp[temp[j]]=j;\\n            }\\n            sort(temp.begin(),temp.end());\\n            vector<bool> vis(temp.size(),false);\\n            int ans1=0;\\n            for(int j=0;j<temp.size();j++){\\n                if(vis[j] || mp[temp[j]] == j) continue;\\n                int x=j,cz=0;\\n                while(!vis[x]){\\n                    vis[x] = true;\\n                    x = mp[temp[x]];\\n                    cz++;\\n                }\\n                if(cz > 0){\\n                    ans1 += (cz-1);\\n                }\\n            }\\n            ans += ans1;\\n            // cout<<ans1<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2808865,
                "title": "javascript-queue-sort-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minimumOperations = function(root) {\\n    let ans = 0;\\n    let queue = [root];\\n    \\n    while (queue.length) {\\n        const next = [];\\n        const cur = [];\\n        \\n        for (let i = 0; i < queue.length; i++) {\\n            const node = queue[i];\\n            cur.push(node.val);\\n            \\n            if (node.left) {\\n                next.push(node.left);\\n            }\\n            \\n            if (node.right) {\\n                next.push(node.right);\\n            }\\n        }\\n        \\n        const asc = [...cur].sort((a, b) => a - b);\\n        \\n        const map = {};\\n        for (let i = 0; i < asc.length; i++) {\\n            map[asc[i]] = i;\\n        }\\n        \\n        let i = 0;\\n        while (i < cur.length) {\\n            if (map[cur[i]] !== i) {\\n                ans++;\\n                const j = map[cur[i]];\\n                const temp = cur[i];\\n                cur[i] = cur[j];\\n                cur[j] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minimumOperations = function(root) {\\n    let ans = 0;\\n    let queue = [root];\\n    \\n    while (queue.length) {\\n        const next = [];\\n        const cur = [];\\n        \\n        for (let i = 0; i < queue.length; i++) {\\n            const node = queue[i];\\n            cur.push(node.val);\\n            \\n            if (node.left) {\\n                next.push(node.left);\\n            }\\n            \\n            if (node.right) {\\n                next.push(node.right);\\n            }\\n        }\\n        \\n        const asc = [...cur].sort((a, b) => a - b);\\n        \\n        const map = {};\\n        for (let i = 0; i < asc.length; i++) {\\n            map[asc[i]] = i;\\n        }\\n        \\n        let i = 0;\\n        while (i < cur.length) {\\n            if (map[cur[i]] !== i) {\\n                ans++;\\n                const j = map[cur[i]];\\n                const temp = cur[i];\\n                cur[i] = cur[j];\\n                cur[j] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808859,
                "title": "c-bfs-swap-sort-clean-code",
                "content": "**Video Solution :**\\n\\nhttps://www.youtube.com/watch?v=l1cE9IRMkA4&list=PLsgq4reKtSzzoOhBANbmUi4Ay16vg1fHC&index=1\\n\\n\\n**Code :**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>arr, int n)\\n    {\\n    // Create an array of\\n    // pairs where first\\n    // element is array element\\n    // and second element\\n    // is position of first element\\n        vector<pair<int,int>>ve;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            ve.push_back({arr[i],i});\\n        }\\n        sort(ve.begin(),ve.end());\\n        \\n        int cnt=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(ve[i].second==i) continue;\\n            else\\n            {\\n                cnt++;\\n                swap(ve[i],ve[ve[i].second]);\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        \\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            vector<int>tempp;\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                tempp.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n            int kk=tempp.size();\\n            ans+=minSwaps(tempp,kk);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>arr, int n)\\n    {\\n    // Create an array of\\n    // pairs where first\\n    // element is array element\\n    // and second element\\n    // is position of first element\\n        vector<pair<int,int>>ve;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            ve.push_back({arr[i],i});\\n        }\\n        sort(ve.begin(),ve.end());\\n        \\n        int cnt=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(ve[i].second==i) continue;\\n            else\\n            {\\n                cnt++;\\n                swap(ve[i],ve[ve[i].second]);\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        \\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            vector<int>tempp;\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                tempp.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n            int kk=tempp.size();\\n            ans+=minSwaps(tempp,kk);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808853,
                "title": "bfs-min-numbers-of-swaps-swap-cycles",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr)\\n{\\n    int n = arr.size();\\n    pair<int, int> arrPos[n];\\n    for (int i = 0; i < n; i++)   {\\n        arrPos[i].first = arr[i];\\n        arrPos[i].second = i;\\n    }\\n    sort(arrPos, arrPos + n);\\n\\n    vector<bool> vis(n, false);\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (vis[i] || arrPos[i].second == i)\\n            continue;\\n        int cycle_size = 0;\\n        int j = i;\\n        while (!vis[j])\\n        {\\n            vis[j] = 1;\\n            j = arrPos[j].second;\\n            cycle_size++;\\n        }\\n        if (cycle_size > 0) ans += (cycle_size - 1);\\n        \\n    }\\n   \\n    return ans;\\n}\\n    int minimumOperations(TreeNode* root) {\\n        int res = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> temp;\\n            for(int i= 0;i<sz;i++){\\n                auto ele = q.front();\\n                q.pop();\\n                temp.push_back(ele->val);\\n                if(ele->left)q.push(ele->left);\\n                if(ele->right)q.push(ele->right);\\n            };\\n            res+=minSwaps(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr)\\n{\\n    int n = arr.size();\\n    pair<int, int> arrPos[n];\\n    for (int i = 0; i < n; i++)   {\\n        arrPos[i].first = arr[i];\\n        arrPos[i].second = i;\\n    }\\n    sort(arrPos, arrPos + n);\\n\\n    vector<bool> vis(n, false);\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (vis[i] || arrPos[i].second == i)\\n            continue;\\n        int cycle_size = 0;\\n        int j = i;\\n        while (!vis[j])\\n        {\\n            vis[j] = 1;\\n            j = arrPos[j].second;\\n            cycle_size++;\\n        }\\n        if (cycle_size > 0) ans += (cycle_size - 1);\\n        \\n    }\\n   \\n    return ans;\\n}\\n    int minimumOperations(TreeNode* root) {\\n        int res = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> temp;\\n            for(int i= 0;i<sz;i++){\\n                auto ele = q.front();\\n                q.pop();\\n                temp.push_back(ele->val);\\n                if(ele->left)q.push(ele->left);\\n                if(ele->right)q.push(ele->right);\\n            };\\n            res+=minSwaps(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808841,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int indexOf(int[] arr, int ele)\\n    {\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == ele) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void swap(int[] arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public int minSwaps(int[] arr, int N)\\n    {\\n        int ans = 0;\\n        int[] temp = Arrays.copyOfRange(arr, 0, N);\\n        Arrays.sort(temp);\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (arr[i] != temp[i])\\n            {\\n                ans++;\\n                swap(arr, i, indexOf(arr, temp[i]));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int minimumOperations(TreeNode root) {\\n        if(root.left == null && root.right == null) return 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode node = q.poll();\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n                \\n            }\\n            int[] arr = new int[q.size()];\\n            int k=0;\\n            for(TreeNode num: q){\\n                arr[k++] = num.val;\\n            }\\n            ans += minSwaps(arr, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int indexOf(int[] arr, int ele)\\n    {\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == ele) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void swap(int[] arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public int minSwaps(int[] arr, int N)\\n    {\\n        int ans = 0;\\n        int[] temp = Arrays.copyOfRange(arr, 0, N);\\n        Arrays.sort(temp);\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (arr[i] != temp[i])\\n            {\\n                ans++;\\n                swap(arr, i, indexOf(arr, temp[i]));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int minimumOperations(TreeNode root) {\\n        if(root.left == null && root.right == null) return 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode node = q.poll();\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n                \\n            }\\n            int[] arr = new int[q.size()];\\n            int k=0;\\n            for(TreeNode num: q){\\n                arr[k++] = num.val;\\n            }\\n            ans += minSwaps(arr, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096748,
                "title": "level-order-traversal-and-sorting-swap-algo-correctness-proof-for-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int totalSwaps = 0;\\n        while(queue.size() > 0) {\\n            int k = queue.size(); \\n            List<int[]> nodes = new ArrayList<>();\\n            for(int i=0; i<k; i++) {\\n                TreeNode node = queue.remove();\\n                nodes.add(new int[]{node.val, i});\\n                if(node.left != null) {\\n                    queue.add(node.left);\\n                }\\n                if(node.right != null) {\\n                    queue.add(node.right);\\n                }\\n                \\n            }\\n            Collections.sort(nodes, (n1, n2) -> n1[0] - n2[0]);\\n            // ith pos element should be at index i to become original array\\n            int m = nodes.get(0)[1];\\n            int n = nodes.size();\\n            for(int i=0; i<n; i++) {\\n                int key = nodes.get(i)[0], val = nodes.get(i)[1];\\n                while(val != i) {\\n                    int temp = nodes.get(val)[1];\\n                    nodes.set(val, new int[]{key, val});\\n                    val = temp;\\n                    totalSwaps += 1;\\n                }\\n            }\\n        }\\n        return totalSwaps;\\n    }\\n}\\n\\n\\n/***\\n\\nProof that number of swaps <= n for any array of size n, correctness of swap algorithm\\n\\nBy induction: \\n\\nassume ai > aj if i>j\\nS(n) : [a1, a2, a3, ..., an] -> sorted array -> Let\\'s say the statement is true and we have sorted the array in min O(n) swaps. i.e swap count <= n \\n\\nFor S(n+1): \\nValid configurations can be \\n[a_n+1, a1 , a2, a3, ..., an], [a1, a_n+1, a2,... ,an], [a1, a2, a_n+1, a3, ....,an], ....\\n[a1, a2, ....a_n+1]\\n\\nFor every configuration let\\'s find the max number of swaps required \\nMax swaps will be for configuration: [a_n+1, a1 , a2, a3, ..., an]\\n\\nnew swap count = n\\nswap(a_n+1, a1), swap(a_n+1, a2), ....swap(a_n+1, an)\\n\\nnew swap count = n < n + 1\\nhence S(n + 1) is also true\\n\\nso S(n) is true, it is upper bounded by O(n)\\n\\n**/\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int totalSwaps = 0;\\n        while(queue.size() > 0) {\\n            int k = queue.size(); \\n            List<int[]> nodes = new ArrayList<>();\\n            for(int i=0; i<k; i++) {\\n                TreeNode node = queue.remove();\\n                nodes.add(new int[]{node.val, i});\\n                if(node.left != null) {\\n                    queue.add(node.left);\\n                }\\n                if(node.right != null) {\\n                    queue.add(node.right);\\n                }\\n                \\n            }\\n            Collections.sort(nodes, (n1, n2) -> n1[0] - n2[0]);\\n            // ith pos element should be at index i to become original array\\n            int m = nodes.get(0)[1];\\n            int n = nodes.size();\\n            for(int i=0; i<n; i++) {\\n                int key = nodes.get(i)[0], val = nodes.get(i)[1];\\n                while(val != i) {\\n                    int temp = nodes.get(val)[1];\\n                    nodes.set(val, new int[]{key, val});\\n                    val = temp;\\n                    totalSwaps += 1;\\n                }\\n            }\\n        }\\n        return totalSwaps;\\n    }\\n}\\n\\n\\n/***\\n\\nProof that number of swaps <= n for any array of size n, correctness of swap algorithm\\n\\nBy induction: \\n\\nassume ai > aj if i>j\\nS(n) : [a1, a2, a3, ..., an] -> sorted array -> Let\\'s say the statement is true and we have sorted the array in min O(n) swaps. i.e swap count <= n \\n\\nFor S(n+1): \\nValid configurations can be \\n[a_n+1, a1 , a2, a3, ..., an], [a1, a_n+1, a2,... ,an], [a1, a2, a_n+1, a3, ....,an], ....\\n[a1, a2, ....a_n+1]\\n\\nFor every configuration let\\'s find the max number of swaps required \\nMax swaps will be for configuration: [a_n+1, a1 , a2, a3, ..., an]\\n\\nnew swap count = n\\nswap(a_n+1, a1), swap(a_n+1, a2), ....swap(a_n+1, an)\\n\\nnew swap count = n < n + 1\\nhence S(n + 1) is also true\\n\\nso S(n) is true, it is upper bounded by O(n)\\n\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094292,
                "title": "minimum-swaps-to-make-array-sorted-tree-simple-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        def bfs(root):\\n            if not root:\\n                return \\n            \\n            result = []\\n            \\n            q = deque([root])\\n            \\n            while q:\\n                n = len(q)\\n                tmp = []\\n                \\n                for i in range(n):\\n                    node = q.popleft()\\n                    tmp.append(node.val)\\n                    \\n                    if node.left:\\n                        q.append(node.left)\\n                    \\n                    if node.right:\\n                        q.append(node.right)\\n                        \\n                result.append(tmp)\\n                \\n            return result\\n        \\n        \\n        lsts = bfs(root)\\n        \\n        result = 0\\n        \\n        for lst in lsts:\\n            if len(lst)==1:\\n                continue\\n            else:\\n                srtd = sorted(lst)\\n                \\n                for i in range(len(lst)):\\n                    if srtd[i] != lst[i]:\\n                        idx = lst.index(srtd[i])\\n                        lst[i], lst[idx] = lst[idx], lst[i]\\n                        result+=1\\n                        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        def bfs(root):\\n            if not root:\\n                return \\n            \\n            result = []\\n            \\n            q = deque([root])\\n            \\n            while q:\\n                n = len(q)\\n                tmp = []\\n                \\n                for i in range(n):\\n                    node = q.popleft()\\n                    tmp.append(node.val)\\n                    \\n                    if node.left:\\n                        q.append(node.left)\\n                    \\n                    if node.right:\\n                        q.append(node.right)\\n                        \\n                result.append(tmp)\\n                \\n            return result\\n        \\n        \\n        lsts = bfs(root)\\n        \\n        result = 0\\n        \\n        for lst in lsts:\\n            if len(lst)==1:\\n                continue\\n            else:\\n                srtd = sorted(lst)\\n                \\n                for i in range(len(lst)):\\n                    if srtd[i] != lst[i]:\\n                        idx = lst.index(srtd[i])\\n                        lst[i], lst[idx] = lst[idx], lst[i]\\n                        result+=1\\n                        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094148,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n\\n    void minSwapsToSort(vector<pair<int,int>> currLevel, int &swaps) {\\n\\n        sort(currLevel.begin(), currLevel.end());\\n\\n        for(int i=0;i<currLevel.size();i++) {\\n            pair<int,int> currElement = currLevel[i];\\n            int value = currElement.first;\\n            int index = currElement.second;\\n\\n            if(i != index) {\\n                swap(currLevel[i], currLevel[index]);\\n                swaps++;\\n                i--;\\n            }\\n        }\\n\\n    }\\n\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n\\n        int swaps = 0;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<pair<int,int>> currLevel;\\n\\n            for(int i=0;i<size;i++) {\\n                TreeNode* p = q.front();\\n                q.pop();\\n\\n                currLevel.push_back({p->val, i});\\n\\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n            }\\n\\n            minSwapsToSort(currLevel, swaps);\\n        }\\n\\n\\n        return swaps;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n\\n    void minSwapsToSort(vector<pair<int,int>> currLevel, int &swaps) {\\n\\n        sort(currLevel.begin(), currLevel.end());\\n\\n        for(int i=0;i<currLevel.size();i++) {\\n            pair<int,int> currElement = currLevel[i];\\n            int value = currElement.first;\\n            int index = currElement.second;\\n\\n            if(i != index) {\\n                swap(currLevel[i], currLevel[index]);\\n                swaps++;\\n                i--;\\n            }\\n        }\\n\\n    }\\n\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n\\n        int swaps = 0;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<pair<int,int>> currLevel;\\n\\n            for(int i=0;i<size;i++) {\\n                TreeNode* p = q.front();\\n                q.pop();\\n\\n                currLevel.push_back({p->val, i});\\n\\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n            }\\n\\n            minSwapsToSort(currLevel, swaps);\\n        }\\n\\n\\n        return swaps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065274,
                "title": "c-sort-and-2-maps",
                "content": "```\\nclass Solution {\\npublic:   \\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        int ans = 0;\\n        while (!bfs.empty()){\\n            vector<TreeNode*> lvl;\\n            queue<TreeNode*> next;\\n            while (!bfs.empty()){\\n                lvl.push_back(bfs.front());\\n                bfs.pop();\\n                if (lvl.back()->left)\\n                next.push(lvl.back()->left);\\n                if (lvl.back()->right)\\n                next.push(lvl.back()->right);\\n            }\\n            ans += summation(lvl);\\n            bfs = next;\\n        }\\n        return ans;\\n    }\\n    int summation(vector<TreeNode*>& lvl){\\n        vector<int> sortedValues;\\n        unordered_map<int,int> a;\\n        unordered_map<int,int> b;\\n        for (int i = 0; i < lvl.size(); ++i){\\n            int v = lvl[i]->val;\\n            a[i] = v;\\n            b[v] = i;\\n            sortedValues.push_back(v);\\n        }\\n        sort(sortedValues.begin(), sortedValues.end());\\n        int sum = 0;\\n        for (int i = 0; i < lvl.size(); ++i){\\n            if (a[i] != sortedValues[i]){\\n                ++sum;\\n                int newI = b[sortedValues[i]];\\n                b[a[i]] = newI;\\n                a[newI] = a[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        int ans = 0;\\n        while (!bfs.empty()){\\n            vector<TreeNode*> lvl;\\n            queue<TreeNode*> next;\\n            while (!bfs.empty()){\\n                lvl.push_back(bfs.front());\\n                bfs.pop();\\n                if (lvl.back()->left)\\n                next.push(lvl.back()->left);\\n                if (lvl.back()->right)\\n                next.push(lvl.back()->right);\\n            }\\n            ans += summation(lvl);\\n            bfs = next;\\n        }\\n        return ans;\\n    }\\n    int summation(vector<TreeNode*>& lvl){\\n        vector<int> sortedValues;\\n        unordered_map<int,int> a;\\n        unordered_map<int,int> b;\\n        for (int i = 0; i < lvl.size(); ++i){\\n            int v = lvl[i]->val;\\n            a[i] = v;\\n            b[v] = i;\\n            sortedValues.push_back(v);\\n        }\\n        sort(sortedValues.begin(), sortedValues.end());\\n        int sum = 0;\\n        for (int i = 0; i < lvl.size(); ++i){\\n            if (a[i] != sortedValues[i]){\\n                ++sum;\\n                int newI = b[sortedValues[i]];\\n                b[a[i]] = newI;\\n                a[newI] = a[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051695,
                "title": "simple-c-solution-runtime-beats-97-83-memory-beats-86-79",
                "content": "# Intuition\\nI think that i could create an algorithm that used permutation cicles to resolve the Min.Changes problem. Furthermore i think that using a BFS i could take all layers and work on each one. \\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n    - The principle While -> is N, being the number of layers.\\n        - For that iterate on all nodes from the specific layer M\\n        - CountMinChanges function\\n            - For initialization vectorPairs\\n            - For in M\\n                - While \\n    \\n    In general: O( N * (M + (M + M * log(m))) ) => **O(N * M * log(M))**  \\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int CountMinChanges(const vector<TreeNode*> &layer, const int &sz) {\\n        int diferencias = 0;\\n        vector<pair<int,int>> ValInx(sz);\\n        for (int i = 0; i < sz; i++)\\n            ValInx[i] = {layer[i]->val,i};\\n        sort(ValInx.begin(), ValInx.end());\\n        for (int i = 0; i < sz; i++) {\\n            while (i != ValInx[i].second) {\\n                swap(ValInx[i], ValInx[ValInx[i].second]);\\n                diferencias++;\\n            }\\n        }\\n        return diferencias;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        vector<TreeNode*> layer;\\n        layer.push_back(root);\\n        int CambiosRealizados = 0;\\n        while (true) {\\n            // Tomar todos los elementos de la siguiente capa\\n            int sz = layer.size();\\n            vector<TreeNode*> aux;\\n            for (int i = 0; i < sz; i++) {\\n                TreeNode* ActualNode = layer[i];\\n                if (ActualNode->left != nullptr)\\n                    aux.push_back(ActualNode->left);\\n                if (ActualNode->right != nullptr)\\n                    aux.push_back(ActualNode->right);\\n            }\\n            layer = aux;\\n            sz = layer.size();\\n            // Revisar el minimo numero de cambios en el vector\\n            if (layer.empty()) \\n                return CambiosRealizados;\\n            CambiosRealizados += CountMinChanges(layer, sz); \\n        }\\n        return CambiosRealizados;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int CountMinChanges(const vector<TreeNode*> &layer, const int &sz) {\\n        int diferencias = 0;\\n        vector<pair<int,int>> ValInx(sz);\\n        for (int i = 0; i < sz; i++)\\n            ValInx[i] = {layer[i]->val,i};\\n        sort(ValInx.begin(), ValInx.end());\\n        for (int i = 0; i < sz; i++) {\\n            while (i != ValInx[i].second) {\\n                swap(ValInx[i], ValInx[ValInx[i].second]);\\n                diferencias++;\\n            }\\n        }\\n        return diferencias;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        vector<TreeNode*> layer;\\n        layer.push_back(root);\\n        int CambiosRealizados = 0;\\n        while (true) {\\n            // Tomar todos los elementos de la siguiente capa\\n            int sz = layer.size();\\n            vector<TreeNode*> aux;\\n            for (int i = 0; i < sz; i++) {\\n                TreeNode* ActualNode = layer[i];\\n                if (ActualNode->left != nullptr)\\n                    aux.push_back(ActualNode->left);\\n                if (ActualNode->right != nullptr)\\n                    aux.push_back(ActualNode->right);\\n            }\\n            layer = aux;\\n            sz = layer.size();\\n            // Revisar el minimo numero de cambios en el vector\\n            if (layer.empty()) \\n                return CambiosRealizados;\\n            CambiosRealizados += CountMinChanges(layer, sz); \\n        }\\n        return CambiosRealizados;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038967,
                "title": "c-levelordertraversal-in-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwap(vector<int>& num){\\n        int res=0;\\n        int n=num.size();\\n        vector<pair<int,int>> numPos(n);\\n        for(int i=0;i<n;++i){\\n            numPos[i].first = num[i];\\n            numPos[i].second = i;\\n        }\\n        sort(numPos.begin(),numPos.end());\\n\\n        vector<bool> vis(n,false);\\n        for(int i=0;i<n;++i){\\n            if(vis[i] || numPos[i].second==i)\\n                continue;\\n            int cycleSize = 0;\\n            int t = i;\\n            while(!vis[t]){\\n                vis[t] = true;\\n                t = numPos[t].second;\\n                ++cycleSize;\\n            }\\n            res += (cycleSize-1);\\n        }\\n\\n        return res;\\n    }\\n    void levelOrder(TreeNode* root, int *ans){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n\\n            queue<TreeNode*> temp;\\n            while(!q.empty()){\\n                temp.push(q.front());\\n                q.pop();\\n            }\\n            vector<int> numsInSameLevel;\\n            while(!temp.empty()){\\n                TreeNode* node = temp.front();\\n                temp.pop();\\n                numsInSameLevel.push_back(node->val);\\n                if(node->left != nullptr)\\n                    q.push(node->left);\\n                if(node->right != nullptr)\\n                    q.push(node->right);\\n            }\\n            *ans += minSwap(numsInSameLevel);\\n               \\n        }\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        levelOrder(root,&ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwap(vector<int>& num){\\n        int res=0;\\n        int n=num.size();\\n        vector<pair<int,int>> numPos(n);\\n        for(int i=0;i<n;++i){\\n            numPos[i].first = num[i];\\n            numPos[i].second = i;\\n        }\\n        sort(numPos.begin(),numPos.end());\\n\\n        vector<bool> vis(n,false);\\n        for(int i=0;i<n;++i){\\n            if(vis[i] || numPos[i].second==i)\\n                continue;\\n            int cycleSize = 0;\\n            int t = i;\\n            while(!vis[t]){\\n                vis[t] = true;\\n                t = numPos[t].second;\\n                ++cycleSize;\\n            }\\n            res += (cycleSize-1);\\n        }\\n\\n        return res;\\n    }\\n    void levelOrder(TreeNode* root, int *ans){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n\\n            queue<TreeNode*> temp;\\n            while(!q.empty()){\\n                temp.push(q.front());\\n                q.pop();\\n            }\\n            vector<int> numsInSameLevel;\\n            while(!temp.empty()){\\n                TreeNode* node = temp.front();\\n                temp.pop();\\n                numsInSameLevel.push_back(node->val);\\n                if(node->left != nullptr)\\n                    q.push(node->left);\\n                if(node->right != nullptr)\\n                    q.push(node->right);\\n            }\\n            *ans += minSwap(numsInSameLevel);\\n               \\n        }\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        levelOrder(root,&ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983634,
                "title": "using-level-order-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findMinOperations(vector<int>& arr){\\n        if(arr.size() == 1){\\n            return 0;\\n        }\\n        if(arr.size() == 2){\\n            return (arr[0] > arr[1]) ? 1:0;\\n        }\\n        vector<pair<int,int>> arrPos;\\n        for(int i=0; i<arr.size(); i++){\\n            arrPos.push_back({arr[i],i});\\n        }\\n        sort(begin(arrPos),end(arrPos));\\n        int minOps = 0;\\n        vector<bool> vis(arr.size(),false);\\n        for(int i=0; i<arr.size(); i++){\\n            if(vis[i] or arrPos[i].second == i){\\n                continue;\\n            }\\n            int cycle = 0;\\n            int j = i;\\n            while(!vis[j]){\\n                vis[j] = true;\\n                j = arrPos[j].second;\\n                cycle++;\\n            }\\n            if(cycle > 0){\\n                minOps += cycle - 1;\\n            }\\n        }\\n        return minOps;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            return 0;\\n        }\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n        int minOperations = 0;\\n        while(!Q.empty()){\\n            int n = Q.size();\\n            vector<int> levelArray;\\n            while(n--){\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                levelArray.push_back(curr->val);\\n                if(curr->left){\\n                    Q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    Q.push(curr->right);\\n                }\\n            }\\n            cout<<levelArray.size()<<\"  \";\\n            minOperations += findMinOperations(levelArray);\\n        }\\n        return minOperations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findMinOperations(vector<int>& arr){\\n        if(arr.size() == 1){\\n            return 0;\\n        }\\n        if(arr.size() == 2){\\n            return (arr[0] > arr[1]) ? 1:0;\\n        }\\n        vector<pair<int,int>> arrPos;\\n        for(int i=0; i<arr.size(); i++){\\n            arrPos.push_back({arr[i],i});\\n        }\\n        sort(begin(arrPos),end(arrPos));\\n        int minOps = 0;\\n        vector<bool> vis(arr.size(),false);\\n        for(int i=0; i<arr.size(); i++){\\n            if(vis[i] or arrPos[i].second == i){\\n                continue;\\n            }\\n            int cycle = 0;\\n            int j = i;\\n            while(!vis[j]){\\n                vis[j] = true;\\n                j = arrPos[j].second;\\n                cycle++;\\n            }\\n            if(cycle > 0){\\n                minOps += cycle - 1;\\n            }\\n        }\\n        return minOps;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            return 0;\\n        }\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n        int minOperations = 0;\\n        while(!Q.empty()){\\n            int n = Q.size();\\n            vector<int> levelArray;\\n            while(n--){\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                levelArray.push_back(curr->val);\\n                if(curr->left){\\n                    Q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    Q.push(curr->right);\\n                }\\n            }\\n            cout<<levelArray.size()<<\"  \";\\n            minOperations += findMinOperations(levelArray);\\n        }\\n        return minOperations;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3968202,
                "title": "better-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        \\n        int count=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int> v;\\n            for(int i=0;i<s;i++){\\n                TreeNode* temp=q.front();\\n                v.push_back(temp->val);\\n                q.pop();\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n           vector<pair<int,int>> ans(v.size());\\n           for(int i=0;i<v.size();i++){\\n              ans[i]={v[i],i};\\n           }\\n\\n           sort(ans.begin(),ans.end());\\n\\n           for(int i=0;i<ans.size();i++){\\n               if(i!=ans[i].second){\\n                   swap(ans[i],ans[ans[i].second]);\\n                   count++;\\n                   i--;\\n               }\\n           }\\n\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        \\n        int count=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int> v;\\n            for(int i=0;i<s;i++){\\n                TreeNode* temp=q.front();\\n                v.push_back(temp->val);\\n                q.pop();\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n           vector<pair<int,int>> ans(v.size());\\n           for(int i=0;i<v.size();i++){\\n              ans[i]={v[i],i};\\n           }\\n\\n           sort(ans.begin(),ans.end());\\n\\n           for(int i=0;i<ans.size();i++){\\n               if(i!=ans[i].second){\\n                   swap(ans[i],ans[ans[i].second]);\\n                   count++;\\n                   i--;\\n               }\\n           }\\n\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904083,
                "title": "java-solution-without-hashmap-used-graph-therory",
                "content": "```\\nclass Solution {\\n    \\n    class Pair implements Comparable<Pair>{\\n        int val;\\n        int idx;\\n        \\n        Pair(int val , int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair o){\\n            return this.val - o.val;\\n        }\\n    }\\n    \\n    int ans = 0;\\n    public int minimumOperations(TreeNode root) {\\n        levelOrderTraversal(root);\\n        return ans;\\n    }\\n\\n    private void levelOrderTraversal(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode pop = queue.remove();\\n\\n                list.add(pop.val);\\n\\n                if (pop.left != null) {\\n                    queue.add(pop.left);\\n                }\\n                if (pop.right != null) {\\n                    queue.add(pop.right);\\n                }\\n            }\\n\\n            findMiniumSwapToSort(list);\\n        }\\n    }\\n//     using cyclic approach\\n    private void findMiniumSwapToSort(List<Integer> list){\\n        \\n        List<Pair> myList = new ArrayList<>();\\n        boolean isVisited[] = new boolean[list.size()];\\n               \\n        for(int i = 0 ; i < list.size(); i++){\\n            myList.add(new Pair(list.get(i), i));\\n        }\\n        Collections.sort(myList);\\n        \\n        int tempAns = 0;\\n        \\n        for(int i = 0 ; i < list.size(); i++){\\n            if(isVisited[i] == true || myList.get(i).idx == i ) continue;\\n            int clen = 0 ;\\n            int j = i;\\n            \\n            while(!isVisited[j]){\\n                clen++;\\n                isVisited[j] = true;\\n                j = myList.get(j).idx; \\n            }\\n            tempAns += clen - 1; \\n        }\\n        ans += tempAns;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair implements Comparable<Pair>{\\n        int val;\\n        int idx;\\n        \\n        Pair(int val , int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair o){\\n            return this.val - o.val;\\n        }\\n    }\\n    \\n    int ans = 0;\\n    public int minimumOperations(TreeNode root) {\\n        levelOrderTraversal(root);\\n        return ans;\\n    }\\n\\n    private void levelOrderTraversal(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode pop = queue.remove();\\n\\n                list.add(pop.val);\\n\\n                if (pop.left != null) {\\n                    queue.add(pop.left);\\n                }\\n                if (pop.right != null) {\\n                    queue.add(pop.right);\\n                }\\n            }\\n\\n            findMiniumSwapToSort(list);\\n        }\\n    }\\n//     using cyclic approach\\n    private void findMiniumSwapToSort(List<Integer> list){\\n        \\n        List<Pair> myList = new ArrayList<>();\\n        boolean isVisited[] = new boolean[list.size()];\\n               \\n        for(int i = 0 ; i < list.size(); i++){\\n            myList.add(new Pair(list.get(i), i));\\n        }\\n        Collections.sort(myList);\\n        \\n        int tempAns = 0;\\n        \\n        for(int i = 0 ; i < list.size(); i++){\\n            if(isVisited[i] == true || myList.get(i).idx == i ) continue;\\n            int clen = 0 ;\\n            int j = i;\\n            \\n            while(!isVisited[j]){\\n                clen++;\\n                isVisited[j] = true;\\n                j = myList.get(j).idx; \\n            }\\n            tempAns += clen - 1; \\n        }\\n        ans += tempAns;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891542,
                "title": "c-bfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\n    int minSwaps(vector<int>arr, int n)\\n    {\\n    // Create an array of\\n    // pairs where first\\n    // element is array element\\n    // and second element\\n    // is position of first element\\n        vector<pair<int,int>>ve;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            ve.push_back({arr[i],i});\\n        }\\n        sort(ve.begin(),ve.end());\\n        \\n        int cnt=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(ve[i].second==i) continue;\\n            else\\n            {\\n                cnt++;\\n                swap(ve[i],ve[ve[i].second]);\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        \\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            vector<int>tempp;\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                tempp.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n            int kk=tempp.size();\\n            ans+=minSwaps(tempp,kk);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\n    int minSwaps(vector<int>arr, int n)\\n    {\\n    // Create an array of\\n    // pairs where first\\n    // element is array element\\n    // and second element\\n    // is position of first element\\n        vector<pair<int,int>>ve;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            ve.push_back({arr[i],i});\\n        }\\n        sort(ve.begin(),ve.end());\\n        \\n        int cnt=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(ve[i].second==i) continue;\\n            else\\n            {\\n                cnt++;\\n                swap(ve[i],ve[ve[i].second]);\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        \\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            vector<int>tempp;\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                tempp.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n            int kk=tempp.size();\\n            ans+=minSwaps(tempp,kk);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885593,
                "title": "java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        helper(root, 0);\\n        for(int i = 0;i< map.size();i++){\\n            count += task(map.get(i));\\n\\n        }\\n        return count;\\n\\n    }\\n\\n    public void helper(TreeNode root, int level) {\\n        if(!map.containsKey(level)){\\n            map.put(level, new ArrayList<>());\\n        }\\n        map.get(level).add(root.val);\\n\\n        if(root.left!=null) helper(root.left, level+1);\\n        if(root.right!=null) helper(root.right, level+1);\\n        \\n    }\\n    \\n    public int task(List<Integer> list){\\n        Map<Integer, Integer> mapp = new HashMap<>();\\n        for(int i = 0;i< list.size();i++){\\n            mapp.put(list.get(i), i);\\n        }\\n        Collections.sort(list);\\n        boolean[] k = new boolean[list.size()];\\n        int res = 0;\\n        for(int i = 0;i< list.size();i++){\\n            if(k[i] || mapp.get(list.get(i))==i){\\n                continue;\\n            }\\n            int j = i, m=0;\\n            while(!k[j]){\\n                k[j] = true;\\n                j = mapp.get(list.get(j));\\n                m++;\\n            }\\n            if(m>0){\\n                res += m-1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        helper(root, 0);\\n        for(int i = 0;i< map.size();i++){\\n            count += task(map.get(i));\\n\\n        }\\n        return count;\\n\\n    }\\n\\n    public void helper(TreeNode root, int level) {\\n        if(!map.containsKey(level)){\\n            map.put(level, new ArrayList<>());\\n        }\\n        map.get(level).add(root.val);\\n\\n        if(root.left!=null) helper(root.left, level+1);\\n        if(root.right!=null) helper(root.right, level+1);\\n        \\n    }\\n    \\n    public int task(List<Integer> list){\\n        Map<Integer, Integer> mapp = new HashMap<>();\\n        for(int i = 0;i< list.size();i++){\\n            mapp.put(list.get(i), i);\\n        }\\n        Collections.sort(list);\\n        boolean[] k = new boolean[list.size()];\\n        int res = 0;\\n        for(int i = 0;i< list.size();i++){\\n            if(k[i] || mapp.get(list.get(i))==i){\\n                continue;\\n            }\\n            int j = i, m=0;\\n            while(!k[j]){\\n                k[j] = true;\\n                j = mapp.get(list.get(j));\\n                m++;\\n            }\\n            if(m>0){\\n                res += m-1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832671,
                "title": "using-hashmap-c-easy-solution-98-13-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        vector<int>v;\\n        vector<int>c;\\n        unordered_map<int,int>l;\\n        queue<TreeNode *>a;\\n        a.push(root);\\n        int g = 0;\\n\\n        while(!a.empty()){\\n            int s = a.size();\\n\\n            while(s){\\n                v.push_back(a.front()->val);\\n                l[a.front()->val] = v.size()-1;\\n                if(a.front()->left!=NULL){\\n                    a.push(a.front()->left);\\n                }\\n                if(a.front()->right!=NULL){\\n                    a.push(a.front()->right);\\n                }\\n                a.pop();\\n                s--;\\n            }\\n            // cout<<\"{ \";\\n            c = v;\\n            sort(c.begin(),c.end());\\n            for(int i = 0 ; i<c.size() ; i++){\\n                if(l[c[i]]!=i){\\n                    int h = v[i];\\n                    int j = l[c[i]];\\n                    swap(v[i],v[l[c[i]]]);\\n                    l[v[i]] = i;\\n                    l[h] = j;\\n                    g++;\\n                }\\n            }\\n            // cout<<\"}\";\\n            // for(int i = 0 ; i<c.size() ; i++){\\n            //     cout<<v[i]<<\" \";\\n            // }cout<<endl;\\n            v.clear();\\n            c.clear();\\n            l.clear();\\n\\n        }\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        vector<int>v;\\n        vector<int>c;\\n        unordered_map<int,int>l;\\n        queue<TreeNode *>a;\\n        a.push(root);\\n        int g = 0;\\n\\n        while(!a.empty()){\\n            int s = a.size();\\n\\n            while(s){\\n                v.push_back(a.front()->val);\\n                l[a.front()->val] = v.size()-1;\\n                if(a.front()->left!=NULL){\\n                    a.push(a.front()->left);\\n                }\\n                if(a.front()->right!=NULL){\\n                    a.push(a.front()->right);\\n                }\\n                a.pop();\\n                s--;\\n            }\\n            // cout<<\"{ \";\\n            c = v;\\n            sort(c.begin(),c.end());\\n            for(int i = 0 ; i<c.size() ; i++){\\n                if(l[c[i]]!=i){\\n                    int h = v[i];\\n                    int j = l[c[i]];\\n                    swap(v[i],v[l[c[i]]]);\\n                    l[v[i]] = i;\\n                    l[h] = j;\\n                    g++;\\n                }\\n            }\\n            // cout<<\"}\";\\n            // for(int i = 0 ; i<c.size() ; i++){\\n            //     cout<<v[i]<<\" \";\\n            // }cout<<endl;\\n            v.clear();\\n            c.clear();\\n            l.clear();\\n\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3821935,
                "title": "easy-c-solution-using-hash-table-easy-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void swap(vector<int>& arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    int minSwaps(vector<int> arr, int N)\\n    {\\n        int ans = 0;\\n        vector<int> temp = arr;\\n        map<int, int> h;\\n        sort(temp.begin(), temp.end());\\n        for (int i = 0; i < N; i++) {\\n            h[arr[i]] = i;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            if (arr[i] != temp[i]) {\\n                ans++;\\n                int init = arr[i];\\n                swap(arr, i, h[temp[i]]);\\n                h[init] = h[temp[i]];\\n                h[temp[i]] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        if(!root)return 0;\\n        int cnt=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int sz=q.size();\\n            vector<int>level;\\n            while(sz--){\\n                auto t=q.front();\\n                q.pop();\\n                level.push_back(t->val);\\n                if(t->left)q.push(t->left);\\n                if(t->right)q.push(t->right);\\n            }\\n            int ans=minSwaps(level,level.size());\\n            cnt+=ans;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void swap(vector<int>& arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    int minSwaps(vector<int> arr, int N)\\n    {\\n        int ans = 0;\\n        vector<int> temp = arr;\\n        map<int, int> h;\\n        sort(temp.begin(), temp.end());\\n        for (int i = 0; i < N; i++) {\\n            h[arr[i]] = i;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            if (arr[i] != temp[i]) {\\n                ans++;\\n                int init = arr[i];\\n                swap(arr, i, h[temp[i]]);\\n                h[init] = h[temp[i]];\\n                h[temp[i]] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        if(!root)return 0;\\n        int cnt=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int sz=q.size();\\n            vector<int>level;\\n            while(sz--){\\n                auto t=q.front();\\n                q.pop();\\n                level.push_back(t->val);\\n                if(t->left)q.push(t->left);\\n                if(t->right)q.push(t->right);\\n            }\\n            int ans=minSwaps(level,level.size());\\n            cnt+=ans;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809349,
                "title": "minimum-number-of-operations-to-sort-binary-tree-by-level-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    // Code here\\n\\t    int ans = 0;\\n\\t    vector<pair<int,int>>v;\\n\\t    for(int i = 0; i<nums.size(); i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    \\n\\t    sort(v.begin(),v.end());\\n\\t    \\n\\t    for(int i = 0; i<v.size(); i++)\\n\\t    {\\n\\t        if(i!=v[i].second)\\n\\t        {\\n\\t            ans++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    return ans;\\n\\t}\\n\\n    int minimumOperations(TreeNode* root) \\n    {\\n        int res = 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int>t;\\n            while(n--)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                t.push_back(temp->val);\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n            }\\n\\n            res += minSwaps(t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    // Code here\\n\\t    int ans = 0;\\n\\t    vector<pair<int,int>>v;\\n\\t    for(int i = 0; i<nums.size(); i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    \\n\\t    sort(v.begin(),v.end());\\n\\t    \\n\\t    for(int i = 0; i<v.size(); i++)\\n\\t    {\\n\\t        if(i!=v[i].second)\\n\\t        {\\n\\t            ans++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    return ans;\\n\\t}\\n\\n    int minimumOperations(TreeNode* root) \\n    {\\n        int res = 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int>t;\\n            while(n--)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                t.push_back(temp->val);\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n            }\\n\\n            res += minSwaps(t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802506,
                "title": "javascript-bfs-level-order-traversal-compare-swap-sorted-level-and-unsorted-level",
                "content": "# Intuition\\nThis was a straight forward BFS level order traversal. The difficult part is trying to get a count of how many swaps is needed. There is a more optimal solution to version known as the cylic sort. That algo can get O(n) time complexity for getting the optimal \"writes\" to an array before it becomes sorted. I did not go through with that approach and I used other people\\'s JavaScript solution to solve this.\\n\\n# Approach\\n        BFS(root) -> Level Order Traversal\\n\\n        For each Level\\n            let sortedLevel = level.sort()\\n            let unsortedLevel = level\\n            let map = {\\n                key(sortedNumber)\\n                value(sortedIndex)\\n            }\\n\\n            iterate over each value of unsorted level\\n                for each index \\n                    is the current index inside map\\n                        yes -> sortedIndex !== unsortedIndex\\n                            yes -> swap(), count += 1\\n                            no  -> skip, as the index of sorted === unsorted are equal\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nBFS O(n)\\n\\nFor N levels, we sort each level @ o(n log n)\\n\\n- Space complexity:\\n\\nO(n) -> Map, Levels, \\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minimumOperations = function(root) {\\n    let queue = [root]\\n    let levels = []\\n\\n    while (queue.length > 0) {\\n        let len = queue.length\\n        let level = []\\n        for (let i = 0; i < len; i++) {\\n            const node = queue.shift()\\n            if (!node) continue\\n            level.push(node.val)\\n            if (node.left) {\\n                queue.push(node.left)\\n            }\\n            if (node.right) {\\n                queue.push(node.right)\\n            }\\n        }\\n        levels.push(level)\\n    }\\n\\n    const swap = (i, j, arr) => {\\n        let tmp = arr[i]\\n        arr[i] = arr[j]\\n        arr[j] = tmp\\n    }\\n\\n    const getTotalSwapsByLevel = (arr) => {\\n        let count = 0\\n        let sorted = [...arr].sort((a, b) => a - b)\\n        let m = {}\\n\\n        for (let i = 0; i < sorted.length; i++) {\\n            m[sorted[i]] = i\\n        }\\n\\n        for (let i = 0; i < arr.length; i++) {\\n            // while sortedIndex !== unsortedIndex\\n            while (i !== m[arr[i]]) {\\n                swap(i, m[arr[i]], arr)\\n                count++\\n            }\\n        }\\n\\n        return count\\n    }\\n\\n    let res = 0\\n\\n    for (let level of levels) {\\n        res += getTotalSwapsByLevel(level)\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minimumOperations = function(root) {\\n    let queue = [root]\\n    let levels = []\\n\\n    while (queue.length > 0) {\\n        let len = queue.length\\n        let level = []\\n        for (let i = 0; i < len; i++) {\\n            const node = queue.shift()\\n            if (!node) continue\\n            level.push(node.val)\\n            if (node.left) {\\n                queue.push(node.left)\\n            }\\n            if (node.right) {\\n                queue.push(node.right)\\n            }\\n        }\\n        levels.push(level)\\n    }\\n\\n    const swap = (i, j, arr) => {\\n        let tmp = arr[i]\\n        arr[i] = arr[j]\\n        arr[j] = tmp\\n    }\\n\\n    const getTotalSwapsByLevel = (arr) => {\\n        let count = 0\\n        let sorted = [...arr].sort((a, b) => a - b)\\n        let m = {}\\n\\n        for (let i = 0; i < sorted.length; i++) {\\n            m[sorted[i]] = i\\n        }\\n\\n        for (let i = 0; i < arr.length; i++) {\\n            // while sortedIndex !== unsortedIndex\\n            while (i !== m[arr[i]]) {\\n                swap(i, m[arr[i]], arr)\\n                count++\\n            }\\n        }\\n\\n        return count\\n    }\\n\\n    let res = 0\\n\\n    for (let level of levels) {\\n        res += getTotalSwapsByLevel(level)\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789666,
                "title": "c-bfs-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int exe(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int cnt=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            cnt++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return cnt;\\n\\t} \\n    int minimumOperations(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        int ans = 0;\\n        q.push({root, 0});\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> ds;\\n            for(int i=0;i<size;i++){\\n                TreeNode *node = q.front().first;\\n                int level = q.front().second;\\n                q.pop();\\n                ds.push_back(node->val);\\n                if(node->left) q.push({node->left, level+1});\\n                if(node->right) q.push({node->right, level+1});\\n            }\\n            ans+=exe(ds);\\n\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int exe(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int cnt=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            cnt++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return cnt;\\n\\t} \\n    int minimumOperations(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        int ans = 0;\\n        q.push({root, 0});\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> ds;\\n            for(int i=0;i<size;i++){\\n                TreeNode *node = q.front().first;\\n                int level = q.front().second;\\n                q.pop();\\n                ds.push_back(node->val);\\n                if(node->left) q.push({node->left, level+1});\\n                if(node->right) q.push({node->right, level+1});\\n            }\\n            ans+=exe(ds);\\n\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769824,
                "title": "java-bruteforce-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int swaps=0;\\n        if(root==null)\\n        return swaps;\\n        Queue<TreeNode> al = new LinkedList<>();\\n        al.add(root);\\n        while(!al.isEmpty())\\n        {\\n            int sze = al.size();\\n            ArrayList<Integer>sol = new ArrayList<>();\\n            while(sze>0)\\n            {\\n                sze--;\\n                TreeNode cur =al.poll();\\n                sol.add(cur.val);\\n                if(cur.left!=null)\\n                al.offer(cur.left);\\n                if(cur.right!=null)\\n                al.offer(cur.right);\\n            }\\n           ArrayList<Integer> sorted = (ArrayList<Integer>)sol.clone();\\n           Collections.sort(sorted);\\n           System.out.println(sol+\"....\"+sorted);\\n           for(int i=0; i<sorted.size(); i++)\\n           {\\n               int cur =sorted.get(i);\\n               if(sol.get(i)==cur)continue;\\n               int ind =i;\\n               \\n               for(int j=i+1;j<sorted.size();j++)\\n                    {\\n                        if(sol.get(j)==cur)\\n                        {\\n                            ind = j;\\n                            break;\\n                        }\\n                    }\\n                    System.out.print(cur+\"__\");\\n               \\n                sol.set(ind,sol.get(i));\\n                \\n                sol.set(i,cur);\\n                swaps++;\\n           }\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int swaps=0;\\n        if(root==null)\\n        return swaps;\\n        Queue<TreeNode> al = new LinkedList<>();\\n        al.add(root);\\n        while(!al.isEmpty())\\n        {\\n            int sze = al.size();\\n            ArrayList<Integer>sol = new ArrayList<>();\\n            while(sze>0)\\n            {\\n                sze--;\\n                TreeNode cur =al.poll();\\n                sol.add(cur.val);\\n                if(cur.left!=null)\\n                al.offer(cur.left);\\n                if(cur.right!=null)\\n                al.offer(cur.right);\\n            }\\n           ArrayList<Integer> sorted = (ArrayList<Integer>)sol.clone();\\n           Collections.sort(sorted);\\n           System.out.println(sol+\"....\"+sorted);\\n           for(int i=0; i<sorted.size(); i++)\\n           {\\n               int cur =sorted.get(i);\\n               if(sol.get(i)==cur)continue;\\n               int ind =i;\\n               \\n               for(int j=i+1;j<sorted.size();j++)\\n                    {\\n                        if(sol.get(j)==cur)\\n                        {\\n                            ind = j;\\n                            break;\\n                        }\\n                    }\\n                    System.out.print(cur+\"__\");\\n               \\n                sol.set(ind,sol.get(i));\\n                \\n                sol.set(i,cur);\\n                swaps++;\\n           }\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754833,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int f(vector<int>&x){\\n       vector<pair<int,int>>vec;\\n       for(int i=0;i<x.size();i++){\\n          vec.push_back({x[i],i});\\n       }\\n       sort(vec.begin(),vec.end());\\n       int swaps=0;\\n       for(int i=0;i<x.size();i++){\\n           pair<int,int>p=vec[i];\\n           int val=p.first;\\n           int idx=p.second;\\n           int d=i;//i=0 d=0; idx=2\\n          if(i!=idx){  //idx=2    {5,2}  {7,3}\\n        //   cout<<\"pop\"<<vec[d].first<<\" \"<<vec[idx].first<<endl;\\n              swaps++;\\n              swap(vec[d],vec[idx]);\\n            i--;\\n          }\\n       }\\n       return swaps;\\n   }\\n   void dfs(TreeNode* root,vector<vector<int>>&level,int l){\\n     if(root==NULL)return;\\n     if(level.size()<=l){\\n         level.push_back({});\\n     }\\n         level[l].push_back(root->val);\\n     if(root->left!=NULL){\\n         dfs(root->left,level,l+1);\\n     }\\n      if(root->right!=NULL){\\n         dfs(root->right,level,l+1);\\n     }\\n   }\\n    int minimumOperations(TreeNode* root) {\\n        vector<vector<int>>level;\\n        int l=0;\\n        dfs(root,level,l);\\n        int sum=0;\\n        for(auto x:level){\\n            // for(auto y:x)cout<<y<<\" \";\\n            int ok=f(x);\\n            // cout<<\"a\"<<\"\\\\n\"<<ok<<endl;\\n            sum+=ok;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int f(vector<int>&x){\\n       vector<pair<int,int>>vec;\\n       for(int i=0;i<x.size();i++){\\n          vec.push_back({x[i],i});\\n       }\\n       sort(vec.begin(),vec.end());\\n       int swaps=0;\\n       for(int i=0;i<x.size();i++){\\n           pair<int,int>p=vec[i];\\n           int val=p.first;\\n           int idx=p.second;\\n           int d=i;//i=0 d=0; idx=2\\n          if(i!=idx){  //idx=2    {5,2}  {7,3}\\n        //   cout<<\"pop\"<<vec[d].first<<\" \"<<vec[idx].first<<endl;\\n              swaps++;\\n              swap(vec[d],vec[idx]);\\n            i--;\\n          }\\n       }\\n       return swaps;\\n   }\\n   void dfs(TreeNode* root,vector<vector<int>>&level,int l){\\n     if(root==NULL)return;\\n     if(level.size()<=l){\\n         level.push_back({});\\n     }\\n         level[l].push_back(root->val);\\n     if(root->left!=NULL){\\n         dfs(root->left,level,l+1);\\n     }\\n      if(root->right!=NULL){\\n         dfs(root->right,level,l+1);\\n     }\\n   }\\n    int minimumOperations(TreeNode* root) {\\n        vector<vector<int>>level;\\n        int l=0;\\n        dfs(root,level,l);\\n        int sum=0;\\n        for(auto x:level){\\n            // for(auto y:x)cout<<y<<\" \";\\n            int ok=f(x);\\n            // cout<<\"a\"<<\"\\\\n\"<<ok<<endl;\\n            sum+=ok;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3754717,
                "title": "cpp-easy-implementation-min-swaps-function-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void swap(vector<int>& arr, int i, int j)\\n    {\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n    }\\n    int min_swaps(vector<int>v){\\n        int ans=0;\\n        int n=v.size();\\n        vector<int>temp=v;\\n        sort(temp.begin(),temp.end());\\n        map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[v[i]]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]!=temp[i]){\\n                ans++;\\n                int nw=v[i];\\n                swap(v,i,m[temp[i]]);\\n                m[nw]=m[temp[i]];\\n                m[temp[i]]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        vector<vector<int>> h;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int> t;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode*cur=q.front();\\n                q.pop();\\n                t.push_back(cur->val);\\n                if(cur->left)q.push(cur->left);\\n                if(cur->right)q.push(cur->right);\\n            }\\n            h.push_back(t);\\n        }\\n        int ans=0;\\n        //ans=min_swaps(h[2]);\\n        for(vector<int> e:h){\\n            ans+=min_swaps(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void swap(vector<int>& arr, int i, int j)\\n    {\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n    }\\n    int min_swaps(vector<int>v){\\n        int ans=0;\\n        int n=v.size();\\n        vector<int>temp=v;\\n        sort(temp.begin(),temp.end());\\n        map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[v[i]]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]!=temp[i]){\\n                ans++;\\n                int nw=v[i];\\n                swap(v,i,m[temp[i]]);\\n                m[nw]=m[temp[i]];\\n                m[temp[i]]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        vector<vector<int>> h;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int> t;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode*cur=q.front();\\n                q.pop();\\n                t.push_back(cur->val);\\n                if(cur->left)q.push(cur->left);\\n                if(cur->right)q.push(cur->right);\\n            }\\n            h.push_back(t);\\n        }\\n        int ans=0;\\n        //ans=min_swaps(h[2]);\\n        for(vector<int> e:h){\\n            ans+=min_swaps(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744572,
                "title": "optimized-level-order-traversal-with-swapping-minimum-operations-to-sort-levels-of-a-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M * (N log N)), where M is the number of levels in the binary tree and N is the maximum number of nodes at any level.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        vector<int> temp;\\n        while(!q.empty()){\\n            TreeNode* node= q.front();\\n            q.pop();\\n\\n            if(node){\\n                temp.push_back(node-> val);\\n                if(node-> left) q.push(node->left);\\n                if(node-> right) q.push(node->right);\\n            }else{\\n                if(!q.empty()) q.push(NULL);\\n                ans.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n\\tint minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v(nums.size());\\n\\t    for(int i=0; i<nums.size();i++){\\n\\t        v[i]= {nums[i],i};\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int cnt=0;\\n\\t    int i=0;\\n\\t    while(i<nums.size()){\\n\\t        if(i != v[i].second){\\n\\t            int ogind= v[i].second;\\n\\t            swap(v[i],v[ogind]);\\n\\t            cnt++;\\n\\t        }else i++;\\n\\t    }\\n\\t    return cnt;\\n\\t}\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        vector<vector<int>> ans= levelOrder(root);\\n        int cnt=0;\\n        for(auto temp: ans){\\n            cnt += minSwaps(temp);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        vector<int> temp;\\n        while(!q.empty()){\\n            TreeNode* node= q.front();\\n            q.pop();\\n\\n            if(node){\\n                temp.push_back(node-> val);\\n                if(node-> left) q.push(node->left);\\n                if(node-> right) q.push(node->right);\\n            }else{\\n                if(!q.empty()) q.push(NULL);\\n                ans.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n\\tint minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v(nums.size());\\n\\t    for(int i=0; i<nums.size();i++){\\n\\t        v[i]= {nums[i],i};\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int cnt=0;\\n\\t    int i=0;\\n\\t    while(i<nums.size()){\\n\\t        if(i != v[i].second){\\n\\t            int ogind= v[i].second;\\n\\t            swap(v[i],v[ogind]);\\n\\t            cnt++;\\n\\t        }else i++;\\n\\t    }\\n\\t    return cnt;\\n\\t}\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        vector<vector<int>> ans= levelOrder(root);\\n        int cnt=0;\\n        for(auto temp: ans){\\n            cnt += minSwaps(temp);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704891,
                "title": "breadth-first-search-queue-array-sorting-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst level order then number of operation to sort that level\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst using queue we do level order traversal and store a level in vector(v) have map for storing index of position of element in that vector\\nthen one more vector orig for storing element in sorted order with the help of map we can do it.\\nelement that is not present on right position increment out count but there is a chance that one single operation help to put two element on their right position\\nthen for number of operation calculation   we start by putting  element in correct order  from sorted order (orig vector) so we find \\nint mpor = mp[orig[i]];\\nint mpvi = mp[v[i]];\\nposition to be swap in v so that v is in sorted order \\nupdate map  with new index\\nmp[v[i]]=mpor;\\nmp[orig[i]] = mpvi;\\n\\n// swap v vector\\nswap(v[mpor],v[mpvi]);\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(size of tree)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(size of tree)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int cnt = 0;\\n        while(!q.empty()){\\nint n = q.size();\\n            map<int,int>mp;\\n            vector<int>v;\\n            vector<int>orig;\\n            \\n            for(int i = 0;i<n;i++) {\\n                auto node = q.front();\\n                q.pop();\\n                v.push_back(node->val);\\n                mp[node->val]=i;\\n                \\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right) {\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n            for(auto it:mp) {\\n                orig.push_back(it.first);\\n            }\\n         \\n            for(int i = 0;i<n;i++) {\\n                if(mp[orig[i]]!=i) {\\n                    cnt++;              \\nint mpor = mp[orig[i]];\\nint mpvi = mp[v[i]];\\nmp[v[i]]=mpor;\\nmp[orig[i]] = mpvi;\\nswap(v[mpor],v[mpvi]);\\n\\n               \\n                     }\\n            }\\n            cout<<cnt<<endl;\\n                 \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int cnt = 0;\\n        while(!q.empty()){\\nint n = q.size();\\n            map<int,int>mp;\\n            vector<int>v;\\n            vector<int>orig;\\n            \\n            for(int i = 0;i<n;i++) {\\n                auto node = q.front();\\n                q.pop();\\n                v.push_back(node->val);\\n                mp[node->val]=i;\\n                \\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right) {\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n            for(auto it:mp) {\\n                orig.push_back(it.first);\\n            }\\n         \\n            for(int i = 0;i<n;i++) {\\n                if(mp[orig[i]]!=i) {\\n                    cnt++;              \\nint mpor = mp[orig[i]];\\nint mpvi = mp[v[i]];\\nmp[v[i]]=mpor;\\nmp[orig[i]] = mpvi;\\nswap(v[mpor],v[mpvi]);\\n\\n               \\n                     }\\n            }\\n            cout<<cnt<<endl;\\n                 \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3694033,
                "title": "sorting-bfs",
                "content": "class Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int swaps=0;\\n        if(!root)\\n            return swaps;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\nint s=q.size();\\n            vector<int>temp;\\n            for(int i=0;i<s;i++){\\nTreeNode *node=q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n            vector<pair<int, int>>v;\\n            for(int i=0;i<temp.size();i++){\\n v.push_back({temp[i], i}); \\n            }\\n            sort(v.begin(), v.end());\\n            for(int i=0;i<temp.size();i++){\\n    pair<int,int>p=v[i];\\n                int ele=p.first;\\n                int index=p.second;\\n                if(i!=index){\\n swap(v[i],v[index]);\\n                    i--;\\n                    swaps+=1;\\n                }\\n            }\\n        }\\n        return swaps;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int swaps=0;\\n        if(!root)\\n            return swaps;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\nint s=q.size();\\n            vector<int>temp;\\n            for(int i=0;i<s;i++){\\nTreeNode *node=q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3692682,
                "title": "simple-cycle-detection-full-detail-explanation-c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Prerequsite level order traversal(BFS).\\n\\nAfter reading question we can easily see that we have to just find number of swap operations needed to sort each level.\\n- This can be easily done by visualizing the problem as a graph. We will have N nodes and an edge directed from node i to node j if the element at the i\\u2019th index must be present at the j\\u2019th index in the sorted array.\\n- The graph will now contain many non-intersecting cycles. Now a cycle with 2 nodes will only require 1 swap to reach the correct ordering, similarly, a cycle with 3 nodes will only require 2 swaps to do so. \\n[]()\\n![image.png](https://assets.leetcode.com/users/images/cfbe01e1-663e-4e86-bf69-2332468e37ec_1687948207.7437716.png)\\n***Graph for {4, 5, 2, 1, 3}***\\n**Source:**[GFG](https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/)\\n\\n- Hence, ans = \\u03A3(cycle_size \\u2013 1) for each level.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize a queue **$$q$$** and enqueue the root of the binary tree.\\n2. Initialize a variable **$$ans$$** to keep track of the minimum number of operations.\\n3. While the queue is not empty, perform the following steps:\\n    - Get the size of the current level$$(n)$$ by accessing the size of the queue.\\n    - Create an empty vector of pairs $$v$$ to store the values and indices of the nodes in the current level.\\n    - Iterate$$ n$$ times to process each node in the current level:\\n        - Dequeue a node it from the front of the queue.\\n        - Add the pair $${it->val, i}$$ to the vector v, where i represents the index of the node in the current level.\\n        - Enqueue the left and right child nodes of it if they exist.\\n    - Sort the vector v in ascending order based on the node values.\\n    - Create an empty vector of vectors edges to represent the adjacency list of the nodes in the current level.\\n    - Iterate over the sorted vector v and populate the adjacency list edges using the index information.\\n    - Create a boolean vector vis of size n to mark the visited nodes. Initialize all elements to false.\\n    - Iterate over each index i from 0 to n-1:\\n        - If the node at index i is not visited:\\n        - Initialize a variable count to 1 to count the number of nodes in the special tree.\\n        - Initialize a variable node to i.\\n        - Mark the node at index node as visited.\\n        - While the first element of the adjacency list for node is not equal to i:\\n            - Update node to the first element of the adjacency list for node.\\n            - Mark the node at index node as visited.\\n            - Increment count by 1.\\n        - Add count - 1 to ans to calculate the minimum number of operations required to transform the current connected component into a special tree.\\n4. Return the final value of **$$ans$$**.\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n    - Here, n is the number of nodes in the binary tree. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            vector<pair<int, int>> v;\\n            for(int i=0;i<n;i++){\\n                auto it = q.front();\\n                q.pop();\\n                v.push_back({it->val, i});\\n                st.insert(it->val);\\n                if(it->left){\\n                    q.push(it->left);\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                }\\n            }\\n            sort(v.begin(), v.end());\\n            vector<vector<int>> edges(n);\\n            for(int i=0;i<n;i++){\\n                edges[v[i].second].push_back(i);\\n            }\\n            vector<bool> vis(n,false);\\n            for(int i=0;i<n;i++){\\n                if(!vis[i]){\\n                    int count=1;\\n                    int node = i;\\n                    vis[node]=1;\\n                    while(edges[node][0]!=i){\\n                        node = edges[node][0];\\n                        vis[node]=true;\\n                        count++;\\n                    }\\n                    ans+=count-1;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            vector<pair<int, int>> v;\\n            for(int i=0;i<n;i++){\\n                auto it = q.front();\\n                q.pop();\\n                v.push_back({it->val, i});\\n                st.insert(it->val);\\n                if(it->left){\\n                    q.push(it->left);\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                }\\n            }\\n            sort(v.begin(), v.end());\\n            vector<vector<int>> edges(n);\\n            for(int i=0;i<n;i++){\\n                edges[v[i].second].push_back(i);\\n            }\\n            vector<bool> vis(n,false);\\n            for(int i=0;i<n;i++){\\n                if(!vis[i]){\\n                    int count=1;\\n                    int node = i;\\n                    vis[node]=1;\\n                    while(edges[node][0]!=i){\\n                        node = edges[node][0];\\n                        vis[node]=true;\\n                        count++;\\n                    }\\n                    ans+=count-1;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678202,
                "title": "c-count-number-of-swap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int cal(vector<int>&a){\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<a.size();i++){\\n            v.push_back({a[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        for(int i=0;i<a.size();i++){\\n            if(v[i].second==i){\\n                continue;\\n            } else {\\n                swap(v[i],v[v[i].second]);\\n                ans++;\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n    if(!root) return 0;\\n    queue<TreeNode*> q;\\n     int ans=0;\\n    vector<vector<int>> v;\\n    q.push(root);\\n    while(!q.empty()){\\n        int sz=q.size();\\n        vector<int> level;\\n        while(sz--){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(node->left!=NULL) q.push(node->left);\\n            if(node->right!=NULL) q.push(node->right);\\n            level.push_back(node->val);\\n        }\\n        ans+=cal(level);\\n\\n    } \\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int cal(vector<int>&a){\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<a.size();i++){\\n            v.push_back({a[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        for(int i=0;i<a.size();i++){\\n            if(v[i].second==i){\\n                continue;\\n            } else {\\n                swap(v[i],v[v[i].second]);\\n                ans++;\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n    if(!root) return 0;\\n    queue<TreeNode*> q;\\n     int ans=0;\\n    vector<vector<int>> v;\\n    q.push(root);\\n    while(!q.empty()){\\n        int sz=q.size();\\n        vector<int> level;\\n        while(sz--){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(node->left!=NULL) q.push(node->left);\\n            if(node->right!=NULL) q.push(node->right);\\n            level.push_back(node->val);\\n        }\\n        ans+=cal(level);\\n\\n    } \\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676559,
                "title": "easy-understanding-bfs-level-order-traversal-c-begginer-freindly",
                "content": "Easy Understanding | BFS| LEVEL ORDER TRAVERSAL| C++| Begginer Freindly\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\n    \\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<vector<int> > res;\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> temp;\\n            while(size--){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            res.push_back(temp);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<res.size(); i++){\\n            if(!is_sorted(res[i].begin(), res[i].end() ) ){\\n                ans+= minSwaps(res[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\n    \\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<vector<int> > res;\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> temp;\\n            while(size--){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            res.push_back(temp);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<res.size(); i++){\\n            if(!is_sorted(res[i].begin(), res[i].end() ) ){\\n                ans+= minSwaps(res[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673547,
                "title": "level-order-traversal-java-min-swaps-logic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int res = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            List<Integer> child = new ArrayList<>();\\n            for(int i=0; i<n; i++){\\n                TreeNode temp = q.poll();\\n                child.add(temp.val);\\n                if(temp.left != null){\\n                    q.offer(temp.left);\\n                }\\n                if(temp.right != null){\\n                    q.offer(temp.right);\\n                }\\n            }\\n            res += helper(child.stream().mapToInt(i -> i).toArray());\\n        }\\n\\n        return res;\\n    }\\n\\n    public static int helper(int arr[]){\\n        int ans = 0;\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++){\\n            map.put(arr[i], i);\\n        }\\n\\n        Arrays.sort(arr);\\n\\n        boolean vis[] = new boolean[arr.length];\\n\\n        Arrays.fill(vis, false);\\n\\n        for(int i = 0; i<arr.length; i++){\\n            if(vis[i] || map.get(arr[i]) == i){\\n                continue;\\n            }\\n\\n            int j = i;\\n            int tempAns = 0;\\n            while(!vis[j]){\\n                vis[j] = true;\\n                j = map.get(arr[j]);\\n                tempAns++;\\n            }\\n\\n            if(tempAns > 0){\\n                ans += (tempAns - 1);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int res = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            List<Integer> child = new ArrayList<>();\\n            for(int i=0; i<n; i++){\\n                TreeNode temp = q.poll();\\n                child.add(temp.val);\\n                if(temp.left != null){\\n                    q.offer(temp.left);\\n                }\\n                if(temp.right != null){\\n                    q.offer(temp.right);\\n                }\\n            }\\n            res += helper(child.stream().mapToInt(i -> i).toArray());\\n        }\\n\\n        return res;\\n    }\\n\\n    public static int helper(int arr[]){\\n        int ans = 0;\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++){\\n            map.put(arr[i], i);\\n        }\\n\\n        Arrays.sort(arr);\\n\\n        boolean vis[] = new boolean[arr.length];\\n\\n        Arrays.fill(vis, false);\\n\\n        for(int i = 0; i<arr.length; i++){\\n            if(vis[i] || map.get(arr[i]) == i){\\n                continue;\\n            }\\n\\n            int j = i;\\n            int tempAns = 0;\\n            while(!vis[j]){\\n                vis[j] = true;\\n                j = map.get(arr[j]);\\n                tempAns++;\\n            }\\n\\n            if(tempAns > 0){\\n                ans += (tempAns - 1);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672722,
                "title": "c-easy-solution-level-order-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(vector<int>& a)\\n    {\\n        int n=a.size();\\n        vector<int> v=a;\\n        sort(v.begin(),v.end());\\n        map<int,int> m;\\n        for(int i=0;i<n;i++) m[v[i]]=i;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(m[a[i]]!=i){\\n                swap(a[i],a[m[a[i]]]);\\n                cnt++;\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int> v;\\n            for(int i=0;i<s;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                v.push_back(node->val);\\n            }\\n            ans+=helper(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(vector<int>& a)\\n    {\\n        int n=a.size();\\n        vector<int> v=a;\\n        sort(v.begin(),v.end());\\n        map<int,int> m;\\n        for(int i=0;i<n;i++) m[v[i]]=i;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(m[a[i]]!=i){\\n                swap(a[i],a[m[a[i]]]);\\n                cnt++;\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int> v;\\n            for(int i=0;i<s;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                v.push_back(node->val);\\n            }\\n            ans+=helper(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670251,
                "title": "easy-c-solution-using-map-and-minimum-number-of-swaps-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid swap(vector<int>& arr, int i, int j)\\n{\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = 0;\\n        q.push(NULL);\\n        while(q.empty() == false){\\n            auto curr = q.front();\\n            //q.pop();\\n            if(curr == NULL){\\n                q.pop();\\n                if(q.empty())\\n                    return ans;\\n                q.push(NULL);\\n                continue;\\n            }\\n            vector<int> temp,tt;\\n            unordered_map<int,int> mp;\\n            int i = 0;\\n            while(q.front()!=NULL){\\n                if(q.front()->left){\\n                    temp.push_back(q.front()->left->val);\\n                    tt.push_back(q.front()->left->val);\\n                    mp[q.front()->left->val] = i;\\n                    q.push(q.front()->left);\\n                    i++;\\n                }\\n                if(q.front()->right){\\n                    mp[q.front()->right->val] = i;\\n                    tt.push_back(q.front()->right->val);\\n                    i++;\\n                    temp.push_back(q.front()->right->val);\\n                    q.push(q.front()->right);\\n                }\\n                q.pop();\\n            }\\n            sort(temp.begin(),temp.end());\\n            for(int j = 0;j<temp.size();j++){\\n                if(temp[j] == tt[j]){\\n                    continue;\\n                }\\n                else{\\n                    ans++;\\n                    int x = tt[j];\\n                    swap(tt,j,mp[temp[j]]);\\n\\n                    mp[x] = mp[temp[j]];\\n                    mp[temp[j]] = j;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid swap(vector<int>& arr, int i, int j)\\n{\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = 0;\\n        q.push(NULL);\\n        while(q.empty() == false){\\n            auto curr = q.front();\\n            //q.pop();\\n            if(curr == NULL){\\n                q.pop();\\n                if(q.empty())\\n                    return ans;\\n                q.push(NULL);\\n                continue;\\n            }\\n            vector<int> temp,tt;\\n            unordered_map<int,int> mp;\\n            int i = 0;\\n            while(q.front()!=NULL){\\n                if(q.front()->left){\\n                    temp.push_back(q.front()->left->val);\\n                    tt.push_back(q.front()->left->val);\\n                    mp[q.front()->left->val] = i;\\n                    q.push(q.front()->left);\\n                    i++;\\n                }\\n                if(q.front()->right){\\n                    mp[q.front()->right->val] = i;\\n                    tt.push_back(q.front()->right->val);\\n                    i++;\\n                    temp.push_back(q.front()->right->val);\\n                    q.push(q.front()->right);\\n                }\\n                q.pop();\\n            }\\n            sort(temp.begin(),temp.end());\\n            for(int j = 0;j<temp.size();j++){\\n                if(temp[j] == tt[j]){\\n                    continue;\\n                }\\n                else{\\n                    ans++;\\n                    int x = tt[j];\\n                    swap(tt,j,mp[temp[j]]);\\n\\n                    mp[x] = mp[temp[j]];\\n                    mp[temp[j]] = j;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658548,
                "title": "dsu-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing find and join method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst store the elements is level order. Then for each row sort them. Then for index find which element must be there and where it is currently.\\nExample- 9 4 12 5 (sorted array and corresponding index- ({4,1},{5,3},{9,0},{12,2}))\\n1st pass- 4 9 12 5\\n2nd pass- 4 5 12 5\\n3rd pass- we want 9 in index=2 and its initial index was 0 but it is currently at index=3.\\nSo, at every pass we join the index where element is getting swapped.\\nSo, 0->1 in 1st pass, 1->3 in second pass. So, the chain becomes 0->1->3;\\nSo, in 3rd pass when we want to find element at index 0 and it leads to current index 3 where 9 is present. \\n# Complexity\\n- Time complexity: Nlog(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void level_order(TreeNode* root, int level,unordered_map<int,vector<int>>& um){\\n        if(!root) return;\\n        um[level].push_back(root->val);\\n        level_order(root->left,level-1,um);\\n        level_order(root->right,level-1,um);\\n    }\\n    int find(int i,vector<int>& arr){\\n        while(arr[i]!=i) {arr[i]=arr[arr[i]];i=arr[i];}\\n        return arr[i];\\n    }\\n    void join(int i,int j,vector<int>& arr){\\n        int p1= find(i,arr);\\n        int p2=find(j,arr);\\n        arr[p1]=p2;\\n    }\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        unordered_map<int,vector<int>> um;\\n        level_order(root,0,um);\\n\\n        int ans=0;\\n        for(auto it:um){\\n            vector<int> v= it.second;\\n            vector<pair<int,int>> arr;\\n            vector<int> pos(v.size());\\n            for(int i=0;i<v.size();i++){\\n                arr.push_back({v[i],i});\\n                pos[i]=i;\\n            }\\n            \\n            sort(arr.begin(),arr.end());\\n            for(int i=0;i<v.size();i++){\\n                if(v[i]!=arr[i].first){\\n                    ++ans;\\n                    int temp= find(arr[i].second,pos);\\n                    swap(v[i],v[temp]);\\n                    join(i,temp,pos);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void level_order(TreeNode* root, int level,unordered_map<int,vector<int>>& um){\\n        if(!root) return;\\n        um[level].push_back(root->val);\\n        level_order(root->left,level-1,um);\\n        level_order(root->right,level-1,um);\\n    }\\n    int find(int i,vector<int>& arr){\\n        while(arr[i]!=i) {arr[i]=arr[arr[i]];i=arr[i];}\\n        return arr[i];\\n    }\\n    void join(int i,int j,vector<int>& arr){\\n        int p1= find(i,arr);\\n        int p2=find(j,arr);\\n        arr[p1]=p2;\\n    }\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        unordered_map<int,vector<int>> um;\\n        level_order(root,0,um);\\n\\n        int ans=0;\\n        for(auto it:um){\\n            vector<int> v= it.second;\\n            vector<pair<int,int>> arr;\\n            vector<int> pos(v.size());\\n            for(int i=0;i<v.size();i++){\\n                arr.push_back({v[i],i});\\n                pos[i]=i;\\n            }\\n            \\n            sort(arr.begin(),arr.end());\\n            for(int i=0;i<v.size();i++){\\n                if(v[i]!=arr[i].first){\\n                    ++ans;\\n                    int temp= find(arr[i].second,pos);\\n                    swap(v[i],v[temp]);\\n                    join(i,temp,pos);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643590,
                "title": "ten-liner-readable-solution-1620-ms-beats-100",
                "content": "# Code\\n```\\nfunc minimumOperations(_ root: TreeNode?) -> Int {\\n    minimumOperations(0, [root!])\\n}\\n\\nprivate func minimumOperations(_ count: Int, _ stack: [TreeNode]) -> Int {\\n    stack.isEmpty ? count : minimumOperations(\\n        count + sortCount(stack.map(\\\\.val)), \\n        stack.flatMap { [$0.left, $0.right] }.compactMap { $0 }\\n    )\\n}\\n\\nprivate func sortCount(_ arr: [Int]) -> Int {\\n    let increased = arr.sorted()\\n    var arr = arr\\n    var count = 0\\n    for i in arr.indices where arr[i] != increased[i] {\\n        arr.swapAt(i, arr[i...].firstIndex { $0 == increased[i] }!)\\n        count += 1\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc minimumOperations(_ root: TreeNode?) -> Int {\\n    minimumOperations(0, [root!])\\n}\\n\\nprivate func minimumOperations(_ count: Int, _ stack: [TreeNode]) -> Int {\\n    stack.isEmpty ? count : minimumOperations(\\n        count + sortCount(stack.map(\\\\.val)), \\n        stack.flatMap { [$0.left, $0.right] }.compactMap { $0 }\\n    )\\n}\\n\\nprivate func sortCount(_ arr: [Int]) -> Int {\\n    let increased = arr.sorted()\\n    var arr = arr\\n    var count = 0\\n    for i in arr.indices where arr[i] != increased[i] {\\n        arr.swapAt(i, arr[i...].firstIndex { $0 == increased[i] }!)\\n        count += 1\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3614909,
                "title": "level-wise-traversal-map-c-easy-explained-in-comments",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(vector<int>&v,unordered_map<int,int> &m){\\n         vector<int> s = v;\\n         sort(s.begin(),s.end());\\n         int ans = 0;\\n         int n = v.size();\\n         for(int i =0;i<n;i++){\\n               if(v[i] != s[i]){\\n                   ans++;\\n                //    int temp = m[v[i]];\\n                   //  updating  the map \\n                           /*\\n                 at first we need to swap 7 and 5 \\n                 map \\n                 7-->0\\n                 6-->1\\n                 8-->2\\n                 5-->3\\n                \\n                first we are changing the map\\n\\n                it becomes \\n                m[v[i]] -- > m[7] --> m[s[i]] (m[5]) --> 3\\n                7-->3\\n                m[s[i]]  m[5] = i --> 0\\n                \\n                5-->0\\n                updated map \\n                 \\n                 7-->3\\n                 6-->1\\n                 8-->2\\n                 5-->0\\n\\n                after this value swap \\n\\n                \\n\\n\\n                to know the index of the 5 before the index change we need to get the index from the changed map so \\n                v[m[v[i]]]  = v[i]\\n                 i.e\\n                 v[m[7]]  = 5;\\n                 v[3] = 5;\\n\\n                 and for the start value \\n\\n                 v[i] = s[i]\\n                \\n                \\nwe can also use differnt ways for swapping \\n*/\\n                   m[v[i]] = m[s[i]];\\n                   m[s[i]] = i;\\n                // swaping the two values in the vector\\n\\n                v[m[v[i]]] = v[i];\\n                v[i] = s[i];\\n\\n\\n               }\\n         }\\n         return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        TreeNode * head = root;\\n        int ans = 0;\\n        queue<TreeNode *> q;\\n        q.push(head);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            int ind = 0;\\n            unordered_map<int,int> m;\\n            for(int i = 0;i<sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int value = temp->val;\\n                v.push_back(value);\\n                m[temp->val] = ind;\\n                ind++;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n\\n            }\\n            ans+= count(v,m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(vector<int>&v,unordered_map<int,int> &m){\\n         vector<int> s = v;\\n         sort(s.begin(),s.end());\\n         int ans = 0;\\n         int n = v.size();\\n         for(int i =0;i<n;i++){\\n               if(v[i] != s[i]){\\n                   ans++;\\n                //    int temp = m[v[i]];\\n                   //  updating  the map \\n                           /*\\n                 at first we need to swap 7 and 5 \\n                 map \\n                 7-->0\\n                 6-->1\\n                 8-->2\\n                 5-->3\\n                \\n                first we are changing the map\\n\\n                it becomes \\n                m[v[i]] -- > m[7] --> m[s[i]] (m[5]) --> 3\\n                7-->3\\n                m[s[i]]  m[5] = i --> 0\\n                \\n                5-->0\\n                updated map \\n                 \\n                 7-->3\\n                 6-->1\\n                 8-->2\\n                 5-->0\\n\\n                after this value swap \\n\\n                \\n\\n\\n                to know the index of the 5 before the index change we need to get the index from the changed map so \\n                v[m[v[i]]]  = v[i]\\n                 i.e\\n                 v[m[7]]  = 5;\\n                 v[3] = 5;\\n\\n                 and for the start value \\n\\n                 v[i] = s[i]\\n                \\n                \\nwe can also use differnt ways for swapping \\n*/\\n                   m[v[i]] = m[s[i]];\\n                   m[s[i]] = i;\\n                // swaping the two values in the vector\\n\\n                v[m[v[i]]] = v[i];\\n                v[i] = s[i];\\n\\n\\n               }\\n         }\\n         return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        TreeNode * head = root;\\n        int ans = 0;\\n        queue<TreeNode *> q;\\n        q.push(head);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            int ind = 0;\\n            unordered_map<int,int> m;\\n            for(int i = 0;i<sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int value = temp->val;\\n                v.push_back(value);\\n                m[temp->val] = ind;\\n                ind++;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n\\n            }\\n            ans+= count(v,m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576142,
                "title": "bfs-dfs-move-semantics-speed-98-1-memory-99-8",
                "content": "# Intuition\\ngo through each level, sort the entire level, and compare to the origin indices\\n\\n# Approach\\nuse BFS to go through each level, record the value and index in a vector, sort the vector by value, use DFS to calc the index shift count, use move-semamtics as possible.\\n\\n# Complexity\\n- Time complexity:\\nbound by sorting the leaf nodes from a perfect tree: \\nO((n/2) * log(n/2)) = O(n * log(n))\\n\\n- Space complexity:\\nbound by holding the leaf nodes from a perfect tree: \\nO(n/2) = O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs_swap(vector<pair<int, int>>& v, int i, int& res) {\\n        int j = v[i].second;\\n        if (j != i) {\\n            ++res;\\n            swap(v[i], v[j]);\\n            dfs_swap(v, i, res);\\n        }\\n    }\\n\\n    int calc(vector<pair<int, int>>& v) {\\n        sort(v.begin(), v.end());\\n        int res = 0;\\n        for (int i = 0, len = v.size(); i < len; ++i) {\\n            dfs_swap(v, i, res);\\n        }\\n        return res;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ret = 0;\\n        vector<pair<int, int>> v;\\n        while (!q.empty()) {\\n            int len = q.size();\\n            v.clear();\\n            for (int i = 0; i < len; ++i) {\\n                auto n = q.front();\\n                v.emplace_back(n->val, i);\\n                if (n->left)\\n                    q.push(n->left);\\n                if (n->right)\\n                    q.push(n->right);\\n                q.pop();\\n            }\\n            ret += calc(v);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs_swap(vector<pair<int, int>>& v, int i, int& res) {\\n        int j = v[i].second;\\n        if (j != i) {\\n            ++res;\\n            swap(v[i], v[j]);\\n            dfs_swap(v, i, res);\\n        }\\n    }\\n\\n    int calc(vector<pair<int, int>>& v) {\\n        sort(v.begin(), v.end());\\n        int res = 0;\\n        for (int i = 0, len = v.size(); i < len; ++i) {\\n            dfs_swap(v, i, res);\\n        }\\n        return res;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ret = 0;\\n        vector<pair<int, int>> v;\\n        while (!q.empty()) {\\n            int len = q.size();\\n            v.clear();\\n            for (int i = 0; i < len; ++i) {\\n                auto n = q.front();\\n                v.emplace_back(n->val, i);\\n                if (n->left)\\n                    q.push(n->left);\\n                if (n->right)\\n                    q.push(n->right);\\n                q.pop();\\n            }\\n            ret += calc(v);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538749,
                "title": "java-easy-bigger-but-better",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        bfs(q, levels, root);\\n        return minOperations(levels);\\n    }\\n    private void bfs(Queue<TreeNode> q, List<List<Integer>> levels, TreeNode root){\\n        int curr_level = -1;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            ++ curr_level;\\n            levels.add(new ArrayList<>());\\n            for(int i = 0; i < s; i ++){\\n                TreeNode node = q.poll();\\n                levels.get(curr_level).add(node.val);\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n        }\\n    }\\n    private int minOperations(List<List<Integer>> levels){\\n        int ans = 0;\\n        for(List<Integer> li: levels){\\n            int s = li.size();\\n            int[] sorted = new int[s];\\n            for(int i = 0; i < s; i ++)\\n                sorted[i] = li.get(i);\\n            Arrays.sort(sorted);\\n            Map<Integer, Integer> ind = new HashMap<>();\\n            for(int i = 0; i < s; i ++){\\n                ind.put(sorted[i], i);\\n            }\\n\\n            for(int i = 0; i < s; i ++){\\n                if(sorted[i] != li.get(i)){\\n                    ++ ans;\\n                    int j = ind.get(li.get(i));\\n                    ind.put(li.get(i), i);\\n                    ind.put(sorted[i], j);\\n                    int t = sorted[i];\\n                    sorted[i] = li.get(i);\\n                    sorted[j] = t;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        bfs(q, levels, root);\\n        return minOperations(levels);\\n    }\\n    private void bfs(Queue<TreeNode> q, List<List<Integer>> levels, TreeNode root){\\n        int curr_level = -1;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            ++ curr_level;\\n            levels.add(new ArrayList<>());\\n            for(int i = 0; i < s; i ++){\\n                TreeNode node = q.poll();\\n                levels.get(curr_level).add(node.val);\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n        }\\n    }\\n    private int minOperations(List<List<Integer>> levels){\\n        int ans = 0;\\n        for(List<Integer> li: levels){\\n            int s = li.size();\\n            int[] sorted = new int[s];\\n            for(int i = 0; i < s; i ++)\\n                sorted[i] = li.get(i);\\n            Arrays.sort(sorted);\\n            Map<Integer, Integer> ind = new HashMap<>();\\n            for(int i = 0; i < s; i ++){\\n                ind.put(sorted[i], i);\\n            }\\n\\n            for(int i = 0; i < s; i ++){\\n                if(sorted[i] != li.get(i)){\\n                    ++ ans;\\n                    int j = ind.get(li.get(i));\\n                    ind.put(li.get(i), i);\\n                    ind.put(sorted[i], j);\\n                    int t = sorted[i];\\n                    sorted[i] = li.get(i);\\n                    sorted[j] = t;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500841,
                "title": "c-with-the-use-of-binary-tree-level-order-traversal-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We will first find the level order Traversal of the given tree. \\nYou can see the solution for same with the help of below link\\n[https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3500823/c-line-by-line-code-explained/]()\\n- We will find swaps in reverse method , first we will store the our value with index , then we will sort it . After Sorting we will try to convert the array again back to normal form with the help of the index stored , we will swap the array until we get correct index .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSwaps(vector<int> v , int swaps){\\n        vector<pair<int, int>> p;\\n        for(int i =0 ; i <v.size();i++){\\n            p.push_back({v[i] , i});\\n        }\\n        sort(p.begin(),p.end());\\n        int i =0;\\n        for(int i= 0 ; i<p.size();i++){\\n\\n            while(p[i].second!=i){\\n                swap(p[i], p[p[i].second]);\\n                swaps++;\\n            }\\n        }\\n        return swaps;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        vector<int> v; \\n        vector<vector<int>> ans; \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            if(q.front()->left!=NULL){\\n                \\n                q.push(q.front()->left);\\n            }\\n            if(q.front()->right !=NULL){\\n                q.push(q.front()->right);\\n            }\\n            if(q.front()!=NULL){\\n                v.push_back(q.front()->val);\\n            }\\n            q.pop();\\n            if(q.front()==NULL){\\n                q.pop();\\n                ans.push_back(v);\\n                v.clear();\\n                if(!q.empty()){\\n                    q.push(NULL);\\n                }\\n                \\n            }\\n        }\\n        int swap = 0;\\n        for(int i=0;i<ans.size();i++){\\n            swap+=findSwaps(ans[i],0);\\n        }\\n        return swap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSwaps(vector<int> v , int swaps){\\n        vector<pair<int, int>> p;\\n        for(int i =0 ; i <v.size();i++){\\n            p.push_back({v[i] , i});\\n        }\\n        sort(p.begin(),p.end());\\n        int i =0;\\n        for(int i= 0 ; i<p.size();i++){\\n\\n            while(p[i].second!=i){\\n                swap(p[i], p[p[i].second]);\\n                swaps++;\\n            }\\n        }\\n        return swaps;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        vector<int> v; \\n        vector<vector<int>> ans; \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            if(q.front()->left!=NULL){\\n                \\n                q.push(q.front()->left);\\n            }\\n            if(q.front()->right !=NULL){\\n                q.push(q.front()->right);\\n            }\\n            if(q.front()!=NULL){\\n                v.push_back(q.front()->val);\\n            }\\n            q.pop();\\n            if(q.front()==NULL){\\n                q.pop();\\n                ans.push_back(v);\\n                v.clear();\\n                if(!q.empty()){\\n                    q.push(NULL);\\n                }\\n                \\n            }\\n        }\\n        int swap = 0;\\n        for(int i=0;i<ans.size();i++){\\n            swap+=findSwaps(ans[i],0);\\n        }\\n        return swap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496056,
                "title": "java",
                "content": "can cut to nlogn, too much overhead\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int ans=0;\\n        Queue<TreeNode> q= new LinkedList();\\n        q.offer(root);\\n        while(!(q.isEmpty())){\\n            int poll = q.size();\\n            int [] curLvl = new int [poll];\\n            for (int i=0;i<poll;i++){\\n                TreeNode next = q.poll();\\n                curLvl[i]=next.val;\\n                if (next.left!=null) q.offer(next.left);\\n                if (next.right!=null) q.offer(next.right);\\n            }       \\n            if (poll>1) ans+=countSwaps(curLvl);\\n            //if (poll==4) return ans*1000;\\n        }\\n        return ans;\\n    }\\n\\n    public int countSwaps(int[] nums){\\n        int ans=0;\\n        for (int i=0;i<nums.length;i++){      \\n            int swap=-1,min=nums[i];  \\n            for (int j=i+1;j<nums.length;j++){        \\n                if (nums[j]<min){\\n                    min=nums[j];\\n                    swap=j;\\n                }\\n            }\\n            if (swap==-1) continue;\\n            int tmp = nums[i];\\n            nums[i]=nums[swap];\\n            nums[swap]=tmp;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int ans=0;\\n        Queue<TreeNode> q= new LinkedList();\\n        q.offer(root);\\n        while(!(q.isEmpty())){\\n            int poll = q.size();\\n            int [] curLvl = new int [poll];\\n            for (int i=0;i<poll;i++){\\n                TreeNode next = q.poll();\\n                curLvl[i]=next.val;\\n                if (next.left!=null) q.offer(next.left);\\n                if (next.right!=null) q.offer(next.right);\\n            }       \\n            if (poll>1) ans+=countSwaps(curLvl);\\n            //if (poll==4) return ans*1000;\\n        }\\n        return ans;\\n    }\\n\\n    public int countSwaps(int[] nums){\\n        int ans=0;\\n        for (int i=0;i<nums.length;i++){      \\n            int swap=-1,min=nums[i];  \\n            for (int j=i+1;j<nums.length;j++){        \\n                if (nums[j]<min){\\n                    min=nums[j];\\n                    swap=j;\\n                }\\n            }\\n            if (swap==-1) continue;\\n            int tmp = nums[i];\\n            nums[i]=nums[swap];\\n            nums[swap]=tmp;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474706,
                "title": "python3-minimum-operations-to-make-a-tree-sorted",
                "content": "# Intuition\\n\\nThe problem asks to find the minimum number of swaps needed to sort each level of a binary tree. One approach could be to perform a Breadth First Search (BFS) traversal and check if each level is already sorted, otherwise calculate the minimum number of swaps needed to sort the level using an implementation of the minimum swaps algorithm for an array.\\n# Heading\\nApproach:-\\n\\nWe can perform a BFS traversal and check if each level is already sorted. If not, we can use the minimum swaps algorithm for an array to calculate the minimum number of swaps needed to sort the level. To implement the minimum swaps algorithm for an array, we can use an ordered dictionary to store the indices of each element in the input array. We can then sort the ordered dictionary by the values and swap the elements to sort the array while keeping track of the number of swaps needed. We can use this implementation to calculate the minimum number of swaps needed to sort each level of the binary tree.\\n\\n# Complexity\\n\\nTime complexity: The time complexity of the BFS traversal is O(N) where N is the number of nodes in the binary tree. The time complexity of the minimum swaps algorithm is O(NlogN) where N is the number of elements in the input array. Therefore, the overall time complexity of the solution is O(N^2logN).\\nSpace complexity: The space complexity of the BFS traversal is O(N) where N is the number of nodes in the binary tree. The space complexity of the minimum swaps algorithm is O(N) where N is the number of elements in the input array. Therefore, the overall space complexity of the solution is O(N).\\n\\n# Code\\n\\n```\\nfrom typing import Optional\\nfrom collections import deque, OrderedDict\\n\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        def minSwaps(nums):\\n            dic = OrderedDict()\\n            for i in range(len(nums)):\\n                dic[nums[i]] = i\\n            sorted_dic = OrderedDict(sorted(dic.items()))\\n            swaps = 0\\n            for i, v in enumerate(sorted_dic.values()):\\n                if i != v:\\n                    nums[i], nums[v] = nums[v], nums[i]\\n                    dic[nums[i]], dic[nums[v]] = dic[nums[v]], dic[nums[i]]\\n                    sorted_dic[nums[i]], sorted_dic[nums[v]] = sorted_dic[nums[v]], sorted_dic[nums[i]]\\n                    swaps += 1\\n            return swaps\\n        \\n        if root is None:\\n            return 0\\n        \\n        bfs = []\\n        q = deque([root])\\n        level = 0\\n        count = 0\\n        \\n        while q:\\n            level += 1\\n            curr_level = []\\n            for i in range(len(q)):\\n                curr = q.popleft()\\n                curr_level.append(curr.val)\\n                if curr.left is not None:\\n                    q.append(curr.left)\\n                if curr.right is not None:\\n                    q.append(curr.right)\\n            \\n            # Check if current level is already sorted\\n            if curr_level == sorted(curr_level):\\n                continue\\n            else:\\n                count += minSwaps(curr_level)\\n            \\n            bfs.append(curr_level)\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import Optional\\nfrom collections import deque, OrderedDict\\n\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        def minSwaps(nums):\\n            dic = OrderedDict()\\n            for i in range(len(nums)):\\n                dic[nums[i]] = i\\n            sorted_dic = OrderedDict(sorted(dic.items()))\\n            swaps = 0\\n            for i, v in enumerate(sorted_dic.values()):\\n                if i != v:\\n                    nums[i], nums[v] = nums[v], nums[i]\\n                    dic[nums[i]], dic[nums[v]] = dic[nums[v]], dic[nums[i]]\\n                    sorted_dic[nums[i]], sorted_dic[nums[v]] = sorted_dic[nums[v]], sorted_dic[nums[i]]\\n                    swaps += 1\\n            return swaps\\n        \\n        if root is None:\\n            return 0\\n        \\n        bfs = []\\n        q = deque([root])\\n        level = 0\\n        count = 0\\n        \\n        while q:\\n            level += 1\\n            curr_level = []\\n            for i in range(len(q)):\\n                curr = q.popleft()\\n                curr_level.append(curr.val)\\n                if curr.left is not None:\\n                    q.append(curr.left)\\n                if curr.right is not None:\\n                    q.append(curr.right)\\n            \\n            # Check if current level is already sorted\\n            if curr_level == sorted(curr_level):\\n                continue\\n            else:\\n                count += minSwaps(curr_level)\\n            \\n            bfs.append(curr_level)\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469679,
                "title": "neatest-code-faang-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint help(vector<int> v)\\n{\\n    if(v.size()==1)\\n    return 0 ;\\n    int res = 0 ;  \\n    vector<pair<int,int>> p ; \\n    for(int i = 0 ; i<v.size();i++)\\n    p.push_back({v[i],i});\\n    sort(p.begin(),p.end());\\n    for(int i = 0 ; i<p.size();i++)\\n    {\\n        if(p[i].second==i)\\n        continue; \\n        while(p[i].second!=i)\\n        {\\n            res++ ; \\n            swap(p[i],p[p[i].second]);\\n        }\\n    }\\n    \\n\\n\\n\\n\\n    return res;\\n\\n}\\n\\n    int minimumOperations(TreeNode* root) \\n    {\\n        queue<TreeNode* >q ;\\n        int ans = 0;  \\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size(); \\n            vector<int> v ; \\n            while(k--)\\n            {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            v.push_back(curr->val);\\n            if(curr->left) q.push(curr->left);\\n            if(curr->right) q.push(curr->right);\\n            }\\n\\n            ans += help(v);\\n        }\\n        return ans;\\n        \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint help(vector<int> v)\\n{\\n    if(v.size()==1)\\n    return 0 ;\\n    int res = 0 ;  \\n    vector<pair<int,int>> p ; \\n    for(int i = 0 ; i<v.size();i++)\\n    p.push_back({v[i],i});\\n    sort(p.begin(),p.end());\\n    for(int i = 0 ; i<p.size();i++)\\n    {\\n        if(p[i].second==i)\\n        continue; \\n        while(p[i].second!=i)\\n        {\\n            res++ ; \\n            swap(p[i],p[p[i].second]);\\n        }\\n    }\\n    \\n\\n\\n\\n\\n    return res;\\n\\n}\\n\\n    int minimumOperations(TreeNode* root) \\n    {\\n        queue<TreeNode* >q ;\\n        int ans = 0;  \\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size(); \\n            vector<int> v ; \\n            while(k--)\\n            {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            v.push_back(curr->val);\\n            if(curr->left) q.push(curr->left);\\n            if(curr->right) q.push(curr->right);\\n            }\\n\\n            ans += help(v);\\n        }\\n        return ans;\\n        \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460124,
                "title": "minimum-number-of-operations-to-sort-a-binary-tree-by-level",
                "content": "--------------------- Easy C++ Solution -----------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint minimumOperations(TreeNode* root) {\\n        int result = 0;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while (!empty(q)) {\\n            \\n              int x=q.size();\\n            while (x-->0) {\\n                 TreeNode*front=q.front();\\n                 q.pop();\\n                if (front->left) {\\n                    q.push(front->left);\\n                }\\n                if (front->right) {\\n                    q.push(front->right);\\n                }\\n            }\\n            vector<pair<int,int>>p;\\n            queue<TreeNode*>t;\\n            int i=0;\\n            while(!q.empty()){\\n                TreeNode*f=q.front();\\n                t.push(f);\\n                q.pop();\\n\\n                p.push_back({f->val,i});\\n                i++;\\n            }\\n            sort(p.begin(),p.end());\\n\\n            for (int i = 0; i < size(p); ++i) {\\n                if(p[i].second==i) continue;\\n                else{\\n                    result++;\\n                    swap(p[i],p[p[i].second]);\\n                    i--;\\n                }\\n            }\\n           q=t; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minimumOperations(TreeNode* root) {\\n        int result = 0;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while (!empty(q)) {\\n            \\n              int x=q.size();\\n            while (x-->0) {\\n                 TreeNode*front=q.front();\\n                 q.pop();\\n                if (front->left) {\\n                    q.push(front->left);\\n                }\\n                if (front->right) {\\n                    q.push(front->right);\\n                }\\n            }\\n            vector<pair<int,int>>p;\\n            queue<TreeNode*>t;\\n            int i=0;\\n            while(!q.empty()){\\n                TreeNode*f=q.front();\\n                t.push(f);\\n                q.pop();\\n\\n                p.push_back({f->val,i});\\n                i++;\\n            }\\n            sort(p.begin(),p.end());\\n\\n            for (int i = 0; i < size(p); ++i) {\\n                if(p[i].second==i) continue;\\n                else{\\n                    result++;\\n                    swap(p[i],p[p[i].second]);\\n                    i--;\\n                }\\n            }\\n           q=t; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423800,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int MinimumOperations(TreeNode root) {\\n        var operations = 0;\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        while(queue.Count > 0) {\\n            var count = queue.Count;\\n            var list1 = new List<int>();\\n            var list2 = new List<int>();\\n            var map = new Dictionary<int, int>();\\n            for(int i = 0; i < count; i++) {\\n                var node = queue.Dequeue();\\n                if(node.left != null)\\n                    queue.Enqueue(node.left);\\n\\n                if(node.right != null)\\n                    queue.Enqueue(node.right); \\n\\n                list1.Add(node.val);\\n                list2.Add(node.val);\\n                map[node.val] = i;\\n            }\\n\\n            list2.Sort();\\n            Console.WriteLine(operations);\\n            operations += GetMinOperations(list1, list2, map);\\n        }\\n\\n        return operations;\\n    }\\n\\n    private int GetMinOperations(List<int> list, List<int> sortedList, Dictionary<int, int> map) {\\n        var operations = 0;\\n        for(int i = 0; i < list.Count; i++) {\\n            if(list[i] != sortedList[i]) {\\n                var temp = list[i];\\n                list[i] = sortedList[i];\\n                list[map[sortedList[i]]] = temp;\\n                map[temp] = map[sortedList[i]];\\n                operations++;\\n            }\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Sort",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int MinimumOperations(TreeNode root) {\\n        var operations = 0;\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        while(queue.Count > 0) {\\n            var count = queue.Count;\\n            var list1 = new List<int>();\\n            var list2 = new List<int>();\\n            var map = new Dictionary<int, int>();\\n            for(int i = 0; i < count; i++) {\\n                var node = queue.Dequeue();\\n                if(node.left != null)\\n                    queue.Enqueue(node.left);\\n\\n                if(node.right != null)\\n                    queue.Enqueue(node.right); \\n\\n                list1.Add(node.val);\\n                list2.Add(node.val);\\n                map[node.val] = i;\\n            }\\n\\n            list2.Sort();\\n            Console.WriteLine(operations);\\n            operations += GetMinOperations(list1, list2, map);\\n        }\\n\\n        return operations;\\n    }\\n\\n    private int GetMinOperations(List<int> list, List<int> sortedList, Dictionary<int, int> map) {\\n        var operations = 0;\\n        for(int i = 0; i < list.Count; i++) {\\n            if(list[i] != sortedList[i]) {\\n                var temp = list[i];\\n                list[i] = sortedList[i];\\n                list[map[sortedList[i]]] = temp;\\n                map[temp] = map[sortedList[i]];\\n                operations++;\\n            }\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398505,
                "title": "log-n-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int find(vector<int> a){\\n        int n=a.size();\\n        map<int,int>mp;\\n        for(int i=0;i<a.size();i++){\\n            cout<<a[i]<<\" \";\\n            mp[a[i]]=i;\\n        }\\n        cout<<endl;\\n        int ans=0;\\n        int vis[n];\\n        memset(vis,0,sizeof vis);\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==1 || mp[a[i]]==i){\\n                continue;\\n            }\\n            int j=i,cy=0;\\n            while(vis[j]!=1){\\n                vis[j]=1;\\n                j=mp[a[j]];\\n                cy++;\\n            }\\n            if(cy>0){\\n                ans+=cy-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*>temp;\\n        temp.push(root);\\n        while(temp.size()){\\n            vector<int>curr;\\n            int n=temp.size();\\n            while(n--){\\n               TreeNode* t=temp.front();\\n               temp.pop();\\n               curr.push_back(t->val);\\n               if(t->left!=NULL)temp.push(t->left);\\n               if(t->right!=NULL)temp.push(t->right);\\n            }\\n            ans+=find(curr);\\n        }\\n        return ans;\\n    }\\n\\n    Solution(){\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int find(vector<int> a){\\n        int n=a.size();\\n        map<int,int>mp;\\n        for(int i=0;i<a.size();i++){\\n            cout<<a[i]<<\" \";\\n            mp[a[i]]=i;\\n        }\\n        cout<<endl;\\n        int ans=0;\\n        int vis[n];\\n        memset(vis,0,sizeof vis);\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==1 || mp[a[i]]==i){\\n                continue;\\n            }\\n            int j=i,cy=0;\\n            while(vis[j]!=1){\\n                vis[j]=1;\\n                j=mp[a[j]];\\n                cy++;\\n            }\\n            if(cy>0){\\n                ans+=cy-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*>temp;\\n        temp.push(root);\\n        while(temp.size()){\\n            vector<int>curr;\\n            int n=temp.size();\\n            while(n--){\\n               TreeNode* t=temp.front();\\n               temp.pop();\\n               curr.push_back(t->val);\\n               if(t->left!=NULL)temp.push(t->left);\\n               if(t->right!=NULL)temp.push(t->right);\\n            }\\n            ans+=find(curr);\\n        }\\n        return ans;\\n    }\\n\\n    Solution(){\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3394262,
                "title": "count-swapping-circle-beat-100",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n)^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\n\\nclass Solution:\\n\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        queue = deque()\\n        queue.append(root)\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                node = queue.popleft()\\n                if (left := node.left):\\n                    queue.append(left)\\n                if (right := node.right):\\n                    queue.append(right)\\n            if queue:\\n                res += self.insertSortSwapCount([node.val for node in queue])\\n        return res\\n    \\n    def insertSortSwapCount(self, nums: List[int]) -> int:\\n        swapCount = 0\\n        sortedPosList = list(range(len(nums)))\\n        sortedPosList.sort(key=lambda x: nums[x])\\n        for i in range(len(sortedPosList)):\\n            while (originalPos := sortedPosList[i]) != i:\\n                swapCount += 1\\n                sortedPosList[i], sortedPosList[originalPos] = sortedPosList[originalPos], sortedPosList[i]\\n        return swapCount\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\n\\nclass Solution:\\n\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        queue = deque()\\n        queue.append(root)\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                node = queue.popleft()\\n                if (left := node.left):\\n                    queue.append(left)\\n                if (right := node.right):\\n                    queue.append(right)\\n            if queue:\\n                res += self.insertSortSwapCount([node.val for node in queue])\\n        return res\\n    \\n    def insertSortSwapCount(self, nums: List[int]) -> int:\\n        swapCount = 0\\n        sortedPosList = list(range(len(nums)))\\n        sortedPosList.sort(key=lambda x: nums[x])\\n        for i in range(len(sortedPosList)):\\n            while (originalPos := sortedPosList[i]) != i:\\n                swapCount += 1\\n                sortedPosList[i], sortedPosList[originalPos] = sortedPosList[originalPos], sortedPosList[i]\\n        return swapCount\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392817,
                "title": "java-soln-level-order-selection-sort-and-count-cycles-in-a-graph",
                "content": "Level order traversal and selection sort at each level (not very efficient)\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        // BFS\\n        Deque<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        int minSwaps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int[] level = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                TreeNode front = q.poll();\\n                level[i] = front.val;\\n                if(front.left != null) {\\n                    q.offer(front.left);\\n                }\\n                \\n                if(front.right != null) {\\n                    q.offer(front.right);\\n                }\\n            }\\n            // imitate selection sort and count number of swaps\\n            int n = level.length;\\n            for (int i = 0; i < n - 1; i++) {\\n                int minIdx = i;\\n                for(int j = i + 1; j < n; j++) {\\n                    if(level[j] < level[minIdx]) {\\n                        minIdx = j;\\n                    }\\n                }\\n                \\n                if(minIdx != i) {\\n                    int temp = level[minIdx];\\n                    level[minIdx] = level[i];\\n                    level[i] = temp;\\n                    minSwaps++;\\n                }\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n}\\n```\\n\\nlevel order and count cycles in a graph\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        // BFS\\n        Deque<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        int minSwaps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int[] level = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                TreeNode front = q.poll();\\n                level[i] = front.val;\\n                if(front.left != null) {\\n                    q.offer(front.left);\\n                }\\n                \\n                if(front.right != null) {\\n                    q.offer(front.right);\\n                }\\n            }\\n            //  count number of swaps\\n            if(level.length > 1) {\\n                minSwaps += countSwaps(level);\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n    \\n    private int countSwaps(int[] nums)\\n    {\\n        int len = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++)\\n            map.put(nums[i], i);\\n  \\n        Arrays.sort(nums);\\n  \\n        // To keep track of visited elements. Initialize\\n        // all elements as not visited or false.\\n        boolean[] visited = new boolean[len];\\n        Arrays.fill(visited, false);\\n  \\n        // Initialize result\\n        int ans = 0;\\n        for (int i = 0; i < len; i++) {\\n  \\n            // already swapped and corrected or\\n            // already present at correct pos\\n            if (visited[i] || map.get(nums[i]) == i)\\n                continue;\\n  \\n            int j = i, cycle_size = 0;\\n            while (!visited[j]) {\\n                visited[j] = true;\\n  \\n                // move to next node\\n                j = map.get(nums[j]);\\n                cycle_size++;\\n            }\\n  \\n            // Update answer by adding current cycle.\\n            if (cycle_size > 0) {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        // BFS\\n        Deque<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        int minSwaps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int[] level = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                TreeNode front = q.poll();\\n                level[i] = front.val;\\n                if(front.left != null) {\\n                    q.offer(front.left);\\n                }\\n                \\n                if(front.right != null) {\\n                    q.offer(front.right);\\n                }\\n            }\\n            // imitate selection sort and count number of swaps\\n            int n = level.length;\\n            for (int i = 0; i < n - 1; i++) {\\n                int minIdx = i;\\n                for(int j = i + 1; j < n; j++) {\\n                    if(level[j] < level[minIdx]) {\\n                        minIdx = j;\\n                    }\\n                }\\n                \\n                if(minIdx != i) {\\n                    int temp = level[minIdx];\\n                    level[minIdx] = level[i];\\n                    level[i] = temp;\\n                    minSwaps++;\\n                }\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        // BFS\\n        Deque<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        int minSwaps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int[] level = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                TreeNode front = q.poll();\\n                level[i] = front.val;\\n                if(front.left != null) {\\n                    q.offer(front.left);\\n                }\\n                \\n                if(front.right != null) {\\n                    q.offer(front.right);\\n                }\\n            }\\n            //  count number of swaps\\n            if(level.length > 1) {\\n                minSwaps += countSwaps(level);\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n    \\n    private int countSwaps(int[] nums)\\n    {\\n        int len = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++)\\n            map.put(nums[i], i);\\n  \\n        Arrays.sort(nums);\\n  \\n        // To keep track of visited elements. Initialize\\n        // all elements as not visited or false.\\n        boolean[] visited = new boolean[len];\\n        Arrays.fill(visited, false);\\n  \\n        // Initialize result\\n        int ans = 0;\\n        for (int i = 0; i < len; i++) {\\n  \\n            // already swapped and corrected or\\n            // already present at correct pos\\n            if (visited[i] || map.get(nums[i]) == i)\\n                continue;\\n  \\n            int j = i, cycle_size = 0;\\n            while (!visited[j]) {\\n                visited[j] = true;\\n  \\n                // move to next node\\n                j = map.get(nums[j]);\\n                cycle_size++;\\n            }\\n  \\n            // Update answer by adding current cycle.\\n            if (cycle_size > 0) {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390196,
                "title": "beats-80-java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public static int check_position(int[][] arr){\\n        int result=0;\\n\\n        Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] o1,int[] o2){\\n                return o1[0]-o2[0];\\n            }\\n        });\\n\\n        for(int i=0;i<arr.length;i++){\\n            \\n            while(i!=arr[i][1]){\\n                swap(arr,i,arr[i][1]);\\n                result++;\\n            }\\n            \\n        }\\n\\n        return result;\\n        \\n    }\\n\\n    public static void swap(int[][] arr,int i,int j){\\n\\n        int temp1=arr[i][0];\\n        int temp2=arr[i][1];\\n\\n        arr[i][0]=arr[j][0];\\n        arr[i][1]=arr[j][1];\\n\\n        arr[j][0]=temp1;\\n        arr[j][1]=temp2;\\n    }\\n\\n    public int minimumOperations(TreeNode root) {\\n\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        q.add(root);\\n        int result=0;\\n\\n        while(q.size()>0){\\n            int n=q.size();\\n            int[][] arr=new int[n][2];\\n\\n            for(int i=0;i<n;i++){\\n\\n                TreeNode temp=q.remove();\\n                arr[i][0]=temp.val;\\n                arr[i][1]=i;\\n\\n                if(temp.left!=null){\\n                    q.add(temp.left);\\n                }\\n\\n                if(temp.right!=null){\\n                    q.add(temp.right);\\n                }\\n            }\\n\\n            result+=check_position(arr);\\n\\n\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int check_position(int[][] arr){\\n        int result=0;\\n\\n        Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] o1,int[] o2){\\n                return o1[0]-o2[0];\\n            }\\n        });\\n\\n        for(int i=0;i<arr.length;i++){\\n            \\n            while(i!=arr[i][1]){\\n                swap(arr,i,arr[i][1]);\\n                result++;\\n            }\\n            \\n        }\\n\\n        return result;\\n        \\n    }\\n\\n    public static void swap(int[][] arr,int i,int j){\\n\\n        int temp1=arr[i][0];\\n        int temp2=arr[i][1];\\n\\n        arr[i][0]=arr[j][0];\\n        arr[i][1]=arr[j][1];\\n\\n        arr[j][0]=temp1;\\n        arr[j][1]=temp2;\\n    }\\n\\n    public int minimumOperations(TreeNode root) {\\n\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        q.add(root);\\n        int result=0;\\n\\n        while(q.size()>0){\\n            int n=q.size();\\n            int[][] arr=new int[n][2];\\n\\n            for(int i=0;i<n;i++){\\n\\n                TreeNode temp=q.remove();\\n                arr[i][0]=temp.val;\\n                arr[i][1]=i;\\n\\n                if(temp.left!=null){\\n                    q.add(temp.left);\\n                }\\n\\n                if(temp.right!=null){\\n                    q.add(temp.right);\\n                }\\n            }\\n\\n            result+=check_position(arr);\\n\\n\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382695,
                "title": "c-solution-o-nlogn-no-tle",
                "content": "# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - Selection sort--> TLE\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    auto selection_sort(vector<int> vec){\\n        int ans=0;\\n        int n=vec.size();\\n        for(int i=0;i<n-1;i++){\\n            int minn=i,temp;\\n            for(int j=i+1;j<n;j++){\\n                if(vec[j]<vec[minn]){\\n                minn=j;\\n            }\\n            }\\n            if(i!=minn){\\n            temp=vec[i];\\n            vec[i]=vec[minn];\\n            vec[minn]=temp;\\n            ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int len=q.size();\\n      vector<int>v;\\n      while(len--){\\n        auto  node=q.front();\\n        q.pop();\\n        v.push_back(node->val);\\n        if(node->left!=NULL)q.push(node->left);\\n        if(node->right!=NULL)q.push(node->right);\\n      }\\n      ans+=selection_sort(v);\\n\\n    }\\n    return ans;\\n    }\\n};\\n```\\n---\\n# Code - No TLE\\n```\\nclass Solution {\\npublic:\\n  \\n    int fun(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++){\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int s=0;\\n\\t    for(int i=0;i<n;i++){\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            s++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return s;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int len=q.size();\\n      vector<int>v;\\n      while(len--){\\n        auto  node=q.front();\\n        q.pop();\\n        v.push_back(node->val);\\n        if(node->left!=NULL)q.push(node->left);\\n        if(node->right!=NULL)q.push(node->right);\\n      }\\n      ans+=fun(v);\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    auto selection_sort(vector<int> vec){\\n        int ans=0;\\n        int n=vec.size();\\n        for(int i=0;i<n-1;i++){\\n            int minn=i,temp;\\n            for(int j=i+1;j<n;j++){\\n                if(vec[j]<vec[minn]){\\n                minn=j;\\n            }\\n            }\\n            if(i!=minn){\\n            temp=vec[i];\\n            vec[i]=vec[minn];\\n            vec[minn]=temp;\\n            ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int len=q.size();\\n      vector<int>v;\\n      while(len--){\\n        auto  node=q.front();\\n        q.pop();\\n        v.push_back(node->val);\\n        if(node->left!=NULL)q.push(node->left);\\n        if(node->right!=NULL)q.push(node->right);\\n      }\\n      ans+=selection_sort(v);\\n\\n    }\\n    return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    int fun(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++){\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int s=0;\\n\\t    for(int i=0;i<n;i++){\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            s++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return s;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n        int ans=0;\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int len=q.size();\\n      vector<int>v;\\n      while(len--){\\n        auto  node=q.front();\\n        q.pop();\\n        v.push_back(node->val);\\n        if(node->left!=NULL)q.push(node->left);\\n        if(node->right!=NULL)q.push(node->right);\\n      }\\n      ans+=fun(v);\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380006,
                "title": "level-order-traversal-getswapcount-map",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            int[] levelValues = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                levelValues[i] = node.val;\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n\\n            count += getSwaps(levelValues);\\n        }\\n        return count;\\n    }\\n    \\nprivate int getSwaps(int[] arr) {\\n    int n = arr.length;\\n    int[] sortedArr = Arrays.copyOf(arr, n);\\n    Arrays.sort(sortedArr);\\n    Map<Integer, Integer> idxMap = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n        idxMap.put(arr[i], i);\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (arr[i] != sortedArr[i]) {\\n            int j = idxMap.get(sortedArr[i]);\\n            idxMap.put(arr[i], j);\\n            arr[j] = arr[i];\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n}\\n```\\n# Upvoting is Much Appreciated",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            int[] levelValues = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                levelValues[i] = node.val;\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n\\n            count += getSwaps(levelValues);\\n        }\\n        return count;\\n    }\\n    \\nprivate int getSwaps(int[] arr) {\\n    int n = arr.length;\\n    int[] sortedArr = Arrays.copyOf(arr, n);\\n    Arrays.sort(sortedArr);\\n    Map<Integer, Integer> idxMap = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n        idxMap.put(arr[i], i);\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (arr[i] != sortedArr[i]) {\\n            int j = idxMap.get(sortedArr[i]);\\n            idxMap.put(arr[i], j);\\n            arr[j] = arr[i];\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351422,
                "title": "c-hashmap",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:map<int,vector<int>> p;\\n    void t(TreeNode* r,int i)\\n    {\\n        if(!r)\\n        return ;\\n        p[i].push_back(r->val);\\n        t(r->left,i+1);\\n        t(r->right,i+1);\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        t(root,0);\\n        int c=0;\\n        for(auto i : p)\\n        {\\n            vector<int> a=i.second,b=a;\\n            map<int,int> q;\\n            for(int j=0;j<a.size();j++)\\n            q[a[j]]=j;\\n            sort(b.begin(),b.end());\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(a[j]!=b[j])\\n                {\\n                    int id=q[b[j]];int g=a[j];\\n                    a[j]=b[j];\\n                    a[id]=g;\\n                    q[g]=id;\\n                    c++;\\n                }\\n            }\\n        }\\n    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:map<int,vector<int>> p;\\n    void t(TreeNode* r,int i)\\n    {\\n        if(!r)\\n        return ;\\n        p[i].push_back(r->val);\\n        t(r->left,i+1);\\n        t(r->right,i+1);\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        t(root,0);\\n        int c=0;\\n        for(auto i : p)\\n        {\\n            vector<int> a=i.second,b=a;\\n            map<int,int> q;\\n            for(int j=0;j<a.size();j++)\\n            q[a[j]]=j;\\n            sort(b.begin(),b.end());\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(a[j]!=b[j])\\n                {\\n                    int id=q[b[j]];int g=a[j];\\n                    a[j]=b[j];\\n                    a[id]=g;\\n                    q[g]=id;\\n                    c++;\\n                }\\n            }\\n        }\\n    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349251,
                "title": "level-order-traversal-swaps-check-python",
                "content": "```\\n\"\"\"\\nTreatment: level order traversal + get n_swaps\\n\\n\\nKey assumption: nodes values are unique\\n\\nIdea: for each level, we get the corresponding arr. Then for this arr, we\\nget the n_swaps needed to make it sorted. The return is the sum of n_swaps across levels.\\n\\nComments:\\n\\n    - level order traversal is a standard task. we could use list comprehension to do it\\n      effectively\\n    - the main effort is get the n_swaps. This is also not hard with the help of dict ADT.\\n    \\n\\nE.g. arr = [7, 6, 8, 5]; d = {7:0, 6:1, 8:2, 5:3}\\n    sorted= [5, 6, 7, 8]\\n    \\ni = 0: sorted[i] != arr[i], need one swap. How to swap?\\n       \\n       i is the destination position for the element 5.\\n       but now 5 has index 3 in arr.  we need to swap arr[0] = 7 and arr[3] = 5,\\n       and also update the indices in d for next iteration.\\n       \\n       arr =  [5, 6, 8, 7]; d = {7:3, 6:1, 8:2, 5:0}\\n      sorted =[5, 6, 7, 8] \\n\\ni = 1: sorted[i] == arr[i]; no swap needed; continue.\\n\\ni = 2: sorted[i] != arr[i]; need one swap. swap as in i = 0 step:\\n      \\n       i is the destination position for the element 7\\n       but now 7 has index 3 in arr. we need to swap arr[2]=8 with arr[3] = 7\\n       (and update the indices of them in d)\\n       \\n       arr = [5, 6, 7, 8]; d = {7:2, 6:1, 8:3, 5:0}\\n       now arr == sorted\\nIn summary, we need 2 swaps.\\n            \\n\"\"\"\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        # step-1 level order traversal\\n        levels = []\\n        q = [root]\\n        while q:\\n            levels.append([node.val for node in q])\\n            q = [child for node in q for child in (node.left, node.right) if child]\\n        \\n        # step-2 helper fn to get n_swaps\\n        def n_swaps(arr):\\n            \"\"\"\\n            update indices in d, then swap\\n            \"\"\"\\n            s = sorted(arr)\\n            res = 0\\n            d = {y:i for i, y in enumerate(arr)}\\n            n = len(arr)\\n            for i in range(n):\\n                if arr[i] != s[i]:\\n                    # i is the supposed to hold s[i], but now hold arr[i]\\n                    idx = d[s[i]]\\n                    d[arr[i]] = idx\\n                    d[s[i]] = i\\n                    arr[i], arr[idx] = arr[idx], arr[i]\\n                    res += 1\\n            return res\\n        \\n        def n_swaps_r(arr):\\n            \"\"\"\\n            swap then update d\\n            \"\"\"\\n            s = sorted(arr)\\n            res = 0\\n            d = {y:i for i, y in enumerate(arr)}\\n            n = len(arr)\\n            for i in range(n):\\n                if arr[i] != s[i]:\\n                    # i is the supposed to hold s[i], but now hold arr[i]\\n                    idx = d[s[i]]\\n                    arr[i], arr[idx] = arr[idx], arr[i]\\n                    res += 1\\n                    d[arr[i]] = i\\n                    d[arr[idx]] = idx       \\n            return res\\n        \\n        # step-3 summation\\n        return sum(n_swaps_r(arr) for arr in levels)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: level order traversal + get n_swaps\\n\\n\\nKey assumption: nodes values are unique\\n\\nIdea: for each level, we get the corresponding arr. Then for this arr, we\\nget the n_swaps needed to make it sorted. The return is the sum of n_swaps across levels.\\n\\nComments:\\n\\n    - level order traversal is a standard task. we could use list comprehension to do it\\n      effectively\\n    - the main effort is get the n_swaps. This is also not hard with the help of dict ADT.\\n    \\n\\nE.g. arr = [7, 6, 8, 5]; d = {7:0, 6:1, 8:2, 5:3}\\n    sorted= [5, 6, 7, 8]\\n    \\ni = 0: sorted[i] != arr[i], need one swap. How to swap?\\n       \\n       i is the destination position for the element 5.\\n       but now 5 has index 3 in arr.  we need to swap arr[0] = 7 and arr[3] = 5,\\n       and also update the indices in d for next iteration.\\n       \\n       arr =  [5, 6, 8, 7]; d = {7:3, 6:1, 8:2, 5:0}\\n      sorted =[5, 6, 7, 8] \\n\\ni = 1: sorted[i] == arr[i]; no swap needed; continue.\\n\\ni = 2: sorted[i] != arr[i]; need one swap. swap as in i = 0 step:\\n      \\n       i is the destination position for the element 7\\n       but now 7 has index 3 in arr. we need to swap arr[2]=8 with arr[3] = 7\\n       (and update the indices of them in d)\\n       \\n       arr = [5, 6, 7, 8]; d = {7:2, 6:1, 8:3, 5:0}\\n       now arr == sorted\\nIn summary, we need 2 swaps.\\n            \\n\"\"\"\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        # step-1 level order traversal\\n        levels = []\\n        q = [root]\\n        while q:\\n            levels.append([node.val for node in q])\\n            q = [child for node in q for child in (node.left, node.right) if child]\\n        \\n        # step-2 helper fn to get n_swaps\\n        def n_swaps(arr):\\n            \"\"\"\\n            update indices in d, then swap\\n            \"\"\"\\n            s = sorted(arr)\\n            res = 0\\n            d = {y:i for i, y in enumerate(arr)}\\n            n = len(arr)\\n            for i in range(n):\\n                if arr[i] != s[i]:\\n                    # i is the supposed to hold s[i], but now hold arr[i]\\n                    idx = d[s[i]]\\n                    d[arr[i]] = idx\\n                    d[s[i]] = i\\n                    arr[i], arr[idx] = arr[idx], arr[i]\\n                    res += 1\\n            return res\\n        \\n        def n_swaps_r(arr):\\n            \"\"\"\\n            swap then update d\\n            \"\"\"\\n            s = sorted(arr)\\n            res = 0\\n            d = {y:i for i, y in enumerate(arr)}\\n            n = len(arr)\\n            for i in range(n):\\n                if arr[i] != s[i]:\\n                    # i is the supposed to hold s[i], but now hold arr[i]\\n                    idx = d[s[i]]\\n                    arr[i], arr[idx] = arr[idx], arr[i]\\n                    res += 1\\n                    d[arr[i]] = i\\n                    d[arr[idx]] = idx       \\n            return res\\n        \\n        # step-3 summation\\n        return sum(n_swaps_r(arr) for arr in levels)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345272,
                "title": "basic-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGo to each level and store in the vector<int> small and now,find the minimum swap to sort this array using (inversion sort (merge_sort technique)) but that was lengthy.So,\\nwe count the minimum number of swap on the basis of indexing marking:\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\n   int mini_swap(vector<int> &small){\\n       int ans = 0;\\n\\n       vector<pair<int,int>> p;\\n       for(int i=0;i<small.size();i++){\\n           p.push_back({small[i],i});\\n       }\\n\\n       sort(p.begin(),p.end());\\n       for(int i=0;i<small.size();i++){\\n           if(p[i].second == i){\\n               continue;\\n           }\\n\\n           while(p[i].second!=i){\\n               ans++;\\n               swap(p[i],p[p[i].second]);\\n           }\\n       }\\n       return ans;\\n\\n   }\\n\\n\\n    int minimumOperations(TreeNode* root) {\\n        int cnt = 0;\\n        queue<TreeNode*> qu;\\n        qu.push(root);\\n        while(!qu.empty()){\\n            int size = qu.size();\\n            vector<int> small;\\n            while(size--){\\n                TreeNode *node = qu.front();\\n                qu.pop();\\n                small.push_back(node->val);\\n                if(node->left!=NULL){\\n                    qu.push(node->left);\\n                }\\n                if(node->right!=NULL){\\n                    qu.push(node->right);\\n                }\\n            }\\n            cnt+=mini_swap(small);  //count the minimum swap->inversion but not (n*log(N)) has in merge_sort in inversion count:\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\n   int mini_swap(vector<int> &small){\\n       int ans = 0;\\n\\n       vector<pair<int,int>> p;\\n       for(int i=0;i<small.size();i++){\\n           p.push_back({small[i],i});\\n       }\\n\\n       sort(p.begin(),p.end());\\n       for(int i=0;i<small.size();i++){\\n           if(p[i].second == i){\\n               continue;\\n           }\\n\\n           while(p[i].second!=i){\\n               ans++;\\n               swap(p[i],p[p[i].second]);\\n           }\\n       }\\n       return ans;\\n\\n   }\\n\\n\\n    int minimumOperations(TreeNode* root) {\\n        int cnt = 0;\\n        queue<TreeNode*> qu;\\n        qu.push(root);\\n        while(!qu.empty()){\\n            int size = qu.size();\\n            vector<int> small;\\n            while(size--){\\n                TreeNode *node = qu.front();\\n                qu.pop();\\n                small.push_back(node->val);\\n                if(node->left!=NULL){\\n                    qu.push(node->left);\\n                }\\n                if(node->right!=NULL){\\n                    qu.push(node->right);\\n                }\\n            }\\n            cnt+=mini_swap(small);  //count the minimum swap->inversion but not (n*log(N)) has in merge_sort in inversion count:\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345268,
                "title": "easy-java-solution-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q= new LinkedList<TreeNode>();\\n        q.add(root);\\n        int res=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n             ArrayList<Integer> list = new ArrayList<>();\\n            for( int i=0; i<size;i++){\\n                TreeNode temp=q.remove();\\n                list.add(temp.val);\\n                if(temp.left!=null)q.add(temp.left);\\n                if(temp.right!=null)q.add(temp.right);\\n            }\\n            res+=swapped(list);\\n        }\\n        return res;\\n    }\\n    private int swapped(ArrayList<Integer>list){\\n        int ans=0;\\n        ArrayList<Integer> temp = new ArrayList<>(list);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<list.size();i++){\\n            map.put(list.get(i),i);\\n        }\\n        Collections.sort(temp);\\n        for( int i=0;i<list.size();i++){\\n            if(list.get(i)!=temp.get(i)){\\n                ans++;\\n                int init=list.get(i);\\n                Collections.swap(list,i,map.get(temp.get(i)));\\n                  \\n                map.put(init, map.get(temp.get(i)));\\n                map.put(temp.get(i), i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q= new LinkedList<TreeNode>();\\n        q.add(root);\\n        int res=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n             ArrayList<Integer> list = new ArrayList<>();\\n            for( int i=0; i<size;i++){\\n                TreeNode temp=q.remove();\\n                list.add(temp.val);\\n                if(temp.left!=null)q.add(temp.left);\\n                if(temp.right!=null)q.add(temp.right);\\n            }\\n            res+=swapped(list);\\n        }\\n        return res;\\n    }\\n    private int swapped(ArrayList<Integer>list){\\n        int ans=0;\\n        ArrayList<Integer> temp = new ArrayList<>(list);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<list.size();i++){\\n            map.put(list.get(i),i);\\n        }\\n        Collections.sort(temp);\\n        for( int i=0;i<list.size();i++){\\n            if(list.get(i)!=temp.get(i)){\\n                ans++;\\n                int init=list.get(i);\\n                Collections.swap(list,i,map.get(temp.get(i)));\\n                  \\n                map.put(init, map.get(temp.get(i)));\\n                map.put(temp.get(i), i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342573,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid swap(vector<int>& arr, int i, int j)\\n{\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n// Return the minimum number\\n// of swaps required to sort\\n// the array\\nint minSwaps(vector<int> arr, int N)\\n{\\n    int ans = 0;\\n    vector<int> temp = arr;\\n  \\n    // Hashmap which stores the\\n    // indexes of the input array\\n    map<int, int> h;\\n  \\n    sort(temp.begin(), temp.end());\\n    for (int i = 0; i < N; i++) {\\n        h[arr[i]] = i;\\n    }\\n    for (int i = 0; i < N; i++) {\\n        // This is checking whether\\n        // the current element is\\n        // at the right place or not\\n        if (arr[i] != temp[i]) {\\n            ans++;\\n            int init = arr[i];\\n  \\n            // If not, swap this element\\n            // with the index of the\\n            // element which should come here\\n            swap(arr, i, h[temp[i]]);\\n  \\n            // Update the indexes in\\n            // the hashmap accordingly\\n            h[init] = h[temp[i]];\\n            h[temp[i]] = i;\\n        }\\n    }\\n    return ans;\\n}\\n  \\n    int minimumOperations(TreeNode* root) {\\n        vector<int>v;\\n        int ans=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            if(n==1)\\n            {\\n                TreeNode* c=q.front();\\n                q.pop();\\n                if(c->left)\\n                {\\n                    q.push(c->left);\\n                }\\n                if(c->right)\\n                {\\n                    q.push(c->right);\\n                }\\n                \\n            }\\n            else\\n            {\\n                while(n--)\\n                {\\n                    TreeNode* curr=q.front();\\n                    q.pop();\\n                    v.push_back(curr->val);\\n                    if(curr->left)\\n                    {\\n                        q.push(curr->left);\\n                    }\\n                    if(curr->right)\\n                    {\\n                        q.push(curr->right);\\n                    }\\n                }\\n                if(v.size()>0)\\n                {\\n                    ans+=minSwaps(v,v.size());\\n                    v.clear();\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/bf0c878b-2289-4ebf-a339-bc31eaf9bf1e_1679813293.5808282.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid swap(vector<int>& arr, int i, int j)\\n{\\n    int temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n// Return the minimum number\\n// of swaps required to sort\\n// the array\\nint minSwaps(vector<int> arr, int N)\\n{\\n    int ans = 0;\\n    vector<int> temp = arr;\\n  \\n    // Hashmap which stores the\\n    // indexes of the input array\\n    map<int, int> h;\\n  \\n    sort(temp.begin(), temp.end());\\n    for (int i = 0; i < N; i++) {\\n        h[arr[i]] = i;\\n    }\\n    for (int i = 0; i < N; i++) {\\n        // This is checking whether\\n        // the current element is\\n        // at the right place or not\\n        if (arr[i] != temp[i]) {\\n            ans++;\\n            int init = arr[i];\\n  \\n            // If not, swap this element\\n            // with the index of the\\n            // element which should come here\\n            swap(arr, i, h[temp[i]]);\\n  \\n            // Update the indexes in\\n            // the hashmap accordingly\\n            h[init] = h[temp[i]];\\n            h[temp[i]] = i;\\n        }\\n    }\\n    return ans;\\n}\\n  \\n    int minimumOperations(TreeNode* root) {\\n        vector<int>v;\\n        int ans=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            if(n==1)\\n            {\\n                TreeNode* c=q.front();\\n                q.pop();\\n                if(c->left)\\n                {\\n                    q.push(c->left);\\n                }\\n                if(c->right)\\n                {\\n                    q.push(c->right);\\n                }\\n                \\n            }\\n            else\\n            {\\n                while(n--)\\n                {\\n                    TreeNode* curr=q.front();\\n                    q.pop();\\n                    v.push_back(curr->val);\\n                    if(curr->left)\\n                    {\\n                        q.push(curr->left);\\n                    }\\n                    if(curr->right)\\n                    {\\n                        q.push(curr->right);\\n                    }\\n                }\\n                if(v.size()>0)\\n                {\\n                    ans+=minSwaps(v,v.size());\\n                    v.clear();\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339990,
                "title": "using-level-order-traversal-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        if(root==null)return 0;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty())\\n        {\\n         TreeNode curr=q.remove();\\n         if(curr==null){\\n          ans.add(new ArrayList<>(list));\\n          list=new ArrayList<>();\\n          if(q.isEmpty()){\\n              break;\\n          }\\n          else{\\n              q.add(null);\\n          }\\n\\n         }\\n         else{\\n         list.add(curr.val);\\n         if(curr.left!=null){\\n           q.add(curr.left);\\n         }\\n         if(curr.right!=null){\\n             q.add(curr.right);\\n         }\\n\\n         }\\n\\n\\n        }\\n        int out=0;\\n        for(int i=1; i<ans.size(); i++)\\n        {\\n          int count=swap(ans.get(i));\\n           out=out+count;\\n        }\\n\\nreturn out;\\n    }\\n\\n    public int swap(List<Integer> list)\\n    {\\n        int res=0;\\n        int arr[]=new int[list.size()];\\n        for(int i=0; i<list.size(); i++){\\n            arr[i]=list.get(i);\\n        }\\n\\nint temp[]=new int[list.size()];\\n        for(int i=0; i<list.size(); i++){\\n            temp[i]=list.get(i);\\n        }\\n        Arrays.sort(temp);\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    for(int i=0; i<list.size(); i++){\\n        map.put(list.get(i),i);\\n    }\\n    \\n     for(int i=0; i<list.size(); i++)\\n     {\\n     if(arr[i]!=temp[i])\\n      {\\n          res++;\\n       int intial=arr[i];\\n       //swap values\\n       \\n       swapping(arr,i,map.get(temp[i]));\\n       //swap values in map\\n       map.replace(intial,map.get(temp[i]));\\n       map.replace(temp[i],i);\\n       /*\\n       map.get(intial)=map.get(temp[i]);\\n       map.get(temp[i])=i;\\n       */\\n      }\\n\\n\\n     }\\n\\n\\n\\nreturn res;\\n    }\\n    public void swapping(int arr[],int i,int j){\\n        int temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        if(root==null)return 0;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty())\\n        {\\n         TreeNode curr=q.remove();\\n         if(curr==null){\\n          ans.add(new ArrayList<>(list));\\n          list=new ArrayList<>();\\n          if(q.isEmpty()){\\n              break;\\n          }\\n          else{\\n              q.add(null);\\n          }\\n\\n         }\\n         else{\\n         list.add(curr.val);\\n         if(curr.left!=null){\\n           q.add(curr.left);\\n         }\\n         if(curr.right!=null){\\n             q.add(curr.right);\\n         }\\n\\n         }\\n\\n\\n        }\\n        int out=0;\\n        for(int i=1; i<ans.size(); i++)\\n        {\\n          int count=swap(ans.get(i));\\n           out=out+count;\\n        }\\n\\nreturn out;\\n    }\\n\\n    public int swap(List<Integer> list)\\n    {\\n        int res=0;\\n        int arr[]=new int[list.size()];\\n        for(int i=0; i<list.size(); i++){\\n            arr[i]=list.get(i);\\n        }\\n\\nint temp[]=new int[list.size()];\\n        for(int i=0; i<list.size(); i++){\\n            temp[i]=list.get(i);\\n        }\\n        Arrays.sort(temp);\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    for(int i=0; i<list.size(); i++){\\n        map.put(list.get(i),i);\\n    }\\n    \\n     for(int i=0; i<list.size(); i++)\\n     {\\n     if(arr[i]!=temp[i])\\n      {\\n          res++;\\n       int intial=arr[i];\\n       //swap values\\n       \\n       swapping(arr,i,map.get(temp[i]));\\n       //swap values in map\\n       map.replace(intial,map.get(temp[i]));\\n       map.replace(temp[i],i);\\n       /*\\n       map.get(intial)=map.get(temp[i]);\\n       map.get(temp[i])=i;\\n       */\\n      }\\n\\n\\n     }\\n\\n\\n\\nreturn res;\\n    }\\n    public void swapping(int arr[],int i,int j){\\n        int temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333572,
                "title": "dfs-minimum-swap-to-sort-finding-algorithm-approach-and-complexity-discussion",
                "content": "# Approach\\nFirst do DFS traversal of tree to find level wise node value, means lavel order traversal. Store it in a two dimensional array and for each single array in 2d array find the minimum number of swaps needed to make array sorted which implicitly means the minimum number od swaps needed to make the level sorted. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2log(n))$$\\n    - $$n^2$$ is for 2d array travesal.\\n    - $$log(n)$$ for sorting in findMinSwaps function.\\n\\n- Space complexity:\\n$$O(2^nn^2)$$\\n    - $$n^2$$ is for 2d array storing.\\n    - $$2^n$$ for recursion stack space.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int ans = 0;\\n    vector<vector<int>>num;\\n    void dfs(TreeNode *root, int level){\\n        if(root == NULL)return;\\n        if(level >= num.size()){\\n            num.push_back({root->val});\\n        }\\n        else{\\n            num[level].push_back(root->val);\\n        }\\n        dfs(root->left, level+1);\\n        dfs(root->right, level+1);\\n    }\\n    int findMinSwaps(vector<int> &v) {\\n        int n = v.size();\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i < n; i++) {\\n            vec.push_back({v[i],i});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int swaps = 0;\\n        for(int i = 0; i < n; i++) {\\n            int num = vec[i].first;\\n            int idx = vec[i].second;\\n            if(i!=idx) {\\n                swaps++;\\n                swap(vec[i],vec[idx]);\\n                i--;\\n            }\\n        }\\n        return swaps;\\n    }\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        dfs(root,0);\\n        int ans = 0;\\n        for(auto i:num) {\\n            ans+= findMinSwaps(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int ans = 0;\\n    vector<vector<int>>num;\\n    void dfs(TreeNode *root, int level){\\n        if(root == NULL)return;\\n        if(level >= num.size()){\\n            num.push_back({root->val});\\n        }\\n        else{\\n            num[level].push_back(root->val);\\n        }\\n        dfs(root->left, level+1);\\n        dfs(root->right, level+1);\\n    }\\n    int findMinSwaps(vector<int> &v) {\\n        int n = v.size();\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i < n; i++) {\\n            vec.push_back({v[i],i});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int swaps = 0;\\n        for(int i = 0; i < n; i++) {\\n            int num = vec[i].first;\\n            int idx = vec[i].second;\\n            if(i!=idx) {\\n                swaps++;\\n                swap(vec[i],vec[idx]);\\n                i--;\\n            }\\n        }\\n        return swaps;\\n    }\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        dfs(root,0);\\n        int ans = 0;\\n        for(auto i:num) {\\n            ans+= findMinSwaps(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330167,
                "title": "c-level-order-hashmap",
                "content": "```\\n**/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long minswaps(vector<int>&temp){\\n        \\n        bool flag=1;\\n        int n=temp.size();\\n        for(int i=0;i<n-1;i++){\\n            if(temp[i]>temp[i+1]){\\n                flag=0;\\n                break;\\n            }\\n        }\\n        if(flag==1){\\n            return 0;\\n        }\\n        map<int,int> ourmap;\\n        for(int i=0;i<n;i++){\\n            ourmap[temp[i]]=i;\\n        }\\n        vector<int> a=temp;\\n        sort(a.begin(),a.end());\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==temp[i]){\\n                continue;\\n            }\\n            else{\\n                int index=ourmap[a[i]];\\n                int num=temp[i];\\n                swap(temp[i],temp[index]);\\n                ourmap[a[i]]=i;\\n                ourmap[num]=index;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    long long helper(TreeNode* root){\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        vector<int> temp;\\n        long long ans=0;\\n        while(q.size()!=0){\\n            \\n            TreeNode* front=q.front();\\n            q.pop();\\n            if(front!=NULL){\\n                temp.push_back(front->val);\\n                if(front->left!=NULL){\\n                    q.push(front->left);\\n                }\\n                if(front->right!=NULL){\\n                    q.push(front->right);\\n                }\\n            }\\n            else{\\n                \\n                if(q.size()!=0){\\n                    q.push(NULL);\\n                }\\n                long long moves=minswaps(temp);\\n                ans=ans+moves;\\n                temp.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        \\n        if(root==NULL){\\n            return 0;\\n        }\\n        long long ans=helper(root);\\n        return ans;\\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minswaps(vector<int>&temp){\\n        \\n        bool flag=1;\\n        int n=temp.size();\\n        for(int i=0;i<n-1;i++){\\n            if(temp[i]>temp[i+1]){\\n                flag=0;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3306816,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minimumOperations(_ root: TreeNode?) -> Int {\\n\\n        func sort(_ a: [(Int, Int)]) -> Int {\\n\\n            guard !a.isEmpty else { return 0 }\\n            guard a.count > 2 else { return 1 }\\n            guard a.count > 3 else { return 2 }\\n\\n            var res = 0\\n            var v = a\\n                .map(\\\\.0)\\n                .enumerated()\\n                .sorted { $0.element < $1.element }\\n                .map { $0.offset }\\n\\n            while let i = v.indices.first(where: { $0 != v[$0] }) {\\n                let o = v[v[i]]\\n                v[v[i]] = v[i]\\n                v[i] = o\\n                res += 1\\n            }\\n\\n            return res\\n        }\\n        \\n        var stack = [root!]\\n        var res = 0\\n\\n        while !stack.isEmpty {\\n\\n            let vals = stack.map(\\\\.val)\\n            let c = sort(zip(vals, vals.sorted()).filter({ $0 != $1 }))\\n\\n            res += c\\n            stack = stack\\n                .flatMap { [$0.left, $0.right] }\\n                .compactMap { $0 }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumOperations(_ root: TreeNode?) -> Int {\\n\\n        func sort(_ a: [(Int, Int)]) -> Int {\\n\\n            guard !a.isEmpty else { return 0 }\\n            guard a.count > 2 else { return 1 }\\n            guard a.count > 3 else { return 2 }\\n\\n            var res = 0\\n            var v = a\\n                .map(\\\\.0)\\n                .enumerated()\\n                .sorted { $0.element < $1.element }\\n                .map { $0.offset }\\n\\n            while let i = v.indices.first(where: { $0 != v[$0] }) {\\n                let o = v[v[i]]\\n                v[v[i]] = v[i]\\n                v[i] = o\\n                res += 1\\n            }\\n\\n            return res\\n        }\\n        \\n        var stack = [root!]\\n        var res = 0\\n\\n        while !stack.isEmpty {\\n\\n            let vals = stack.map(\\\\.val)\\n            let c = sort(zip(vals, vals.sorted()).filter({ $0 != $1 }))\\n\\n            res += c\\n            stack = stack\\n                .flatMap { [$0.left, $0.right] }\\n                .compactMap { $0 }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303057,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int res=0;\\n       Queue<TreeNode> q=new LinkedList<>();\\n       q.add(root);\\n       while(!q.isEmpty()){\\n           int len=q.size();\\n           List<Integer> s=new ArrayList<>();\\n\\n           for(int i=0;i<len;i++){\\n               TreeNode first=q.poll();\\n               s.add(first.val);\\n               if(first.left!=null){\\n                   q.add(first.left);\\n               }\\n                  if(first.right!=null){\\n                   q.add(first.right);\\n               }\\n           }\\n           res+=minswap(s);\\n           \\n       }\\n       return res; \\n    }\\n    public int minswap(List<Integer> nm){\\n      \\n    \\n    Map<Integer,Integer> kk=new HashMap<>();\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            kk.put(nm.get(i),i);\\n        }\\n        Collections.sort(nm);\\n        boolean k[]=new boolean[nm.size()];\\n        int s=0;\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            if(k[i] || kk.get(nm.get(i))==i)\\n            {\\n                continue;\\n            }\\n            int j=i,m=0;\\n            while(!k[j])\\n            {\\n                k[j]=true;\\n                j=kk.get(nm.get(j));\\n                m++;\\n            }\\n            if(m>0)\\n            {\\n                s+=m-1;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int res=0;\\n       Queue<TreeNode> q=new LinkedList<>();\\n       q.add(root);\\n       while(!q.isEmpty()){\\n           int len=q.size();\\n           List<Integer> s=new ArrayList<>();\\n\\n           for(int i=0;i<len;i++){\\n               TreeNode first=q.poll();\\n               s.add(first.val);\\n               if(first.left!=null){\\n                   q.add(first.left);\\n               }\\n                  if(first.right!=null){\\n                   q.add(first.right);\\n               }\\n           }\\n           res+=minswap(s);\\n           \\n       }\\n       return res; \\n    }\\n    public int minswap(List<Integer> nm){\\n      \\n    \\n    Map<Integer,Integer> kk=new HashMap<>();\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            kk.put(nm.get(i),i);\\n        }\\n        Collections.sort(nm);\\n        boolean k[]=new boolean[nm.size()];\\n        int s=0;\\n        for(int i=0;i<nm.size();i++)\\n        {\\n            if(k[i] || kk.get(nm.get(i))==i)\\n            {\\n                continue;\\n            }\\n            int j=i,m=0;\\n            while(!k[j])\\n            {\\n                k[j]=true;\\n                j=kk.get(nm.get(j));\\n                m++;\\n            }\\n            if(m>0)\\n            {\\n                s+=m-1;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295260,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int findMinSwap(vector<int> &arr, int n)\\n{\\n    // temporary vector to store values, along with its index in the original vector\\n    vector<pair<int, int>> temp(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        // values in the vector\\n        temp[i].first = arr[i];\\n        // index of the particular value.\\n        temp[i].second = i;\\n    }\\n\\n\\n    //sort the temp vector according to the values\\n    sort(temp.begin(), temp.end());\\n    // variable to store the answer\\n    int minimum_swaps = 0;\\n    int i = 0;\\n    while (i < n)\\n    {\\n        // If there is no need to swap then continue\\n        if (temp[i].second == i or temp[i].first == arr[i])\\n        {\\n            ++i;\\n            continue;\\n        }\\n        else\\n        {\\n            // swap the values accordingly\\n            swap(temp[i].first, temp[temp[i].second].first);\\n            // swap the indices also within the temp array also\\n            swap(temp[i].second, temp[temp[i].second].second);\\n            // stay on the same position until, we fulfill the criterion\\n            if (temp[i].second != i)\\n                i--;\\n        }\\n        //increment the answer\\n        minimum_swaps++;\\n        // move to the next index\\n        ++i;\\n    }\\n    return minimum_swaps;\\n}\\n\\n\\n\\n\\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            vector<int>temp;\\n            while(sz--)\\n            {\\n                auto node=q.front();\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push(node->left);\\n                }\\n                if (node->right)\\n                {\\n                    q.push(node->right);\\n                }\\n                temp.push_back(node->val);\\n            }\\n            ans+=findMinSwap(temp,temp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int findMinSwap(vector<int> &arr, int n)\\n{\\n    // temporary vector to store values, along with its index in the original vector\\n    vector<pair<int, int>> temp(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        // values in the vector\\n        temp[i].first = arr[i];\\n        // index of the particular value.\\n        temp[i].second = i;\\n    }\\n\\n\\n    //sort the temp vector according to the values\\n    sort(temp.begin(), temp.end());\\n    // variable to store the answer\\n    int minimum_swaps = 0;\\n    int i = 0;\\n    while (i < n)\\n    {\\n        // If there is no need to swap then continue\\n        if (temp[i].second == i or temp[i].first == arr[i])\\n        {\\n            ++i;\\n            continue;\\n        }\\n        else\\n        {\\n            // swap the values accordingly\\n            swap(temp[i].first, temp[temp[i].second].first);\\n            // swap the indices also within the temp array also\\n            swap(temp[i].second, temp[temp[i].second].second);\\n            // stay on the same position until, we fulfill the criterion\\n            if (temp[i].second != i)\\n                i--;\\n        }\\n        //increment the answer\\n        minimum_swaps++;\\n        // move to the next index\\n        ++i;\\n    }\\n    return minimum_swaps;\\n}\\n\\n\\n\\n\\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            vector<int>temp;\\n            while(sz--)\\n            {\\n                auto node=q.front();\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push(node->left);\\n                }\\n                if (node->right)\\n                {\\n                    q.push(node->right);\\n                }\\n                temp.push_back(node->val);\\n            }\\n            ans+=findMinSwap(temp,temp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283901,
                "title": "bfs-c-solution-easy",
                "content": "The question is combination of minimum swaps to sort an array and level order traversal. Using its concepts, it can be easily solved .\\n```\\n int solve(vector<int> &v, int n){\\n        int swaps = 0 ;\\n        vector<pair<int,int>> p ;\\n        for(int i = 0; i < n; i++)\\n            p.push_back({v[i], i}) ;\\n        sort(p.begin(), p.end()) ;\\n        for(int i = 0; i < n; i++){\\n            int val = p[i].first ;\\n            int idx = p[i].second ;\\n            if(i != idx){\\n                swaps++ ;\\n                swap(p[i], p[idx]) ;\\n                i-- ;\\n            }\\n        }\\n            return swaps ;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        long long count = 0 ;\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        while(!q.empty()){\\n            int n = q.size() ;\\n            vector<int> v ;\\n            for(int i = 0 ; i < n ; i++){\\n                auto node = q.front() ; q.pop() ;\\n                v.push_back(node -> val) ;\\n                if(node -> left)\\n                    q.push(node -> left) ;\\n                if(node -> right)\\n                    q.push(node -> right) ;\\n            }\\n                count += solve(v, n) ;\\n        }\\n            return count ;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "The question is combination of minimum swaps to sort an array and level order traversal. Using its concepts, it can be easily solved .\\n```\\n int solve(vector<int> &v, int n){\\n        int swaps = 0 ;\\n        vector<pair<int,int>> p ;\\n        for(int i = 0; i < n; i++)\\n            p.push_back({v[i], i}) ;\\n        sort(p.begin(), p.end()) ;\\n        for(int i = 0; i < n; i++){\\n            int val = p[i].first ;\\n            int idx = p[i].second ;\\n            if(i != idx){\\n                swaps++ ;\\n                swap(p[i], p[idx]) ;\\n                i-- ;\\n            }\\n        }\\n            return swaps ;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        long long count = 0 ;\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        while(!q.empty()){\\n            int n = q.size() ;\\n            vector<int> v ;\\n            for(int i = 0 ; i < n ; i++){\\n                auto node = q.front() ; q.pop() ;\\n                v.push_back(node -> val) ;\\n                if(node -> left)\\n                    q.push(node -> left) ;\\n                if(node -> right)\\n                    q.push(node -> right) ;\\n            }\\n                count += solve(v, n) ;\\n        }\\n            return count ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3282386,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        pair<int, int> arrPos[n];\\n        for (int i = 0; i < n; i++) {\\n            arrPos[i].first = arr[i];\\n            arrPos[i].second = i;\\n        }\\n    \\n        sort(arrPos, arrPos + n);\\n    \\n        vector<bool> vis(n, false);\\n    \\n        int ans = 0;\\n    \\n        for (int i = 0; i < n; i++) {\\n            if (vis[i] || arrPos[i].second == i)\\n                continue;\\n    \\n            int cycle_size = 0;\\n            int j = i;\\n            while (!vis[j]) {\\n                vis[j] = 1;\\n                j = arrPos[j].second;\\n                cycle_size++;\\n            }\\n            if (cycle_size > 0) {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n  \\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans =0;\\n\\n        while(!q.empty()){\\n            int s =q.size();\\n            vector<int> temp;\\n            while(s--){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                temp.push_back(curr -> val);\\n                if(curr -> left){\\n                    q.push(curr -> left);\\n                }\\n                if(curr -> right){\\n                    q.push(curr -> right);\\n                }\\n            }\\n            int t = minSwaps(temp);\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        pair<int, int> arrPos[n];\\n        for (int i = 0; i < n; i++) {\\n            arrPos[i].first = arr[i];\\n            arrPos[i].second = i;\\n        }\\n    \\n        sort(arrPos, arrPos + n);\\n    \\n        vector<bool> vis(n, false);\\n    \\n        int ans = 0;\\n    \\n        for (int i = 0; i < n; i++) {\\n            if (vis[i] || arrPos[i].second == i)\\n                continue;\\n    \\n            int cycle_size = 0;\\n            int j = i;\\n            while (!vis[j]) {\\n                vis[j] = 1;\\n                j = arrPos[j].second;\\n                cycle_size++;\\n            }\\n            if (cycle_size > 0) {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n  \\n\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans =0;\\n\\n        while(!q.empty()){\\n            int s =q.size();\\n            vector<int> temp;\\n            while(s--){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                temp.push_back(curr -> val);\\n                if(curr -> left){\\n                    q.push(curr -> left);\\n                }\\n                if(curr -> right){\\n                    q.push(curr -> right);\\n                }\\n            }\\n            int t = minSwaps(temp);\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272899,
                "title": "python3-esy-90-faster-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        def noOfOperationsNeeded(arr):\\n            x=sorted(arr)\\n            hashMap={arr[i]:i for i in range(len(arr))}\\n            cnt=0\\n            for i in range(len(arr)):\\n                if arr[i]!=x[i]:\\n                    a=arr[i]\\n                    b=x[i]\\n                    hashMap[a],hashMap[b]=hashMap[b],hashMap[a]\\n                    arr[i]=b\\n                    arr[hashMap[a]]=a\\n                    cnt+=1            \\n            return cnt\\n\\n        res=0\\n        q=deque()\\n        q.append(root)\\n\\n        while len(q)!=0:\\n            level=[]\\n            size=len(q)\\n            for i in range(size):\\n                node=q.popleft()\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n                level.append(node.val)\\n            res+=noOfOperationsNeeded(level)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Tree",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        def noOfOperationsNeeded(arr):\\n            x=sorted(arr)\\n            hashMap={arr[i]:i for i in range(len(arr))}\\n            cnt=0\\n            for i in range(len(arr)):\\n                if arr[i]!=x[i]:\\n                    a=arr[i]\\n                    b=x[i]\\n                    hashMap[a],hashMap[b]=hashMap[b],hashMap[a]\\n                    arr[i]=b\\n                    arr[hashMap[a]]=a\\n                    cnt+=1            \\n            return cnt\\n\\n        res=0\\n        q=deque()\\n        q.append(root)\\n\\n        while len(q)!=0:\\n            level=[]\\n            size=len(q)\\n            for i in range(size):\\n                node=q.popleft()\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n                level.append(node.val)\\n            res+=noOfOperationsNeeded(level)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207074,
                "title": "python-dictionary-to-count-number-of-swaps-bfs",
                "content": "BFS is easy part.\\nHow to find number of swaps? I create a dictionary: value of the node and its initial index. For example we have a list of nodes values: `[7,6,8,5]`. Than, the dictionary: `d = {7:0, 6:1, 8:2, 5:3}`. We can make it because the values are unique.\\nThan, I sort values and keep in the separate list `[5,6,7,8]`. I loop throuth the sorted list and compare the values of both: original and sorted lists. If values are different: I find the indexes of the both values in the `d` and swap them in the original list. Thus, we made one swap. In order to keep the `d` up to date - I update its values.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        ans = 0\\n        stack = [root]\\n        while stack:\\n            \\n            new_stack = []\\n            d = dict()\\n            \\n            for i, node in enumerate(stack):\\n                d[node.val] = i\\n                if node.left:\\n                    new_stack.append(node.left)\\n                if node.right:\\n                    new_stack.append(node.right)\\n            \\n            keys = list(d.keys())\\n            sorted_keys = sorted(d.keys())\\n            for i in range(len(keys)):\\n                if keys[i] == sorted_keys[i]:\\n                    continue\\n                else:\\n                    ans += 1\\n                    idx_key, idx_sorted_key = d[keys[i]], d[sorted_keys[i]]\\n                    keys[idx_key], keys[idx_sorted_key] = keys[idx_sorted_key], keys[idx_key]\\n                    d[keys[idx_sorted_key]] = idx_sorted_key\\n            \\n            stack = new_stack\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        \\n        ans = 0\\n        stack = [root]\\n        while stack:\\n            \\n            new_stack = []\\n            d = dict()\\n            \\n            for i, node in enumerate(stack):\\n                d[node.val] = i\\n                if node.left:\\n                    new_stack.append(node.left)\\n                if node.right:\\n                    new_stack.append(node.right)\\n            \\n            keys = list(d.keys())\\n            sorted_keys = sorted(d.keys())\\n            for i in range(len(keys)):\\n                if keys[i] == sorted_keys[i]:\\n                    continue\\n                else:\\n                    ans += 1\\n                    idx_key, idx_sorted_key = d[keys[i]], d[sorted_keys[i]]\\n                    keys[idx_key], keys[idx_sorted_key] = keys[idx_sorted_key], keys[idx_key]\\n                    d[keys[idx_sorted_key]] = idx_sorted_key\\n            \\n            stack = new_stack\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206259,
                "title": "level-order-traversal-hashing-at-each-level",
                "content": "# Intuition\\n- Combine level order traversal and evaluate number of swaps at each level.\\n\\n# Approach\\n- Evaluate the elements at each level and lets store them in 2 arrays, one for original order of reference and one for sorting.\\n- Sort one array and create a map containing the mapping of value and its correct index\\n- iterate through oiriginal array, and if the index of the element does not match its index in map, swap the two indexes and keep the count of swaps.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) (for sorting) + O(2*n) (for in-order traversal + iteration)\\n\\n- Space complexity:\\n- O(3n) one for map and one for array lists.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> row = new ArrayList<>();\\n            List<Integer> copy = new ArrayList<>();\\n            for (int i=0; i< n; i++) {\\n                TreeNode front = q.peek();\\n                q.poll();\\n                if (front.left != null) q.add(front.left);\\n                if (front.right != null) q.add(front.right);\\n                row.add(front.val);\\n                copy.add(front.val);\\n            }\\n            Collections.sort(copy);\\n            Map<Integer, Integer> index = new HashMap<>();\\n            for (int i=0;i<copy.size();i++) {\\n                index.put(copy.get(i), i);\\n            }\\n\\n            for (int i=0; i<row.size(); i++) {\\n                if (index.get(row.get(i)) != i) {\\n                    Collections.swap(row, index.get(row.get(i)), i);\\n                    count++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        int count = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> row = new ArrayList<>();\\n            List<Integer> copy = new ArrayList<>();\\n            for (int i=0; i< n; i++) {\\n                TreeNode front = q.peek();\\n                q.poll();\\n                if (front.left != null) q.add(front.left);\\n                if (front.right != null) q.add(front.right);\\n                row.add(front.val);\\n                copy.add(front.val);\\n            }\\n            Collections.sort(copy);\\n            Map<Integer, Integer> index = new HashMap<>();\\n            for (int i=0;i<copy.size();i++) {\\n                index.put(copy.get(i), i);\\n            }\\n\\n            for (int i=0; i<row.size(); i++) {\\n                if (index.get(row.get(i)) != i) {\\n                    Collections.swap(row, index.get(row.get(i)), i);\\n                    count++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205240,
                "title": "java-bfs-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        //we have to use BFS\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int operation = 0;\\n        while(!q.isEmpty()){\\n            //traverse through level\\n            \\n            int size = q.size();\\n            int[] arr1 = new int[size];\\n            int[] arr2 = new int[size];\\n            \\n            for(int  i = 0 ; i < size ; i++){\\n                \\n                TreeNode last = q.poll();\\n\\n                arr1[i] = last.val;\\n                arr2[i] = last.val;\\n                if(last.left != null){\\n                \\n                    q.add(last.left);\\n                \\n                }\\n                \\n                if(last.right != null){\\n                    \\n                    q.add(last.right);\\n                \\n                }\\n                   \\n            }\\n            \\n            operation+=numberOfSwapsInLevel(arr1,arr2);\\n            \\n            \\n        }\\n        \\n        return operation;\\n        \\n        \\n    }\\n    \\n    \\n    public int numberOfSwapsInLevel(int[] list1 , int[] list2){\\n        int swap = 0;\\n        Arrays.sort(list2);\\n        \\n        //take the indexes of the List\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        int ind = 0;\\n        \\n        for(int key : list1){\\n            map.put(key,ind);\\n            ind++;\\n        }\\n        int temp = 0;\\n        int mapInd = 0;\\n        for(int i = 0 ; i < list2.length ; i++){\\n            \\n            if(list1[i] != list2[i]){\\n                \\n                //swap will happen\\n                //get the index of list2[i] in list1[i]\\n                 mapInd = map.get(list2[i]);\\n                 map.put(list1[i],mapInd);\\n                 map.put(list1[mapInd],ind);\\n                 temp = list1[mapInd];\\n                 list1[mapInd] = list1[i];\\n                 list1[i] = temp;\\n                \\n                swap++;\\n            }\\n        }\\n        \\n        \\n        return swap;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        //we have to use BFS\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int operation = 0;\\n        while(!q.isEmpty()){\\n            //traverse through level\\n            \\n            int size = q.size();\\n            int[] arr1 = new int[size];\\n            int[] arr2 = new int[size];\\n            \\n            for(int  i = 0 ; i < size ; i++){\\n                \\n                TreeNode last = q.poll();\\n\\n                arr1[i] = last.val;\\n                arr2[i] = last.val;\\n                if(last.left != null){\\n                \\n                    q.add(last.left);\\n                \\n                }\\n                \\n                if(last.right != null){\\n                    \\n                    q.add(last.right);\\n                \\n                }\\n                   \\n            }\\n            \\n            operation+=numberOfSwapsInLevel(arr1,arr2);\\n            \\n            \\n        }\\n        \\n        return operation;\\n        \\n        \\n    }\\n    \\n    \\n    public int numberOfSwapsInLevel(int[] list1 , int[] list2){\\n        int swap = 0;\\n        Arrays.sort(list2);\\n        \\n        //take the indexes of the List\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        int ind = 0;\\n        \\n        for(int key : list1){\\n            map.put(key,ind);\\n            ind++;\\n        }\\n        int temp = 0;\\n        int mapInd = 0;\\n        for(int i = 0 ; i < list2.length ; i++){\\n            \\n            if(list1[i] != list2[i]){\\n                \\n                //swap will happen\\n                //get the index of list2[i] in list1[i]\\n                 mapInd = map.get(list2[i]);\\n                 map.put(list1[i],mapInd);\\n                 map.put(list1[mapInd],ind);\\n                 temp = list1[mapInd];\\n                 list1[mapInd] = list1[i];\\n                 list1[i] = temp;\\n                \\n                swap++;\\n            }\\n        }\\n        \\n        \\n        return swap;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191671,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid swap(TreeNode* A, TreeNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\n    int minimumOperations(TreeNode* root) {\\n  \\n      queue<TreeNode*>q;\\n      q.push(root);\\n      int res = 0;\\n\\n      while(!q.empty())\\n      {\\n          int n = q.size();\\n           vector<TreeNode*>v;\\n\\n          for(int i = 0; i < n ; ++i)\\n          {\\n              auto temp = q.front();\\n              q.pop();\\n\\n              if(temp->left != NULL) q.push(temp->left);\\n              if(temp->right != NULL) q.push(temp->right);\\n\\n              v.push_back(temp);\\n          }\\n\\n          vector<int>copy;\\n          unordered_map<int,int>mpp;\\n\\n          for(auto it : v) copy.push_back(it->val);\\n          \\n          \\n          sort(copy.begin(), copy.end());\\n\\n          \\n          for(int i = 0;i < copy.size(); ++i) mpp[copy[i]] = i;\\n          \\n         \\n          for(int i = 0; i < v.size(); ++i)\\n          {\\n              if(mpp[v[i]->val] != i)\\n              {\\n                 swap(v[i], v[mpp[v[i]->val]]);\\n                 res++;\\n                 i--;\\n              }\\n          }\\n\\n      }\\n\\n      return res;  \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid swap(TreeNode* A, TreeNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\n    int minimumOperations(TreeNode* root) {\\n  \\n      queue<TreeNode*>q;\\n      q.push(root);\\n      int res = 0;\\n\\n      while(!q.empty())\\n      {\\n          int n = q.size();\\n           vector<TreeNode*>v;\\n\\n          for(int i = 0; i < n ; ++i)\\n          {\\n              auto temp = q.front();\\n              q.pop();\\n\\n              if(temp->left != NULL) q.push(temp->left);\\n              if(temp->right != NULL) q.push(temp->right);\\n\\n              v.push_back(temp);\\n          }\\n\\n          vector<int>copy;\\n          unordered_map<int,int>mpp;\\n\\n          for(auto it : v) copy.push_back(it->val);\\n          \\n          \\n          sort(copy.begin(), copy.end());\\n\\n          \\n          for(int i = 0;i < copy.size(); ++i) mpp[copy[i]] = i;\\n          \\n         \\n          for(int i = 0; i < v.size(); ++i)\\n          {\\n              if(mpp[v[i]->val] != i)\\n              {\\n                 swap(v[i], v[mpp[v[i]->val]]);\\n                 res++;\\n                 i--;\\n              }\\n          }\\n\\n      }\\n\\n      return res;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180742,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndo a normal BFS and save the elements in an array for each level and then find how many minimum swaps is required to sort that array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. BFS and store the elements for each level\\n2. call another function to find minimum swaps required to sort it\\n3. to find the minimum swaps to sort array, i have used an arraylist of pair class to store the element and its index and then i sorted it and then i made the sorted list to original array to find the count.basically i did in the reverse order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int res = 0;\\n        while(q.size() > 0){\\n            int size = q.size();\\n            int[] arr = new int[size];\\n            int k = 0;\\n            while(size-- > 0){\\n                TreeNode node = q.poll();\\n                arr[k++] = node.val;\\n                if(node.left != null) q.add(node.left);\\n                if(node.right != null) q.add(node.right);\\n            }\\n            res += minSwaps(arr);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    class Pair {\\n    int num;\\n    int idx;\\n    \\n    Pair(int n, int i){\\n        num = n;\\n        idx = i;\\n    }\\n}\\n    \\n    public int minSwaps(int nums[])\\n    {\\n        // Code here\\n        int n = nums.length;\\n        List<Pair> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            Pair p = new Pair(nums[i], i);\\n            list.add(p);\\n        }\\n        \\n        Collections.sort(list, (a, b) -> a.num - b.num);\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i == list.get(i).idx) continue;\\n            swap(list, i);\\n            cnt++;\\n            i--;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    void swap(List<Pair> list, int i){\\n        Pair p = list.get(i);\\n        int j = p.idx;\\n        Pair temp = list.get(i);\\n        list.set(i, list.get(j));\\n        list.set(j, temp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int res = 0;\\n        while(q.size() > 0){\\n            int size = q.size();\\n            int[] arr = new int[size];\\n            int k = 0;\\n            while(size-- > 0){\\n                TreeNode node = q.poll();\\n                arr[k++] = node.val;\\n                if(node.left != null) q.add(node.left);\\n                if(node.right != null) q.add(node.right);\\n            }\\n            res += minSwaps(arr);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    class Pair {\\n    int num;\\n    int idx;\\n    \\n    Pair(int n, int i){\\n        num = n;\\n        idx = i;\\n    }\\n}\\n    \\n    public int minSwaps(int nums[])\\n    {\\n        // Code here\\n        int n = nums.length;\\n        List<Pair> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            Pair p = new Pair(nums[i], i);\\n            list.add(p);\\n        }\\n        \\n        Collections.sort(list, (a, b) -> a.num - b.num);\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i == list.get(i).idx) continue;\\n            swap(list, i);\\n            cnt++;\\n            i--;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    void swap(List<Pair> list, int i){\\n        Pair p = list.get(i);\\n        int j = p.idx;\\n        Pair temp = list.get(i);\\n        list.set(i, list.get(j));\\n        list.set(j, temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179127,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void swap(int *x, int *y) {\\n        int temp= *x;\\n        *x= *y;\\n        *y= temp;\\n    }\\n    int minSwaps(vector<int>& v) {\\n        int n= v.size();\\n        int count= 0;\\n        vector<int> k= v;\\n        sort(v.begin(), v.end());\\n        map<int, int> m;\\n        for(int i=0;i<n;i++){\\n            m[k[i]]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            auto it= m.find(v[i]);\\n            int idx= it->second;\\n            if(idx!=i){\\n                count++;\\n                m[k[i]]=idx;\\n                m[k[idx]]=i;\\n                swap(&k[i], &k[idx]);\\n            }\\n        }\\n        return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int count= 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n= q.size();\\n            vector<int> v;\\n            while(n--){\\n                TreeNode* curr= q.front();\\n                int value= curr->val;\\n                q.pop();\\n                v.push_back(value);\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            count+=minSwaps(v);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void swap(int *x, int *y) {\\n        int temp= *x;\\n        *x= *y;\\n        *y= temp;\\n    }\\n    int minSwaps(vector<int>& v) {\\n        int n= v.size();\\n        int count= 0;\\n        vector<int> k= v;\\n        sort(v.begin(), v.end());\\n        map<int, int> m;\\n        for(int i=0;i<n;i++){\\n            m[k[i]]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            auto it= m.find(v[i]);\\n            int idx= it->second;\\n            if(idx!=i){\\n                count++;\\n                m[k[i]]=idx;\\n                m[k[idx]]=i;\\n                swap(&k[i], &k[idx]);\\n            }\\n        }\\n        return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        int count= 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n= q.size();\\n            vector<int> v;\\n            while(n--){\\n                TreeNode* curr= q.front();\\n                int value= curr->val;\\n                q.pop();\\n                v.push_back(value);\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            count+=minSwaps(v);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137701,
                "title": "accepted-solution-simple-approach",
                "content": "# Approach\\nSimple BFS for level order traversal of the tree and storing all elements on the same level\\n\\nNow, for minimum swaps:\\ntake first element of the array, place it in the array at its right position,(swap it with the element at its position),count that as one swap\\n(To find out the position of an element in the array, traverse the array to find the number of elements lesser than our current element,if there are **\\'n\\'** elements lesser than our element,then its final position in array is **\\'n\\'**)\\nDo that till all elements are in the right position\\n\\nNote:\\n**```list.stream().mapToInt(i->i).toArray()```**\\nThis is to convert the list of current level elements into an array(using Java8 streams API),and pass it to the function\\nOne can do it manually as well\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int swaps = 0;\\n\\n        while(!q.isEmpty()){\\n            int level = q.size();\\n            List<Integer> list = new ArrayList<>();\\n            while(level-->0){\\n                TreeNode node = q.poll();\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n                list.add(node.val);\\n            }\\n            swaps+=getQSSwapCount(list.stream().mapToInt(i->i).toArray());\\n        }\\n        return swaps;        \\n    }\\n\\n    int getQSSwapCount(int[] arr){\\n        if(isDesc(arr)) return arr.length/2;\\n        int count = 0,i = 0;\\n        while(i<arr.length){\\n            int idx = 0;\\n            for(int num:arr) if(num<arr[i]) idx++;\\n            if(i == idx) i++;\\n            else{\\n                int t = arr[i];\\n                arr[i] = arr[idx];\\n                arr[idx] = t;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    boolean isDesc(int[] arr){\\n        for(int i=0;i<arr.length-1;i++)\\n            if(arr[i]<arr[i+1])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```list.stream().mapToInt(i->i).toArray()```\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int swaps = 0;\\n\\n        while(!q.isEmpty()){\\n            int level = q.size();\\n            List<Integer> list = new ArrayList<>();\\n            while(level-->0){\\n                TreeNode node = q.poll();\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n                list.add(node.val);\\n            }\\n            swaps+=getQSSwapCount(list.stream().mapToInt(i->i).toArray());\\n        }\\n        return swaps;        \\n    }\\n\\n    int getQSSwapCount(int[] arr){\\n        if(isDesc(arr)) return arr.length/2;\\n        int count = 0,i = 0;\\n        while(i<arr.length){\\n            int idx = 0;\\n            for(int num:arr) if(num<arr[i]) idx++;\\n            if(i == idx) i++;\\n            else{\\n                int t = arr[i];\\n                arr[i] = arr[idx];\\n                arr[idx] = t;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    boolean isDesc(int[] arr){\\n        for(int i=0;i<arr.length-1;i++)\\n            if(arr[i]<arr[i+1])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112753,
                "title": "python-cyclesort-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        ans = [0] \\n        def minimum_swaps(arr):\\n            n = len(arr)\\n            arr_index = [*enumerate(arr)]\\n            arr_index.sort(key=lambda x: x[1])\\n            visited = [False] * n\\n            swaps = 0\\n            for i in range(n):\\n                if visited[i] or arr_index[i][0] == i:\\n                    continue\\n                cycle_size = 0\\n                j = i\\n                while not visited[j]:\\n                    visited[j] = True\\n                    j = arr_index[j][0]\\n                    cycle_size += 1\\n                if cycle_size > 0:\\n                    swaps += (cycle_size - 1)\\n            return swaps\\n\\n\\n        q = deque() \\n        q.append(root) \\n        while q:\\n            n = len(q)\\n            res = [] \\n            for _ in range(n):\\n                node = q.popleft()\\n                res.append(node.val) \\n                if node.left:\\n                    q.append(node.left) \\n                if node.right:\\n                    q.append(node.right) \\n            ans[0]+=minimum_swaps(res)\\n        return ans[0]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        ans = [0] \\n        def minimum_swaps(arr):\\n            n = len(arr)\\n            arr_index = [*enumerate(arr)]\\n            arr_index.sort(key=lambda x: x[1])\\n            visited = [False] * n\\n            swaps = 0\\n            for i in range(n):\\n                if visited[i] or arr_index[i][0] == i:\\n                    continue\\n                cycle_size = 0\\n                j = i\\n                while not visited[j]:\\n                    visited[j] = True\\n                    j = arr_index[j][0]\\n                    cycle_size += 1\\n                if cycle_size > 0:\\n                    swaps += (cycle_size - 1)\\n            return swaps\\n\\n\\n        q = deque() \\n        q.append(root) \\n        while q:\\n            n = len(q)\\n            res = [] \\n            for _ in range(n):\\n                node = q.popleft()\\n                res.append(node.val) \\n                if node.left:\\n                    q.append(node.left) \\n                if node.right:\\n                    q.append(node.right) \\n            ans[0]+=minimum_swaps(res)\\n        return ans[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108843,
                "title": "java-easy-to-understand-fast",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(ArrayList<Integer> al) {\\n        int count = 0;\\n        //compare sorted array element positions with actual array element positions\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<al.size(); i++) {\\n            map.put(al.get(i), i);\\n        }\\n        Collections.sort(al);\\n        for(int i=0; i<al.size(); i++) {\\n            if(map.get(al.get(i)) == i) {\\n                continue;\\n            } else {\\n                count++;\\n                swap(al, map.get(al.get(i)), i);\\n            }\\n            i--;\\n        }\\n        return count;\\n    }\\n    public void swap(ArrayList<Integer> al, int i, int j) {\\n        int temp = al.get(i);\\n        al.set(i, al.get(j));\\n        al.set(j, temp);\\n    }\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int ans = 0;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        //at every level change question to min swaps reqd to sort arraylist\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i=0; i<size; i++) {\\n                TreeNode pop = q.remove();\\n                al.add(pop.val);\\n                if(pop.left != null) {\\n                    q.offer(pop.left);\\n                }\\n                if(pop.right != null) {\\n                    q.offer(pop.right);\\n                }\\n            }\\n            ans += getMinSwaps(al);\\n            al = new ArrayList<>();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(ArrayList<Integer> al) {\\n        int count = 0;\\n        //compare sorted array element positions with actual array element positions\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<al.size(); i++) {\\n            map.put(al.get(i), i);\\n        }\\n        Collections.sort(al);\\n        for(int i=0; i<al.size(); i++) {\\n            if(map.get(al.get(i)) == i) {\\n                continue;\\n            } else {\\n                count++;\\n                swap(al, map.get(al.get(i)), i);\\n            }\\n            i--;\\n        }\\n        return count;\\n    }\\n    public void swap(ArrayList<Integer> al, int i, int j) {\\n        int temp = al.get(i);\\n        al.set(i, al.get(j));\\n        al.set(j, temp);\\n    }\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int ans = 0;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        //at every level change question to min swaps reqd to sort arraylist\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i=0; i<size; i++) {\\n                TreeNode pop = q.remove();\\n                al.add(pop.val);\\n                if(pop.left != null) {\\n                    q.offer(pop.left);\\n                }\\n                if(pop.right != null) {\\n                    q.offer(pop.right);\\n                }\\n            }\\n            ans += getMinSwaps(al);\\n            al = new ArrayList<>();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105360,
                "title": "short-and-concise-c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> vec;\\n    void helper(TreeNode* root,int level){\\n        if(!root)return;\\n        if(level==vec.size()) vec.push_back({root->val});\\n        else vec[level].push_back(root->val);\\n        helper(root->left,level+1);\\n        helper(root->right,level+1);\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        helper(root,0);\\n        int res=0;\\n        for(vector<int> &v:vec){\\n\\t\\t    map<int, int>mp1;\\n\\t\\t    for(int i=0;i<v.size();i++){\\n\\t\\t    \\tmp1[v[i]] = i;\\n\\t\\t    }\\n\\t\\t    int idx = 0;\\n\\t\\t    for(auto &pr:mp1){\\n\\t\\t    \\tif(pr.second != idx){\\n\\t\\t    \\t\\tres++;\\n\\t\\t    \\t\\tmp1[v[idx]] = pr.second;\\n\\t\\t    \\t\\tswap(v[idx], v[pr.second]);\\n\\t\\t    \\t\\tpr.second = idx;\\n\\t\\t    \\t}\\n\\t\\t    \\tidx++;\\n\\t\\t    }\\n\\t    }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> vec;\\n    void helper(TreeNode* root,int level){\\n        if(!root)return;\\n        if(level==vec.size()) vec.push_back({root->val});\\n        else vec[level].push_back(root->val);\\n        helper(root->left,level+1);\\n        helper(root->right,level+1);\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        helper(root,0);\\n        int res=0;\\n        for(vector<int> &v:vec){\\n\\t\\t    map<int, int>mp1;\\n\\t\\t    for(int i=0;i<v.size();i++){\\n\\t\\t    \\tmp1[v[i]] = i;\\n\\t\\t    }\\n\\t\\t    int idx = 0;\\n\\t\\t    for(auto &pr:mp1){\\n\\t\\t    \\tif(pr.second != idx){\\n\\t\\t    \\t\\tres++;\\n\\t\\t    \\t\\tmp1[v[idx]] = pr.second;\\n\\t\\t    \\t\\tswap(v[idx], v[pr.second]);\\n\\t\\t    \\t\\tpr.second = idx;\\n\\t\\t    \\t}\\n\\t\\t    \\tidx++;\\n\\t\\t    }\\n\\t    }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098525,
                "title": "c-solution-hash-map",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int swaps = 0;\\n\\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<int> v;\\n            while(n--) {\\n                auto p = q.front();\\n                q.pop();\\n                v.push_back(p->val);\\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n            }\\n\\n            vector<int> temp (v);\\n            sort(temp.begin(), temp.end());\\n            \\n            unordered_map<int,int> mp;\\n            for(int i=0;i<temp.size();i++) mp[temp[i]] = i;\\n\\n            for(int i=0;i<temp.size();i++) {\\n                if(mp[v[i]] != i) { // if it is not on correct index\\n                    swap(v[i], v[mp[v[i]]]);\\n                    swaps++;\\n                    i--;\\n                }\\n            }\\n        }\\n\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int swaps = 0;\\n\\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<int> v;\\n            while(n--) {\\n                auto p = q.front();\\n                q.pop();\\n                v.push_back(p->val);\\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n            }\\n\\n            vector<int> temp (v);\\n            sort(temp.begin(), temp.end());\\n            \\n            unordered_map<int,int> mp;\\n            for(int i=0;i<temp.size();i++) mp[temp[i]] = i;\\n\\n            for(int i=0;i<temp.size();i++) {\\n                if(mp[v[i]] != i) { // if it is not on correct index\\n                    swap(v[i], v[mp[v[i]]]);\\n                    swaps++;\\n                    i--;\\n                }\\n            }\\n        }\\n\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095470,
                "title": "c-very-easy-using-level-order-traversal-of-tree",
                "content": "# Approach\\n1. Write a finction **\\'minimumSwap\\'** to find out the minimum number of swap required to sort an array. and it returns an integer **\\'count\\'** which is minimum no. of swaps.\\n2. Write code for level order traversal of tree and call **\\'minimumSwap\\'** function for each level.\\n3. add into **ans** what returns \\'minimumSwap\\' function.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int minimumSwap(vector<int> &temp){\\n        int count = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i=0; i<temp.size(); i++){\\n            v.push_back(make_pair(temp[i], i));\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(i == v[i].second)\\n                continue;\\n            else{\\n                count++;\\n                swap(v[i], v[v[i].second]);\\n                i--;\\n            }    \\n        }\\n        return count;\\n    }\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int siz = q.size();\\n            vector<int> level;\\n            while(siz--){\\n                TreeNode* frontt = q.front();\\n                q.pop();\\n                level.push_back(frontt->val);\\n                if(frontt->left)\\n                    q.push(frontt->left);\\n                if(frontt->right)\\n                    q.push(frontt->right);    \\n            }\\n            ans += minimumSwap(level);\\n\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int minimumSwap(vector<int> &temp){\\n        int count = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i=0; i<temp.size(); i++){\\n            v.push_back(make_pair(temp[i], i));\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(i == v[i].second)\\n                continue;\\n            else{\\n                count++;\\n                swap(v[i], v[v[i].second]);\\n                i--;\\n            }    \\n        }\\n        return count;\\n    }\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int siz = q.size();\\n            vector<int> level;\\n            while(siz--){\\n                TreeNode* frontt = q.front();\\n                q.pop();\\n                level.push_back(frontt->val);\\n                if(frontt->left)\\n                    q.push(frontt->left);\\n                if(frontt->right)\\n                    q.push(frontt->right);    \\n            }\\n            ans += minimumSwap(level);\\n\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074387,
                "title": "simulate-swapping-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can greedily sent elements to their proper \"home\" position, and if we get lucky and send 2 home in one swap, thats good too, but we can\\'t do better than just sending elements home. I don\\'t have the proof but its probably a combinatorics proof somewhere. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe go row by row. \\nFor each row, we sort the values so we know their proper \"home\" (the index that they are at in the sorted array). We also keep two dictionaries; `loc`, storing the location of a value, and `res`, storing the resident of an index.\\n\\nWe then go through the sorted array `tmp` and send the from its current location to its home. If its current location is home, we just continue. When we send the element home, we must take the element that is in its home and send it to the location of the current element.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\nr = length of a row\\nMaking the row takes r and finding sorted index and insertion takes r*logr so each iteration takes r + rlogr. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ For the dictionaries and lists. \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        ret = 0\\n        row = [root]\\n        while row: \\n            nxt, tmp, cnt = [], [], 0\\n            loc = {}\\n            res = {}\\n            for n in row:\\n                idx = bisect_left(tmp, n.val)\\n                loc[n.val] = cnt\\n                res[cnt] = n.val\\n                tmp.insert(idx, n.val)\\n                cnt += 1\\n                if n.left: nxt.append(n.left)\\n                if n.right: nxt.append(n.right)\\n            row = nxt\\n            for home, val in enumerate(tmp): \\n                if home == loc[val]: continue\\n                # print(home, val, loc, res)\\n                l, r = loc[val], res[home]\\n                loc[r] = l\\n                res[l] = r\\n                loc[val], res[home] = home, val\\n                \\n                ret += 1\\n        return ret\\n\\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        ret = 0\\n        row = [root]\\n        while row: \\n            nxt, tmp, cnt = [], [], 0\\n            loc = {}\\n            res = {}\\n            for n in row:\\n                idx = bisect_left(tmp, n.val)\\n                loc[n.val] = cnt\\n                res[cnt] = n.val\\n                tmp.insert(idx, n.val)\\n                cnt += 1\\n                if n.left: nxt.append(n.left)\\n                if n.right: nxt.append(n.right)\\n            row = nxt\\n            for home, val in enumerate(tmp): \\n                if home == loc[val]: continue\\n                # print(home, val, loc, res)\\n                l, r = loc[val], res[home]\\n                loc[r] = l\\n                res[l] = r\\n                loc[val], res[home] = home, val\\n                \\n                ret += 1\\n        return ret\\n\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051660,
                "title": "c-level-order-minimum-swaps-to-sort-beats-95",
                "content": "# Please Upvote if Find Helpful!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Level Order Traversal Alongside using the concept of minimum swaps to sort an Array.\\n\\n\\n# Code\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans =  0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> temp(n);\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* a=  q.front();\\n                q.pop();\\n                temp.push_back(a->val);\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                }\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                }\\n            }\\n            //Minimum swaps to sort an array\\n            vector<pair<int, int>> v;\\n                for (int i=0; i<temp.size(); i++){\\n                    v.push_back({temp[i], i});\\n                }\\n                sort(v.begin(), v.end());\\n                for (int i=0; i<temp.size(); i++){\\n                    if (i!=v[i].second){\\n                        ans++;\\n                        swap(v[i], v[v[i].second]);\\n                        i--;\\n                    }\\n                }\\n        }   \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        int ans =  0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> temp(n);\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* a=  q.front();\\n                q.pop();\\n                temp.push_back(a->val);\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3049192,
                "title": "cpp-easy-solution-bfs-level-order-traversal",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q ;\\n        q.push(root) ;\\n        int count =0 ;\\n       \\n        while(!q.empty())\\n        {\\n            vector<int>sortLvl ;\\n            vector<int>level ;\\n            int size= q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n              TreeNode*node=q.front() ;\\n              level.push_back(node->val) ;\\n              sortLvl.push_back(node->val) ;\\n              if(node->left)\\n               q.push(node->left) ;\\n\\n              if(node->right)\\n                q.push(node->right) ;\\n             q.pop() ;\\n            }\\n          \\n           sort(sortLvl.begin(),sortLvl.end()) ;\\n\\n           for(int i=0;i<level.size();i++)\\n           {\\n               if(sortLvl[i]!=level[i])\\n               {\\n                   count++ ;\\nswap(level[i],level[find(level.begin(),level.end(),sortLvl[i])-level.begin()]);\\n               }\\n           }\\n        }\\n\\n        return count ;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q ;\\n        q.push(root) ;\\n        int count =0 ;\\n       \\n        while(!q.empty())\\n        {\\n            vector<int>sortLvl ;\\n            vector<int>level ;\\n            int size= q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n              TreeNode*node=q.front() ;\\n              level.push_back(node->val) ;\\n              sortLvl.push_back(node->val) ;\\n              if(node->left)\\n               q.push(node->left) ;\\n\\n              if(node->right)\\n                q.push(node->right) ;\\n             q.pop() ;\\n            }\\n          \\n           sort(sortLvl.begin(),sortLvl.end()) ;\\n\\n           for(int i=0;i<level.size();i++)\\n           {\\n               if(sortLvl[i]!=level[i])\\n               {\\n                   count++ ;\\nswap(level[i],level[find(level.begin(),level.end(),sortLvl[i])-level.begin()]);\\n               }\\n           }\\n        }\\n\\n        return count ;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038966,
                "title": "java-solution-time-complexity-o-n-n-log-n-space-complexity-o-n",
                "content": "# Intuition\\n    Please refer the comment in the code section\\n\\n# Approach\\n    Please refer the comment in the code section\\n\\n# Complexity\\n- Time complexity:\\n    - O(n* n * log n)\\n\\n- Space complexity:\\n    - O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /** \\n        This problem has been asked in below companies:\\n        Amazon\\n    */\\n\\n    /** \\n        The idea is to collect the nodes in a particular level in a list \\n        Make a copy of the list. Sort any of these.\\n        also create a index map for unorted list where we will be stroing the number with index.\\n        now traverse the unsorted array and check with sorted list where the value is getting mismatched\\n        if mismatched, then increment a variable swap by 1.\\n        update the index of the value of unsorted array in index map, the new index will be index of value in sorted array\\n        update the unsorted array, set the value of unsorted array in unsorted array only but the index will be \\n        index of value of sorted array, we will get the index from index map.\\n\\n        Time complexity: O(n * n * log n), \\n            first n is for nodes number as we are visiting each node once.\\n            we are sorting each level, that is n * log n, well not exactly n but some portion of n but we can consider as n.\\n\\n        Space complexity: O(n), as we are using queue, 2 arrays and a HashMap\\n\\n    */\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        int minswap = 0;\\n\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            int[] unsorted = new int[size];\\n            int[] sorted = new int[size];\\n\\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                unsorted[i] = node.val;\\n                sorted[i] = node.val;\\n                if(node.left != null) queue.add(node.left);\\n                if(node.right != null) queue.add(node.right);\\n            }\\n\\n            minswap += minSwapCount(unsorted, sorted);\\n        }\\n        \\n\\n        return minswap;\\n    }\\n\\n    private int minSwapCount(int[] unsorted, int[] sorted) {\\n        int n = unsorted.length;\\n        Map<Integer, Integer> index = new HashMap<>();\\n\\n        // create the index map\\n        for(int i = 0; i < n; i++) {\\n            index.put(unsorted[i], i);\\n        }\\n\\n        Arrays.sort(sorted);\\n\\n        int swap = 0;\\n        for(int i = 0; i < n; i++) {\\n            // if the value is mismatched\\n            if(unsorted[i] != sorted[i]) {\\n                // increase the swap number by 1\\n                swap++;\\n                // update the index of the value of unsorted with index of the value of sorted\\n                index.put(unsorted[i], index.get(sorted[i]));\\n                // update the unsorted array\\n                // set the value at index of the value of sorted array\\n                unsorted[index.get(sorted[i])] = unsorted[i];\\n            }\\n        }\\n\\n        return swap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /** \\n        This problem has been asked in below companies:\\n        Amazon\\n    */\\n\\n    /** \\n        The idea is to collect the nodes in a particular level in a list \\n        Make a copy of the list. Sort any of these.\\n        also create a index map for unorted list where we will be stroing the number with index.\\n        now traverse the unsorted array and check with sorted list where the value is getting mismatched\\n        if mismatched, then increment a variable swap by 1.\\n        update the index of the value of unsorted array in index map, the new index will be index of value in sorted array\\n        update the unsorted array, set the value of unsorted array in unsorted array only but the index will be \\n        index of value of sorted array, we will get the index from index map.\\n\\n        Time complexity: O(n * n * log n), \\n            first n is for nodes number as we are visiting each node once.\\n            we are sorting each level, that is n * log n, well not exactly n but some portion of n but we can consider as n.\\n\\n        Space complexity: O(n), as we are using queue, 2 arrays and a HashMap\\n\\n    */\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        int minswap = 0;\\n\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            int[] unsorted = new int[size];\\n            int[] sorted = new int[size];\\n\\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                unsorted[i] = node.val;\\n                sorted[i] = node.val;\\n                if(node.left != null) queue.add(node.left);\\n                if(node.right != null) queue.add(node.right);\\n            }\\n\\n            minswap += minSwapCount(unsorted, sorted);\\n        }\\n        \\n\\n        return minswap;\\n    }\\n\\n    private int minSwapCount(int[] unsorted, int[] sorted) {\\n        int n = unsorted.length;\\n        Map<Integer, Integer> index = new HashMap<>();\\n\\n        // create the index map\\n        for(int i = 0; i < n; i++) {\\n            index.put(unsorted[i], i);\\n        }\\n\\n        Arrays.sort(sorted);\\n\\n        int swap = 0;\\n        for(int i = 0; i < n; i++) {\\n            // if the value is mismatched\\n            if(unsorted[i] != sorted[i]) {\\n                // increase the swap number by 1\\n                swap++;\\n                // update the index of the value of unsorted with index of the value of sorted\\n                index.put(unsorted[i], index.get(sorted[i]));\\n                // update the unsorted array\\n                // set the value at index of the value of sorted array\\n                unsorted[index.get(sorted[i])] = unsorted[i];\\n            }\\n        }\\n\\n        return swap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034729,
                "title": "easy-java-approach-hashmap-sorting-bfs",
                "content": "**Idea:**\\n\\nBased on in-place array modification for sorting an array using HashMap. BFS is used for level order traversal.\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        queue.add(root);\\n        list.add(root.val);\\n        int swaps=0;\\n        \\n        while(!queue.isEmpty()) {\\n            swaps += totalSwapsRequired(list);\\n            list = new ArrayList<Integer>();\\n            int n=queue.size();\\n            while(n-->0) {\\n                TreeNode front = queue.removeFirst();\\n\\n                if(front.left != null) {\\n                    queue.add(front.left);\\n                    list.add(front.left.val);\\n                }\\n\\n                if(front.right != null) {\\n                    queue.add(front.right);\\n                    list.add(front.right.val);\\n                }\\n            }\\n        }\\n\\n        return swaps;\\n    }\\n\\n    private int totalSwapsRequired(ArrayList<Integer> list) {\\n        int n = list.size(), swaps=0;\\n        ArrayList<Integer> sortedList = new ArrayList<Integer>(n);\\n        for(int val:list) sortedList.add(val);\\n        Collections.sort(sortedList);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for(int i=0; i<n; ++i) map.put(sortedList.get(i), i);\\n        sortedList = null;\\n\\n        // Calculating no.of swaps required\\n        for(int idx=0; idx<n; ++idx) {\\n            int val = list.get(idx), sortedIdx = map.get(val);\\n            if(idx == sortedIdx) continue;\\n            while(idx != sortedIdx) {\\n                int temp = list.get(sortedIdx);\\n                list.set(sortedIdx, val);\\n                list.set(idx, temp);\\n                sortedIdx = map.get(temp);\\n                val = temp;\\n                ++swaps;\\n            }\\n        }\\n\\n        return swaps;\\n    }\\n}\\n\\n// 4 3 1 2 -> 2 3 1 4 -> 3 2 1 4 -> 1 2 3 4 (3)\\n```\\n\\n**Time Complexity:** O(n log n), where n=no.of nodes in the Tree\\n**Space Complexity:** O(3n), for storing the elements and map\\n\\n**Runtime:** 90ms, faster than 89% of the solutions\\n\\nUpvote if you have liked it! Thanks for reading!",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        queue.add(root);\\n        list.add(root.val);\\n        int swaps=0;\\n        \\n        while(!queue.isEmpty()) {\\n            swaps += totalSwapsRequired(list);\\n            list = new ArrayList<Integer>();\\n            int n=queue.size();\\n            while(n-->0) {\\n                TreeNode front = queue.removeFirst();\\n\\n                if(front.left != null) {\\n                    queue.add(front.left);\\n                    list.add(front.left.val);\\n                }\\n\\n                if(front.right != null) {\\n                    queue.add(front.right);\\n                    list.add(front.right.val);\\n                }\\n            }\\n        }\\n\\n        return swaps;\\n    }\\n\\n    private int totalSwapsRequired(ArrayList<Integer> list) {\\n        int n = list.size(), swaps=0;\\n        ArrayList<Integer> sortedList = new ArrayList<Integer>(n);\\n        for(int val:list) sortedList.add(val);\\n        Collections.sort(sortedList);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for(int i=0; i<n; ++i) map.put(sortedList.get(i), i);\\n        sortedList = null;\\n\\n        // Calculating no.of swaps required\\n        for(int idx=0; idx<n; ++idx) {\\n            int val = list.get(idx), sortedIdx = map.get(val);\\n            if(idx == sortedIdx) continue;\\n            while(idx != sortedIdx) {\\n                int temp = list.get(sortedIdx);\\n                list.set(sortedIdx, val);\\n                list.set(idx, temp);\\n                sortedIdx = map.get(temp);\\n                val = temp;\\n                ++swaps;\\n            }\\n        }\\n\\n        return swaps;\\n    }\\n}\\n\\n// 4 3 1 2 -> 2 3 1 4 -> 3 2 1 4 -> 1 2 3 4 (3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032484,
                "title": "python-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root):\\n        def getMinSwap(arr):\\n            m = len(arr)\\n            M = {}\\n            for i in range(m):\\n                M[arr[i]] = i\\n            arr.sort()\\n            visited = [False for col in range(m)]\\n            ans = 0\\n            for i in range(m):\\n                if (visited[i] or M[arr[i]] == i):\\n                    continue\\n                j, cycle_size = i, 0\\n                while (visited[j] == False):\\n                    visited[j] = True\\n                    j = M[arr[j]]\\n                    cycle_size += 1\\n                if (cycle_size > 0):\\n                    ans += (cycle_size - 1)\\n            return ans\\n        queue = [root]\\n        ans = 0\\n        while queue:\\n            levelSize = len(queue)\\n            arr = []\\n            for i in range(levelSize):\\n                node = queue.pop(0)\\n                arr.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            ans += getMinSwap(arr)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root):\\n        def getMinSwap(arr):\\n            m = len(arr)\\n            M = {}\\n            for i in range(m):\\n                M[arr[i]] = i\\n            arr.sort()\\n            visited = [False for col in range(m)]\\n            ans = 0\\n            for i in range(m):\\n                if (visited[i] or M[arr[i]] == i):\\n                    continue\\n                j, cycle_size = i, 0\\n                while (visited[j] == False):\\n                    visited[j] = True\\n                    j = M[arr[j]]\\n                    cycle_size += 1\\n                if (cycle_size > 0):\\n                    ans += (cycle_size - 1)\\n            return ans\\n        queue = [root]\\n        ans = 0\\n        while queue:\\n            levelSize = len(queue)\\n            arr = []\\n            for i in range(levelSize):\\n                node = queue.pop(0)\\n                arr.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            ans += getMinSwap(arr)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030226,
                "title": "python3-bfs-nlogn-solution",
                "content": "# Intuition\\nBFS because by level. Want to sort then compare indexes.\\nIdea is if you compare the level with a sorted one, and swap the different elements with each other, you\\'ll end up with least swaps required to swap array.\\n\\n# Approach\\nDo BFS. COnstruct level wise array. Compare it with sorted version. Maintain indexes dict and another status dict. Keep updating both of them until traversal is finished\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        dq = deque([root])\\n        ans = 0\\n        while dq:\\n            level = []\\n            for _ in range(len(dq)):\\n                cur = dq.popleft()\\n                if cur:\\n                    level.append(cur.val)\\n                    if cur.left:\\n                        dq.append(cur.left)\\n                    if cur.right:\\n                        dq.append(cur.right)\\n            status = {val: i for i, val in enumerate(level)}\\n            indexes = {i: val for i, val in enumerate(level)}\\n            swaps = 0\\n            for i, l in enumerate(sorted(level)):\\n                if l != indexes[i]:\\n                    ind = status[l]\\n                    status[l], status[indexes[i]] = status[indexes[i]], status[l]\\n                    indexes[i], indexes[ind] = indexes[ind], indexes[i]\\n                    swaps += 1\\n            ans += swaps\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        dq = deque([root])\\n        ans = 0\\n        while dq:\\n            level = []\\n            for _ in range(len(dq)):\\n                cur = dq.popleft()\\n                if cur:\\n                    level.append(cur.val)\\n                    if cur.left:\\n                        dq.append(cur.left)\\n                    if cur.right:\\n                        dq.append(cur.right)\\n            status = {val: i for i, val in enumerate(level)}\\n            indexes = {i: val for i, val in enumerate(level)}\\n            swaps = 0\\n            for i, l in enumerate(sorted(level)):\\n                if l != indexes[i]:\\n                    ind = status[l]\\n                    status[l], status[indexes[i]] = status[indexes[i]], status[l]\\n                    indexes[i], indexes[ind] = indexes[ind], indexes[i]\\n                    swaps += 1\\n            ans += swaps\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018582,
                "title": "swift-bfs-sort",
                "content": "# Approach\\nBFS + Sort\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumOperations(_ root: TreeNode?) -> Int {\\n        guard let r = root else { return 0 }\\n\\n        var queues = [r]\\n        var counter = 0\\n\\n        while !queues.isEmpty {\\n            var nums = [Int]()\\n\\n            for _ in queues {\\n                let queue =  queues.removeFirst()\\n                nums.append(queue.val)\\n                if let q = queue.left { queues.append(q) }\\n                if let q = queue.right { queues.append(q) }\\n            }\\n\\n            counter += sort(&nums)\\n        }\\n        return counter\\n    }\\n\\n    func sort(_ arr: inout [Int]) -> Int {\\n        var swapsCount = 0\\n        \\n        for i in 0..<arr.count - 1 {\\n            var minIndex = i\\n            \\n            for j in i + 1..<arr.count {\\n                if arr[j] < arr[minIndex] {\\n                    minIndex = j\\n                }\\n            }\\n            \\n            if minIndex != i {\\n                var temp = arr[minIndex]\\n                arr[minIndex] = arr[i]\\n                arr[i] = temp\\n                swapsCount += 1\\n            }\\n        }\\n        \\n        return swapsCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumOperations(_ root: TreeNode?) -> Int {\\n        guard let r = root else { return 0 }\\n\\n        var queues = [r]\\n        var counter = 0\\n\\n        while !queues.isEmpty {\\n            var nums = [Int]()\\n\\n            for _ in queues {\\n                let queue =  queues.removeFirst()\\n                nums.append(queue.val)\\n                if let q = queue.left { queues.append(q) }\\n                if let q = queue.right { queues.append(q) }\\n            }\\n\\n            counter += sort(&nums)\\n        }\\n        return counter\\n    }\\n\\n    func sort(_ arr: inout [Int]) -> Int {\\n        var swapsCount = 0\\n        \\n        for i in 0..<arr.count - 1 {\\n            var minIndex = i\\n            \\n            for j in i + 1..<arr.count {\\n                if arr[j] < arr[minIndex] {\\n                    minIndex = j\\n                }\\n            }\\n            \\n            if minIndex != i {\\n                var temp = arr[minIndex]\\n                arr[minIndex] = arr[i]\\n                arr[i] = temp\\n                swapsCount += 1\\n            }\\n        }\\n        \\n        return swapsCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997684,
                "title": "count-swaps-python3",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        levels = defaultdict(list)\\n        def helper(node, level):\\n            if node:\\n                levels[level].append(node.val)\\n                helper(node.left, level + 1)\\n                helper(node.right, level + 1)\\n        ans = 0\\n        helper(root, 0)\\n        for lvl, nodes in levels.items():\\n            sorted_nodes = sorted(nodes)\\n            if sorted_nodes == nodes:\\n                continue\\n\\n            map_nodes = {}\\n            for i, node in enumerate(nodes):\\n                map_nodes[node] = i\\n            \\n            init = 0\\n            for i, node in enumerate(nodes):\\n                if node != sorted_nodes[i]:\\n                    init = node\\n                    nodes[i], nodes[map_nodes[sorted_nodes[i]]] = nodes[map_nodes[sorted_nodes[i]]], nodes[i]\\n                    ans += 1\\n                    map_nodes[init] = map_nodes[sorted_nodes[i]]\\n                    map_nodes[sorted_nodes[i]] = i\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\\n        levels = defaultdict(list)\\n        def helper(node, level):\\n            if node:\\n                levels[level].append(node.val)\\n                helper(node.left, level + 1)\\n                helper(node.right, level + 1)\\n        ans = 0\\n        helper(root, 0)\\n        for lvl, nodes in levels.items():\\n            sorted_nodes = sorted(nodes)\\n            if sorted_nodes == nodes:\\n                continue\\n\\n            map_nodes = {}\\n            for i, node in enumerate(nodes):\\n                map_nodes[node] = i\\n            \\n            init = 0\\n            for i, node in enumerate(nodes):\\n                if node != sorted_nodes[i]:\\n                    init = node\\n                    nodes[i], nodes[map_nodes[sorted_nodes[i]]] = nodes[map_nodes[sorted_nodes[i]]], nodes[i]\\n                    ans += 1\\n                    map_nodes[init] = map_nodes[sorted_nodes[i]]\\n                    map_nodes[sorted_nodes[i]] = i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990094,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwap(queue<TreeNode*> nums) {\\n        vector<std::pair<int, int>> vec;\\n        int n = nums.size();\\n\\t    for (int i=0; i<n; i++) {\\n            vec.push_back({nums.front()->val, i});\\n            nums.pop();\\n        }\\n\\t    sort(vec.begin(), vec.end());\\n\\t   \\n\\t    int count = 0;\\n\\t    for (int i=0; i<n; i++) {\\n\\t        if (i != vec[i].second) {\\n\\t            count++;\\n\\t            swap(vec[i], vec[vec[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        if (!root) return 0;\\n        queue<TreeNode*> q;\\n\\n        q.push(root);\\n        TreeNode* temp;\\n        int ans =0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            ans += minSwap(q);\\n            while (size--) {\\n                temp = q.front();\\n                q.pop();\\n                if (temp->left) q.push(temp->left);\\n                if (temp->right) q.push(temp->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwap(queue<TreeNode*> nums) {\\n        vector<std::pair<int, int>> vec;\\n        int n = nums.size();\\n\\t    for (int i=0; i<n; i++) {\\n            vec.push_back({nums.front()->val, i});\\n            nums.pop();\\n        }\\n\\t    sort(vec.begin(), vec.end());\\n\\t   \\n\\t    int count = 0;\\n\\t    for (int i=0; i<n; i++) {\\n\\t        if (i != vec[i].second) {\\n\\t            count++;\\n\\t            swap(vec[i], vec[vec[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        if (!root) return 0;\\n        queue<TreeNode*> q;\\n\\n        q.push(root);\\n        TreeNode* temp;\\n        int ans =0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            ans += minSwap(q);\\n            while (size--) {\\n                temp = q.front();\\n                q.pop();\\n                if (temp->left) q.push(temp->left);\\n                if (temp->right) q.push(temp->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981394,
                "title": "minimum-number-of-swaps-to-sort-an-array-level-order-traversal-c",
                "content": "# Intuition\\nStore the elements of a level in an array with it\\'s index and sort it. Find the minimum number of swaps required to make the array sorted and add it to the result. Repeat this for all levels.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ --> where `n` is the number of nodes in the binary tree. This includes $$O(nlogn)$$ for sorting (you are sorting all the elements eventually), $$O(n)$$ for cycle size count, and $$O(n)$$ for the level order traversal.\\n\\n- Space complexity:\\n$$O(m)$$ --> where `m` is the maximum number of nodes in any level of the binary tree. This includes $$O(m)$$ for `visited`, $$O(m)$$ for `level`/`current`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinOperationsOfLevel(vector<pair<TreeNode*, int>>& level) {\\n        sort(level.begin(), level.end(), [&] (pair<TreeNode*, int>& p1, pair<TreeNode*, int>& p2) {\\n            return p1.first->val < p2.first->val;\\n        });\\n        vector<bool> visited(level.size(), false);\\n        int result = 0;\\n        for (int i = 0; i < visited.size(); i++) {\\n            if (visited[i] || level[i].second == i) continue;\\n            int cycleSize = 0;\\n            int j = i;\\n            while (!visited[j]) {\\n                visited[j] = true;\\n                j = level[j].second;\\n                cycleSize++;\\n            }\\n\\n            if (cycleSize > 0) result += cycleSize - 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        vector<pair<TreeNode*, int>> level;\\n        level.push_back({root, 0});\\n        int result = 0;\\n        while (level.size() > 0) {\\n            vector<pair<TreeNode*, int>> current;\\n            int k = 0;\\n            for (int j = 0; j < level.size(); j++) {\\n                if (level[j].first->left)\\n                    current.push_back({level[j].first->left, k++});\\n                if (level[j].first->right)\\n                    current.push_back({level[j].first->right, k++});\\n            }\\n            level = current;\\n            result += getMinOperationsOfLevel(current);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinOperationsOfLevel(vector<pair<TreeNode*, int>>& level) {\\n        sort(level.begin(), level.end(), [&] (pair<TreeNode*, int>& p1, pair<TreeNode*, int>& p2) {\\n            return p1.first->val < p2.first->val;\\n        });\\n        vector<bool> visited(level.size(), false);\\n        int result = 0;\\n        for (int i = 0; i < visited.size(); i++) {\\n            if (visited[i] || level[i].second == i) continue;\\n            int cycleSize = 0;\\n            int j = i;\\n            while (!visited[j]) {\\n                visited[j] = true;\\n                j = level[j].second;\\n                cycleSize++;\\n            }\\n\\n            if (cycleSize > 0) result += cycleSize - 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    int minimumOperations(TreeNode* root) {\\n        vector<pair<TreeNode*, int>> level;\\n        level.push_back({root, 0});\\n        int result = 0;\\n        while (level.size() > 0) {\\n            vector<pair<TreeNode*, int>> current;\\n            int k = 0;\\n            for (int j = 0; j < level.size(); j++) {\\n                if (level[j].first->left)\\n                    current.push_back({level[j].first->left, k++});\\n                if (level[j].first->right)\\n                    current.push_back({level[j].first->right, k++});\\n            }\\n            level = current;\\n            result += getMinOperationsOfLevel(current);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974760,
                "title": "level-traversal-cyclesort-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbinary tree level traversal and cycle sort in java.\\nPlease input comments if you find any places to improve.\\nthank you.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.offer(root);\\n        int total =0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<TreeNode> line = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode t = q.poll();\\n                \\n                line.add(t);\\n                if(t.left != null){\\n                    q.offer(t.left);\\n                }\\n                if(t.right != null){\\n                    q.offer(t.right);\\n                }\\n            }\\n            total+=calculateMin(line);\\n        }\\n        return total;\\n    }\\n\\n    public int calculateMin(List<TreeNode> list){\\n        List<TreeNode> sortedList = list.stream()\\n                .sorted((o1,o2) -> Integer.compare(o1.val,o2.val))\\n                .collect(Collectors.toList());\\n        Map<Integer,Integer> map =new HashMap<>();\\n        for(int i=0;i<sortedList.size();i++){\\n            map.put(sortedList.get(i).val,i);\\n        }\\n        int res =0;\\n        int i=0;\\n        while(i<list.size()){\\n            int correctIndex = map.get(list.get(i).val);\\n            if(correctIndex != i){\\n                TreeNode tmp = list.get(correctIndex);\\n                list.set(correctIndex,list.get(i));\\n                list.set(i,tmp);\\n                res++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.offer(root);\\n        int total =0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<TreeNode> line = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode t = q.poll();\\n                \\n                line.add(t);\\n                if(t.left != null){\\n                    q.offer(t.left);\\n                }\\n                if(t.right != null){\\n                    q.offer(t.right);\\n                }\\n            }\\n            total+=calculateMin(line);\\n        }\\n        return total;\\n    }\\n\\n    public int calculateMin(List<TreeNode> list){\\n        List<TreeNode> sortedList = list.stream()\\n                .sorted((o1,o2) -> Integer.compare(o1.val,o2.val))\\n                .collect(Collectors.toList());\\n        Map<Integer,Integer> map =new HashMap<>();\\n        for(int i=0;i<sortedList.size();i++){\\n            map.put(sortedList.get(i).val,i);\\n        }\\n        int res =0;\\n        int i=0;\\n        while(i<list.size()){\\n            int correctIndex = map.get(list.get(i).val);\\n            if(correctIndex != i){\\n                TreeNode tmp = list.get(correctIndex);\\n                list.set(correctIndex,list.get(i));\\n                list.set(i,tmp);\\n                res++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974421,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nint coutNode(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    return 1 + coutNode(root->left) + coutNode(root->right);\\n}\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\nint helper(int* sort, int* copy, int n){\\n    int ans = 0;\\n    int idx = 0;\\n    int N = 10 * n;\\n    int** hash = calloc(N, sizeof(int*));\\n    for(int i = 0; i < n; i++){\\n        int val = sort[i];\\n        int d = val;\\n        while(1){\\n            if(hash[d%N] == NULL){\\n                hash[d%N] = malloc(2 * sizeof(int));\\n                hash[d%N][0] = val;\\n                hash[d%N][1] = i;\\n                break;\\n            }\\n            else \\n                d++;\\n        }\\n    }\\n    while(idx < n){\\n        if(sort[idx] == copy[idx]){\\n            idx++;\\n            continue;\\n        }\\n        ans++;\\n        //find position\\n        int pos;\\n        int val = copy[idx];\\n        int d = val;\\n        while(1){\\n            if(hash[d%N][0] == val){\\n                pos = hash[d%N][1];\\n                break;\\n            }\\n            else\\n                d++;\\n        }    \\n        //swap\\n        int tmp = copy[idx];\\n        copy[idx] = copy[pos];\\n        copy[pos] = tmp;\\n    }\\n    for(int i = 0; i < N; i++){\\n        if(hash[i] != NULL)\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    return ans;\\n}\\nint minimumOperations(struct TreeNode* root){\\n    int ans = 0;\\n    int n = coutNode(root);\\n    struct TreeNode** arr1 = malloc((n+1)/2 * sizeof(struct TreeNode*));\\n    struct TreeNode** arr2 = malloc((n+1)/2 * sizeof(struct TreeNode*));\\n    int* copy = malloc((n+1)/2 * sizeof(int));\\n    int* sort = malloc((n+1)/2 * sizeof(int));\\n    int id1 = 0, id2 = 0;\\n    arr1[id1] = root;\\n    id1++;\\n    bool flag = true;\\n    while(id1 > 0 || id2 > 0){\\n        if(flag){\\n            for(int i = 0; i < id1; i++){\\n                if(arr1[i]->left != NULL){\\n                    arr2[id2] = arr1[i]->left ;\\n                    copy[id2] = arr2[id2]->val;\\n                    id2++;\\n                }\\n                if(arr1[i]->right){\\n                    arr2[id2] = arr1[i]->right ;\\n                    copy[id2] = arr2[id2]->val;\\n                    id2++;\\n                }\\n            } \\n            id1 = 0;\\n            flag = false;\\n            \\n            memcpy(sort, copy, id2*sizeof(int));\\n            qsort(sort, id2, sizeof(int), cmp);\\n            ans += helper(sort, copy, id2);\\n        }\\n        else{\\n            for(int i = 0; i < id2; i++){\\n                if(arr2[i]->left){\\n                    arr1[id1] = arr2[i]->left ;\\n                    copy[id1] = arr1[id1]->val;\\n                    id1++;\\n                }\\n                if(arr2[i]->right){\\n                    arr1[id1] = arr2[i]->right ;\\n                    copy[id1] = arr1[id1]->val;\\n                    id1++;\\n                }\\n            } \\n            id2 = 0;\\n            flag = true;\\n            memcpy(sort, copy, id1*sizeof(int));\\n            qsort(sort, id1, sizeof(int), cmp);\\n            ans += helper(sort, copy, id1);\\n        }\\n    }\\n    free(copy);\\n    free(sort);\\n    free(arr1);\\n    free(arr2);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nint coutNode(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    return 1 + coutNode(root->left) + coutNode(root->right);\\n}\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\nint helper(int* sort, int* copy, int n){\\n    int ans = 0;\\n    int idx = 0;\\n    int N = 10 * n;\\n    int** hash = calloc(N, sizeof(int*));\\n    for(int i = 0; i < n; i++){\\n        int val = sort[i];\\n        int d = val;\\n        while(1){\\n            if(hash[d%N] == NULL){\\n                hash[d%N] = malloc(2 * sizeof(int));\\n                hash[d%N][0] = val;\\n                hash[d%N][1] = i;\\n                break;\\n            }\\n            else \\n                d++;\\n        }\\n    }\\n    while(idx < n){\\n        if(sort[idx] == copy[idx]){\\n            idx++;\\n            continue;\\n        }\\n        ans++;\\n        //find position\\n        int pos;\\n        int val = copy[idx];\\n        int d = val;\\n        while(1){\\n            if(hash[d%N][0] == val){\\n                pos = hash[d%N][1];\\n                break;\\n            }\\n            else\\n                d++;\\n        }    \\n        //swap\\n        int tmp = copy[idx];\\n        copy[idx] = copy[pos];\\n        copy[pos] = tmp;\\n    }\\n    for(int i = 0; i < N; i++){\\n        if(hash[i] != NULL)\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    return ans;\\n}\\nint minimumOperations(struct TreeNode* root){\\n    int ans = 0;\\n    int n = coutNode(root);\\n    struct TreeNode** arr1 = malloc((n+1)/2 * sizeof(struct TreeNode*));\\n    struct TreeNode** arr2 = malloc((n+1)/2 * sizeof(struct TreeNode*));\\n    int* copy = malloc((n+1)/2 * sizeof(int));\\n    int* sort = malloc((n+1)/2 * sizeof(int));\\n    int id1 = 0, id2 = 0;\\n    arr1[id1] = root;\\n    id1++;\\n    bool flag = true;\\n    while(id1 > 0 || id2 > 0){\\n        if(flag){\\n            for(int i = 0; i < id1; i++){\\n                if(arr1[i]->left != NULL){\\n                    arr2[id2] = arr1[i]->left ;\\n                    copy[id2] = arr2[id2]->val;\\n                    id2++;\\n                }\\n                if(arr1[i]->right){\\n                    arr2[id2] = arr1[i]->right ;\\n                    copy[id2] = arr2[id2]->val;\\n                    id2++;\\n                }\\n            } \\n            id1 = 0;\\n            flag = false;\\n            \\n            memcpy(sort, copy, id2*sizeof(int));\\n            qsort(sort, id2, sizeof(int), cmp);\\n            ans += helper(sort, copy, id2);\\n        }\\n        else{\\n            for(int i = 0; i < id2; i++){\\n                if(arr2[i]->left){\\n                    arr1[id1] = arr2[i]->left ;\\n                    copy[id1] = arr1[id1]->val;\\n                    id1++;\\n                }\\n                if(arr2[i]->right){\\n                    arr1[id1] = arr2[i]->right ;\\n                    copy[id1] = arr1[id1]->val;\\n                    id1++;\\n                }\\n            } \\n            id2 = 0;\\n            flag = true;\\n            memcpy(sort, copy, id1*sizeof(int));\\n            qsort(sort, id1, sizeof(int), cmp);\\n            ans += helper(sort, copy, id1);\\n        }\\n    }\\n    free(copy);\\n    free(sort);\\n    free(arr1);\\n    free(arr2);\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2968736,
                "title": "extremely-fast-by-using-greedy-hashmap-swap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minimumOperations = function(root) {\\n    var res = []\\n    function bfs() {\\n        var queue = [[root]]\\n\\n        while (queue.length) {\\n            var curLevel = queue.shift()\\n\\n            if (!curLevel.length) break\\n            res.push(curLevel)\\n\\n            var nextLevel = []\\n            for (var i = 0; i < curLevel.length; i++) {\\n                var node = curLevel[i]\\n                if (node.left) {\\n                    nextLevel.push(node.left)\\n                }\\n                if (node.right) {\\n                    nextLevel.push(node.right)\\n                }\\n            }\\n\\n            queue.push(nextLevel)\\n        }\\n    }  \\n\\n    bfs()\\n\\n    var count = 0\\n    function swap(array) {\\n        var messValueIndexMap = {}\\n        var messIndexValueMap = {}\\n\\n        array.forEach((item, index) => {\\n            messValueIndexMap[item] = index\\n            messIndexValueMap[index] = item\\n        })\\n        array.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n        for (var i = 0; i < array.length; i++) {\\n            var val = array[i]\\n            var messVal = messIndexValueMap[i]\\n            if (messVal === val) continue\\n\\n            messIndexValueMap[i] = val\\n            var messIndex = messValueIndexMap[val]\\n            messIndexValueMap[messIndex] = messVal\\n            messValueIndexMap[val] = i\\n            messValueIndexMap[messVal] = messIndex\\n            count++\\n        }    \\n    }\\n\\n    res.map(level => level.map(node => node.val)).forEach(level => {\\n        swap(level)\\n    })  \\n\\n    return count\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minimumOperations = function(root) {\\n    var res = []\\n    function bfs() {\\n        var queue = [[root]]\\n\\n        while (queue.length) {\\n            var curLevel = queue.shift()\\n\\n            if (!curLevel.length) break\\n            res.push(curLevel)\\n\\n            var nextLevel = []\\n            for (var i = 0; i < curLevel.length; i++) {\\n                var node = curLevel[i]\\n                if (node.left) {\\n                    nextLevel.push(node.left)\\n                }\\n                if (node.right) {\\n                    nextLevel.push(node.right)\\n                }\\n            }\\n\\n            queue.push(nextLevel)\\n        }\\n    }  \\n\\n    bfs()\\n\\n    var count = 0\\n    function swap(array) {\\n        var messValueIndexMap = {}\\n        var messIndexValueMap = {}\\n\\n        array.forEach((item, index) => {\\n            messValueIndexMap[item] = index\\n            messIndexValueMap[index] = item\\n        })\\n        array.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n        for (var i = 0; i < array.length; i++) {\\n            var val = array[i]\\n            var messVal = messIndexValueMap[i]\\n            if (messVal === val) continue\\n\\n            messIndexValueMap[i] = val\\n            var messIndex = messValueIndexMap[val]\\n            messIndexValueMap[messIndex] = messVal\\n            messValueIndexMap[val] = i\\n            messValueIndexMap[messVal] = messIndex\\n            count++\\n        }    \\n    }\\n\\n    res.map(level => level.map(node => node.val)).forEach(level => {\\n        swap(level)\\n    })  \\n\\n    return count\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957234,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val; \\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sol(vector<int> &t){\\n        int count = 0;\\n        map<int,int> mp;\\n        vector<int> u = t;\\n        for(int i = 0; i < t.size(); ++i) mp[t[i]] = i;\\n        sort(u.begin(), u.end());\\n        for(int i = 0; i < t.size(); ++i){\\n            if(t[i] != u[i] ){ \\n                t[mp[u[i]]] = t[i];\\n                mp[t[i]] = mp[u[i]];\\n                mp[u[i]] = i;\\n                t[i] = u[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        if(root == NULL) return {};\\n        queue<TreeNode *> q;\\n        vector<vector<int>> ans;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> a;\\n            for(int i = 0 ; i < size ; i++){\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                a.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            ans.push_back(a);\\n        }\\n        int a = 0;\\n        for(auto i:ans) a+=sol(i);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val; \\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sol(vector<int> &t){\\n        int count = 0;\\n        map<int,int> mp;\\n        vector<int> u = t;\\n        for(int i = 0; i < t.size(); ++i) mp[t[i]] = i;\\n        sort(u.begin(), u.end());\\n        for(int i = 0; i < t.size(); ++i){\\n            if(t[i] != u[i] ){ \\n                t[mp[u[i]]] = t[i];\\n                mp[t[i]] = mp[u[i]];\\n                mp[u[i]] = i;\\n                t[i] = u[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        if(root == NULL) return {};\\n        queue<TreeNode *> q;\\n        vector<vector<int>> ans;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> a;\\n            for(int i = 0 ; i < size ; i++){\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                a.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            ans.push_back(a);\\n        }\\n        int a = 0;\\n        for(auto i:ans) a+=sol(i);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938377,
                "title": "c-faster-than-99-9-easy-solution-using-level-order-traversal",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        vector<pair<int,int>> p;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int count=0;\\n        int i = 0;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n\\n            if(temp==NULL){\\n                sort(p.begin(),p.end());\\n                for(int j = 0;j<p.size();j++){\\n                    if(p[j].second== j) continue;\\n                    else{\\n                        count++;\\n                        swap(p[j],p[p[j].second]);\\n                        j--;\\n                    }\\n                }\\n                p.clear();\\n                i=0;\\n                if(!q.empty()) q.push(NULL);\\n            }\\n            else{\\n                p.push_back({temp->val,i++});\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        vector<pair<int,int>> p;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int count=0;\\n        int i = 0;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n\\n            if(temp==NULL){\\n                sort(p.begin(),p.end());\\n                for(int j = 0;j<p.size();j++){\\n                    if(p[j].second== j) continue;\\n                    else{\\n                        count++;\\n                        swap(p[j],p[p[j].second]);\\n                        j--;\\n                    }\\n                }\\n                p.clear();\\n                i=0;\\n                if(!q.empty()) q.push(NULL);\\n            }\\n            else{\\n                p.push_back({temp->val,i++});\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933306,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        ArrayDeque<TreeNode> q = new ArrayDeque<>();\\n        int count = 0;\\n        if((root.left != null && root.right != null) && (root.left.val > root.right.val)){\\n            count++;\\n        }\\n        if(root.left != null)  q.add(root.left);\\n        if(root.right != null) q.add(root.right);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> al = new ArrayList<>();\\n            while(size-- > 0){\\n                TreeNode node = q.poll();\\n                if(node.left != null){\\n                    al.add(node.left.val);\\n                    q.add(node.left);\\n                }\\n                if(node.right != null){\\n                    al.add(node.right.val);\\n                    q.add(node.right);\\n                }\\n            }\\n            count += helper(al);\\n        }\\n        return count;\\n    }\\n    \\n    private int helper(List<Integer> list) {\\n        int swaps = 0;\\n        int[] sorted = new int[list.size()];\\n        for(int i=0; i<sorted.length; i++) sorted[i] = list.get(i);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> ind = new HashMap<>();\\n        for(int i=0; i<list.size(); i++) ind.put(list.get(i), i);\\n        \\n        for(int i=0; i<list.size(); i++) {\\n            if(list.get(i) != sorted[i]) {\\n                swaps++;\\n                ind.put(list.get(i), ind.get(sorted[i]));\\n                list.set(ind.get(sorted[i]), list.get(i));\\n            }\\n        }\\n        return swaps;\\n    }    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        ArrayDeque<TreeNode> q = new ArrayDeque<>();\\n        int count = 0;\\n        if((root.left != null && root.right != null) && (root.left.val > root.right.val)){\\n            count++;\\n        }\\n        if(root.left != null)  q.add(root.left);\\n        if(root.right != null) q.add(root.right);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> al = new ArrayList<>();\\n            while(size-- > 0){\\n                TreeNode node = q.poll();\\n                if(node.left != null){\\n                    al.add(node.left.val);\\n                    q.add(node.left);\\n                }\\n                if(node.right != null){\\n                    al.add(node.right.val);\\n                    q.add(node.right);\\n                }\\n            }\\n            count += helper(al);\\n        }\\n        return count;\\n    }\\n    \\n    private int helper(List<Integer> list) {\\n        int swaps = 0;\\n        int[] sorted = new int[list.size()];\\n        for(int i=0; i<sorted.length; i++) sorted[i] = list.get(i);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> ind = new HashMap<>();\\n        for(int i=0; i<list.size(); i++) ind.put(list.get(i), i);\\n        \\n        for(int i=0; i<list.size(); i++) {\\n            if(list.get(i) != sorted[i]) {\\n                swaps++;\\n                ind.put(list.get(i), ind.get(sorted[i]));\\n                list.set(ind.get(sorted[i]), list.get(i));\\n            }\\n        }\\n        return swaps;\\n    }    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931534,
                "title": "c-use-bfs-and-hash-map-clean-and-concise-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void swap(TreeNode* A, TreeNode* B){\\n        int tmp = A->val;\\n        A->val = B->val;\\n        B->val = tmp;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            vector<TreeNode*> vec;\\n            for(int i=0;i<n;i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL){\\n                    q.push(node->left);\\n                }\\n                if(node->right!=NULL){\\n                    q.push(node->right);\\n                }\\n                vec.push_back(node);\\n            }\\n            vector<int> copy;\\n            for(int i=0;i<vec.size();i++){\\n                copy.push_back(vec[i]->val);\\n            }\\n            sort(copy.begin(),copy.end());\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<copy.size();i++){\\n                mp[copy[i]]=i;\\n            }\\n            for(int i=0;i<copy.size();i++){\\n                if(mp[vec[i]->val]!=i){\\n                    swap(vec[i],vec[mp[vec[i]->val]]);\\n                    ans++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void swap(TreeNode* A, TreeNode* B){\\n        int tmp = A->val;\\n        A->val = B->val;\\n        B->val = tmp;\\n    }\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            vector<TreeNode*> vec;\\n            for(int i=0;i<n;i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL){\\n                    q.push(node->left);\\n                }\\n                if(node->right!=NULL){\\n                    q.push(node->right);\\n                }\\n                vec.push_back(node);\\n            }\\n            vector<int> copy;\\n            for(int i=0;i<vec.size();i++){\\n                copy.push_back(vec[i]->val);\\n            }\\n            sort(copy.begin(),copy.end());\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<copy.size();i++){\\n                mp[copy[i]]=i;\\n            }\\n            for(int i=0;i<copy.size();i++){\\n                if(mp[vec[i]->val]!=i){\\n                    swap(vec[i],vec[mp[vec[i]->val]]);\\n                    ans++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929236,
                "title": "easy-cpp-solution-using-bfs-traversal",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t   int n=nums.size();\\n       vector<pair<int,int>> v;\\n       for(int i=0;i<n;i++)\\n       v.push_back({nums[i],i});\\n\\n       sort(v.begin(),v.end());\\n       int ct=0;\\n       for(int i=0;i<n;i++){\\n           if(v[i].second != i){\\n               ct++;\\n               swap(v[i],v[v[i].second]);\\n               i--;\\n           }\\n       }\\n       return ct;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int> nums;\\n            for(int i=0;i<s;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                nums.push_back(curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n            if(nums.size()>1) ans+=minSwaps(nums);\\n            nums.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t   int n=nums.size();\\n       vector<pair<int,int>> v;\\n       for(int i=0;i<n;i++)\\n       v.push_back({nums[i],i});\\n\\n       sort(v.begin(),v.end());\\n       int ct=0;\\n       for(int i=0;i<n;i++){\\n           if(v[i].second != i){\\n               ct++;\\n               swap(v[i],v[v[i].second]);\\n               i--;\\n           }\\n       }\\n       return ct;\\n\\t}\\n    int minimumOperations(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int> nums;\\n            for(int i=0;i<s;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                nums.push_back(curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n            if(nums.size()>1) ans+=minSwaps(nums);\\n            nums.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928786,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn min_swaps(arr: &[i32]) -> i32 {\\n            let n = arr.len();\\n            let mut arr_pos = vec![(0, 0); n];\\n            for i in 0..n {\\n                arr_pos[i].0 = arr[i];\\n                arr_pos[i].1 = i;\\n            }\\n            arr_pos.sort();\\n            let mut vis = vec![false; n];\\n            let mut ans = 0;\\n            for i in 0..n {\\n                if vis[i] || arr_pos[i].1 == i {\\n                    continue;\\n                }\\n                let mut temp = 0;\\n                let mut j = i;\\n                while !vis[j] {\\n                    vis[j] = true;\\n                    j = arr_pos[j].1;\\n                    temp += 1;\\n                }\\n                if temp > 0 {\\n                    ans += temp - 1;\\n                }\\n            }\\n            ans\\n        }\\n\\n        fn _minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> Option<i32> {\\n            let mut q = VecDeque::new();\\n            q.push_back(root);\\n            let mut ans = 0;\\n            let mut v = Vec::new();\\n            while !q.is_empty() {\\n                v.clear();\\n                let sz = q.len();\\n                for _ in 0..sz {\\n                    let node = q.pop_front()?;\\n                    v.push(node.as_ref()?.borrow().val);\\n                    let left = node.as_ref()?.borrow().left.clone();\\n                    if left.is_some() {\\n                        q.push_back(left);\\n                    }\\n                    let right = node.as_ref()?.borrow().right.clone();\\n                    if right.is_some() {\\n                        q.push_back(right);\\n                    }\\n                }\\n                ans += min_swaps(&v);\\n            }\\n            Some(ans)\\n        }\\n\\n        _minimum_operations(root).unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn min_swaps(arr: &[i32]) -> i32 {\\n            let n = arr.len();\\n            let mut arr_pos = vec![(0, 0); n];\\n            for i in 0..n {\\n                arr_pos[i].0 = arr[i];\\n                arr_pos[i].1 = i;\\n            }\\n            arr_pos.sort();\\n            let mut vis = vec![false; n];\\n            let mut ans = 0;\\n            for i in 0..n {\\n                if vis[i] || arr_pos[i].1 == i {\\n                    continue;\\n                }\\n                let mut temp = 0;\\n                let mut j = i;\\n                while !vis[j] {\\n                    vis[j] = true;\\n                    j = arr_pos[j].1;\\n                    temp += 1;\\n                }\\n                if temp > 0 {\\n                    ans += temp - 1;\\n                }\\n            }\\n            ans\\n        }\\n\\n        fn _minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> Option<i32> {\\n            let mut q = VecDeque::new();\\n            q.push_back(root);\\n            let mut ans = 0;\\n            let mut v = Vec::new();\\n            while !q.is_empty() {\\n                v.clear();\\n                let sz = q.len();\\n                for _ in 0..sz {\\n                    let node = q.pop_front()?;\\n                    v.push(node.as_ref()?.borrow().val);\\n                    let left = node.as_ref()?.borrow().left.clone();\\n                    if left.is_some() {\\n                        q.push_back(left);\\n                    }\\n                    let right = node.as_ref()?.borrow().right.clone();\\n                    if right.is_some() {\\n                        q.push_back(right);\\n                    }\\n                }\\n                ans += min_swaps(&v);\\n            }\\n            Some(ans)\\n        }\\n\\n        _minimum_operations(root).unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927959,
                "title": "java-level-order-traversal-minswap",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        int numOfSwaps = 0;\\n        \\n        //Perform level order traversal and sort the elements at each leavel\\n        while(!queue.isEmpty()){\\n            int[] arr = new int[queue.size()];\\n            int size = arr.length, i = 0;\\n            while(size > 0){\\n                TreeNode node = queue.remove();\\n                arr[i++] = node.val;\\n                \\n                if(node.left != null)\\n                    queue.add(node.left);\\n                if(node.right != null)\\n                    queue.add(node.right);\\n                \\n                size--;\\n            }\\n            //Count min swaps to sort current array\\n            numOfSwaps += minSwaps(arr);\\n        }\\n        \\n        return numOfSwaps;\\n    }\\n    \\n    private int minSwaps(int[] nums) {\\n        int len = nums.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++)\\n            map.put(nums[i], i);\\n \\n        Arrays.sort(nums);\\n \\n        // To keep track of visited elements. Initialize\\n        // all elements as not visited or false.\\n        boolean[] visited = new boolean[len];\\n        Arrays.fill(visited, false);\\n \\n        // Initialize result\\n        int ans = 0;\\n        for (int i = 0; i < len; i++) {\\n \\n            // already swapped and corrected or\\n            // already present at correct pos\\n            if (visited[i] || map.get(nums[i]) == i)\\n                continue;\\n \\n            int j = i, cycle_size = 0;\\n            while (!visited[j]) {\\n                visited[j] = true;\\n \\n                // move to next node\\n                j = map.get(nums[j]);\\n                cycle_size++;\\n            }\\n \\n            // Update answer by adding current cycle.\\n            if (cycle_size > 0) {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        int numOfSwaps = 0;\\n        \\n        //Perform level order traversal and sort the elements at each leavel\\n        while(!queue.isEmpty()){\\n            int[] arr = new int[queue.size()];\\n            int size = arr.length, i = 0;\\n            while(size > 0){\\n                TreeNode node = queue.remove();\\n                arr[i++] = node.val;\\n                \\n                if(node.left != null)\\n                    queue.add(node.left);\\n                if(node.right != null)\\n                    queue.add(node.right);\\n                \\n                size--;\\n            }\\n            //Count min swaps to sort current array\\n            numOfSwaps += minSwaps(arr);\\n        }\\n        \\n        return numOfSwaps;\\n    }\\n    \\n    private int minSwaps(int[] nums) {\\n        int len = nums.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++)\\n            map.put(nums[i], i);\\n \\n        Arrays.sort(nums);\\n \\n        // To keep track of visited elements. Initialize\\n        // all elements as not visited or false.\\n        boolean[] visited = new boolean[len];\\n        Arrays.fill(visited, false);\\n \\n        // Initialize result\\n        int ans = 0;\\n        for (int i = 0; i < len; i++) {\\n \\n            // already swapped and corrected or\\n            // already present at correct pos\\n            if (visited[i] || map.get(nums[i]) == i)\\n                continue;\\n \\n            int j = i, cycle_size = 0;\\n            while (!visited[j]) {\\n                visited[j] = true;\\n \\n                // move to next node\\n                j = map.get(nums[j]);\\n                cycle_size++;\\n            }\\n \\n            // Update answer by adding current cycle.\\n            if (cycle_size > 0) {\\n                ans += (cycle_size - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911540,
                "title": "c-bfs-cycles-in-graph-easy-100-time-99-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int minSwaps(vector<int> &arr){\\n    int n = arr.size();\\n    pair<int, int> arrPos[n];\\n    for (int i = 0; i < n; i++){\\n      arrPos[i].first = arr[i];\\n      arrPos[i].second = i;\\n    }\\n    sort(arrPos, arrPos + n);\\n    vector<bool> vis(n, false);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++){\\n      if (vis[i] || arrPos[i].second == i)\\n        continue;\\n      int temp = 0;\\n      int j = i;\\n      while (!vis[j]){\\n        vis[j] = 1;\\n        j = arrPos[j].second;\\n        temp++;\\n      }\\n      if (temp > 0){\\n        ans += (temp - 1);\\n      }\\n    }\\n    return ans;\\n  }\\n  \\n  int minimumOperations(TreeNode* root) {\\n    queue<TreeNode *> q;\\n    q.emplace(root);\\n    int ans = 0;\\n    vector<int> temp;\\n    vector<int> v;\\n    while(!q.empty()){\\n      v.resize(0);\\n      int sz = q.size();\\n      for(int i = 0; i < sz; i++){\\n        auto node = q.front(); q.pop();\\n        v.emplace_back(node->val);\\n        if(node->left) q.emplace(node->left);\\n        if(node->right) q.emplace(node->right);\\n      }\\n      ans += minSwaps(v);\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int minSwaps(vector<int> &arr){\\n    int n = arr.size();\\n    pair<int, int> arrPos[n];\\n    for (int i = 0; i < n; i++){\\n      arrPos[i].first = arr[i];\\n      arrPos[i].second = i;\\n    }\\n    sort(arrPos, arrPos + n);\\n    vector<bool> vis(n, false);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++){\\n      if (vis[i] || arrPos[i].second == i)\\n        continue;\\n      int temp = 0;\\n      int j = i;\\n      while (!vis[j]){\\n        vis[j] = 1;\\n        j = arrPos[j].second;\\n        temp++;\\n      }\\n      if (temp > 0){\\n        ans += (temp - 1);\\n      }\\n    }\\n    return ans;\\n  }\\n  \\n  int minimumOperations(TreeNode* root) {\\n    queue<TreeNode *> q;\\n    q.emplace(root);\\n    int ans = 0;\\n    vector<int> temp;\\n    vector<int> v;\\n    while(!q.empty()){\\n      v.resize(0);\\n      int sz = q.size();\\n      for(int i = 0; i < sz; i++){\\n        auto node = q.front(); q.pop();\\n        v.emplace_back(node->val);\\n        if(node->left) q.emplace(node->left);\\n        if(node->right) q.emplace(node->right);\\n      }\\n      ans += minSwaps(v);\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903422,
                "title": "c-bfs",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*L*log L)$$\\nwhere L is Level number\\nn number of nodes\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;   \\n        q.push(root);\\n        int ans = 0;\\n        while(!q.empty()){\\n            int nodeCount = q.size();\\n            vector<int>level;\\n            while (nodeCount > 0) {\\n                TreeNode *node = q.front();\\n                level.push_back(node->val);\\n                q.pop();\\n                if (node->left != NULL)\\n                    q.push(node->left);\\n                if (node->right != NULL)\\n                    q.push(node->right);\\n                nodeCount--;\\n            }\\n            ans += minSwaps(level);\\n        }     \\n        return ans;\\n    }\\n    int minSwaps(vector<int>nums)\\n{\\n    int len = nums.size();\\n    map<int, int> map;\\n    for (int i = 0; i < len; i++)\\n        map[nums[i]] = i;\\n \\n    sort(nums.begin(), nums.end());\\n    vector<bool>visited(len,false);\\n    int ans = 0;\\n    for (int i = 0; i < len; i++) {\\n        if (visited[i] || map[nums[i]] == i)\\n            continue;\\n \\n        int j = i, cycle_size = 0;\\n        while (!visited[j]) {\\n            visited[j] = true;\\n             j = map[nums[j]];\\n            cycle_size++;\\n        }\\n         if (cycle_size > 0) {\\n            ans += (cycle_size - 1);\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*>q;   \\n        q.push(root);\\n        int ans = 0;\\n        while(!q.empty()){\\n            int nodeCount = q.size();\\n            vector<int>level;\\n            while (nodeCount > 0) {\\n                TreeNode *node = q.front();\\n                level.push_back(node->val);\\n                q.pop();\\n                if (node->left != NULL)\\n                    q.push(node->left);\\n                if (node->right != NULL)\\n                    q.push(node->right);\\n                nodeCount--;\\n            }\\n            ans += minSwaps(level);\\n        }     \\n        return ans;\\n    }\\n    int minSwaps(vector<int>nums)\\n{\\n    int len = nums.size();\\n    map<int, int> map;\\n    for (int i = 0; i < len; i++)\\n        map[nums[i]] = i;\\n \\n    sort(nums.begin(), nums.end());\\n    vector<bool>visited(len,false);\\n    int ans = 0;\\n    for (int i = 0; i < len; i++) {\\n        if (visited[i] || map[nums[i]] == i)\\n            continue;\\n \\n        int j = i, cycle_size = 0;\\n        while (!visited[j]) {\\n            visited[j] = true;\\n             j = map[nums[j]];\\n            cycle_size++;\\n        }\\n         if (cycle_size > 0) {\\n            ans += (cycle_size - 1);\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897775,
                "title": "bfs-minswap-duplications-handled",
                "content": "# Approach\\nThe number of swap required for sorting an array is a typical MinSwap problem. So basically for each level we use MinSwap.\\n\\nHere\\'s the thing, despite the question stated that all the tree value is unique AND also typical MinSwap solutions just work on non-duplicated list . I\\'m curious about the MinSwap for duplicates -> I created a solution (somehow)\\n\\nOf course i tested it, here\\'s the link to my notebook which i explained the MinSwap in very detailed\\nhttps://gist.github.com/Howard-O-Neil/dd618ffced1f46ce246d0a1b8d250eb7#file-minswap-for-duplicates-ipynb\\n\\n# Code\\n```\\nclass Solution:\\n    def traverse_h(self, root):\\n        if root is None:\\n            return []\\n    \\n        level = [root]\\n    \\n        res = []\\n        while(len(level) > 0):\\n            \\n            res.append(list(map(lambda x: x.val, level)))\\n\\n            t_level = []\\n            for l in level:\\n                if l.left is not None: t_level.append(l.left)\\n                if l.right is not None: t_level.append(l.right)\\n\\n            level = t_level\\n        \\n        return res\\n\\n    def num_swaps(self, arr):\\n        s_arr = arr[:]\\n        s_arr.sort()\\n\\n        lu = {}\\n        for i, v in enumerate(s_arr):\\n            if v not in lu:\\n                lu[v] = [i]\\n            else: lu[v] += [i]\\n\\n        banned_pos = {}\\n        for i, v in enumerate(s_arr):\\n            if arr[i] == s_arr[i]: banned_pos[i] = True\\n\\n        count = 0\\n        for i, v in enumerate(s_arr):\\n            [ov, sv] = [arr[i], s_arr[i]]\\n\\n            if ov == sv: continue\\n\\n            sv_i = i\\n\\n            span_ov_i = 0\\n            ov_i = lu[ov][span_ov_i]\\n            while ov_i in banned_pos or ov_i <= sv_i:\\n                span_ov_i += 1\\n                ov_i = lu[ov][span_ov_i]\\n            \\n            s_arr[sv_i], s_arr[ov_i] = s_arr[ov_i], s_arr[sv_i]\\n            lu[ov].remove(ov_i); lu[ov] += [sv_i]\\n\\n            lu[sv].remove(sv_i); lu[sv] += [ov_i]\\n\\n            count += 1\\n\\n        return count\\n\\n    def minimumOperations(self, root):\\n        res = 0\\n        for arr in self.traverse_h(root):\\n            res += self.num_swaps(arr)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def traverse_h(self, root):\\n        if root is None:\\n            return []\\n    \\n        level = [root]\\n    \\n        res = []\\n        while(len(level) > 0):\\n            \\n            res.append(list(map(lambda x: x.val, level)))\\n\\n            t_level = []\\n            for l in level:\\n                if l.left is not None: t_level.append(l.left)\\n                if l.right is not None: t_level.append(l.right)\\n\\n            level = t_level\\n        \\n        return res\\n\\n    def num_swaps(self, arr):\\n        s_arr = arr[:]\\n        s_arr.sort()\\n\\n        lu = {}\\n        for i, v in enumerate(s_arr):\\n            if v not in lu:\\n                lu[v] = [i]\\n            else: lu[v] += [i]\\n\\n        banned_pos = {}\\n        for i, v in enumerate(s_arr):\\n            if arr[i] == s_arr[i]: banned_pos[i] = True\\n\\n        count = 0\\n        for i, v in enumerate(s_arr):\\n            [ov, sv] = [arr[i], s_arr[i]]\\n\\n            if ov == sv: continue\\n\\n            sv_i = i\\n\\n            span_ov_i = 0\\n            ov_i = lu[ov][span_ov_i]\\n            while ov_i in banned_pos or ov_i <= sv_i:\\n                span_ov_i += 1\\n                ov_i = lu[ov][span_ov_i]\\n            \\n            s_arr[sv_i], s_arr[ov_i] = s_arr[ov_i], s_arr[sv_i]\\n            lu[ov].remove(ov_i); lu[ov] += [sv_i]\\n\\n            lu[sv].remove(sv_i); lu[sv] += [ov_i]\\n\\n            count += 1\\n\\n        return count\\n\\n    def minimumOperations(self, root):\\n        res = 0\\n        for arr in self.traverse_h(root):\\n            res += self.num_swaps(arr)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896623,
                "title": "cpp-must-see-reverse-approach",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) \\n\\t{\\n\\t\\tint ans = 0;\\n        //we will tackle all the level\\'s independentyly\\n\\t\\t//we will perform bfs in the tree so to manage the level\\'s saperately\\n\\t\\tqueue<TreeNode*>q;\\n\\t\\tq.push(root);\\n\\t\\t\\n\\t\\twhile(!q.empty())\\n\\t\\t{\\n            int size = q.size();\\n            vector<pair<int,int>>v1;\\n            int idx=0;\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n            \\tTreeNode* temp = q.front();\\n            \\tq.pop();\\n            \\t\\n            \\tv1.push_back(make_pair(temp->val,idx));\\n            \\tidx++;\\n            \\t\\n            \\tif(temp -> left != NULL)\\n            \\t{\\n            \\t\\tq.push(temp->left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(temp -> right != NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(temp->right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<pair<int,int>>v2;\\n\\t\\t\\tv2 = v1;\\n\\t\\t\\t//sorting v2 on the basis of the values\\n\\t\\t\\tsort(v2.begin() , v2.end());\\n\\t\\t\\t\\n\\t\\t\\tans = ans + fun(v1,v2);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n    int fun(vector<pair<int,int>>&v1,vector<pair<int,int>>&v2)\\n    {\\n   \\t     int idx = 0;\\n   \\t     \\n   \\t     int size = v1.size();\\n   \\t      \\n         int swap=0;\\n         //initially v2 is sorted\\n   \\t     while(idx < size)\\n   \\t     {\\n      \\t     if(v1[idx].first == v2[idx].first)  //values are same they are on correct positioin\\n      \\t     {\\n      \\t         idx++;\\t\\n\\t         }\\n\\t         else\\n\\t         {\\n\\t         \\t int temp1 = v2[idx].second;\\n\\t         \\t \\n\\t         \\t pair<int,int>p = v2[idx];\\n\\t         \\t v2[idx] = v2[temp1];\\n\\t         \\t v2[temp1] = p;\\n\\t         \\t \\n\\t         \\t swap++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return swap;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minimumOperations(TreeNode* root) \\n\\t{\\n\\t\\tint ans = 0;\\n        //we will tackle all the level\\'s independentyly\\n\\t\\t//we will perform bfs in the tree so to manage the level\\'s saperately\\n\\t\\tqueue<TreeNode*>q;\\n\\t\\tq.push(root);\\n\\t\\t\\n\\t\\twhile(!q.empty())\\n\\t\\t{\\n            int size = q.size();\\n            vector<pair<int,int>>v1;\\n            int idx=0;\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n            \\tTreeNode* temp = q.front();\\n            \\tq.pop();\\n            \\t\\n            \\tv1.push_back(make_pair(temp->val,idx));\\n            \\tidx++;\\n            \\t\\n            \\tif(temp -> left != NULL)\\n            \\t{\\n            \\t\\tq.push(temp->left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(temp -> right != NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(temp->right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<pair<int,int>>v2;\\n\\t\\t\\tv2 = v1;\\n\\t\\t\\t//sorting v2 on the basis of the values\\n\\t\\t\\tsort(v2.begin() , v2.end());\\n\\t\\t\\t\\n\\t\\t\\tans = ans + fun(v1,v2);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n    int fun(vector<pair<int,int>>&v1,vector<pair<int,int>>&v2)\\n    {\\n   \\t     int idx = 0;\\n   \\t     \\n   \\t     int size = v1.size();\\n   \\t      \\n         int swap=0;\\n         //initially v2 is sorted\\n   \\t     while(idx < size)\\n   \\t     {\\n      \\t     if(v1[idx].first == v2[idx].first)  //values are same they are on correct positioin\\n      \\t     {\\n      \\t         idx++;\\t\\n\\t         }\\n\\t         else\\n\\t         {\\n\\t         \\t int temp1 = v2[idx].second;\\n\\t         \\t \\n\\t         \\t pair<int,int>p = v2[idx];\\n\\t         \\t v2[idx] = v2[temp1];\\n\\t         \\t v2[temp1] = p;\\n\\t         \\t \\n\\t         \\t swap++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return swap;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2018120,
                "content": [
                    {
                        "username": "killerraj369",
                        "content": "Problem will be reduced to find the minimum number of moves required to sort an array. Hint:- sort + store indexes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "Nice profile picture "
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get TLE at testcase 145"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Start by initializing a count variable to 0(globally) and a queue to store the nodes of the binary tree.\\n- Add the root node to the queue.\\n- While the queue is not empty, do the following:\\n    - Get the size of the queue and initialize an array to store the values of the nodes at the current level of the tree.\\n    - For each node in the current level, add its value to the array and enqueue its children if they exist.\\n       - Call the getSwaps function with the levelValues array to calculate the number of swaps required to make the level into a heap.\\n- Return the final count variable.\\n\\nThe getSwaps function works as follows:\\n\\n- Copy the input array and sort the copy in ascending order.\\n- Create a mapping of each element in the input array to its index using a HashMap.\\n- For each element in the input array, do the following:\\n   - If the element is not in its correct position in the sorted array, find the correct position of the element in the input array using the mapping created in step 2.\\n   - Swap the current element with the element at the correct position and update the mapping.\\n   - Increment the count variable."
                    },
                    {
                        "username": "nonieno",
                        "content": "Would it be the same if the values weren\\'t unique?"
                    },
                    {
                        "username": "wataru",
                        "content": "No, it would be considerably more difficult. With unique elements you know where each element needs to end up in the sorted level, so you know the permutation you need to apply, then there\\'s an easy way to count how many swaps you need at the minimum to apply the permutation. If some elements are equal, you have a lot of decisions to make, which element goes where, so you can have a lot of different permutations."
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\nprivate:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> res;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            for(int i = 0;i < sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                \\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                \\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                v.push_back(temp->val);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i < res.size();i++){\\n            ans += minSwaps(res[i]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) And you got upvotes lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Bro was looking for some free upvotes but now has gone to negative count."
                    },
                    {
                        "username": "user7234y",
                        "content": "Please use this section for discussion only not for code"
                    }
                ]
            },
            {
                "id": 1946916,
                "content": [
                    {
                        "username": "killerraj369",
                        "content": "Problem will be reduced to find the minimum number of moves required to sort an array. Hint:- sort + store indexes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "Nice profile picture "
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get TLE at testcase 145"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Start by initializing a count variable to 0(globally) and a queue to store the nodes of the binary tree.\\n- Add the root node to the queue.\\n- While the queue is not empty, do the following:\\n    - Get the size of the queue and initialize an array to store the values of the nodes at the current level of the tree.\\n    - For each node in the current level, add its value to the array and enqueue its children if they exist.\\n       - Call the getSwaps function with the levelValues array to calculate the number of swaps required to make the level into a heap.\\n- Return the final count variable.\\n\\nThe getSwaps function works as follows:\\n\\n- Copy the input array and sort the copy in ascending order.\\n- Create a mapping of each element in the input array to its index using a HashMap.\\n- For each element in the input array, do the following:\\n   - If the element is not in its correct position in the sorted array, find the correct position of the element in the input array using the mapping created in step 2.\\n   - Swap the current element with the element at the correct position and update the mapping.\\n   - Increment the count variable."
                    },
                    {
                        "username": "nonieno",
                        "content": "Would it be the same if the values weren\\'t unique?"
                    },
                    {
                        "username": "wataru",
                        "content": "No, it would be considerably more difficult. With unique elements you know where each element needs to end up in the sorted level, so you know the permutation you need to apply, then there\\'s an easy way to count how many swaps you need at the minimum to apply the permutation. If some elements are equal, you have a lot of decisions to make, which element goes where, so you can have a lot of different permutations."
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\nprivate:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> res;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            for(int i = 0;i < sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                \\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                \\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                v.push_back(temp->val);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i < res.size();i++){\\n            ans += minSwaps(res[i]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) And you got upvotes lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Bro was looking for some free upvotes but now has gone to negative count."
                    },
                    {
                        "username": "user7234y",
                        "content": "Please use this section for discussion only not for code"
                    }
                ]
            },
            {
                "id": 1853815,
                "content": [
                    {
                        "username": "killerraj369",
                        "content": "Problem will be reduced to find the minimum number of moves required to sort an array. Hint:- sort + store indexes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "Nice profile picture "
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get TLE at testcase 145"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Start by initializing a count variable to 0(globally) and a queue to store the nodes of the binary tree.\\n- Add the root node to the queue.\\n- While the queue is not empty, do the following:\\n    - Get the size of the queue and initialize an array to store the values of the nodes at the current level of the tree.\\n    - For each node in the current level, add its value to the array and enqueue its children if they exist.\\n       - Call the getSwaps function with the levelValues array to calculate the number of swaps required to make the level into a heap.\\n- Return the final count variable.\\n\\nThe getSwaps function works as follows:\\n\\n- Copy the input array and sort the copy in ascending order.\\n- Create a mapping of each element in the input array to its index using a HashMap.\\n- For each element in the input array, do the following:\\n   - If the element is not in its correct position in the sorted array, find the correct position of the element in the input array using the mapping created in step 2.\\n   - Swap the current element with the element at the correct position and update the mapping.\\n   - Increment the count variable."
                    },
                    {
                        "username": "nonieno",
                        "content": "Would it be the same if the values weren\\'t unique?"
                    },
                    {
                        "username": "wataru",
                        "content": "No, it would be considerably more difficult. With unique elements you know where each element needs to end up in the sorted level, so you know the permutation you need to apply, then there\\'s an easy way to count how many swaps you need at the minimum to apply the permutation. If some elements are equal, you have a lot of decisions to make, which element goes where, so you can have a lot of different permutations."
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\nprivate:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> res;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            for(int i = 0;i < sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                \\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                \\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                v.push_back(temp->val);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i < res.size();i++){\\n            ans += minSwaps(res[i]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) And you got upvotes lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Bro was looking for some free upvotes but now has gone to negative count."
                    },
                    {
                        "username": "user7234y",
                        "content": "Please use this section for discussion only not for code"
                    }
                ]
            },
            {
                "id": 1685589,
                "content": [
                    {
                        "username": "killerraj369",
                        "content": "Problem will be reduced to find the minimum number of moves required to sort an array. Hint:- sort + store indexes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "Nice profile picture "
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get TLE at testcase 145"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Start by initializing a count variable to 0(globally) and a queue to store the nodes of the binary tree.\\n- Add the root node to the queue.\\n- While the queue is not empty, do the following:\\n    - Get the size of the queue and initialize an array to store the values of the nodes at the current level of the tree.\\n    - For each node in the current level, add its value to the array and enqueue its children if they exist.\\n       - Call the getSwaps function with the levelValues array to calculate the number of swaps required to make the level into a heap.\\n- Return the final count variable.\\n\\nThe getSwaps function works as follows:\\n\\n- Copy the input array and sort the copy in ascending order.\\n- Create a mapping of each element in the input array to its index using a HashMap.\\n- For each element in the input array, do the following:\\n   - If the element is not in its correct position in the sorted array, find the correct position of the element in the input array using the mapping created in step 2.\\n   - Swap the current element with the element at the correct position and update the mapping.\\n   - Increment the count variable."
                    },
                    {
                        "username": "nonieno",
                        "content": "Would it be the same if the values weren\\'t unique?"
                    },
                    {
                        "username": "wataru",
                        "content": "No, it would be considerably more difficult. With unique elements you know where each element needs to end up in the sorted level, so you know the permutation you need to apply, then there\\'s an easy way to count how many swaps you need at the minimum to apply the permutation. If some elements are equal, you have a lot of decisions to make, which element goes where, so you can have a lot of different permutations."
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\nprivate:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> res;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            for(int i = 0;i < sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                \\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                \\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                v.push_back(temp->val);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i < res.size();i++){\\n            ans += minSwaps(res[i]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) And you got upvotes lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Bro was looking for some free upvotes but now has gone to negative count."
                    },
                    {
                        "username": "user7234y",
                        "content": "Please use this section for discussion only not for code"
                    }
                ]
            },
            {
                "id": 1681923,
                "content": [
                    {
                        "username": "killerraj369",
                        "content": "Problem will be reduced to find the minimum number of moves required to sort an array. Hint:- sort + store indexes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "Nice profile picture "
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get TLE at testcase 145"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Start by initializing a count variable to 0(globally) and a queue to store the nodes of the binary tree.\\n- Add the root node to the queue.\\n- While the queue is not empty, do the following:\\n    - Get the size of the queue and initialize an array to store the values of the nodes at the current level of the tree.\\n    - For each node in the current level, add its value to the array and enqueue its children if they exist.\\n       - Call the getSwaps function with the levelValues array to calculate the number of swaps required to make the level into a heap.\\n- Return the final count variable.\\n\\nThe getSwaps function works as follows:\\n\\n- Copy the input array and sort the copy in ascending order.\\n- Create a mapping of each element in the input array to its index using a HashMap.\\n- For each element in the input array, do the following:\\n   - If the element is not in its correct position in the sorted array, find the correct position of the element in the input array using the mapping created in step 2.\\n   - Swap the current element with the element at the correct position and update the mapping.\\n   - Increment the count variable."
                    },
                    {
                        "username": "nonieno",
                        "content": "Would it be the same if the values weren\\'t unique?"
                    },
                    {
                        "username": "wataru",
                        "content": "No, it would be considerably more difficult. With unique elements you know where each element needs to end up in the sorted level, so you know the permutation you need to apply, then there\\'s an easy way to count how many swaps you need at the minimum to apply the permutation. If some elements are equal, you have a lot of decisions to make, which element goes where, so you can have a lot of different permutations."
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\nprivate:\\n    int minSwaps(vector<int>&nums)\\n\\t{\\n\\t    vector<pair<int,int>> v;\\n\\t    int n=nums.size();\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        v.push_back({nums[i],i});\\n\\t    }\\n\\t    sort(v.begin(),v.end());\\n\\t    int swaps=0;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(v[i].second==i) continue;\\n\\t        else {\\n\\t            swaps++;\\n\\t            swap(v[i],v[v[i].second]);\\n\\t            i--;\\n\\t        }\\n\\t    }\\n\\t    return swaps;\\n\\t}\\n    \\npublic:\\n    int minimumOperations(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        vector<vector<int>> res;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int> v;\\n            for(int i = 0;i < sz;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                \\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                \\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                v.push_back(temp->val);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i < res.size();i++){\\n            ans += minSwaps(res[i]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) And you got upvotes lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Bro was looking for some free upvotes but now has gone to negative count."
                    },
                    {
                        "username": "user7234y",
                        "content": "Please use this section for discussion only not for code"
                    }
                ]
            }
        ]
    }
]