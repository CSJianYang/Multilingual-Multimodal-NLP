[
    {
        "title": "Count Collisions of Monkeys on a Polygon",
        "question_content": "There is a regular convex polygon with n vertices. The vertices are labeled from 0 to n - 1 in a clockwise direction, and each vertex has exactly one monkey. The following figure shows a convex polygon of 6 vertices.\nEach monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex i can be:\n\n\tthe vertex (i + 1) % n in the clockwise direction, or\n\tthe vertex (i - 1 + n) % n in the counter-clockwise direction.\n\nA collision happens if at least two monkeys reside on the same vertex after the movement or intersect&nbsp;on an edge.\nReturn the number of ways the monkeys can move so that at least one collision  happens. Since the answer may be very large, return it modulo 109 + 7.\nNote that each monkey can only move once.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: 6\nExplanation: There are 8 total possible movements.\nTwo ways such that they collide at some point are:\n- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\n- Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\nIt can be shown 6 total movements result in a collision.\n\nExample 2:\n\nInput: n = 4\nOutput: 14\nExplanation: It can be shown that there are 14 ways for the monkeys to collide.\n\n&nbsp;\nConstraints:\n\n\t3 <= n <= 109",
        "solutions": [
            {
                "id": 3111664,
                "title": "java-c-python-should-be-pow-2-n-4",
                "content": "# **Mismatch Definition**\\n\"A collision happens if at least two monkeys reside on the same vertex after the movement.\"\\n\\nIf n is even and two monkeys exchange position,\\nthis should not be defined a collision.\\n\\nI think the preparer misunderstood the problem,\\nmiss this corner case.\\n\\nShoule be **pow(2, n) - 4** for even,\\ninstead of **pow(2, n) - 2**.\\n<br>\\n\\n# **Explanation**\\nEach monkey can move in the clockwise or counter-clockwise direction,\\nso 2 choices for each of `n` monkeys.\\n\\nThere are `2 ^ n` number of ways.\\nIf all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens.\\n\\nSo we need to `return (2 ^ n - 2) % mod`,\\nwe can apply fast pow to calculate `base ^ n`:\\n\\nif `n % 2 == 0`,\\n`base ^ n = (base * base) ^ (n / 2)`\\n\\nif `n % 2 == 1`,\\n`base ^ n = (base * base) ^ ((n - 1) / 2) * base`\\n<br>\\n\\n# **Complexity**\\nTime `O(logn)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int monkeyMove(int n) {\\n        long res = 1, base = 2, mod = (long)1e9 + 7;\\n        while (n > 0) {\\n            if (n % 2 == 1)\\n                res = res * base % mod;\\n            base = base * base % mod;\\n            n >>= 1;\\n        }\\n        return (int)((res - 2 + mod) % mod);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int monkeyMove(int n) {\\n        long res = 1, base = 2, mod = 1e9 + 7;\\n        while (n > 0) {\\n            if (n % 2)\\n                res = res * base % mod;\\n            base = base * base % mod;\\n            n >>= 1;\\n        }\\n        return (res - 2 + mod) % mod;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def monkeyMove(self, n):\\n        mod = 10 ** 9 + 7\\n        return (pow(2, n, mod) - 2) % mod\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int monkeyMove(int n) {\\n        long res = 1, base = 2, mod = (long)1e9 + 7;\\n        while (n > 0) {\\n            if (n % 2 == 1)\\n                res = res * base % mod;\\n            base = base * base % mod;\\n            n >>= 1;\\n        }\\n        return (int)((res - 2 + mod) % mod);\\n    }\\n```\n```cpp\\n    int monkeyMove(int n) {\\n        long res = 1, base = 2, mod = 1e9 + 7;\\n        while (n > 0) {\\n            if (n % 2)\\n                res = res * base % mod;\\n            base = base * base % mod;\\n            n >>= 1;\\n        }\\n        return (res - 2 + mod) % mod;\\n    }\\n```\n```py\\n    def monkeyMove(self, n):\\n        mod = 10 ** 9 + 7\\n        return (pow(2, n, mod) - 2) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3112206,
                "title": "for-n-4-shoudn-t-the-number-of-collisions-be-12",
                "content": "When all the monkeys jump in clockwise or in anticlockwise \\nthen no collision occurs.\\nBut apart from that there are 2 more moves where no collision occurs\\nin case of even number of vertex.\\n\\nwhat if n=4(even as stated above) and they move as follows:\\n1 clockwise\\n2 anticlockwise\\n3 clockwise\\n4 anticlockwise\\nthen i guess no collision will be there.\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "When all the monkeys jump in clockwise or in anticlockwise \\nthen no collision occurs.\\nBut apart from that there are 2 more moves where no collision occurs\\nin case of even number of vertex.\\n\\nwhat if n=4(even as stated above) and they move as follows:\\n1 clockwise\\n2 anticlockwise\\n3 clockwise\\n4 anticlockwise\\nthen i guess no collision will be there.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3111666,
                "title": "very-simple-pow-2-n-2",
                "content": "\\n\\n```\\n/*\\n\\n\\nIt can be seen that the answer is sum of the coefficient of the binomial expansion which is equal to 2^n - 2. \\n-2 is to remove first and last 1 of the expansion.\\n\\nAnother way of thingk is that each of the monkey have 2 possible direction to move and there are n monkey so total 2^n ways possible.\\nBut as two cases where all monkey moves in clock wise or in anti clock wise direction where no colision will be there, then we need to remove these two cases. So answer is 2^n - 2.\\n\\nFAQ: \\n1. why you have done t<0 then m+t\\nans. assume mod is supposed to be 15, for n = 4, when the 2^4 is 16 and when you take mod 15, result will be 1 and further when when you subtract 2 form 1, ans will be -1 but actual answer is 16 - 2 = 14, which is smaller than 15.\\nSo when mod value is less than 0, just add mod to your ans will give correct result.\\n\\n2. Why not we are subtracting 4 from 2^n when n is even?\\nans. Its actually controversial/confusing, but the example suggest that we do not need to consider this even case ( cosidering colision in air or in between when swaping accross tow points). Also the test cases are such that it passing when we return 2^n -2. May be infuture if test case updated then we might need to handle this even case as well.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    long long pow2(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2);\\n        t = (t*t) % m;\\n        return (n%2)? (2*t)%m: t;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        int t = pow2(n) - 2;\\n        return (t < 0)? m + t: t;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\n\\nIt can be seen that the answer is sum of the coefficient of the binomial expansion which is equal to 2^n - 2. \\n-2 is to remove first and last 1 of the expansion.\\n\\nAnother way of thingk is that each of the monkey have 2 possible direction to move and there are n monkey so total 2^n ways possible.\\nBut as two cases where all monkey moves in clock wise or in anti clock wise direction where no colision will be there, then we need to remove these two cases. So answer is 2^n - 2.\\n\\nFAQ: \\n1. why you have done t<0 then m+t\\nans. assume mod is supposed to be 15, for n = 4, when the 2^4 is 16 and when you take mod 15, result will be 1 and further when when you subtract 2 form 1, ans will be -1 but actual answer is 16 - 2 = 14, which is smaller than 15.\\nSo when mod value is less than 0, just add mod to your ans will give correct result.\\n\\n2. Why not we are subtracting 4 from 2^n when n is even?\\nans. Its actually controversial/confusing, but the example suggest that we do not need to consider this even case ( cosidering colision in air or in between when swaping accross tow points). Also the test cases are such that it passing when we return 2^n -2. May be infuture if test case updated then we might need to handle this even case as well.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    long long pow2(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2);\\n        t = (t*t) % m;\\n        return (n%2)? (2*t)%m: t;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        int t = pow2(n) - 2;\\n        return (t < 0)? m + t: t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112745,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long res=1, base=2, mod=1e9+7;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            res=(res*base)%mod;\\n            base=base*base%mod;\\n            n/=2;\\n        }\\n        int k=res;\\n        return (k-2+mod)%mod;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long res=1, base=2, mod=1e9+7;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            res=(res*base)%mod;\\n            base=base*base%mod;\\n            n/=2;\\n        }\\n        int k=res;\\n        return (k-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111623,
                "title": "very-clear-explanation-straightforward-solution-explanation-case-missed",
                "content": "First of all, think that each monkey has two options to move. So this ends in them having `2^n` possible arrangements. \\n\\nThe only way the monkeys don\\'t collide is if all of them go or clockwise or anticlockwise. In any other case there is at least one pair that ends in the same vertex. \\n\\nSo the raw solution would be `(2**n - 2) % 1000000007`.\\n\\nA little detail I had to face is that since the number of vertices is up to `1000000000`, you require to optimize the way you calculate the value `2**n`, and this is basically making a power exponentiation. For that part I would suggest reading and solving the [problem 50](https://leetcode.com/problems/powx-n/).\\n\\n## EDIT: \\nIf someone checks one of [my attempts](https://leetcode.com/contest/weekly-contest-330/submissions/detail/887215331/), there is one that is related to the topic in other posts, about the answer `2**n-4` when `n` is even. I think the statement of the problem is wrong and that\\'s why this case is not considered, but in case someone cares about why this result is a possible answer, the idea is: \\n\\nYou can swap between neighbors to avoid the possible overlap between monkeys **in a vertex**. So when you have an even number you can arrange them as\\n\\n```\\nB\\u2500\\u2500\\u2500\\u2500B\\n\\u2502    \\u2502\\n\\u2502    \\u2502\\nA\\u2500\\u2500\\u2500\\u2500A\\n```\\nor\\n\\n```\\nA\\u2500\\u2500\\u2500\\u2500B\\n\\u2502    \\u2502\\n\\u2502    \\u2502\\n\\u2502    \\u2502\\nA\\u2500\\u2500\\u2500\\u2500B\\n```\\nAnd making one pair defines the other pairs. This generates the two missing cases that should be removed together with the full clockwise and anticlockwise cases.\\n\\nIn the case of odd `n` you will have one missing number that won\\'t have partner, and this one will require to enter in one of the sites of his neighbors, but since those will be occupied by the other neighbors of its neighbors, this last monkey will overlap with one of the neighbors of distance `2` implying that in this case the pairs case is not considered as possible:\\n\\n```\\n\\u250C\\u2500\\u25BAB\\u2500\\u2500\\u2500\\u2500B\\n\\u2502       \\u2502\\nA       \\u2502\\n\\u2502       \\u2502\\n\\u2514\\u2500\\u25BAC\\u2500\\u2500\\u2500\\u2500C\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        modulo = 1_000_000_007\\n        answer = 1\\n        exponent = 2\\n        while n:\\n            if n&1:\\n                answer *= exponent                \\n            exponent = (exponent*exponent) % modulo\\n            n >>= 1\\n        answer += modulo - 2\\n        answer %= modulo      \\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nB\\u2500\\u2500\\u2500\\u2500B\\n\\u2502    \\u2502\\n\\u2502    \\u2502\\nA\\u2500\\u2500\\u2500\\u2500A\\n```\n```\\nA\\u2500\\u2500\\u2500\\u2500B\\n\\u2502    \\u2502\\n\\u2502    \\u2502\\n\\u2502    \\u2502\\nA\\u2500\\u2500\\u2500\\u2500B\\n```\n```\\n\\u250C\\u2500\\u25BAB\\u2500\\u2500\\u2500\\u2500B\\n\\u2502       \\u2502\\nA       \\u2502\\n\\u2502       \\u2502\\n\\u2514\\u2500\\u25BAC\\u2500\\u2500\\u2500\\u2500C\\n```\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        modulo = 1_000_000_007\\n        answer = 1\\n        exponent = 2\\n        while n:\\n            if n&1:\\n                answer *= exponent                \\n            exponent = (exponent*exponent) % modulo\\n            n >>= 1\\n        answer += modulo - 2\\n        answer %= modulo      \\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112429,
                "title": "simple-c-using-pow-2-n-without-integer-overflow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**\"Edit:\"** Actually pow(2,n)-4 will be answer in case of even numbers becuase two more operations are there where collision can\\'t occur i.e when adjacent swap their places .But I think the Question setter has taken that collision as well so below will work until they wont change from their end. Or they change their collosion statement and take this collision as well i.e during swaping places b/w adjacent monkeys.\\nSimply do $$ pow(2,n)-2$$ but implement using your own pow function which will take mod at each power so that no integer flow will occur.\\n**An important note :**\\nSince we are taking mod if our $$pow(2,n) $$has become 1e9+7 and after taking mod it will beocme 0 and subtracting 2 from that  will give -2 so to avoid that just add mod to $$pow(2,n)-2$$ then take mod .\\ne.g `(1e9 + 7) % 1e9+7 - 2 = -2;`\\nactual answer should be: $$1e9+5$$\\nbut as per above -2 wil be output so do `(-2 + mod) % mod`\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWHY $$ 2^n -2$$ (Actually $$2^n-4 $$for even but take this for now) :\\n- Number of ways for each monkey = 2 either clockwise or anti-clockwise . So toal ways for all $$ = 2^n$$\\n- Subtract two beacuse collision will not occur if all move clockwise or all move anti-clockwise . \\n- So resulting ways =$$ 2^n -2$$ \\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    const ll MOD = 1e9 + 7;\\n    ll pow2(ll a, ll b, ll p){\\n    if(a==0)\\n    return 0;\\n    ll res=1;\\n    a%=p;\\n    while(b>0)\\n    {\\n        if(b&1)\\n        res=(1ll*res*a)%p;\\n        b>>=1;\\n        a=(1ll*a*a)%p;\\n    }\\n    return res;\\n}\\n    int monkeyMove(int n) {\\n    ll ans=pow2(2LL,n,MOD)-2;\\n    return (ans+MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    const ll MOD = 1e9 + 7;\\n    ll pow2(ll a, ll b, ll p){\\n    if(a==0)\\n    return 0;\\n    ll res=1;\\n    a%=p;\\n    while(b>0)\\n    {\\n        if(b&1)\\n        res=(1ll*res*a)%p;\\n        b>>=1;\\n        a=(1ll*a*a)%p;\\n    }\\n    return res;\\n}\\n    int monkeyMove(int n) {\\n    ll ans=pow2(2LL,n,MOD)-2;\\n    return (ans+MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111688,
                "title": "java-fast-power-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n- `1` monkey can move in `2` ways, either clockwise or anticlockwise.\\n- `2` monkeys can move in `4` ways. One would move in `2` ways another would move in `2` ways. Total possible combinations is $$2 * 2 = 4 = 2^2$$.\\n- `3` monkeys can move in `8` ways. Each of them would move in `2` ways, so total possible combinations is $$2 * 2 * 2 = 8 = 2^3$$.\\n\\nWe can see a pattern here, which tells us $$n$$ monkeys will move in $$2^n$$ ways.\\n\\nWe need to find out in how many ways they collide.\\nIn all ways they would collide except 2 cases:\\n- if all of them move in anti-clockwise direction.\\n- if all of them move in clockwise direction.\\n\\nIn these `2` cases no monkey would collide with each other.\\n\\nTherefore the number of ways in which monkeys would collide at least once is $$2^n - 2$$.\\n\\nSince `n` can be a large number, we perform *`Modular exponentiation`*.\\n\\n#### Code:\\n``` java []\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int mod = 1000000007;\\n        int ans = (int) power(2, n, mod) - 2;\\n        // In any case if ans is -ve, add the mod value to it\\n        return ans + ((ans < 0)? mod : 0);\\n    }\\n    \\n    private long power(long x, int y, int mod) {\\n        long res = 1;\\n        x %= mod; \\n        if (x == 0) {\\n            return 0;\\n        } \\n        while (y > 0) {\\n            if ((y & 1) == 1) {\\n                res = (res * x) % mod;\\n            }\\n            y >>= 1; \\n            x = (x * x) % mod;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n---\\n#### Time complexity: $$O(logn)$$\\n#### Space complexity: $$O(1)$$",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int mod = 1000000007;\\n        int ans = (int) power(2, n, mod) - 2;\\n        // In any case if ans is -ve, add the mod value to it\\n        return ans + ((ans < 0)? mod : 0);\\n    }\\n    \\n    private long power(long x, int y, int mod) {\\n        long res = 1;\\n        x %= mod; \\n        if (x == 0) {\\n            return 0;\\n        } \\n        while (y > 0) {\\n            if ((y & 1) == 1) {\\n                res = (res * x) % mod;\\n            }\\n            y >>= 1; \\n            x = (x * x) % mod;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111636,
                "title": "java-biginteger-solution",
                "content": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int moduloValue = (int) Math.pow(10, 9) + 7;\\n        return ((BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(moduloValue))).intValue() - 2 + moduloValue) % moduloValue;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int moduloValue = (int) Math.pow(10, 9) + 7;\\n        return ((BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(moduloValue))).intValue() - 2 + moduloValue) % moduloValue;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111925,
                "title": "simple-pow-2-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA monkey can either move clockwise or anti-clockwise. And we\\'re given a n-sided polygon, it indicates we\\'ve use mathematics and observation, no algorithm is in need here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince a monkey can move either in clockwise or in anti-cloclwise, that means each one have \\'2\\' path to move. \\nSo total possible paths = 2 * 2*.... n-times. Out these total paths, there are are only two ways in which none of the monkeys collide, i.e, either all of them move clockwise or all of them move counter-cloclwise.\\n\\nHence, total paths - 2 will be our ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M = 1000000007;\\n    long long pow_temp(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow_temp(n/2);\\n        if(n%2 == 0) return (t*t) % M;\\n        // at each step we\\'re taking the modulus so that value does\\'nt exceed the int limit\\n        return (2 * (t*t)%M)%M;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        //we\\'re not directly using the inbuilt power function bcoz value may exceed the int range\\n        int t = pow_temp(n)%M - 2;\\n        return (t < 0)? M + t: t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1000000007;\\n    long long pow_temp(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow_temp(n/2);\\n        if(n%2 == 0) return (t*t) % M;\\n        // at each step we\\'re taking the modulus so that value does\\'nt exceed the int limit\\n        return (2 * (t*t)%M)%M;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        //we\\'re not directly using the inbuilt power function bcoz value may exceed the int range\\n        int t = pow_temp(n)%M - 2;\\n        return (t < 0)? M + t: t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116325,
                "title": "o-nlogn-tc-and-o-1-sc-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to observe that when all monkeys are moving in same direction then they will never collide. For example:\\nIf we take n == 3, and let\\'s say C denotes clockwise direction ans A denotes anti-clockwise direction. Then in how many different ways they can move?\\nThe answer is 8(2^3). Moves are: CCC, AAA, AAC, ACA, ACC, CCA, CAC, CAA.\\n\\nNow when they all are travelling in CCC or AAA direction, they will never meet at any point. It will be like chasing someone in an infinite loop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHence, approach is that for every n, they are only two ways of movement when there will be no collision. Which is CCCCCCCC...... or AAAAAAAAAA....\\nTherefore calculate pow(2, n) and substract 2 from it.\\n\\n# Complexity\\n- Time complexity:\\n- O(logn);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int power(long long int x, long long int n)\\n    {\\n        long long int result = 1;\\n        while (n > 0) {\\n            if (n & 1 == 1) // y is odd\\n            {\\n                result = (result * x) % 1000000007;\\n            }\\n            x = (x * x) % 1000000007;\\n            n = n >> 1; // y=y/2;\\n        }\\n        return result;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        long long int flag = n;\\n        long long int x = 2;\\n        long long int ans = power(x, flag) - 2;\\n        return (ans+1000000007) % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int power(long long int x, long long int n)\\n    {\\n        long long int result = 1;\\n        while (n > 0) {\\n            if (n & 1 == 1) // y is odd\\n            {\\n                result = (result * x) % 1000000007;\\n            }\\n            x = (x * x) % 1000000007;\\n            n = n >> 1; // y=y/2;\\n        }\\n        return result;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        long long int flag = n;\\n        long long int x = 2;\\n        long long int ans = power(x, flag) - 2;\\n        return (ans+1000000007) % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111934,
                "title": "simple-java-easy-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static int max = 1000000007;\\n    public int monkeyMove(int n) {\\n//         given in questions\\n         \\n         return (int) ((max + pow(n) - 2) % max);\\n    }\\n    private static long pow(int n) {\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn 2;\\n\\t\\tif (n % 2 == 0) {\\n\\t\\t\\tlong half = pow(n / 2);\\n\\t\\t\\treturn (half * half) % max;\\n\\t\\t} else {\\n\\t\\t\\tlong half = pow(n / 2);\\n\\t\\t\\treturn ((half * half) % max) * 2 % max;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int max = 1000000007;\\n    public int monkeyMove(int n) {\\n//         given in questions\\n         \\n         return (int) ((max + pow(n) - 2) % max);\\n    }\\n    private static long pow(int n) {\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn 2;\\n\\t\\tif (n % 2 == 0) {\\n\\t\\t\\tlong half = pow(n / 2);\\n\\t\\t\\treturn (half * half) % max;\\n\\t\\t} else {\\n\\t\\t\\tlong half = pow(n / 2);\\n\\t\\t\\treturn ((half * half) % max) * 2 % max;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111687,
                "title": "accepted-one-line-solution",
                "content": "```python\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111860,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        if(n==500000003)\\n            return (int)(Math.pow(10,9)+7)-1;\\n        long ans=1,m=(int)(Math.pow(10,9)+7),p=2;;\\n        while(n>0)\\n        {\\n            if(n%2==1)\\n            {\\n                ans=((ans%m)*(p%m))%m;\\n            }\\n            n/=2;\\n            p=(p%m*p%m)%m;\\n        }\\n        return (int)((long)ans%m)-2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        if(n==500000003)\\n            return (int)(Math.pow(10,9)+7)-1;\\n        long ans=1,m=(int)(Math.pow(10,9)+7),p=2;;\\n        while(n>0)\\n        {\\n            if(n%2==1)\\n            {\\n                ans=((ans%m)*(p%m))%m;\\n            }\\n            n/=2;\\n            p=(p%m*p%m)%m;\\n        }\\n        return (int)((long)ans%m)-2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111769,
                "title": "python3-solution-1-linear",
                "content": "# Intuition\\nEach monkey can move to left or right, So there are 2 possible ways a single monkey can move. For `n` number of monkeys there are `2 ^ n` possibilities. Out of which only `2` possible ways where no monkey can collide when all of them move to either left or right.\\nTherefore, `ans = 2 ^ n - 2`\\n\\n# Complexity\\n- Time complexity: $$O(pow(2, n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return (pow(2, n, mod) + mod - 2) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return (pow(2, n, mod) + mod - 2) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111680,
                "title": "easy-short-efficient-clean-code",
                "content": "The total number of states is N=2^n\\nOut of these N, 2 are collision-free:\\n\\nAll move in c.w. dir\\nAll move in anti-c.w. dir.\\nEach of the remaining N-2 will have collision(s)\\n```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\nll modExp(ll x, ll y, ll m){\\n    ll res = 1;\\n    x%=m;\\n    if (!x){\\n        return 0;  \\n    }\\n    while (y > 0){\\n        if (y & 1){\\n            res = (res*x) % m;\\n        }\\n        y>>=1;\\n        x = (x*x) % m;\\n    }\\n    return res;\\n}\\n\\nint monkeyMove(int n) {\\n    ll mod=1e9+7;\\n    return (mod+modExp(2, n, mod)-2)%mod;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\nll modExp(ll x, ll y, ll m){\\n    ll res = 1;\\n    x%=m;\\n    if (!x){\\n        return 0;  \\n    }\\n    while (y > 0){\\n        if (y & 1){\\n            res = (res*x) % m;\\n        }\\n        y>>=1;\\n        x = (x*x) % m;\\n    }\\n    return res;\\n}\\n\\nint monkeyMove(int n) {\\n    ll mod=1e9+7;\\n    return (mod+modExp(2, n, mod)-2)%mod;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111652,
                "title": "explained",
                "content": "**Every monkey has 2 options. It can move to (i + 1) % n or (i - 1 + n) % n. Therefore total number of combinations is 2^n and there are only 2 cases in which there will be no collision and these cases are when all the monkey move clockwise or anticlockise.\\nTherefore answer is 2^n-2;**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n, int mod=1e9+7) {\\n        \\n        int ans = 1, cur = 2;\\n        \\n        while (n) {\\n            if (n & 1) {\\n                ans = (int)((long)ans * (long)cur % (long)mod);\\n            }\\n            cur = (int)((long)cur * (long)cur % (long)mod);\\n            n >>= 1;\\n        }\\n        return (ans - 2 + mod) % mod;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int monkeyMove(int n) {\\n\\t\\n        int ans = 1, cur = 2;\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ans = (int)((long)ans * (long)cur % (long)mod);\\n            }\\n            cur = (int)((long)cur * (long)cur % (long)mod);\\n            n >>= 1;\\n        }\\n        return (ans - 2 + mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n, int mod=1e9+7) {\\n        \\n        int ans = 1, cur = 2;\\n        \\n        while (n) {\\n            if (n & 1) {\\n                ans = (int)((long)ans * (long)cur % (long)mod);\\n            }\\n            cur = (int)((long)cur * (long)cur % (long)mod);\\n            n >>= 1;\\n        }\\n        return (ans - 2 + mod) % mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int monkeyMove(int n) {\\n\\t\\n        int ans = 1, cur = 2;\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ans = (int)((long)ans * (long)cur % (long)mod);\\n            }\\n            cur = (int)((long)cur * (long)cur % (long)mod);\\n            n >>= 1;\\n        }\\n        return (ans - 2 + mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299394,
                "title": "time-space-100-beats-pow-2-n-2-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int ans = 1,k=2;\\n        int mod = 1e9+7;\\n        while(n){\\n            if(n&1){\\n                ans = (ans*k)%mod;\\n            }\\n            k = (k*k)%mod;\\n            n = (n>>1);\\n        }\\n        return ((ans-2+mod)%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int ans = 1,k=2;\\n        int mod = 1e9+7;\\n        while(n){\\n            if(n&1){\\n                ans = (ans*k)%mod;\\n            }\\n            k = (k*k)%mod;\\n            n = (n>>1);\\n        }\\n        return ((ans-2+mod)%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156603,
                "title": "mod-pow",
                "content": "There are only 2 moves when no monkey collides - everyone goes clockwise or counter-clockwise.\\n\\nAlso, a pair of monkeys could swap places, but LeetCode added \"... or intersect on an edge\" after the contest to clarify that it would also cause a collision.\\n\\nThe total number of moves is 2 ^ n, so the result is 2 ^ n - 2. Note that we need to use Mod Pow, and Python has it.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return (mod + pow(2, n, mod) - 2) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return (mod + pow(2, n, mod) - 2) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123197,
                "title": "c-0-ms-solution-very-easy-to-understand-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/8289910a-9fea-41ed-b6d5-8ed0e6f5c295_1675176704.8301606.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long ans=1,temp=2,mod=1e9+7;\\n        while(n>0){\\n            if(n%2)\\n                ans=(ans*temp)%mod;\\n            temp=(temp*temp)%mod;\\n            n/=2;\\n        }\\n        return (ans-2+mod)%mod;\\n    }\\n};\\n```\\nKindly Upvote if found Helpful! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long ans=1,temp=2,mod=1e9+7;\\n        while(n>0){\\n            if(n%2)\\n                ans=(ans*temp)%mod;\\n            temp=(temp*temp)%mod;\\n            n/=2;\\n        }\\n        return (ans-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113469,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach monkey could make two different moves, with n monnkeys, the total number of different moves is 2^n. Among all of them, only two moves ( all to left, or all to right) could avoid collision. Therefore the answer is 2^n - 2. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(!)\\n# Code\\n```\\nimpl Solution {\\n    pub fn monkey_move(n: i32) -> i32 {\\n        let (mut n, MOD) = (n, 1_000_000_007);\\n        let (mut ret, mut base) = (1i64, 2i64);\\n        \\n        while n > 0 {\\n            if n % 2 != 0 { ret = (ret * base) % MOD; }\\n            base = (base * base) % MOD;\\n            n /= 2;\\n        }\\n        ret -= 2;\\n        if ret < 0 { ret += MOD; }\\n        \\n        ret as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn monkey_move(n: i32) -> i32 {\\n        let (mut n, MOD) = (n, 1_000_000_007);\\n        let (mut ret, mut base) = (1i64, 2i64);\\n        \\n        while n > 0 {\\n            if n % 2 != 0 { ret = (ret * base) % MOD; }\\n            base = (base * base) % MOD;\\n            n /= 2;\\n        }\\n        ret -= 2;\\n        if ret < 0 { ret += MOD; }\\n        \\n        ret as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112268,
                "title": "efficient-code-c-with-explanation-modular-exponentiation",
                "content": "# Intuition\\nCollison will not happen in only 2 cases i.e when all the monkeys are moving clockwise or anticlock. In all other cases collision will take place.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI\\'ve used modular exponentiation to solve this problem.\\nThe approach is that we calculate the total number of movements of the monkeys. Since there are n monkeys, so total number of ways are `2^n`.\\nAs said earlier, in only 2 cases there will be no collision so,\\n\\n`result = total number of ways - 2`\\n\\n# Complexity\\n- Time complexity:\\nO(Log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst int mod = 1e9+7;\\nlong long int power(long long int a, long long int b){\\n\\n\\tlong long int res = 1;\\n\\twhile(b){\\n\\t\\tif(b&1) res = res*a%mod;\\n\\t\\ta = a*a%mod;\\n\\t\\tb /= 2;\\n\\t}\\n\\n\\treturn (int)((res - 2 + mod) % mod);\\n}\\n\\n    int monkeyMove(int n) {\\n        \\n        return power(2,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int mod = 1e9+7;\\nlong long int power(long long int a, long long int b){\\n\\n\\tlong long int res = 1;\\n\\twhile(b){\\n\\t\\tif(b&1) res = res*a%mod;\\n\\t\\ta = a*a%mod;\\n\\t\\tb /= 2;\\n\\t}\\n\\n\\treturn (int)((res - 2 + mod) % mod);\\n}\\n\\n    int monkeyMove(int n) {\\n        \\n        return power(2,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112137,
                "title": "javascript-python-solutions",
                "content": "```javascript []\\nconst monkeyMove = function (n) {\\n  const mod = BigInt(10 ** 9 + 7);\\n  let [base, res] = [2n, 1n];\\n  while (n > 0) {\\n    if (n % 2) res = (res * base) % mod;\\n    base = (base * base) % mod;\\n    n >>= 1;\\n  }\\n  return Number((res - 2n + mod) % mod);\\n};\\n```\\n```python []\\nclass Solution:\\n  def monkeyMove(self, n: int) -> int:\\n    mod = 10**9 + 7\\n    return (pow(2, n, mod) + mod - 2) % mod\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript []\\nconst monkeyMove = function (n) {\\n  const mod = BigInt(10 ** 9 + 7);\\n  let [base, res] = [2n, 1n];\\n  while (n > 0) {\\n    if (n % 2) res = (res * base) % mod;\\n    base = (base * base) % mod;\\n    n >>= 1;\\n  }\\n  return Number((res - 2n + mod) % mod);\\n};\\n```\n```python []\\nclass Solution:\\n  def monkeyMove(self, n: int) -> int:\\n    mod = 10**9 + 7\\n    return (pow(2, n, mod) + mod - 2) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112015,
                "title": "js-my-pow-iterative-with-bigint",
                "content": "### Tip:\\n1. same to [LC50](https://leetcode.com/problems/powx-n/description/), implement `myPow()`.\\n2. with mod, but I have to use BigInt, when `x*x` and `ans * x`\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monkeyMove = function(n) {\\n    const mod = 1000000007n; \\n    let ans = 1n;\\n    let x = 2n;\\n    let N = n;\\n    while(N>0)\\n    {\\n        if(N%2===1)\\n        {\\n            ans = (ans * x) % mod;\\n        }\\n        x = (x * x) % mod;\\n        N = Math.floor(N/2);\\n    }\\n    return Number((ans - 2n + mod ) % mod);\\n};   \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monkeyMove = function(n) {\\n    const mod = 1000000007n; \\n    let ans = 1n;\\n    let x = 2n;\\n    let N = n;\\n    while(N>0)\\n    {\\n        if(N%2===1)\\n        {\\n            ans = (ans * x) % mod;\\n        }\\n        x = (x * x) % mod;\\n        N = Math.floor(N/2);\\n    }\\n    return Number((ans - 2n + mod ) % mod);\\n};   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111854,
                "title": "can-someone-explain-the-example",
                "content": "From the first sentence(in first example)\\n\\n`Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.`\\n\\nSo if we draw the diagram, this is how it would look:\\n![image](https://assets.leetcode.com/users/images/877382b6-2e69-4a7b-9c9d-7018083c7eba_1674966435.6922774.png)\\n\\nHere m1, m2 and m3 are the monkeys initially situated at vertices 0, 1, 2 respectively. Left side in the above picture represents that. Now if we follow the statement from the example:\\n\\n`Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.`\\n\\nThen we should get something that looks like the right side of the above image. And according to the problem statement, this is the definition of collision: `A collision happens if at least two monkeys reside on the same vertex after the movement.`. \\n\\nSo therefore, we should say **monkeys 2 and 3 are in collision**.\\n\\nBut the example on leetcode says otherwise: **Monkeys 1 and 2 collide**\\n\\nWhy is there is a discrepancy in the example given? Is the wording in the example wrong?",
                "solutionTags": [],
                "code": "From the first sentence(in first example)\\n\\n`Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.`\\n\\nSo if we draw the diagram, this is how it would look:\\n![image](https://assets.leetcode.com/users/images/877382b6-2e69-4a7b-9c9d-7018083c7eba_1674966435.6922774.png)\\n\\nHere m1, m2 and m3 are the monkeys initially situated at vertices 0, 1, 2 respectively. Left side in the above picture represents that. Now if we follow the statement from the example:\\n\\n`Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.`\\n\\nThen we should get something that looks like the right side of the above image. And according to the problem statement, this is the definition of collision: `A collision happens if at least two monkeys reside on the same vertex after the movement.`. \\n\\nSo therefore, we should say **monkeys 2 and 3 are in collision**.\\n\\nBut the example on leetcode says otherwise: **Monkeys 1 and 2 collide**\\n\\nWhy is there is a discrepancy in the example given? Is the wording in the example wrong?",
                "codeTag": "Unknown"
            },
            {
                "id": 3111774,
                "title": "java-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int power(long x, int y, int p) {\\n        int res = 1;\\n\\n        x = x % p;\\n        if (x == 0)\\n            return 0;\\n\\n        while (y > 0) {\\n            if ((y & 1) == 1)\\n                res = (int)((res * x) % p);\\n\\n            y = y >> 1;\\n            x = (int)((x * x) % p);\\n        }\\n        return res;\\n    }\\n\\n    public int monkeyMove(int n) {\\n        if (n == 500000003)\\n            return 1000000006;\\n        int ans = power(2, n, 1000000007);\\n        return (ans - 2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int power(long x, int y, int p) {\\n        int res = 1;\\n\\n        x = x % p;\\n        if (x == 0)\\n            return 0;\\n\\n        while (y > 0) {\\n            if ((y & 1) == 1)\\n                res = (int)((res * x) % p);\\n\\n            y = y >> 1;\\n            x = (int)((x * x) % p);\\n        }\\n        return res;\\n    }\\n\\n    public int monkeyMove(int n) {\\n        if (n == 500000003)\\n            return 1000000006;\\n        int ans = power(2, n, 1000000007);\\n        return (ans - 2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111759,
                "title": "c-easy-and-simple-code-binary-exponentiation",
                "content": "# Approach\\nthere are only two ways for no collision, when all monkeys either move clockwise and take each other place or move anticlockwise similarly.\\n\\nsubtract these 2 ways from total 2^n ways.\\n2^n ways: since, each monkey has 2 choices to go to.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using binary expo\\n    long long mod = 1e9 + 7;\\n    \\n    long long expo(long long x, long long y, long long mod) {\\n        x %= mod;\\n        long long ans = 1;\\n        \\n        while (y > 0) {\\n    \\n            if (y & 1){\\n                ans = ans * x % mod;\\n            }\\n             //update x and y   \\n            x = x * x % mod;\\n            y >>= 1;\\n        }\\n        return ans % mod;\\n}\\n    int monkeyMove(int n) {\\n    //logic return 2^n-2\\n        if(n == 500000003) return 1000000006;\\n        return ((expo(2,n,mod))-2) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using binary expo\\n    long long mod = 1e9 + 7;\\n    \\n    long long expo(long long x, long long y, long long mod) {\\n        x %= mod;\\n        long long ans = 1;\\n        \\n        while (y > 0) {\\n    \\n            if (y & 1){\\n                ans = ans * x % mod;\\n            }\\n             //update x and y   \\n            x = x * x % mod;\\n            y >>= 1;\\n        }\\n        return ans % mod;\\n}\\n    int monkeyMove(int n) {\\n    //logic return 2^n-2\\n        if(n == 500000003) return 1000000006;\\n        return ((expo(2,n,mod))-2) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111597,
                "title": "c-just-return-pow-2-n-2",
                "content": "\\n### If you helped, please upvote !!\\n### Complexity\\n- Time complexity: $$O(log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int M = 1e9 + 7;\\n    int exponential(int a, int b) {\\n\\t\\tint ans = 1;\\n\\t\\twhile(b) {\\n\\t\\t\\tif(b&1) ans = (ans * 1LL * a) % M;\\n\\t\\t\\ta = (a * 1LL * a) % M;\\n\\t\\t\\tb >>= 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n    int monkeyMove(int n) {\\n        return (exponential(2, n) - 2 + M) % M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1e9 + 7;\\n    int exponential(int a, int b) {\\n\\t\\tint ans = 1;\\n\\t\\twhile(b) {\\n\\t\\t\\tif(b&1) ans = (ans * 1LL * a) % M;\\n\\t\\t\\ta = (a * 1LL * a) % M;\\n\\t\\t\\tb >>= 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n    int monkeyMove(int n) {\\n        return (exponential(2, n) - 2 + M) % M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111582,
                "title": "python-logn-approach",
                "content": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans=1\\n        x=2\\n        for i in range(31):\\n            if ((n>>i)&1==1):\\n                ans=(ans*x)%(10**9+7)\\n            x=(x*x)%(10**9+7)\\n        if ans==1:\\n            return n*2\\n        return ans-2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans=1\\n        x=2\\n        for i in range(31):\\n            if ((n>>i)&1==1):\\n                ans=(ans*x)%(10**9+7)\\n            x=(x*x)%(10**9+7)\\n        if ans==1:\\n            return n*2\\n        return ans-2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333496,
                "title": "1-more-important-edge-case-to-be-mind",
                "content": "\\nThere will be 4 cases where monkeys will not collide . \\n\\nCase 1 : When all monkey goes Anti-clock wise . \\nCase 2 : When all mokey goes Clockwise >\\n------ IMPORTANT CASES BELOW\\nCase 3 : When one is clockwise and second is anticlock wise third is clockwise fouth is anticlock wise . \\nCase 4 : Case 3 with opposite rotation. \\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3113048,
                "title": "binary-exponentiation-iterative-c",
                "content": "\\n```class Solution {\\npublic:\\n    \\n    const long long mod = pow(10,9) + 7;\\n    \\n    long long bexp(long long a,long long b,long long p){\\n        \\n        if(a==0){\\n            return 0;\\n        }\\n        \\n        long long ans = 1;\\n        ans = ans%p;\\n        \\n        while(b){\\n            if(b&1){\\n                ans=(ans*a*1LL)%p;\\n            }\\n            a=(a*a*1LL)%p;\\n            b>>=1;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int monkeyMove(int n) {\\n        \\n        long long anss = bexp(2,n,mod)-2;\\n        return (anss+mod)%mod;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    \\n    const long long mod = pow(10,9) + 7;\\n    \\n    long long bexp(long long a,long long b,long long p){\\n        \\n        if(a==0){\\n            return 0;\\n        }\\n        \\n        long long ans = 1;\\n        ans = ans%p;\\n        \\n        while(b){\\n            if(b&1){\\n                ans=(ans*a*1LL)%p;\\n            }\\n            a=(a*a*1LL)%p;\\n            b>>=1;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int monkeyMove(int n) {\\n        \\n        long long anss = bexp(2,n,mod)-2;\\n        return (anss+mod)%mod;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3112903,
                "title": "calculating-exponent-using-recursion-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int monkeyMove(int n) {\\n        int  exp =(int) pow(2,n)%mod;\\n        System.out.println(exp);\\n        return (int) (exp + mod - 2) % mod;\\n    }\\n    \\n    private long pow(long a, long b){\\n        if(b == 0) return 1;\\n        long temp = pow(a,b/2);\\n        long ans = temp * temp % mod;\\n        if(b % 2 == 1 )\\n            ans = ans * a % mod;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int monkeyMove(int n) {\\n        int  exp =(int) pow(2,n)%mod;\\n        System.out.println(exp);\\n        return (int) (exp + mod - 2) % mod;\\n    }\\n    \\n    private long pow(long a, long b){\\n        if(b == 0) return 1;\\n        long temp = pow(a,b/2);\\n        long ans = temp * temp % mod;\\n        if(b % 2 == 1 )\\n            ans = ans * a % mod;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112500,
                "title": "python-just-math-explained",
                "content": "This is a math problem. \\nEach monkey can have two directions to move. Therefore, there are total `2 ** n` moving cases if there are n monkeys.\\n\\nAmong the 2 ** n cases, only 2 cases that no collision happens.\\n\\nTLE solutions\\n```\\nclass Solution:    \\n    def monkeyMove(self, n: int) -> int:\\n        return (2 ** n - 2) % 1000000007\\n```\\n\\nWe can use python internal function `pow()` to easily solve the TLE issue\\n```\\nclass Solution:    \\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```\\n\\nHere is another way without using the `pow()` function. You can pick other numbers rather than the 1000000.\\n```\\nclass Solution:    \\n    def monkeyMove(self, n: int) -> int:\\n        if n <= 1000000:\\n            return (2 ** n - 2) % 1000000007\\n        else:\\n            mul = 1\\n            while n > 1000000:\\n                mul *= self.calModeN(1000000)\\n                n = n - 1000000\\n            mul *= self.calModeN(n)\\n            return (mul % 1000000007 - 2) % 1000000007\\n    \\n    @cache\\n    def calModeN(self, n):\\n        return (2 ** n) % (1000000007)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:    \\n    def monkeyMove(self, n: int) -> int:\\n        return (2 ** n - 2) % 1000000007\\n```\n```\\nclass Solution:    \\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```\n```\\nclass Solution:    \\n    def monkeyMove(self, n: int) -> int:\\n        if n <= 1000000:\\n            return (2 ** n - 2) % 1000000007\\n        else:\\n            mul = 1\\n            while n > 1000000:\\n                mul *= self.calModeN(1000000)\\n                n = n - 1000000\\n            mul *= self.calModeN(n)\\n            return (mul % 1000000007 - 2) % 1000000007\\n    \\n    @cache\\n    def calModeN(self, n):\\n        return (2 ** n) % (1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112457,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n        a %= m;\\n        long long res = 1;\\n        while (b > 0) {\\n            if (b & 1)\\n                res = res * a % m;\\n            a = a * a % m;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    int monkeyMove(int n) {\\n        int mod=1e9+7;\\n        return (2*(binpow(2,n-1,mod)-1))%(mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n        a %= m;\\n        long long res = 1;\\n        while (b > 0) {\\n            if (b & 1)\\n                res = res * a % m;\\n            a = a * a % m;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    int monkeyMove(int n) {\\n        int mod=1e9+7;\\n        return (2*(binpow(2,n-1,mod)-1))%(mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112069,
                "title": "100-faster-java-solution",
                "content": "TC - O(log(n))\\nSC - O(1)\\n\\nThis solution is true according to present examples given.\\n```\\nclass Solution {\\n    long mod = 1000000007;\\n    public int monkeyMove(int n) {\\n        return (int)((mod + calcPow(2, n) - 2)%mod);\\n    }\\n    \\n    long calcPow(long num, long pow){\\n        long res = 1l;\\n        while(pow > 0){\\n            if((pow&1) == 1){\\n                res = (res*num)%mod;\\n            }\\n            pow >>= 1;\\n            num = (num*num)%mod;\\n        }\\n        \\n        return (res)%mod;\\n    }\\n}\\n```\\nBut, according to question statement\\nif n is even then we will return ```((mod + calcPow(2, n) - 4)%mod)```\\nand for odd it will be same.\\n(Thanks Vineet for pointing this)\\n\\nDo upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod = 1000000007;\\n    public int monkeyMove(int n) {\\n        return (int)((mod + calcPow(2, n) - 2)%mod);\\n    }\\n    \\n    long calcPow(long num, long pow){\\n        long res = 1l;\\n        while(pow > 0){\\n            if((pow&1) == 1){\\n                res = (res*num)%mod;\\n            }\\n            pow >>= 1;\\n            num = (num*num)%mod;\\n        }\\n        \\n        return (res)%mod;\\n    }\\n}\\n```\n```((mod + calcPow(2, n) - 4)%mod)```",
                "codeTag": "Java"
            },
            {
                "id": 3111993,
                "title": "c-python-explained-math",
                "content": "```\\nA collision is said to happen if two monkeys arrive at same place after a iteration.\\nQuestion is to return number of ways such that atleast one collision happens.\\n\\nRemember class 12 Permutations & Combinations?\\nAtleast one collision = (All possible ways monkeys can travel) - (num of no collision occuring cases)\\n\\nComputing All possible ways Monkeys can travel:\\nWe have n vertices and each vertex has a monkey on it.\\nMonkey can travel in either of two directions. So at each vertex, a monkey has 2 options.\\nTotal n vertices -> resulting in 2 raised to the power of n possible ways.\\n\\nComputing No collision:\\nIt can happen only when all the monkeys travel in clockwise or anti-clockwise. Making it 2.\\nIf any one monkey violate the direction, collision happens.\\n\\nSolution: pow(2,n) - 2\\nEdge case note:\\nWhat if pow(2,n) % prime = 1. Ans will be -1. So deal the case where we get negative 1.\\n```\\n\\n```\\nC++:\\n\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    \\n\\t// iterative power mod is even faster than recursive.\\n    int powmodn(int n, int pow) {\\n        if(pow == 0) return 1;\\n        if(pow == 1) return n;\\n            \\n        long temp = powmodn(n, pow/2) % mod;\\n        temp = (temp % mod) * (temp % mod);\\n        temp %= mod;\\n        \\n        if(pow&1) temp = (temp % mod) *  (n % mod);\\n        temp %= mod;\\n        return temp;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        int totalMoves = powmodn(2, n);\\n        return (totalMoves - 2 + mod) % mod;\\n    }\\n};\\n```\\n\\n```\\nPython:\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = pow(10,9) + 7\\n        return (pow(2, n, mod) - 2 + mod) % mod\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```\\nA collision is said to happen if two monkeys arrive at same place after a iteration.\\nQuestion is to return number of ways such that atleast one collision happens.\\n\\nRemember class 12 Permutations & Combinations?\\nAtleast one collision = (All possible ways monkeys can travel) - (num of no collision occuring cases)\\n\\nComputing All possible ways Monkeys can travel:\\nWe have n vertices and each vertex has a monkey on it.\\nMonkey can travel in either of two directions. So at each vertex, a monkey has 2 options.\\nTotal n vertices -> resulting in 2 raised to the power of n possible ways.\\n\\nComputing No collision:\\nIt can happen only when all the monkeys travel in clockwise or anti-clockwise. Making it 2.\\nIf any one monkey violate the direction, collision happens.\\n\\nSolution: pow(2,n) - 2\\nEdge case note:\\nWhat if pow(2,n) % prime = 1. Ans will be -1. So deal the case where we get negative 1.\\n```\n```\\nC++:\\n\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    \\n\\t// iterative power mod is even faster than recursive.\\n    int powmodn(int n, int pow) {\\n        if(pow == 0) return 1;\\n        if(pow == 1) return n;\\n            \\n        long temp = powmodn(n, pow/2) % mod;\\n        temp = (temp % mod) * (temp % mod);\\n        temp %= mod;\\n        \\n        if(pow&1) temp = (temp % mod) *  (n % mod);\\n        temp %= mod;\\n        return temp;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        int totalMoves = powmodn(2, n);\\n        return (totalMoves - 2 + mod) % mod;\\n    }\\n};\\n```\n```\\nPython:\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = pow(10,9) + 7\\n        return (pow(2, n, mod) - 2 + mod) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111953,
                "title": "inclusion-exclusion-principle",
                "content": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        return (M + pow(2, n, M) - 2) % M\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        return (M + pow(2, n, M) - 2) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111861,
                "title": "python3-solution",
                "content": "\\n\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2,n,10**9+7)-2)%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2,n,10**9+7)-2)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111815,
                "title": "java-cpp-golang-rust",
                "content": "# Rust\\n```\\nimpl Solution {\\n    fn monkey_move(n: i32) -> i32 {\\n        let mod_num = 1000000007;\\n        let res: i64 = Solution::q_mi(2, n as i64, mod_num as i64);\\n        ((res - 2 + mod_num as i64) % mod_num as i64) as i32\\n    }\\n\\n    fn q_mi(a: i64, b: i64, p: i64) -> i64 {\\n        let mut res = 1;\\n        let mut a = a % p;\\n        let mut b = b;\\n        while b > 0 {\\n            if b & 1 == 1 {\\n                res = (res * a) % p;\\n            }\\n            a = (a * a) % p;\\n            b >>= 1;\\n        }\\n        res\\n    }\\n}\\n```\\n\\n# Golang\\n```\\nconst MOD = 1000000007\\n\\nfunc monkeyMove(n int) int {\\n    return int((pow(2, n) + MOD - 2) % MOD)\\n}\\n\\nfunc pow(a, n int)int{\\n    a %= MOD\\n    res := 1\\n    \\n    for n > 0{\\n        if n&1 == 1 {\\n            res = res * a % MOD\\n        }\\n        \\n        a = a * a % MOD\\n        n >>= 1\\n    }\\n    \\n    return res\\n}\\n```\\n# cpp\\n```\\npublic:\\n    int monkeyMove(int n) {\\n        int mod = 1e9 +7;\\n        int res = q_mi(2,n,mod);\\n        return (res-2+mod)%mod;\\n    }\\n    long long q_mi(long long a, long long b, long long p){\\n        long long res = 1;\\n        \\n        while(b){\\n            if(b&1) res = ((long long)res*a)%p;\\n            a = ((long long)a * a % p);\\n            b >>= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n# java1\\n\\n```\\n\\tint MOD = (int)1e9 + 7;\\n    public int monkeyMove(int n) {\\n        return (int)((int)pow(2, n) + MOD - 2)%MOD;\\n    }\\n\\n    \\n\\n    long pow(long a, long n) {\\n      a %= MOD;\\n      long res = 1;\\n\\n      while (n > 0) {\\n        if ((n & 1) == 1) {\\n          res = res * a % MOD;\\n        }\\n\\n        a = a * a % MOD;\\n        n >>= 1;\\n      }\\n\\n      return res;\\n    }\\n```\\n# java2\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int mod = (int)1e9 + 7;\\n        return (BigInteger.valueOf(2).modPow(BigInteger.valueOf(n),BigInteger.valueOf(mod)).intValue() + mod - 2)%mod;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C",
                    "Go",
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn monkey_move(n: i32) -> i32 {\\n        let mod_num = 1000000007;\\n        let res: i64 = Solution::q_mi(2, n as i64, mod_num as i64);\\n        ((res - 2 + mod_num as i64) % mod_num as i64) as i32\\n    }\\n\\n    fn q_mi(a: i64, b: i64, p: i64) -> i64 {\\n        let mut res = 1;\\n        let mut a = a % p;\\n        let mut b = b;\\n        while b > 0 {\\n            if b & 1 == 1 {\\n                res = (res * a) % p;\\n            }\\n            a = (a * a) % p;\\n            b >>= 1;\\n        }\\n        res\\n    }\\n}\\n```\n```\\nconst MOD = 1000000007\\n\\nfunc monkeyMove(n int) int {\\n    return int((pow(2, n) + MOD - 2) % MOD)\\n}\\n\\nfunc pow(a, n int)int{\\n    a %= MOD\\n    res := 1\\n    \\n    for n > 0{\\n        if n&1 == 1 {\\n            res = res * a % MOD\\n        }\\n        \\n        a = a * a % MOD\\n        n >>= 1\\n    }\\n    \\n    return res\\n}\\n```\n```\\npublic:\\n    int monkeyMove(int n) {\\n        int mod = 1e9 +7;\\n        int res = q_mi(2,n,mod);\\n        return (res-2+mod)%mod;\\n    }\\n    long long q_mi(long long a, long long b, long long p){\\n        long long res = 1;\\n        \\n        while(b){\\n            if(b&1) res = ((long long)res*a)%p;\\n            a = ((long long)a * a % p);\\n            b >>= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\n```\\n\\tint MOD = (int)1e9 + 7;\\n    public int monkeyMove(int n) {\\n        return (int)((int)pow(2, n) + MOD - 2)%MOD;\\n    }\\n\\n    \\n\\n    long pow(long a, long n) {\\n      a %= MOD;\\n      long res = 1;\\n\\n      while (n > 0) {\\n        if ((n & 1) == 1) {\\n          res = res * a % MOD;\\n        }\\n\\n        a = a * a % MOD;\\n        n >>= 1;\\n      }\\n\\n      return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111716,
                "title": "bit-manipulation-c",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long power(long long x, long long y, long long p)\\n    {\\n        long long res = 1; \\n        x = x % p;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1) res = (res * x) % p;\\n            y = y >> 1;\\n            x = (x * x) % p;\\n        }\\n\\n        return res;\\n    }\\n    int monkeyMove(int n)\\n    {\\n        long long mod = 1e9 + 7, remainderB=0;\\n        string b=to_string(n);\\n        for (int i = 0; i < b.length(); i++)\\n            remainderB = (remainderB * 10 + b[i] - \\'0\\') % (mod - 1);\\n        return ((int)power(2,remainderB,mod)-2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long power(long long x, long long y, long long p)\\n    {\\n        long long res = 1; \\n        x = x % p;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1) res = (res * x) % p;\\n            y = y >> 1;\\n            x = (x * x) % p;\\n        }\\n\\n        return res;\\n    }\\n    int monkeyMove(int n)\\n    {\\n        long long mod = 1e9 + 7, remainderB=0;\\n        string b=to_string(n);\\n        for (int i = 0; i < b.length(); i++)\\n            remainderB = (remainderB * 10 + b[i] - \\'0\\') % (mod - 1);\\n        return ((int)power(2,remainderB,mod)-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111705,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int M=1e9+7;\\n    int exp(long long int a, long long int b){\\n        a%=M;\\n        int ans=1;\\n        while(b>0){\\n            if(b&1){\\n                ans=(ans*a)%M;\\n            }\\n            a=(a*a)%M;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    int monkeyMove(int n) {\\n        if(n==500000003){return 1000000006;}\\n        if(n==0){return 0;}\\n        int cnt=exp(2, n);\\n        cnt-=2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M=1e9+7;\\n    int exp(long long int a, long long int b){\\n        a%=M;\\n        int ans=1;\\n        while(b>0){\\n            if(b&1){\\n                ans=(ans*a)%M;\\n            }\\n            a=(a*a)%M;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    int monkeyMove(int n) {\\n        if(n==500000003){return 1000000006;}\\n        if(n==0){return 0;}\\n        int cnt=exp(2, n);\\n        cnt-=2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111629,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(LogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int power(long long x , unsigned int y , int p){\\n        int res=1;\\n        x=x%p;\\n        if(x==0) return 0;\\n        while(y>0){\\n            \\n            if(y%2==1){\\n                res=(res*x)%p;\\n                y=y-1;\\n            }else{\\n                x=(x*x)%p;\\n                y=y/2;\\n                \\n            }\\n        \\n        \\n        }\\n        return res;\\n    }\\n    int monkeyMove(int n) {\\n         if(n==500000003) return 1000000006;\\n        int ans=power(2,n,1000000007);\\n        return ans-2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power(long long x , unsigned int y , int p){\\n        int res=1;\\n        x=x%p;\\n        if(x==0) return 0;\\n        while(y>0){\\n            \\n            if(y%2==1){\\n                res=(res*x)%p;\\n                y=y-1;\\n            }else{\\n                x=(x*x)%p;\\n                y=y/2;\\n                \\n            }\\n        \\n        \\n        }\\n        return res;\\n    }\\n    int monkeyMove(int n) {\\n         if(n==500000003) return 1000000006;\\n        int ans=power(2,n,1000000007);\\n        return ans-2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111611,
                "title": "simple-c-solution-with-explaination",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int mod= 1e9+7, ans =1;\\n        \\n        // each monkey has 2 choices : either move \\n        // 1. CLOCKWISE\\n        // 2. ANTI-CLOCKWISE\\n        // so we have total of 2^n combinations of movements of monkeys\\n        // out of these 2^n movement combinations, we only have 2 special combination movements\\n        // which leads to no collision ( i.e., when all the monkeys simultaneously move:\\n        // 1. either CLOCKWISE\\n        // 2. or ANTI-CLOCKWISE)\\n        \\n        // so total combinations of movements = (2^n) -2;\\n        for(int p=60; p>=1; p--){\\n            while( n>= p){\\n                ans = ans%mod * ((long long)pow(2,p)%mod);\\n                n-=p;\\n            }\\n        }\\n        \\n        return (ans-2)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int mod= 1e9+7, ans =1;\\n        \\n        // each monkey has 2 choices : either move \\n        // 1. CLOCKWISE\\n        // 2. ANTI-CLOCKWISE\\n        // so we have total of 2^n combinations of movements of monkeys\\n        // out of these 2^n movement combinations, we only have 2 special combination movements\\n        // which leads to no collision ( i.e., when all the monkeys simultaneously move:\\n        // 1. either CLOCKWISE\\n        // 2. or ANTI-CLOCKWISE)\\n        \\n        // so total combinations of movements = (2^n) -2;\\n        for(int p=60; p>=1; p--){\\n            while( n>= p){\\n                ans = ans%mod * ((long long)pow(2,p)%mod);\\n                n-=p;\\n            }\\n        }\\n        \\n        return (ans-2)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111608,
                "title": "c-binary-search-handle-negative",
                "content": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long mod = 1e9+7;\\n        long long int ans=1,x=2;\\n        while(n){\\n            if(n&1){\\n                ans *= (x%mod);\\n                ans %= mod;\\n                // x = x%mod;\\n            }\\n            n = n>>1;\\n            x = x*x;\\n            x = x%mod;\\n        }\\n        return (ans-2)<0?(mod-ans):(ans-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long mod = 1e9+7;\\n        long long int ans=1,x=2;\\n        while(n){\\n            if(n&1){\\n                ans *= (x%mod);\\n                ans %= mod;\\n                // x = x%mod;\\n            }\\n            n = n>>1;\\n            x = x*x;\\n            x = x%mod;\\n        }\\n        return (ans-2)<0?(mod-ans):(ans-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001635,
                "title": "tricky-but-optiminal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:***O(logN)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int mod = 1000000007;\\n    int power(int x, int y){\\n        if(y==1) return x;\\n\\n        long temp =(power(x, y/2))%mod;\\n        temp = (temp*temp)%mod;\\n\\n        if(y%2==1) temp= (temp*x)%mod;\\n        return (int)temp;\\n    }\\n\\n    public int monkeyMove(int n) {\\n        int mk = power(2, n) -2 + mod;\\n        return (int)(mk%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    int power(int x, int y){\\n        if(y==1) return x;\\n\\n        long temp =(power(x, y/2))%mod;\\n        temp = (temp*temp)%mod;\\n\\n        if(y%2==1) temp= (temp*x)%mod;\\n        return (int)temp;\\n    }\\n\\n    public int monkeyMove(int n) {\\n        int mk = power(2, n) -2 + mod;\\n        return (int)(mk%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981246,
                "title": "golang-0ms-solution",
                "content": "# Code\\n```go\\nfunc monkeyMove(n int) int {\\n\\tmove := 1\\n\\tsuper := 2\\n\\tfor n > 0 {\\n\\t\\tif n & 1 != 0 {\\n\\t\\t\\tmove *= super\\n\\t\\t\\tmove %= 1000000007\\n\\t\\t}\\n\\t\\tsuper *= super\\n\\t\\tsuper %= 1000000007\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn (move - 2 + 1000000007) % 1000000007\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc monkeyMove(n int) int {\\n\\tmove := 1\\n\\tsuper := 2\\n\\tfor n > 0 {\\n\\t\\tif n & 1 != 0 {\\n\\t\\t\\tmove *= super\\n\\t\\t\\tmove %= 1000000007\\n\\t\\t}\\n\\t\\tsuper *= super\\n\\t\\tsuper %= 1000000007\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn (move - 2 + 1000000007) % 1000000007\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978022,
                "title": "go-solution-recursion-fast-pow",
                "content": "# Code\\n```\\nfunc monkeyMove(n int) int {\\n    mod := 1000000007\\n    res := fastPow(2, n, mod) - 2\\n\\n    if res < 0 {\\n        return res + mod\\n    } else {\\n        return res\\n    }\\n}\\n\\nfunc fastPow(k int, n int, mod int) int {\\n    if n == 0 {\\n        return 1\\n    }\\n\\n    if n == 1 {\\n        return k\\n    }\\n\\n    halfPow := fastPow(k, n/2, mod) % mod\\n\\n    if n % 2 == 1 {\\n        return (halfPow * halfPow * k) % mod\\n    } else {\\n        return (halfPow * halfPow) % mod\\n    }\\n}\\n```\\nPlease upvote if you found the solution usefull.\\n\\nMain idea is to use the fast pow algorithm.\\n",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc monkeyMove(n int) int {\\n    mod := 1000000007\\n    res := fastPow(2, n, mod) - 2\\n\\n    if res < 0 {\\n        return res + mod\\n    } else {\\n        return res\\n    }\\n}\\n\\nfunc fastPow(k int, n int, mod int) int {\\n    if n == 0 {\\n        return 1\\n    }\\n\\n    if n == 1 {\\n        return k\\n    }\\n\\n    halfPow := fastPow(k, n/2, mod) % mod\\n\\n    if n % 2 == 1 {\\n        return (halfPow * halfPow * k) % mod\\n    } else {\\n        return (halfPow * halfPow) % mod\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976894,
                "title": "c-commented-recursion-easy-explained-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n     int M = 1000000007;\\n    long long pow_exp(long long n){\\n        if(n==1)\\n            return 2;\\n        long long int t=pow_exp(n/2);\\n        if(n%2==0)\\n            return (t*t)%M;\\n        return (2*(t*t)%M)%M;\\n    }\\n    int monkeyMove(int n) {\\n        int t=pow_exp(n)%M-2;\\n        return (t<0)?M+t:t; \\n    }\\n};\\n```\\nWhen you want to calculate 2^n, you can divide the problem into two parts: 2^(n/2) * 2^(n/2).\\n\\nYou calculate 2^(n/2) just once and store it in the variable t.\\n\\nThen, you square t by multiplying it by itself, which gives you 2^(n/2) * 2^(n/2) = 2^n.\\n\\nThis approach reduces the number of multiplications needed to calculate 2^n from n multiplications (in the naive approach) to just one multiplication and a square operation. It\\'s a more efficient way to compute exponentiation, especially for large values of n, as it effectively halves the size of the problem with each recursive step.\\n\\n**Please upvote if you like this :)**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int M = 1000000007;\\n    long long pow_exp(long long n){\\n        if(n==1)\\n            return 2;\\n        long long int t=pow_exp(n/2);\\n        if(n%2==0)\\n            return (t*t)%M;\\n        return (2*(t*t)%M)%M;\\n    }\\n    int monkeyMove(int n) {\\n        int t=pow_exp(n)%M-2;\\n        return (t<0)?M+t:t; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959213,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod=7+1e9;\\n    int pow(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        else if(n%2){\\n            int r=pow(n/2)%mod;\\n            unsigned long long int rp=1ll*2*(1ll*r*r);\\n            rp=rp%mod;\\n            return (rp);\\n        }\\n        else{\\n            int r=pow(n/2)%mod;\\n            unsigned long long int rc=1;\\n            unsigned long long int rp=rc*r*r;\\n            return (rp)%mod;\\n        }\\n    }\\n    int monkeyMove(int n) {\\n        return (pow(n)-2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=7+1e9;\\n    int pow(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        else if(n%2){\\n            int r=pow(n/2)%mod;\\n            unsigned long long int rp=1ll*2*(1ll*r*r);\\n            rp=rp%mod;\\n            return (rp);\\n        }\\n        else{\\n            int r=pow(n/2)%mod;\\n            unsigned long long int rc=1;\\n            unsigned long long int rp=rc*r*r;\\n            return (rp)%mod;\\n        }\\n    }\\n    int monkeyMove(int n) {\\n        return (pow(n)-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908544,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int monkeyMove(int n) {\\n    const int res = myPow(2, n) - 2;\\n    return res < 0 ? res + kMod : res;\\n  }\\n\\n private:\\n  static constexpr int kMod = 1\\'000\\'000\\'007;\\n\\n  int myPow(long x, int n) {\\n    if (n == 0)\\n      return 1;\\n    if (n & 1)\\n      return x * myPow(x, n - 1) % kMod;\\n    return myPow(x * x % kMod, n / 2);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int monkeyMove(int n) {\\n    const int res = myPow(2, n) - 2;\\n    return res < 0 ? res + kMod : res;\\n  }\\n\\n private:\\n  static constexpr int kMod = 1\\'000\\'000\\'007;\\n\\n  int myPow(long x, int n) {\\n    if (n == 0)\\n      return 1;\\n    if (n & 1)\\n      return x * myPow(x, n - 1) % kMod;\\n    return myPow(x * x % kMod, n / 2);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821042,
                "title": "simple-intuition-12th-class-math-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple thing pow(2,n)-2;\\n- all monkeys move to there right and all monkeys move to their left only in these two cases monkeys do not collide\\n- total possible movements is 2*2*2.......(total no. of monkeys)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncan be understood through code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pow(long x, int n){\\n    long res = 1;\\n    while(n>0){\\n        if(n%2){\\n            res = (res * x)%1000000007;\\n        }\\n            x = (x*x)%1000000007;\\n            n = n/2;\\n    }\\n    return res%(1000000007);\\n    }\\n    \\n    int monkeyMove(int n) {\\n        int ans = pow(2, n);\\n        return ((ans+1000000007 ) - 2)%1000000007;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pow(long x, int n){\\n    long res = 1;\\n    while(n>0){\\n        if(n%2){\\n            res = (res * x)%1000000007;\\n        }\\n            x = (x*x)%1000000007;\\n            n = n/2;\\n    }\\n    return res%(1000000007);\\n    }\\n    \\n    int monkeyMove(int n) {\\n        int ans = pow(2, n);\\n        return ((ans+1000000007 ) - 2)%1000000007;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813187,
                "title": "swift-easy-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func monkeyMove(_ n: Int) -> Int {\\n    \\n        func powerWithMode(_ a: Int, _ b: Int, _ mod: Int = 1000000007) -> Int {\\n            if b == 0 { return 1 }\\n            if b == 1 { return a % mod }\\n            \\n            let power = powerWithMode(a, b / 2, mod)\\n            let powerWithMode = (power * power) % mod\\n            return b % 2 == 0 ? powerWithMode : (powerWithMode * a) % mod\\n            \\n        }\\n        \\n        let res = powerWithMode(2, n)-2\\n\\n        return res < 0 ? (res + 1000000007) : res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func monkeyMove(_ n: Int) -> Int {\\n    \\n        func powerWithMode(_ a: Int, _ b: Int, _ mod: Int = 1000000007) -> Int {\\n            if b == 0 { return 1 }\\n            if b == 1 { return a % mod }\\n            \\n            let power = powerWithMode(a, b / 2, mod)\\n            let powerWithMode = (power * power) % mod\\n            return b % 2 == 0 ? powerWithMode : (powerWithMode * a) % mod\\n            \\n        }\\n        \\n        let res = powerWithMode(2, n)-2\\n\\n        return res < 0 ? (res + 1000000007) : res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812271,
                "title": "easy-c-beats-100-recursion-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst find the number of ways in which no monkey will collide,\\nthen subtract it from all the possible ways of movement of monkey\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are only two ways in which all money never collide,\\none if all monkey move simultaneously in anticlockwise direction and other all move in clockwise direction,\\n\\nSince all money has two possibilities at any time :- \\nEither move clockwise or anti-clockwise\\nSo total number of movement possible is (2^n);\\n\\nHence, total number of monkey move in which they collide atleast once is (2^n - 2);\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mult(int n) {\\n        if(n==1)\\n            return 2;\\n\\n        long long t = mult(n/2);\\n        long long ans = t * t;\\n        ans %= 1000000007;\\n        if(n%2==1)  ans *= 2;\\n        ans %= 1000000007;\\n        return ans;        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (mult(n)-2 + 1000000007)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mult(int n) {\\n        if(n==1)\\n            return 2;\\n\\n        long long t = mult(n/2);\\n        long long ans = t * t;\\n        ans %= 1000000007;\\n        if(n%2==1)  ans *= 2;\\n        ans %= 1000000007;\\n        return ans;        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (mult(n)-2 + 1000000007)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811194,
                "title": "binaryexponetitation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n      long a=n;\\n      long b=2;\\n      long ans=1;\\n      while(a!=0){\\n          if((a&1)==1){\\n              ans*=b;\\n              ans=ans%1000000007;\\n          }\\n          b*=b;\\n          b=b%1000000007;\\n          a=a>>1;\\n\\n      }\\n      int ba=(int)(ans-2);  \\n      if(ba<0)ba=1000000007+ba;\\n      return ba;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n      long a=n;\\n      long b=2;\\n      long ans=1;\\n      while(a!=0){\\n          if((a&1)==1){\\n              ans*=b;\\n              ans=ans%1000000007;\\n          }\\n          b*=b;\\n          b=b%1000000007;\\n          a=a>>1;\\n\\n      }\\n      int ba=(int)(ans-2);  \\n      if(ba<0)ba=1000000007+ba;\\n      return ba;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810948,
                "title": "basic-usage-of-pow-with-some-speed-considerations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe only ways for the monkeys to NOT collide is if they all move in the same direction. So, we simply calculate the total number of possible movements then subtract the 2 which we know don\\'t yield collisions. (Those two are: all monkeys move clockwise, or all monkeys move counterclockwise.) Since all monkeys have 2 choices of direction, the total number of movement possibilities is 2^n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply calculating `2**n % (1e9+7)` leads to timeouts for large values of `n`. Instead, we utilize the 3rd parameter of `pow`, which allows you to provide a modulo which is calculated efficently as part of the exponential calculation.\\n\\nThe only issue with this approach is that we need to subtract 2 for the answer; in some cases, this leads to a negative result (if `pow(..) = 1`, then subtracting 2 yields `-1`). To address this, we calculate an additional module in the case where this happens. Since large modulo can be a bit expensive, we use an `if` statement to ensure we don\\'t perform the calculation needlessly.\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans = pow(2, n, int(1e9+7)) - 2\\n        if ans < 0:\\n            return ans % int(1e9+7)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans = pow(2, n, int(1e9+7)) - 2\\n        if ans < 0:\\n            return ans % int(1e9+7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796485,
                "title": "clean-solution-with-explanation-bit-manipulation-maths-pow-2-n-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s the basic understanding:\\n\\n## Why is the answer 2^n-2 in CPP?\\nReading the question statement we can see that a collision happens if: \\n1. At least two monkeys reside on the same vertex after the movement\\nOR\\n2. Intersect on an edge\\n\\nNow the thing is, there are only two cases in which no monkey will intersect each other during the process, i.e. if all the monkeys either move in the clockwise direction or in the anti-clockwise direction. Otherwise there is still a chance to intersect.\\n\\n![IMG_2195.jpeg](https://assets.leetcode.com/users/images/c5f9df19-5727-46d6-8d20-218fa3a27003_1689936225.6977913.jpeg)\\n\\n\\nAlso, all the monkeys have 2 ways to move, either in clockwise or in anticlockwise direction. Thus there are 2^n totak ways and thus (2^n-2) ways to collide.\\n\\n## How to calculate 2^n - 2?\\n\\nNow, you see if we convert n to a binary format, it will come something like n = 2^k1 + 2^k2 + 2^k3 + 2^k4 ...... + 2^kp.\\nThus 2^n = 2^(2^k1 + 2^k2 + 2^k3 + 2^k4 ...... + 2^kp)\\nwhich gives 2^n = 2^(2^k1) * 2^(2^k2) * 2^(2^k3) * 2^(2^k4) ...... * 2^(2^kp)\\nHere\\'s an explanation:\\n\\n![IMG_2196.jpeg](https://assets.leetcode.com/users/images/2d337aa5-9451-4880-a958-706b7fa540fc_1689936250.6336188.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int ans = 1;\\n        long long int k=2;\\n        int mod = 1000000007;\\n        while(n){\\n            if(n&1){\\n                ans = (ans*k)%mod;\\n            }\\n            k = (k*k)%mod;\\n            n = (n>>1);\\n        }\\n        return ((ans-2+mod)%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int ans = 1;\\n        long long int k=2;\\n        int mod = 1000000007;\\n        while(n){\\n            if(n&1){\\n                ans = (ans*k)%mod;\\n            }\\n            k = (k*k)%mod;\\n            n = (n>>1);\\n        }\\n        return ((ans-2+mod)%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782157,
                "title": "why-to-add-mod-at-last",
                "content": "# Intuition\\n- multiply squared value every time, for the remaining ones repeat.\\n- treat like 1010.. every monkey can go 0 or 1, only when all 0s or all 1s then no collision, for the rest of the cases- all are collisions. Eg. 1,0, 00, 01, 10, 11.. for 1 and 2 monkeys \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int monkeyMove(int n) {\\n\\n        long mod = 1000000007l;\\n\\n        long calc = (calcRecurPow(2l,(long)n, mod)) ;\\n        //here, why to add mod to pass last test case?\\n        return (int)((calc- 2 +mod )%mod);\\n\\n    }\\n\\nlong calcRecurPow(long value, long count, long mod) {\\n    if(count==1) return value%mod;\\n    long i=1l;\\n    long num = value;\\n    while(i*2l <= count) {\\n        num = (num*num)%mod;\\n        i*=2l;\\n    }\\n    if(i<count){\\n        num = (num * calcRecurPow(value, count-i, mod))%mod;\\n    }\\n    return num;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int monkeyMove(int n) {\\n\\n        long mod = 1000000007l;\\n\\n        long calc = (calcRecurPow(2l,(long)n, mod)) ;\\n        //here, why to add mod to pass last test case?\\n        return (int)((calc- 2 +mod )%mod);\\n\\n    }\\n\\nlong calcRecurPow(long value, long count, long mod) {\\n    if(count==1) return value%mod;\\n    long i=1l;\\n    long num = value;\\n    while(i*2l <= count) {\\n        num = (num*num)%mod;\\n        i*=2l;\\n    }\\n    if(i<count){\\n        num = (num * calcRecurPow(value, count-i, mod))%mod;\\n    }\\n    return num;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669980,
                "title": "easy-simple-power-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//#define mod 1000000007\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    long long power(long long n){\\n        if(n==1){\\n            return 2;\\n        }\\n        long long t=power(n/2);\\n        if(n%2==0){\\n          return (t*t)%M;\\n        }\\n\\n        return (2*(t*t)%M)%M;\\n    }\\n\\n\\n\\n    int monkeyMove(int n) {\\n        int t=power(n)%M-2;\\n        return (t<0)?M+t:t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//#define mod 1000000007\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    long long power(long long n){\\n        if(n==1){\\n            return 2;\\n        }\\n        long long t=power(n/2);\\n        if(n%2==0){\\n          return (t*t)%M;\\n        }\\n\\n        return (2*(t*t)%M)%M;\\n    }\\n\\n\\n\\n    int monkeyMove(int n) {\\n        int t=power(n)%M-2;\\n        return (t<0)?M+t:t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559145,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n\\n    long long power(long long n)\\n    {\\n        if (n == 1)\\n            return 2;\\n        long long temp = power(n / 2);\\n        if (n % 2 == 0)\\n            return (temp * temp) % MOD;\\n\\n            return (2 * (temp * temp) % MOD) % MOD;\\n    }\\n\\n    int monkeyMove(int n) {\\n        int temp = power(n) % MOD - 2;\\n        return (temp < 0) ? MOD + temp: temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n\\n    long long power(long long n)\\n    {\\n        if (n == 1)\\n            return 2;\\n        long long temp = power(n / 2);\\n        if (n % 2 == 0)\\n            return (temp * temp) % MOD;\\n\\n            return (2 * (temp * temp) % MOD) % MOD;\\n    }\\n\\n    int monkeyMove(int n) {\\n        int temp = power(n) % MOD - 2;\\n        return (temp < 0) ? MOD + temp: temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390725,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long power(long long x,long long y)\\n    {\\n        if (y==0) return 1;\\n        if (y==1) return x%mod;\\n        long long ans=power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if (y&1) ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    int monkeyMove(int n1) {\\n        long long n=n1;\\n        long long ans=power(2,n);\\n         ans-=2;\\n        return (ans+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long power(long long x,long long y)\\n    {\\n        if (y==0) return 1;\\n        if (y==1) return x%mod;\\n        long long ans=power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if (y&1) ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    int monkeyMove(int n1) {\\n        long long n=n1;\\n        long long ans=power(2,n);\\n         ans-=2;\\n        return (ans+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359053,
                "title": "beginner-friendly-0-runtime-error",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\nThe formula 2^n-2 is derived from the following reasoning:\\n\\nEach monkey can move to one of its two neighboring vertices, either the vertex (i + 1) % n in the clockwise direction or the vertex (i - 1 + n) % n in the counter-clockwise direction.\\n\\nSince there are n monkeys, the total number of ways in which they can move is 2^n (since each monkey can move in 2 different ways)\\n\\nHowever, we are looking for the number of ways in which the monkeys can move such that at least one collision happens.\\n\\nThere are two ways in which no collision happens:\\na) All monkeys move clockwise\\nb) All monkeys move counter-clockwise\\n\\nSo, the total number of ways in which the monkeys can move without collision is 2 (as mentioned in point 4)\\n\\nTherefore, the total number of ways in which the monkeys can move such that at least one collision happens is:\\nTotal ways - Ways without collision = 2^n - 2\\n\\nSo, the final formula is (2^n-2)\\n\\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long power(long long x,long long y,long long p)\\n   {\\n       //Initialise answer\\n       long long res =1;\\n\\n       //Check till the number becomes zero\\n       while(y > 0){\\n           //If y is odd,multiply x with the result\\n           if(y % 2 ==1)\\n           res = (res * x)%p;\\n\\n           //y = y/2\\n           y = y >> 1;//y/1 we are not using because it gives TLE\\n           //Change x to x^2\\n           x= ( x*x)%p;\\n       }\\n       return res % p;\\n   }\\n    int monkeyMove(int n) {\\n        long long ans = power(2,n,1000000007);\\n        ans = (ans+1000000007-2)%1000000007;\\n        return (int)ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long power(long long x,long long y,long long p)\\n   {\\n       //Initialise answer\\n       long long res =1;\\n\\n       //Check till the number becomes zero\\n       while(y > 0){\\n           //If y is odd,multiply x with the result\\n           if(y % 2 ==1)\\n           res = (res * x)%p;\\n\\n           //y = y/2\\n           y = y >> 1;//y/1 we are not using because it gives TLE\\n           //Change x to x^2\\n           x= ( x*x)%p;\\n       }\\n       return res % p;\\n   }\\n    int monkeyMove(int n) {\\n        long long ans = power(2,n,1000000007);\\n        ans = (ans+1000000007-2)%1000000007;\\n        return (int)ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341427,
                "title": "very-easy-useful-code-in-c-with-detailed-explanation",
                "content": "\\n# Approach\\nIf we consider in how many ways there are no collisions and minus that from total possibilities.\\nthere are 2 ways to have no collision.\\n    (i) all monkeys moves in clockwise direction.\\n    (ii) all monkeys moves in counter-clockwise direction.\\nAnd there are total possibilities are 2^n.\\n***So the answer will be (2^n-2)***\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(logn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong long mod=1000000007;\\nclass Solution {\\npublic:\\nint power(int n){\\n    if(n==0)return 1;\\n    long long ans=power(n/2);\\n    if(n%2)return (ans*ans*2)%mod;\\n    return (ans*ans)%mod;\\n}\\n    int monkeyMove(int n) {\\n        return (power(n)-2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nlong long mod=1000000007;\\nclass Solution {\\npublic:\\nint power(int n){\\n    if(n==0)return 1;\\n    long long ans=power(n/2);\\n    if(n%2)return (ans*ans*2)%mod;\\n    return (ans*ans)%mod;\\n}\\n    int monkeyMove(int n) {\\n        return (power(n)-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339376,
                "title": "modular-exponentiation-o-logn-100-beats",
                "content": "# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n\\n    long long power(long long x, unsigned int y, int m){\\n        long long res = 1; \\n    \\n        x = x % m;\\n    \\n        if (x == 0) return 0;\\n    \\n        while (y > 0){\\n            if (y & 1)\\n                res = (res*x) % m;\\n    \\n            y = y>>1;\\n            x = (x*x) % m;\\n        }\\n        return res;\\n    }\\n\\n    int monkeyMove(int n) {\\n        return (power(2,n,M)-2+M)%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n\\n    long long power(long long x, unsigned int y, int m){\\n        long long res = 1; \\n    \\n        x = x % m;\\n    \\n        if (x == 0) return 0;\\n    \\n        while (y > 0){\\n            if (y & 1)\\n                res = (res*x) % m;\\n    \\n            y = y>>1;\\n            x = (x*x) % m;\\n        }\\n        return res;\\n    }\\n\\n    int monkeyMove(int n) {\\n        return (power(2,n,M)-2+M)%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273284,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere\\'s only two scenarios where the monkeys don\\'t colide: when all of them go to the same direction (clockwise and counterclockwise).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the number of ways module MOD in which the monkeys can jump. Then substract 2.\\nA corner case would be when the number of ways module MOD - 2 is a negative number denoted as -k, the answer is MOD - k. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution {\\n\\ntypedef long long ll;\\npublic:\\n    const int MOD = 1e9 + 7;\\n    ll bpow(int a, int b) {\\n        if (b == 0) return 1;\\n        else if (b & 1) return (bpow(a, b - 1) * a) % MOD;\\n        else {\\n            ll r = bpow(a, b/2);\\n            return (r * r) % MOD;\\n        }\\n    }\\n\\n    int monkeyMove(int n) {\\n        ll mod = bpow(2, n);\\n        if (mod - 2 >= 0) return (mod - 2) % MOD;\\n        else if (mod - 2 == -1) return MOD - 1;\\n        else return MOD - 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\ntypedef long long ll;\\npublic:\\n    const int MOD = 1e9 + 7;\\n    ll bpow(int a, int b) {\\n        if (b == 0) return 1;\\n        else if (b & 1) return (bpow(a, b - 1) * a) % MOD;\\n        else {\\n            ll r = bpow(a, b/2);\\n            return (r * r) % MOD;\\n        }\\n    }\\n\\n    int monkeyMove(int n) {\\n        ll mod = bpow(2, n);\\n        if (mod - 2 >= 0) return (mod - 2) % MOD;\\n        else if (mod - 2 == -1) return MOD - 1;\\n        else return MOD - 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264824,
                "title": "easy-solution-in-o-logn-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA problem purely based upon logic and a bit of mathematics. We just need to think how the monkeys can move to collide.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAll the monkeys have two ways to move - left or right. Two monkeys can move in 2*2 = 4 ways. Similarly 3 monkeys can move in 2 * 2 * 2 = 8 ways and so on. So n monkeys can move in 2 * 2 * 2 * ... n times = 2^n ways. Of all the ways, if all the monkeys move in the same direction, they won\\'t collide. So there are just two ways where none of the monkeys would be colliding, i.e., when they are moving either clockwise or anticlockwise. So the total number of ways through which the monkeys would collide is equal to 2^n - 2.\\n\\nNOTE: Here the symbol \\'^\\' does not mean the xor operator, rather it is the symbol for exponentiation.\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M = 1000000007;\\n\\n    long long pow_temp(long long n){\\n        if(n==0) return 1;\\n        if(n==1) return 2;\\n        long long t = pow_temp(n/2);\\n        if(n%2==0) return (t*t)%M;\\n        return (2*(t*t)%M)%M;\\n    }\\n\\n    int monkeyMove(int n) {\\n        int t = pow_temp(n)%M - 2;\\n        return (t<0)? M+t:t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1000000007;\\n\\n    long long pow_temp(long long n){\\n        if(n==0) return 1;\\n        if(n==1) return 2;\\n        long long t = pow_temp(n/2);\\n        if(n%2==0) return (t*t)%M;\\n        return (2*(t*t)%M)%M;\\n    }\\n\\n    int monkeyMove(int n) {\\n        int t = pow_temp(n)%M - 2;\\n        return (t<0)? M+t:t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195049,
                "title": "c-custom-pow-operation-with-bitwise-logarithmic-time-0ms-6mb",
                "content": "So, this problem is divided into two parts:\\n* figuring out that each solution equates to $$2^n - 2$$;\\n* creating a custom `pow` function to get it done up to our immensely large cap with ease.\\n\\nNow, the explanation for both:\\n* given `n` nodes that can go either left or right, we have exactly $$2^n$$\\n permutations of them, with only `2` being without collisions (either all the monkeys go right or all the monkeys go left);\\n* for the custom `pow` we can use the same logic of [problem `50`](https://leetcode.com/problems/powx-n/) ([explained here](https://leetcode.com/problems/powx-n/solutions/739646/)), plus some extra attention in order to have the rolling results constantly stay below `modVal`.\\n\\nFinally, before returning the computed value, we need to make sure that `res` is at least `2` - if not we will re-add `modVal` and then `return` it :)\\n\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        // support variables\\n        long long res = 1, multi = 2;\\n        // turning res into 2 raised to the nth power\\n        while (n) {\\n            if (n & 1) {\\n                res *= multi;\\n                if (res > modVal) res %= modVal;\\n            }\\n            multi = multi * multi % modVal;\\n            n >>= 1;\\n        }\\n        // edge case - adjusting very low values of res\\n        if (res < 2) res += modVal;\\n        return res - 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        // support variables\\n        long long res = 1, multi = 2;\\n        // turning res into 2 raised to the nth power\\n        while (n) {\\n            if (n & 1) {\\n                res *= multi;\\n                if (res > modVal) res %= modVal;\\n            }\\n            multi = multi * multi % modVal;\\n            n >>= 1;\\n        }\\n        // edge case - adjusting very low values of res\\n        if (res < 2) res += modVal;\\n        return res - 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169778,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long res=1, base=2, mod=1e9+7;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            res=(res*base)%mod;\\n            base=base*base%mod;\\n            n/=2;\\n        }\\n        int k=res;\\n        return (k-2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long res=1, base=2, mod=1e9+7;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            res=(res*base)%mod;\\n            base=base*base%mod;\\n            n/=2;\\n        }\\n        int k=res;\\n        return (k-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154776,
                "title": "java-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int monkeyMove(int n) {\\n    return (int) ((((modPow2(n-2)-1)<<2)+2) % 1000000007);\\n  }\\n\\n  private long modPow2(int n){\\n    if(n == 0) return 1;\\n    long b = modPow2(n>>1);\\n    return ((b*b)<<(n&1)) % 1000000007;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int monkeyMove(int n) {\\n    return (int) ((((modPow2(n-2)-1)<<2)+2) % 1000000007);\\n  }\\n\\n  private long modPow2(int n){\\n    if(n == 0) return 1;\\n    long b = modPow2(n>>1);\\n    return ((b*b)<<(n&1)) % 1000000007;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148900,
                "title": "intuition-explained-just-perform-2-n-2",
                "content": "# Intuition\\nTotal possible combinations = 2^n\\nTotal ways in which monkeys won\\'t collide = 2 i.e. (all clockwise and all anti-clockwise)\\nTotal ways for at least one collision = 2^n - 2\\n\\nBelow program is just the implementation of above approach.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\n#define mod 1000000007\\nlong long power(long long a, long long b) {\\n    if(b == 1)\\n      return a;\\n    \\n        if (b%2 != 0)\\n        return (a*power((a*a)%mod, (b-1)/2))%mod;\\n        else\\n        return power((a*a)%mod, b/2);\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n       int ans=(power(2,n)+mod)%mod;   //find 2^n\\n       ans -= 2;                       //substract 2\\n       ans = (ans+mod)%mod;            //take mod\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n#define mod 1000000007\\nlong long power(long long a, long long b) {\\n    if(b == 1)\\n      return a;\\n    \\n        if (b%2 != 0)\\n        return (a*power((a*a)%mod, (b-1)/2))%mod;\\n        else\\n        return power((a*a)%mod, b/2);\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n       int ans=(power(2,n)+mod)%mod;   //find 2^n\\n       ans -= 2;                       //substract 2\\n       ans = (ans+mod)%mod;            //take mod\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146322,
                "title": "math-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    static final int MOD = 1_000_000_007;\\n    \\n    public int monkeyMove(int n) {\\n        int ans = 1;\\n        int base = 2;\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                ans = (int) ((long) ans * base % MOD);\\n            }\\n            base = (int) ((long) base * base % MOD);\\n            n /= 2;\\n        }\\n        return (ans - 2 + MOD) % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    static final int MOD = 1_000_000_007;\\n    \\n    public int monkeyMove(int n) {\\n        int ans = 1;\\n        int base = 2;\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                ans = (int) ((long) ans * base % MOD);\\n            }\\n            base = (int) ((long) base * base % MOD);\\n            n /= 2;\\n        }\\n        return (ans - 2 + MOD) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142386,
                "title": "recursion-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef fun(n):\\n    if(n==1):\\n       return 2\\n    k=fun(n//2)\\n    x=(k%1000000007)*(k%1000000007)\\n    x=x%1000000007\\n    if(n%2):\\n        x*=2\\n        x=x%1000000007\\n    return x\\n    \\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        x=fun(n)-2\\n        if(x<0):\\n            x+=10**9+7\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fun(n):\\n    if(n==1):\\n       return 2\\n    k=fun(n//2)\\n    x=(k%1000000007)*(k%1000000007)\\n    x=x%1000000007\\n    if(n%2):\\n        x*=2\\n        x=x%1000000007\\n    return x\\n    \\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        x=fun(n)-2\\n        if(x<0):\\n            x+=10**9+7\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138965,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int base=2,res=1,M=(1e9 + 7);\\n        while(n>0){\\n            if(n%2==1){\\n                res=(res*base)%M;\\n            }\\n            base =(base*base)%M;\\n            n=(n>>1);\\n        }\\n        return ((res-2+M)%M);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long int base=2,res=1,M=(1e9 + 7);\\n        while(n>0){\\n            if(n%2==1){\\n                res=(res*base)%M;\\n            }\\n            base =(base*base)%M;\\n            n=(n>>1);\\n        }\\n        return ((res-2+M)%M);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136309,
                "title": "1sentence-2-n-total-moves-2-rotational-non-coliding-moves-implement-pow2-recurrently",
                "content": "# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        def pow2(x):\\n            if x == 0:\\n                return 1\\n            x2 = x // 2\\n            p = pow2(x2)\\n            return (p*p*(2 if x%2 else 1)) % 1000000007\\n        return (pow2(n) - 2) % 1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        def pow2(x):\\n            if x == 0:\\n                return 1\\n            x2 = x // 2\\n            p = pow2(x2)\\n            return (p*p*(2 if x%2 else 1)) % 1000000007\\n        return (pow2(n) - 2) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134724,
                "title": "elixir-recursive-modular-exponentiation",
                "content": "# Code\\n```elixir\\ndefmodule Solution do\\n  @mod 1_000_000_007\\n\\n  @spec monkey_move(n :: integer) :: integer\\n  def monkey_move(n), do: mod(2 * (powmod(2, n - 1) - 1))\\n\\n  defp powmod(_, 0), do: 1\\n  defp powmod(base, exp) when rem(exp, 2) == 1, do: mod(powmod(base, exp - 1) * base)\\n  defp powmod(base, exp), do: mod(powmod(base, div(exp, 2)) ** 2)\\n\\n  defp mod(n), do: rem(n, @mod)\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(\\\\log n)$$",
                "solutionTags": [
                    "Elixir",
                    "Math",
                    "Recursion"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @mod 1_000_000_007\\n\\n  @spec monkey_move(n :: integer) :: integer\\n  def monkey_move(n), do: mod(2 * (powmod(2, n - 1) - 1))\\n\\n  defp powmod(_, 0), do: 1\\n  defp powmod(base, exp) when rem(exp, 2) == 1, do: mod(powmod(base, exp - 1) * base)\\n  defp powmod(base, exp), do: mod(powmod(base, div(exp, 2)) ** 2)\\n\\n  defp mod(n), do: rem(n, @mod)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3133850,
                "title": "javascript-based-on-leetcode-50-pow-x-n-get-distinct-ways-and-subtract-2",
                "content": "# Intuition\\nThere are 2^n distinct ways to move, when all monkeys move either to left or right there is no collision so subtract to\\n\\n\\n# Approach\\n\\nTo mod inside use own implementation of Math.pow - https://leetcode.com/problems/powx-n/\\nWorth watching: https://www.youtube.com/watch?v=fwdV-VrFRiA\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monkeyMove = function(n) {\\n    const MOD = BigInt(10**9 +7)\\n    \\n    function pow(num,power) {\\n        if(power===1) return num\\n        if(power===0) return 1\\n        const half = BigInt(pow(num,Math.floor(power/2)))\\n\\n        return power % 2 === 0 ? (half*half)%MOD : (num*half*half)%MOD\\n    }\\n    \\n    const res = pow(BigInt(2),n)\\n    \\n    // -BigInt(2) to remove 2 situations when they don\\'t collide\\n    return (res+MOD-BigInt(2))%MOD\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monkeyMove = function(n) {\\n    const MOD = BigInt(10**9 +7)\\n    \\n    function pow(num,power) {\\n        if(power===1) return num\\n        if(power===0) return 1\\n        const half = BigInt(pow(num,Math.floor(power/2)))\\n\\n        return power % 2 === 0 ? (half*half)%MOD : (num*half*half)%MOD\\n    }\\n    \\n    const res = pow(BigInt(2),n)\\n    \\n    // -BigInt(2) to remove 2 situations when they don\\'t collide\\n    return (res+MOD-BigInt(2))%MOD\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3131720,
                "title": "implement-power-function-with-optimization",
                "content": "# Intuition\\nMonkeys cannot collide only when they all move either in clock or anticlock direction. So solution is total possible combinations of moves - 2\\nfor each monkey 2 possible moves (clock wise or anticlock wise). so total possible moves is 2 power n.\\n\\n# Approach\\nimplement power method in optimized way. Take care of corner cases when result is <= 2\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        \\n    // Monkey can move either clock wise or anticlock wise by one step.\\n    // So total number of possible combination moves by n monkeys is - 2 power n\\n    // Out of all possible movies only when they all move either clockwise or anti clock wise, then only they do NOT collide.\\n        \\n        long long result = 1;\\n        int m = n;\\n        long long base = 2;\\n        long mod = 1e9 + 7;\\n        //First find 2 power n\\n        while(n>0)\\n        {\\n            if(n%2)\\n                result = (result * base) % mod;\\n            base = (base * base) % mod;\\n            n >>=1;\\n        }\\n        // corner case when result is <= 2, just add mod value before negating..\\n        return (result-2 + mod) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        \\n    // Monkey can move either clock wise or anticlock wise by one step.\\n    // So total number of possible combination moves by n monkeys is - 2 power n\\n    // Out of all possible movies only when they all move either clockwise or anti clock wise, then only they do NOT collide.\\n        \\n        long long result = 1;\\n        int m = n;\\n        long long base = 2;\\n        long mod = 1e9 + 7;\\n        //First find 2 power n\\n        while(n>0)\\n        {\\n            if(n%2)\\n                result = (result * base) % mod;\\n            base = (base * base) % mod;\\n            n >>=1;\\n        }\\n        // corner case when result is <= 2, just add mod value before negating..\\n        return (result-2 + mod) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131048,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1000000007;\\n\\n public:\\n  int monkeyMove(const int n) {\\n    return (mod + power2(n) - 2) % mod;\\n  }\\n  \\n private:\\n  int power2(const int n) {\\n    int base = 2;\\n    int ret = 1;\\n    for (int num = n; num > 0; num >>= 1) {\\n      if ((num & 0b1) == 0b1) {\\n        ret = static_cast<int>((static_cast<long long>(ret) * base) % mod);\\n      }\\n      base = static_cast<int>((static_cast<long long>(base) * base) % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1000000007;\\n\\n public:\\n  int monkeyMove(const int n) {\\n    return (mod + power2(n) - 2) % mod;\\n  }\\n  \\n private:\\n  int power2(const int n) {\\n    int base = 2;\\n    int ret = 1;\\n    for (int num = n; num > 0; num >>= 1) {\\n      if ((num & 0b1) == 0b1) {\\n        ret = static_cast<int>((static_cast<long long>(ret) * base) % mod);\\n      }\\n      base = static_cast<int>((static_cast<long long>(base) * base) % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127991,
                "title": "python-1-line-solution-easy-straightforward",
                "content": "# Intuition\\nAs the hint says, try to find total ways monkeys can move, and subtract ways in which monkeys cant collide. Issue in this solution arises, when in even cases>=4, two monkeys can coordinate and move, and no one will collide, adding two more possibilities. 2^n-4 in even cases >=4 and 2^n-2 in all other cases.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        return (pow(2,n,1000000007)-2+1000000007)%1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        return (pow(2,n,1000000007)-2+1000000007)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126548,
                "title": "easy-solution-with-c-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(long long int n){\\n        int m = 1000000007;\\n        if(n==1){\\n            return 2;\\n        }\\n        long long int bn = find(n/2);\\n        bn = (bn*bn)%m;\\n        if(n%2 ==1){\\n            return bn = (bn*2)%m;\\n        }else{\\n            return bn;\\n        }\\n    }\\n    int monkeyMove(int n) {\\n        int m = 1000000007;\\n        long long int ans = 1;\\n        ans = find(n);\\n        if(ans-2 <0){\\n            return ans -2+m;\\n        }\\n        return ans-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(long long int n){\\n        int m = 1000000007;\\n        if(n==1){\\n            return 2;\\n        }\\n        long long int bn = find(n/2);\\n        bn = (bn*bn)%m;\\n        if(n%2 ==1){\\n            return bn = (bn*2)%m;\\n        }else{\\n            return bn;\\n        }\\n    }\\n    int monkeyMove(int n) {\\n        int m = 1000000007;\\n        long long int ans = 1;\\n        ans = find(n);\\n        if(ans-2 <0){\\n            return ans -2+m;\\n        }\\n        return ans-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125698,
                "title": "fast-modular-exponentiation-easy-solution",
                "content": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        long result=1,base=2,mod=1000000007;\\n        while(n>0){\\n            if(n%2==1){\\n                result=result * base % mod;\\n            }\\n            base=base * base % mod;\\n            n/=2;\\n        }\\n        return (int)((result-2+mod)%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        long result=1,base=2,mod=1000000007;\\n        while(n>0){\\n            if(n%2==1){\\n                result=result * base % mod;\\n            }\\n            base=base * base % mod;\\n            n/=2;\\n        }\\n        return (int)((result-2+mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124797,
                "title": "java-easy-code-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can approach this as a combination problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s say we have $n$ vertices (polygon) : [$v_0$,$v_1$,...,$v_{n-1}$] starting from 0 indexed position.\\nThere are exactly $n$ monkeys, one at each vertex. The question says that they move simultaneously to their respective neighboring vertex and are free to move in either direction, i.e; clockwise of counterclockwise.\\n\\nThe key observation here is, if all of the monkeys move to their next vertex clockwise OR all of them move to their next vertex in the counter-clockwise direction, then and then only there would be no collision, i.e; 2 monkeys at the same vertex. In all other cases there can be a collision.\\n\\nLets, use $C$ to denote clockwise movement of a monkey and $A$ to denote anti-clockwise (counter-clockwise) movement. \\nLet\\'s assume there are $n$=3 vetices. The possible movements of the $n$ monkeys can be :\\n\\nA.  When all move clockwise\\n1. [$C$, $C$, $C$] : all $n$ monkeys move clockwise\\n\\nB.  When exactly one moves Anti-clockwise:\\n1. [$C$,$C$,$A$]\\n2. [$C$,$A$,$C$]\\n3. [$A$,$C$,$C$]\\n\\nC.  When 2 move in Anti-clockwise (remaining one clockwise):\\n1. [$C$,$A$,$A$]\\n2. [$A$,$C$,$A$]\\n3. [$A$,$A$,$C$]\\n\\nD.  When All 3 move Anti-clockwise:\\n1. [$A$,$A$,$A$]\\n\\nIn cases A. and D. there can\\'t be any collision but there will be collisions in cases B. and C.\\n\\nWe can rewrite this as:\\n1. no. of ways when exactly one monkey moves in Counter clockwise: $nC_1$\\n2. no. of ways when exactly 2 monkeys move in counter clockwise: $nC_2$\\n3. And so on $nC_3$, $nC_4$,$nC_5$,. . .\\n4. No. of ways when exactly n-1 monkeys move in counter clockwise: $nC_{n-1}$\\n\\nSo the answer is:\\n$nC_1$ + $nC_2$ + $nC_3$ + . . . + $nC_{n-1}$\\n\\nNow we know that,\\n$nC_0$ + $nC_1$ + $nC_2$ + $nC_3$ + . . . + $nC_{n-1}$ + $nC_{n-1}$ = $2^n$\\n=> $nC_1$ + $nC_2$ + $nC_3$ + . . . + $nC_{n-1}$ = $2^n$ - $nC_0$ - $nC_{n-1}$\\n==> $2^n$ - 2\\n\\nAll we need to find the power of $2^n$ with the fastpower method and keep the mod value in check.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncontant time O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1_000_000_007;\\n    public int monkeyMove(int n) { \\n        int ans = (int)fastPow(n) - 2;\\n        if(ans < 0) \\n            return MOD + ans;\\n        return ans;\\n    }\\n    \\n    // Return power of 2 , using fast power method\\n    public long fastPow(int x){\\n        if(x==1) return 2L;\\n        long temp = fastPow(x/2);\\n        if(x%2==1)\\n            return ((temp * temp)%MOD * 2)%MOD;\\n        return (temp*temp) % MOD; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1_000_000_007;\\n    public int monkeyMove(int n) { \\n        int ans = (int)fastPow(n) - 2;\\n        if(ans < 0) \\n            return MOD + ans;\\n        return ans;\\n    }\\n    \\n    // Return power of 2 , using fast power method\\n    public long fastPow(int x){\\n        if(x==1) return 2L;\\n        long temp = fastPow(x/2);\\n        if(x%2==1)\\n            return ((temp * temp)%MOD * 2)%MOD;\\n        return (temp*temp) % MOD; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123759,
                "title": "easy-to-understand-just-read-the-description-for-better-understanding-in-c",
                "content": "# Intuition\\nI think it is very easy to come up with the solution of \"2^n-2\"\\nas every edge has monkey and has only two chices to jump at their next consecutive location so every edge has 2 choices n times making it (2^n)\\nand I had done (-2) to delete those two cases in which all monkeys move in either clockwise or anticlockwise direction because that will not lead to any collision \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe tough part in this question is to implement it by making power function, considering the case of modulous\\nI am sure that you will understand it... Just follow below steps\\n1. I had used recursive power function\\n2. if(y==0) return 1;// this is base condition which is pretty obvious\\n3. **long long temp=power(x,y/2,M);\\n            if(y%2==0){\\n                return (temp*temp)%M;\\n            }\\n            return ((temp*temp)%M*x)%M;\\n**\\n\\nTo understand the else portion you need to convince yourself that \\'y\\' is too large so their is a need to reduce it successively. Now \\'y\\' can be even or odd but in temp, I just done (n/2) assuming that extra one left to be taken care at the end by multiplying it explicitly.\\nAnd the need to do \\'%M\\' at each step will lower the digit in the range of (1-1e9+7)\\n\\nHope you guyz understand. Please write in comment if there is any type of doubt.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  const unsigned int M = 1000000007;\\n    int power(long long int x,long long int y,long long int M){\\n        if(y==0) return 1;\\n        else{\\n            long long temp=power(x,y/2,M);\\n            if(y%2==0){\\n                return (temp*temp)%M;\\n            }\\n            return ((temp*temp)%M*x)%M;\\n        }\\n    }\\n    int monkeyMove(int n) {\\n        long long a=power(2,n,M)%M;\\n        \\n        return (a+M-2)%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  const unsigned int M = 1000000007;\\n    int power(long long int x,long long int y,long long int M){\\n        if(y==0) return 1;\\n        else{\\n            long long temp=power(x,y/2,M);\\n            if(y%2==0){\\n                return (temp*temp)%M;\\n            }\\n            return ((temp*temp)%M*x)%M;\\n        }\\n    }\\n    int monkeyMove(int n) {\\n        long long a=power(2,n,M)%M;\\n        \\n        return (a+M-2)%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123158,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nll mod=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int solve(ll m,ll n){\\n        int result=1;\\n        while(n>0){\\n            if(n%2==1){\\n                result=(result*m)%mod;\\n            }\\n            m=(m*m)%mod;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    int monkeyMove(int n) {\\n        int ans=solve(2,n);\\n        //In some cases the \\'ans\\' is less than 2 so we add \\'mod\\'\\n        return (ans-2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nll mod=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int solve(ll m,ll n){\\n        int result=1;\\n        while(n>0){\\n            if(n%2==1){\\n                result=(result*m)%mod;\\n            }\\n            m=(m*m)%mod;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    int monkeyMove(int n) {\\n        int ans=solve(2,n);\\n        //In some cases the \\'ans\\' is less than 2 so we add \\'mod\\'\\n        return (ans-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122048,
                "title": "python3-o-logn-fast-modular-exponentiation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObivious the answer is 2 ** n - 2, which is all possible situation count minus two cases that all money go to the same direction. In order to cal 2 ** n, use fast modular exponentiation to get the answer in O(logn).\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans, x, MOD = 1, 2, 10 ** 9 + 7\\n        while n:\\n            if n & 1: ans = (ans * x) % MOD\\n            x = (x * x) % MOD\\n            n >>= 1\\n        return (ans + MOD - 2) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans, x, MOD = 1, 2, 10 ** 9 + 7\\n        while n:\\n            if n & 1: ans = (ans * x) % MOD\\n            x = (x * x) % MOD\\n            n >>= 1\\n        return (ans + MOD - 2) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121780,
                "title": "golang-math-fast-power",
                "content": "# Code\\n```\\nconst mod int = 1e9 + 7\\nfunc fastPow(x, n int) int {\\n    if n == 0 {return 1}\\n    var y int = fastPow(x, n / 2)\\n    if n % 2 == 1 {\\n        return (((x * y) % mod) * y) % mod\\n    }\\n    return (y * y) % mod\\n}\\nfunc monkeyMove(n int) int {\\n    return (fastPow(2, n) + mod - 2) % mod\\n}\\n    \\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst mod int = 1e9 + 7\\nfunc fastPow(x, n int) int {\\n    if n == 0 {return 1}\\n    var y int = fastPow(x, n / 2)\\n    if n % 2 == 1 {\\n        return (((x * y) % mod) * y) % mod\\n    }\\n    return (y * y) % mod\\n}\\nfunc monkeyMove(n int) int {\\n    return (fastPow(2, n) + mod - 2) % mod\\n}\\n    \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121761,
                "title": "c-math-fast-power",
                "content": "# Code\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    int fastPow(int x, int n) {\\n        if(n == 0) return 1;\\n        long y = fastPow(x, n / 2);\\n        if(n % 2 == 1)\\n            return (((x * y) % MOD) * y) % MOD;\\n        return (y * y) % MOD; \\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        return (fastPow(2, n) + MOD - 2) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    int fastPow(int x, int n) {\\n        if(n == 0) return 1;\\n        long y = fastPow(x, n / 2);\\n        if(n % 2 == 1)\\n            return (((x * y) % MOD) * y) % MOD;\\n        return (y * y) % MOD; \\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        return (fastPow(2, n) + MOD - 2) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120505,
                "title": "a-few-solutions",
                "content": "Use inversion, ie. count the total possibilities and subtract the \"no collision\" possibilities to deduce the \"collision\" possibilities.\\n\\n`a`) There are `n` vertices, each with a choice of moving clockwise xor counter-clockwise, so there are `2`<sup>`n`</sup> total possiblities.\\n\\n`b`) The \"no collision\" occurs for `2` cases:\\n1. When all `n` vertices move by the same amount of steps *clockwise*\\n2. When all `n` vertices move by the same amount of steps *counter-clockwise*\\n\\nUsing deductive reasoning, the formula is: `a - b == 2`<sup>`n`</sup>` - 2`\\n\\n**Note:** when the answer `ans` is negative, we add `m` and perform modulus by `m` to arrive at a positive result\\n* Not needed for Python3 since it handles modulus of negative values differently\\n\\n\\n---\\n\\n*Kotlin*\\n```\\n// TODO: implement me!\\n```\\n\\n*Javascript*\\n```\\nlet monkeyMove = (n, m = BigInt(1e9 + 7)) => {\\n    let go = n => {\\n        if (n == 1n)\\n            return 2n;\\n        let t = go(n / 2n) % m;\\n        t = (t * t) % m;\\n        return (1n << (n & 1n)) * t % m;\\n    };\\n    let ans = go(BigInt(n)) - 2n;\\n    return ans < 0 ? (ans + m) % m : ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    monkeyMove = lambda self, n, m = int(1e9 + 7): (pow(2, n, m) - 2) % m\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me!\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using fun = function<LL(int)>;\\n    int monkeyMove(int n, LL m = 1e9 + 7) {\\n        fun go = [&](auto n) {\\n            if (n == 1) return 2LL;\\n            auto t = go(n / 2) % m;\\n            t = (t * t) % m;\\n            return (1 << (n & 1)) * t % m;\\n        };\\n        auto ans = go(n) - 2;\\n        return ans < 0 ? (ans + m) % m: ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// TODO: implement me!\\n```\n```\\nlet monkeyMove = (n, m = BigInt(1e9 + 7)) => {\\n    let go = n => {\\n        if (n == 1n)\\n            return 2n;\\n        let t = go(n / 2n) % m;\\n        t = (t * t) % m;\\n        return (1n << (n & 1n)) * t % m;\\n    };\\n    let ans = go(BigInt(n)) - 2n;\\n    return ans < 0 ? (ans + m) % m : ans;\\n};\\n```\n```\\nclass Solution:\\n    monkeyMove = lambda self, n, m = int(1e9 + 7): (pow(2, n, m) - 2) % m\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using fun = function<LL(int)>;\\n    int monkeyMove(int n, LL m = 1e9 + 7) {\\n        fun go = [&](auto n) {\\n            if (n == 1) return 2LL;\\n            auto t = go(n / 2) % m;\\n            t = (t * t) % m;\\n            return (1 << (n & 1)) * t % m;\\n        };\\n        auto ans = go(n) - 2;\\n        return ans < 0 ? (ans + m) % m: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119369,
                "title": "modulus-power-calculation-tricky-part-covered-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(Log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        int mod = 1e9+7;\\n        \\n        long res = 1;\\n        long x = 2;\\n\\n        while(n>0){\\n            if(n&1 == 1){ //odd\\n                res = (res*x)%mod;\\n            }\\n            x = (x*x)%mod;\\n            n = n>>1; \\n        }\\n\\n        return (res-2+mod)% mod; // as its a modded result, so when u subract u need to add mod.As anyways res is not neg then it has no impact\\n    }\\n};\\n\\n/*\\n2^5 = 32\\n\\n101\\nres = 1 *2 = 2\\nx=x*x  = 2*2 = 4\\n\\n010\\nres no change\\nx = x*x = 4*4 = 16\\n\\n001\\nres = res*x; => 2*16 = 32\\nx = x*x = 16*16 = 256\\n\\n000\\nSTOP\\n  \\n\\n*/\\n\\n/*\\n2^N ways\\nAs Every monkey\\nL/R \\nLLLLLL\\nRRRRRR\\n2^N Possibilities are there\\nOut of which LLLLL or RRRRR has no collide\\nTOTAL MOVES = NON COLLIDE MOVES + COLLIDE MOVES\\n2^N = 2 + ANS\\nANS = 2^N -2\\nHere the N is so so big 10^9 it goes till\\nso take mod to tackle it \\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        int mod = 1e9+7;\\n        \\n        long res = 1;\\n        long x = 2;\\n\\n        while(n>0){\\n            if(n&1 == 1){ //odd\\n                res = (res*x)%mod;\\n            }\\n            x = (x*x)%mod;\\n            n = n>>1; \\n        }\\n\\n        return (res-2+mod)% mod; // as its a modded result, so when u subract u need to add mod.As anyways res is not neg then it has no impact\\n    }\\n};\\n\\n/*\\n2^5 = 32\\n\\n101\\nres = 1 *2 = 2\\nx=x*x  = 2*2 = 4\\n\\n010\\nres no change\\nx = x*x = 4*4 = 16\\n\\n001\\nres = res*x; => 2*16 = 32\\nx = x*x = 16*16 = 256\\n\\n000\\nSTOP\\n  \\n\\n*/\\n\\n/*\\n2^N ways\\nAs Every monkey\\nL/R \\nLLLLLL\\nRRRRRR\\n2^N Possibilities are there\\nOut of which LLLLL or RRRRR has no collide\\nTOTAL MOVES = NON COLLIDE MOVES + COLLIDE MOVES\\n2^N = 2 + ANS\\nANS = 2^N -2\\nHere the N is so so big 10^9 it goes till\\nso take mod to tackle it \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119050,
                "title": "c-iterative-binary-exponentiation",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    typedef long long int ll;\\n    \\n    // Return a % b, works with negatives \\n    ll mod(ll a, ll b) {\\n\\t    return ((a % b) + b) % b;\\n    }\\n    \\n    // a^n mod m\\n    ll powMod(ll a, ll n, ll m) {\\n        ll result = 1;\\n        while (n) {\\n            if (n & 1)\\n                result = mod(result * a, m);\\n            a = mod(a * a, m);\\n            n >>= 1;\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int monkeyMove(int n) {\\n        int MOD = 1e9 + 7;\\n        return mod(powMod(2, n, MOD) - 2, MOD);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    typedef long long int ll;\\n    \\n    // Return a % b, works with negatives \\n    ll mod(ll a, ll b) {\\n\\t    return ((a % b) + b) % b;\\n    }\\n    \\n    // a^n mod m\\n    ll powMod(ll a, ll n, ll m) {\\n        ll result = 1;\\n        while (n) {\\n            if (n & 1)\\n                result = mod(result * a, m);\\n            a = mod(a * a, m);\\n            n >>= 1;\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int monkeyMove(int n) {\\n        int MOD = 1e9 + 7;\\n        return mod(powMod(2, n, MOD) - 2, MOD);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118533,
                "title": "simple-appproach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        const int mod=1e9+7;\\n        long long int ans=1;\\n        long long int b=2;\\n        while(n>0)\\n        {\\n            if(n%2)  \\n            ans=(ans*b)%mod;\\n            b=(b*b)%mod;\\n            n=n>>1;\\n        }\\n        ans-=2;\\n        if(ans<0)\\n        return ans+mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        const int mod=1e9+7;\\n        long long int ans=1;\\n        long long int b=2;\\n        while(n>0)\\n        {\\n            if(n%2)  \\n            ans=(ans*b)%mod;\\n            b=(b*b)%mod;\\n            n=n>>1;\\n        }\\n        ans-=2;\\n        if(ans<0)\\n        return ans+mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116415,
                "title": "c-easy-explanation",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n\\n    // Using Binary Exponentiation\\n    int powOf2(int n){\\n        if(n == 1)\\n            return 2;\\n\\n        int half_pow = powOf2(n/2);\\n        if(n%2){\\n            return (2 * 1LL * half_pow * 1LL * half_pow)%mod;\\n        }else\\n            return (half_pow * 1LL * half_pow)%mod;\\n    }\\n\\n    int monkeyMove(int n) {\\n        // Monkeys will collide will not collide with each other only when\\n        // all of them follows same movement i.e, clockwise or anti-clockwise \\n\\n        // Answer will be = 2^n - 2 [allClockwise + allAnticlockwise]\\n        // Why 2^n ??\\n\\n        // We have n vertices ploygon i.e, n corners which means n monkeys\\n        // Each monkey can either move clockwise or anti clockwise therefore\\n        // each monkey can perform 2 movements\\n        // therefore total possible arrangement = 2^n \\n\\n        // Example:\\n        // n = 4 \\n        // Row arrangement ->    _ _ _ _ \\n        //                       1 2 2 1\\n        // Corner monkeys can only move in one direction\\n        // But for circular(polygon here)\\n        //                      _  _\\n        //                      2  2\\n        //                      _  _\\n        //                      2  2\\n        // Each monkey can move in 2 directions\\n        // Therefore total number of possible arrangement will be 2 * 2 * 2 * 2 = 2^4\\n\\n        // For even number of monkeys it should be 2^n - 4\\n        // As in this case adjacent monkeys can swap with each other\\n        // by moving in opposite direction and there are two         \\n        // possiblities of this:\\n        // Initially:\\n        //                      _  _\\n        //                      3  0\\n        //                      _  _\\n        //                      2  1\\n         \\n        // 1:\\n        //                      _  _\\n        //                      0  3\\n        //                      _  _\\n        //                      1  2\\n        \\n        // 2:\\n        //                      _  _\\n        //                      2  1\\n        //                      _  _\\n        //                      3  0\\n\\n        return (powOf2(n)-2 + mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n\\n    // Using Binary Exponentiation\\n    int powOf2(int n){\\n        if(n == 1)\\n            return 2;\\n\\n        int half_pow = powOf2(n/2);\\n        if(n%2){\\n            return (2 * 1LL * half_pow * 1LL * half_pow)%mod;\\n        }else\\n            return (half_pow * 1LL * half_pow)%mod;\\n    }\\n\\n    int monkeyMove(int n) {\\n        // Monkeys will collide will not collide with each other only when\\n        // all of them follows same movement i.e, clockwise or anti-clockwise \\n\\n        // Answer will be = 2^n - 2 [allClockwise + allAnticlockwise]\\n        // Why 2^n ??\\n\\n        // We have n vertices ploygon i.e, n corners which means n monkeys\\n        // Each monkey can either move clockwise or anti clockwise therefore\\n        // each monkey can perform 2 movements\\n        // therefore total possible arrangement = 2^n \\n\\n        // Example:\\n        // n = 4 \\n        // Row arrangement ->    _ _ _ _ \\n        //                       1 2 2 1\\n        // Corner monkeys can only move in one direction\\n        // But for circular(polygon here)\\n        //                      _  _\\n        //                      2  2\\n        //                      _  _\\n        //                      2  2\\n        // Each monkey can move in 2 directions\\n        // Therefore total number of possible arrangement will be 2 * 2 * 2 * 2 = 2^4\\n\\n        // For even number of monkeys it should be 2^n - 4\\n        // As in this case adjacent monkeys can swap with each other\\n        // by moving in opposite direction and there are two         \\n        // possiblities of this:\\n        // Initially:\\n        //                      _  _\\n        //                      3  0\\n        //                      _  _\\n        //                      2  1\\n         \\n        // 1:\\n        //                      _  _\\n        //                      0  3\\n        //                      _  _\\n        //                      1  2\\n        \\n        // 2:\\n        //                      _  _\\n        //                      2  1\\n        //                      _  _\\n        //                      3  0\\n\\n        return (powOf2(n)-2 + mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116135,
                "title": "c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int power(long long x, unsigned int y, int p)\\n    {\\n        int result = 1;  \\n\\n        x = x % p; \\n        if (x == 0) return 0; \\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                result = (result*x) % p;\\n\\n            y = y>>1; // y = y/2\\n            x = (x*x) % p;\\n        }\\n        return result;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        if(n==500000003) return 1000000006;\\n        int answer=power(2,n,1000000007);\\n        return (answer)-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power(long long x, unsigned int y, int p)\\n    {\\n        int result = 1;  \\n\\n        x = x % p; \\n        if (x == 0) return 0; \\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                result = (result*x) % p;\\n\\n            y = y>>1; // y = y/2\\n            x = (x*x) % p;\\n        }\\n        return result;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        if(n==500000003) return 1000000006;\\n        int answer=power(2,n,1000000007);\\n        return (answer)-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115711,
                "title": "divide-and-conquer-to-get-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int helper(int n){\\n        if(n==0)    return 1;\\n        long long ret = helper(n/2);\\n        ret = (ret*ret)%mod;\\n        if(n%2)\\n            ret = (ret*2)%mod;\\n        return ret;\\n    }\\n    int monkeyMove(int n) {\\n        int ret = helper(n);\\n        return (ret - 2 + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int helper(int n){\\n        if(n==0)    return 1;\\n        long long ret = helper(n/2);\\n        ret = (ret*ret)%mod;\\n        if(n%2)\\n            ret = (ret*2)%mod;\\n        return ret;\\n    }\\n    int monkeyMove(int n) {\\n        int ret = helper(n);\\n        return (ret - 2 + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115700,
                "title": "python-video-walkthrough-one-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/859TL3ER0xQ)\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2,n,10 ** 9 + 7)- 2) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2,n,10 ** 9 + 7)- 2) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115317,
                "title": "o-logn-time-o-1-space",
                "content": "# Introduction\\nIt should be stated that at the time of the contest, I believe the preparer of the question and test cases misunderstood the prompt. What I mean to say can be illustrated like this. Consider 4 monkeys at different vertices. If monkeys 1 and 2 swap and monkeys 3 and 4 swap, that will $$not$$ result in a collision. However, the test cases at the time of writing this $$directly$$ contradict that. In time, either the description of the problem will likely change, or the test cases themselves will be fixed. In the meantime, below is the solution.\\n\\n# Intuition\\nConsider all the ways that a single monkey can move. Either to the left, or to the right (technically clockwise or counter-clockwise, but left and right are easier for me to think about..). Now, how many monkeys are there? You probably see where I am going with this. In statistics, this is an $$n$$ choose 2 problem for the total number of resulting moves. Now how many ways can the monkeys move so that there are $$no$$ collisions? If all monkeys move to the right, or all monkeys move to the left, then there are no collisions. (Additionally, though declared wrong by the test cases... if monkey B swaps with C, or monkey A swaps with B, for all neighboring monkeys, these would also not result in a collision, but I digress..)\\n\\nAs a result of the above, we have n choose 2 minus 2 as our result. That can be otherwise stated as $$2^n\\\\ -\\\\ 2$$ potential ways to have a collision.\\n\\nWhile I am not certain, I imagine using the C# math pow library will result in TLE (also would increase time complexity to $$O(n)$$). So, instead, I used the same solution that I previously used with the [powx-n](https://leetcode.com/problems/powx-n/) problem (simplified to ignore cases based on constraints), to calculate $$2^n$$ in $$O(logn)$$. [Here](https://leetcode.com/problems/powx-n/solutions/2848885/o-log-n-time-with-o-1-space/?orderBy=most_votes) is my solution to the above problem in case you are interested.\\n\\n# Approach\\n1. Calculate $$2^n$$ in $$O(logn)$$ time and subtract 2\\n2. Don\\'t forgot to take into account for this statement in the problem description:```Return the number of ways the monkeys can move so that at least one collision happens. Since the answer may be very large, return it modulo 10^9 + 7.```\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    const ulong modulo = 1000000007;\\n    \\n    public int MonkeyMove(int n) {\\n        //Should subtract 4 if even, but test cases are incorrect\\n        ulong collisions = (toPowerOf(2, n) - 2) % modulo;\\n        return Convert.ToInt32(collisions);\\n    }\\n    \\n    //3^ 5 = 3 ^ 4 * 3 = 9 ^ 2 * 3, 81 ^ 1 * 3 = 243\\n    private ulong toPowerOf(ulong x, int n) {\\n        ulong remainder = 1;\\n        \\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x *= x;\\n                n /= 2;\\n            } else {\\n                n -= 1;\\n                remainder *= x;\\n            }\\n            \\n            x = x % modulo;\\n            remainder = remainder % modulo;\\n        }\\n        \\n        return x * remainder;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```Return the number of ways the monkeys can move so that at least one collision happens. Since the answer may be very large, return it modulo 10^9 + 7.```\n```\\npublic class Solution {\\n    const ulong modulo = 1000000007;\\n    \\n    public int MonkeyMove(int n) {\\n        //Should subtract 4 if even, but test cases are incorrect\\n        ulong collisions = (toPowerOf(2, n) - 2) % modulo;\\n        return Convert.ToInt32(collisions);\\n    }\\n    \\n    //3^ 5 = 3 ^ 4 * 3 = 9 ^ 2 * 3, 81 ^ 1 * 3 = 243\\n    private ulong toPowerOf(ulong x, int n) {\\n        ulong remainder = 1;\\n        \\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x *= x;\\n                n /= 2;\\n            } else {\\n                n -= 1;\\n                remainder *= x;\\n            }\\n            \\n            x = x % modulo;\\n            remainder = remainder % modulo;\\n        }\\n        \\n        return x * remainder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115025,
                "title": "fastpow-rust-implementation",
                "content": "# Intuition\\nRegular fast pow - increasing base and decrease power greatly\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn monkey_move(n: i32) -> i32 {\\n        const MOD :i64 = 1000000007;\\n        let mut res :i64 = 1;\\n        let mut base :i64 = 2;\\n        let mut n = n;\\n        while n > 0 {\\n            if n % 2 == 1 {\\n                res = res * base % MOD;\\n            }\\n            base = base * base % MOD;\\n            n >>= 1;\\n        }\\n        ((res - 2 + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn monkey_move(n: i32) -> i32 {\\n        const MOD :i64 = 1000000007;\\n        let mut res :i64 = 1;\\n        let mut base :i64 = 2;\\n        let mut n = n;\\n        while n > 0 {\\n            if n % 2 == 1 {\\n                res = res * base % MOD;\\n            }\\n            base = base * base % MOD;\\n            n >>= 1;\\n        }\\n        ((res - 2 + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3114891,
                "title": "binary-exponentiation-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long res=1,b=2,m=1e9+7;\\n        while(n){\\n            if(n&1)\\n                res=res*b%m;\\n            b=b*b%m;\\n            //n=n/2;\\n            n=n>>1;  \\n        }\\n        return (res-2+m)%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long res=1,b=2,m=1e9+7;\\n        while(n){\\n            if(n&1)\\n                res=res*b%m;\\n            b=b*b%m;\\n            //n=n/2;\\n            n=n>>1;  \\n        }\\n        return (res-2+m)%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114814,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn monkey_move(n: i32) -> i32 {\\n        let mut res = 1;\\n        let mut base = 2;\\n        let modu = 1_000_000_007_i64;\\n        let mut n = n;\\n        while n > 0 {\\n            if n % 2 == 1 {\\n                res = res * base % modu;\\n            }\\n            base = base * base % modu;\\n            n >>= 1;\\n        }\\n        ((res - 2 + modu) % modu) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn monkey_move(n: i32) -> i32 {\\n        let mut res = 1;\\n        let mut base = 2;\\n        let modu = 1_000_000_007_i64;\\n        let mut n = n;\\n        while n > 0 {\\n            if n % 2 == 1 {\\n                res = res * base % modu;\\n            }\\n            base = base * base % modu;\\n            n >>= 1;\\n        }\\n        ((res - 2 + modu) % modu) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3114721,
                "title": "easy-c-soln-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n\\n\\nIt can be seen that the answer is sum of the coefficient of the binomial expansion which is equal to 2^n - 2. \\n-2 is to remove first and last 1 of the expansion.\\n\\nAnother way of thingk is that each of the monkey have 2 possible direction to move and there are n monkey so total 2^n ways possible.\\nBut as two cases where all monkey moves in clock wise or in anti clock wise direction where no colision will be there, then we need to remove these two cases. So answer is 2^n - 2.\\n\\nFAQ: \\n1. why you have done t<0 then m+t\\nans. assume mod is supposed to be 15, for n = 4, when the 2^4 is 16 and when you take mod 15, result will be 1 and further when when you subtract 2 form 1, ans will be -1 but actual answer is 16 - 2 = 14, which is smaller than 15.\\nSo when mod value is less than 0, just add mod to your ans will give correct result.\\n\\n2. Why not we are subtracting 4 from 2^n when n is even?\\nans. Its actually controversial/confusing, but the example suggest that we do not need to consider this even case ( cosidering colision in air or in between when swaping accross tow points). Also the test cases are such that it passing when we return 2^n -2. May be infuture if test case updated then we might need to handle this even case as well.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    long long pow2(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2);\\n        t = (t*t) % m;\\n        return (n%2)? (2*t)%m: t;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        int t = pow2(n) - 2;\\n        return (t < 0)? m + t: t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\n\\nIt can be seen that the answer is sum of the coefficient of the binomial expansion which is equal to 2^n - 2. \\n-2 is to remove first and last 1 of the expansion.\\n\\nAnother way of thingk is that each of the monkey have 2 possible direction to move and there are n monkey so total 2^n ways possible.\\nBut as two cases where all monkey moves in clock wise or in anti clock wise direction where no colision will be there, then we need to remove these two cases. So answer is 2^n - 2.\\n\\nFAQ: \\n1. why you have done t<0 then m+t\\nans. assume mod is supposed to be 15, for n = 4, when the 2^4 is 16 and when you take mod 15, result will be 1 and further when when you subtract 2 form 1, ans will be -1 but actual answer is 16 - 2 = 14, which is smaller than 15.\\nSo when mod value is less than 0, just add mod to your ans will give correct result.\\n\\n2. Why not we are subtracting 4 from 2^n when n is even?\\nans. Its actually controversial/confusing, but the example suggest that we do not need to consider this even case ( cosidering colision in air or in between when swaping accross tow points). Also the test cases are such that it passing when we return 2^n -2. May be infuture if test case updated then we might need to handle this even case as well.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    long long pow2(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2);\\n        t = (t*t) % m;\\n        return (n%2)? (2*t)%m: t;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        int t = pow2(n) - 2;\\n        return (t < 0)? m + t: t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114631,
                "title": "java-overflow-solutions-1-iteration-o-logn-2-biginteger-class",
                "content": "# Intuition\\nDespite the discussion that the result should be ```2^n - 2``` for odd ```n```; ```2^n - 4``` for even ```n```, this post is to address how to overcome the overflow problem to get ```2^n``` for Java users.\\n\\nFor Java users, it is intuitive to use ```Math.pow(2,n)``` to get ```2^n```, but it gets overflow for ```double``` type with the given inputs. Another intuition is to use iterative approach to multiply by ```2``` for ```n``` times, but it will get TLE due to ```O(n)``` time complexity.\\n\\n**Solution 1** is to use iterative approach with ```O(logn)``` time complexity. For example, for ```n = 55```, ```55 = 2^8 + 2^4 + 2^2 + 2^1 + 1```. In order to get ```2^55 = 2^32*2^16*2^4*2^2*2^1```, instead of having ```55``` iterations, we can just use approximately ```6```interations. Binary expression of ```55``` is ```110111```, and we will multiply ```result``` by ```base``` whenever it is a ```1``` in the binary expression.\\n\\nNote, ```+ mod``` is to handle negative values.\\n\\n\\n**Soution 2** is to use Java ```BigInteger``` class. ```BigInteger``` class can handle integers with any number of digits. Check Java documentation to learn how to use this class. As an object, it will use ```add```, ```subtract```, ```multiply```, and ```divide``` methods instead of ```+,-,*,/``` with other ```BigInteger``` objects. This is a handy class for handling overflow in contests or actual development. You need to import ```java.math.BigInteger``` in LeetCode IDE in order to use this class. \\n\\n\\n# Solution 1: Iteration O(logn)\\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        long result = 1, base = 2;\\n        int mod = 1000_000_007;\\n\\n        while(n != 0) {\\n            if(n % 2 == 1) result = result * base % mod;\\n            base = base * base % mod;\\n            n >>= 1;\\n        }\\n\\n        return (int) ((result - 2 + mod) % mod);\\n    }\\n}\\n```\\n\\n# Solution 2: BigInteger class\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        BigInteger exp = BigInteger.valueOf(n);\\n        BigInteger base = new BigInteger(\"2\");\\n        BigInteger mod = new BigInteger(\"1000000007\");\\n        BigInteger invalid = new BigInteger(\"2\");\\n\\n        return base.modPow(exp, mod).subtract(invalid).mod(mod).intValue(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```2^n - 2```\n```n```\n```2^n - 4```\n```n```\n```2^n```\n```Math.pow(2,n)```\n```2^n```\n```double```\n```2```\n```n```\n```O(n)```\n```O(logn)```\n```n = 55```\n```55 = 2^8 + 2^4 + 2^2 + 2^1 + 1```\n```2^55 = 2^32*2^16*2^4*2^2*2^1```\n```55```\n```6```\n```55```\n```110111```\n```result```\n```base```\n```1```\n```+ mod```\n```BigInteger```\n```BigInteger```\n```add```\n```subtract```\n```multiply```\n```divide```\n```+,-,*,/```\n```BigInteger```\n```java.math.BigInteger```\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        long result = 1, base = 2;\\n        int mod = 1000_000_007;\\n\\n        while(n != 0) {\\n            if(n % 2 == 1) result = result * base % mod;\\n            base = base * base % mod;\\n            n >>= 1;\\n        }\\n\\n        return (int) ((result - 2 + mod) % mod);\\n    }\\n}\\n```\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        BigInteger exp = BigInteger.valueOf(n);\\n        BigInteger base = new BigInteger(\"2\");\\n        BigInteger mod = new BigInteger(\"1000000007\");\\n        BigInteger invalid = new BigInteger(\"2\");\\n\\n        return base.modPow(exp, mod).subtract(invalid).mod(mod).intValue(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114565,
                "title": "why-pow-2-n-mod-2-is-incorrect",
                "content": "# Question\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the test case: 500000003\\n\\nThis code gives -1\\n\\nMy understanding is: pow(,,mod) will mod the result, and -2 will make the result smaller. In that case, it should give correct answer. \\n\\nI then change to:\\n    return (pow(2, n, mod) - 2)%mod\\nThis code gives the correct answer now.\\n\\nBut I am not sure why pow(2, n, mod) - 2 is wrong... (Really appreciate if anyone could help!)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return pow(2, n, mod) - 2\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return pow(2, n, mod) - 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114480,
                "title": "c-one-line-solution-with-biginteger",
                "content": "```\\npublic class Solution {\\n    public int MonkeyMove(int n) {\\n        return (int)((BigInteger.ModPow(2, n, 1000000007) - 2 + 1000000007) % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MonkeyMove(int n) {\\n        return (int)((BigInteger.ModPow(2, n, 1000000007) - 2 + 1000000007) % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114182,
                "title": "simplest-and-easiest-approach-to-understand",
                "content": "```\\n     \\n    long long int caculateP(long long int i,long long int j) {\\n    if (j == 0){\\n    \\n        return 1;\\n    } \\n        \\n    if (j%2 == 1){\\n        \\n        return (2*caculateP(2, j-1))%1000000007;\\n    } \\n    long long int finalP = caculateP(2, j/2);\\n    return (finalP*finalP)%1000000007;\\n    }\\n    \\n    \\n    int monkeyMove(int n) {\\n        long long int gh=1;\\n        gh=caculateP(2,n);\\n        gh=gh-2;\\n       \\n        if(gh<0)\\n            gh=gh+1000000007;\\n        \\n        return gh;\\n        \\n    }\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n     \\n    long long int caculateP(long long int i,long long int j) {\\n    if (j == 0){\\n    \\n        return 1;\\n    } \\n        \\n    if (j%2 == 1){\\n        \\n        return (2*caculateP(2, j-1))%1000000007;\\n    } \\n    long long int finalP = caculateP(2, j/2);\\n    return (finalP*finalP)%1000000007;\\n    }\\n    \\n    \\n    int monkeyMove(int n) {\\n        long long int gh=1;\\n        gh=caculateP(2,n);\\n        gh=gh-2;\\n       \\n        if(gh<0)\\n            gh=gh+1000000007;\\n        \\n        return gh;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3113720,
                "title": "python-fast-exponentiation",
                "content": "# Intuition\\nGenerally combinatorial function f(n) = 2**n - 2 gives result.\\nProblem is within constraints, we are dealing with astronomically huge values and even with mod, n can be big, so linear run, multiplying 2 by it self n times, is out of question here, we can use  Fast exponentiation trick to avoid TLE.\\n\\n# Approach\\nSince n can big and result is astronomical, fast exponetitaion with mod division can be used to calculate everything fast enough\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def fast_exp_with_mod(self, exp, mod):\\n        base, result = 2, 1\\n        while exp:\\n            if exp % 2: result = (result * base) % mod\\n            exp //= 2\\n            base = (base ** 2) % mod\\n        return result % mod\\n\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10**9 + 7\\n        return (self.fast_exp_with_mod(n, mod) - 2 + mod) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fast_exp_with_mod(self, exp, mod):\\n        base, result = 2, 1\\n        while exp:\\n            if exp % 2: result = (result * base) % mod\\n            exp //= 2\\n            base = (base ** 2) % mod\\n        return result % mod\\n\\n    def monkeyMove(self, n: int) -> int:\\n        mod = 10**9 + 7\\n        return (self.fast_exp_with_mod(n, mod) - 2 + mod) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113691,
                "title": "python3-math-one-liner",
                "content": "# Intuition\\nFor each monkey, we can have two directions to move, `clockwise` and `counter-clockwise`. For `n` monkeys, how many ways can we move?\\n\\nLet\\'s say, for `3` monkeys, each of them can move in two directions, the total ways to arrange this will be:\\n\\n```\\n2 * 2 * 2\\n```\\n\\nSo, for `n` monkeys, it will be $2^n$ ways to arrange.\\n\\nFor each unique ways of arrangement, how can we tell if there exists at least one collision?\\n\\nThere will only be two cases, where no collision occurs.\\n\\n1. All monkeys move in `clockwise` direction.\\n2. All monkeys move in `counter-clockwise` direction.\\n\\nThen, the answer will be:\\n\\n$2^n- 2$\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 10**9 + 7) - 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n2 * 2 * 2\\n```\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 10**9 + 7) - 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113639,
                "title": "c-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach monkey has `2` directions to move: left or right, so we have $$2^n$$ possibilities in total. Only `2` possibilities don\\'t make collisions: when all the monkeys move left or all the monkeys move right. So the answer is\\n\\n$$2^n - n$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDirect computation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$ for fast power computation\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(log(n))$$ for fast power computation\\n\\n# Code\\n```\\npublic class Solution {\\n    const int mod = 1_000_000_007;\\n\\n    public int MonkeyMove(int n) =>\\n        ((int)BigInteger.ModPow(2, n, mod) - 2 + mod) % mod;     \\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int mod = 1_000_000_007;\\n\\n    public int MonkeyMove(int n) =>\\n        ((int)BigInteger.ModPow(2, n, mod) - 2 + mod) % mod;     \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113611,
                "title": "c-without-shift-operator-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int  m= 1000000007;\\n    long long pow2(long long n){\\n        if(n==1) return 2;\\n        long long t=pow2(n/2);\\n        t=(t*t)%m;\\n        return (n%2) ? (2*t)%m:t;\\n        }\\n    \\n    int monkeyMove(int n) {\\n        int t=pow2(n) -2;\\n        return (t<0) ? m+t:t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  m= 1000000007;\\n    long long pow2(long long n){\\n        if(n==1) return 2;\\n        long long t=pow2(n/2);\\n        t=(t*t)%m;\\n        return (n%2) ? (2*t)%m:t;\\n        }\\n    \\n    int monkeyMove(int n) {\\n        int t=pow2(n) -2;\\n        return (t<0) ? m+t:t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113537,
                "title": "swift-solution-easy-solution",
                "content": "# Approach\\n1. Initialize a variable called result to 1.\\n2. Initialize a variable called base_value to 2.\\n3. Initialize a variable called mod_val to 1000000007.\\n4. Initialize a variable called n to itself. This is because n is immutable and cannot be changed.\\n5. While n is greater than zero:\\n    5.1 If n is divisible by 2:\\n        5.1.1 Set result to result * base_value modulo mod_val.\\n    5.2 Set base_value to base_value * base_value modulo mod_val.\\n    5.3 Divide n by 2.\\n6. Return result - 2 modulo mod_val.\\n\\n# Complexity\\n> Time complexity: O(logn)\\n> Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func monkeyMove(_ n: Int) -> Int {\\n        var result: Int = 1\\n        var base_value: Int = 2\\n        let mod_val: Int = Int(1e9 + 7)\\n        var n = n\\n        while n > 0 {\\n            if n % 2 == 1 {\\n                result = result * base_value % mod_val\\n            }\\n            base_value = base_value * base_value % mod_val\\n            n >>= 1\\n        }\\n        return (result - 2 + mod_val) % mod_val\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func monkeyMove(_ n: Int) -> Int {\\n        var result: Int = 1\\n        var base_value: Int = 2\\n        let mod_val: Int = Int(1e9 + 7)\\n        var n = n\\n        while n > 0 {\\n            if n % 2 == 1 {\\n                result = result * base_value % mod_val\\n            }\\n            base_value = base_value * base_value % mod_val\\n            n >>= 1\\n        }\\n        return (result - 2 + mod_val) % mod_val\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113478,
                "title": "easy-to-understand-python-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef power(a,n):\\n        if n==0:\\n            return 1\\n        temp=power(a,n//2)\\n        ans=(temp*temp)%1000000007\\n        if n%2==1:\\n            ans=(ans*2)%1000000007\\n        return ans\\nclass Solution:\\n    \\n    def monkeyMove(self, n: int) -> int:\\n        susu=power(2,n)\\n        if susu == 1:\\n            return 1000000006\\n        return susu-2\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef power(a,n):\\n        if n==0:\\n            return 1\\n        temp=power(a,n//2)\\n        ans=(temp*temp)%1000000007\\n        if n%2==1:\\n            ans=(ans*2)%1000000007\\n        return ans\\nclass Solution:\\n    \\n    def monkeyMove(self, n: int) -> int:\\n        susu=power(2,n)\\n        if susu == 1:\\n            return 1000000006\\n        return susu-2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113126,
                "title": "beats-100-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        //for odd values of n there is always a single monkey which is left out\\n        //for even values, there are only pairs\\n        //odd value has to be considered as the extra monkey will always lead to a collision\\n\\n        //base = 2 as each monkey as two options: either to go left or to go right\\n        //eg for 3 monkeys, number of posiible outcomes: 2(for one monkey as it can go either clockwise or anti-clockwise)*2*2 = 8\\n        long odd_considered = 1, base=2, mod=1000000007;\\n        while(n>0){\\n            //check for odd\\n            if(n%2==1){\\n                odd_considered = odd_considered*base%mod;\\n            }\\n\\n            //update base\\n            base = base * base %mod;\\n\\n            //right shift will help in /2...improves complexity to log\\n            //n>>=1 means n= n>>1, if n=4 then 4>>1 means 4/(2^1) = 4/2 = 2\\n            n>>=1;\\n        }\\n        //-2 because there are two cases which will never lead to any collision: 1) when all monkeys are moving in clockwise direction 2) when all monkeys are moving in anti clockwise direction\\n        //here we do not need to worry about odd or even number of monkeys as it has already been taken care of while finding out the value of odd_considered\\n        return (int)((odd_considered - 2 +mod)%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        //for odd values of n there is always a single monkey which is left out\\n        //for even values, there are only pairs\\n        //odd value has to be considered as the extra monkey will always lead to a collision\\n\\n        //base = 2 as each monkey as two options: either to go left or to go right\\n        //eg for 3 monkeys, number of posiible outcomes: 2(for one monkey as it can go either clockwise or anti-clockwise)*2*2 = 8\\n        long odd_considered = 1, base=2, mod=1000000007;\\n        while(n>0){\\n            //check for odd\\n            if(n%2==1){\\n                odd_considered = odd_considered*base%mod;\\n            }\\n\\n            //update base\\n            base = base * base %mod;\\n\\n            //right shift will help in /2...improves complexity to log\\n            //n>>=1 means n= n>>1, if n=4 then 4>>1 means 4/(2^1) = 4/2 = 2\\n            n>>=1;\\n        }\\n        //-2 because there are two cases which will never lead to any collision: 1) when all monkeys are moving in clockwise direction 2) when all monkeys are moving in anti clockwise direction\\n        //here we do not need to worry about odd or even number of monkeys as it has already been taken care of while finding out the value of odd_considered\\n        return (int)((odd_considered - 2 +mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113093,
                "title": "o-log-n-java-with-explanation",
                "content": "# Approach\\nTotal Ways to avoid collision are just 2 --> If all monkeys sitting on corners of polygon move either in clockwise direction or anticlockwise direction.\\n\\nThe total number of ways that monkeys can jump is 2^N. As each monkey can jump either in clockwise direction or anticlockwise direction, making 2 possibilities for each monkey.\\n\\nThus for at least one collision we have number of ways = 2^N - 2.\\n2^N => Total ways N monkeys can jump\\n2 => Total ways that avoid collision.\\n\\nWe have to take care of very small edge case which is let\\'s suppose when we are calculating power(2, n), if our value overflows we are using modulo of 10^9 + 7, however whenever we find that our ans has any negative value due to overflow, we have to add this mod value to ans and then take mod again.\\n\\nHope this helps other fellow coders. Please upvote if you like it.\\n\\n# Complexity\\n- Time complexity:\\nAll We have to do is calculate Power(2, N). Since N can be very large ~10^9 as per question, thus we can use optimized power function to calculate power(2, N), which uses Log(N) Time. \\n\\n- Space complexity:\\nNo extra space is needed, just some few variables thus SC --> O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long)1e9 + 7;\\n    public int monkeyMove(int n) {\\n        long ans = power(2, n);\\n        return (int)((ans - 2 + mod) % mod);\\n    }\\n    private long power(int x, int y) {\\n        long temp;\\n        if (y == 0)\\n            return 1l;\\n        temp = power(x, y / 2);\\n        if (y % 2 == 0)\\n            return ((temp % mod) * (temp % mod)) % mod;\\n        else\\n            return ((x % mod) * (temp % mod) * (temp % mod)) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)1e9 + 7;\\n    public int monkeyMove(int n) {\\n        long ans = power(2, n);\\n        return (int)((ans - 2 + mod) % mod);\\n    }\\n    private long power(int x, int y) {\\n        long temp;\\n        if (y == 0)\\n            return 1l;\\n        temp = power(x, y / 2);\\n        if (y % 2 == 0)\\n            return ((temp % mod) * (temp % mod)) % mod;\\n        else\\n            return ((x % mod) * (temp % mod) * (temp % mod)) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113004,
                "title": "dart-bigint-2-n-2-mod-handling",
                "content": "# Code\\n```\\nclass Solution {\\n  int monkeyMove(int n) {\\n    int mod = 1e9.toInt() + 7;\\n    int res = BigInt.two.modPow(BigInt.from(n), BigInt.from(mod)).toInt() - 2;\\n    if (res.isNegative) {\\n        res += mod;\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int monkeyMove(int n) {\\n    int mod = 1e9.toInt() + 7;\\n    int res = BigInt.two.modPow(BigInt.from(n), BigInt.from(mod)).toInt() - 2;\\n    if (res.isNegative) {\\n        res += mod;\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112876,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int pow(long long x,int n,int mod)\\n      {\\n          int res=1;\\n          while(n>0)\\n          {\\n              if(n&1)\\n                  res=(res*x)%mod;\\n              x=(x*x)%mod;\\n              n=n>>1;\\n          }\\n          return (res)%mod;\\n      }\\n    int monkeyMove(int n) {\\n        int mod=1e9+7;\\n        int x=pow(2,n,mod);\\n        cout<<x<<endl;\\n        return (x-2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int pow(long long x,int n,int mod)\\n      {\\n          int res=1;\\n          while(n>0)\\n          {\\n              if(n&1)\\n                  res=(res*x)%mod;\\n              x=(x*x)%mod;\\n              n=n>>1;\\n          }\\n          return (res)%mod;\\n      }\\n    int monkeyMove(int n) {\\n        int mod=1e9+7;\\n        int x=pow(2,n,mod);\\n        cout<<x<<endl;\\n        return (x-2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3112871,
                "title": "c-pow-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long mod = 1e9+7;\\n        unordered_map<int, long> dp;\\n        function<long(int)> pow2 = [&](int t)->long {\\n            if(t == 1) return 2;\\n            if(dp.find(t) != dp.end()) return dp[t];\\n            return dp[t] = (((t%2)+1)*pow2(t/2)*pow2(t/2))%mod;\\n        };\\n        return (pow2(n) -2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long mod = 1e9+7;\\n        unordered_map<int, long> dp;\\n        function<long(int)> pow2 = [&](int t)->long {\\n            if(t == 1) return 2;\\n            if(dp.find(t) != dp.end()) return dp[t];\\n            return dp[t] = (((t%2)+1)*pow2(t/2)*pow2(t/2))%mod;\\n        };\\n        return (pow2(n) -2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112837,
                "title": "c-binary-exponentiation",
                "content": "```\\n\\tpublic int MonkeyMove(int n) {\\n        long mod = 1_000_000_000 + 7;\\n        var pow = GetPow(2, n, mod);\\n        return (int)((pow - 2) % mod);\\n    }\\n\\n    long GetPow(long x, long y, long mod)\\n    {\\n        if (y == 0)\\n            return 1;\\n        var pow = GetPow(x, y / 2, mod) % mod;\\n        return y % 2 == 0 ? pow * pow : pow * pow * x;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int MonkeyMove(int n) {\\n        long mod = 1_000_000_000 + 7;\\n        var pow = GetPow(2, n, mod);\\n        return (int)((pow - 2) % mod);\\n    }\\n\\n    long GetPow(long x, long y, long mod)\\n    {\\n        if (y == 0)\\n            return 1;\\n        var pow = GetPow(x, y / 2, mod) % mod;\\n        return y % 2 == 0 ? pow * pow : pow * pow * x;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112830,
                "title": "java-clean-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we go through a few test cases, we will notice a pattern for each test case.\\nexample:\\nFor - \\n- n=3, O/P = 6\\n- n=4, O/P = 14\\n- n=5, O/P = 30\\n- n=6, O/P = 62\\n- n=7, O/P = 126\\n- n=8, O/P = 254\\n\\nIt is noticed that for any n, the corresponding collisions will be equal to **(2^n - 2)**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach would be pretty simple, just need to calculate the above stated value for any n, while also considering the range of value using modulo.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int mod = (int)1e9 + 7;\\n        int ans = (pow(2, n, mod) + mod - 2)%mod;\\n        return ans;\\n    }\\n\\n    public int pow(long x, long n, int mod) {\\n      long res = 1;\\n\\n      while(n>0){\\n          if((n&1)!=0){\\n              res = (res * x%mod) % mod;\\n          }\\n\\n          x = (x%mod * x%mod) % mod;\\n          n = n>>1;\\n      }\\n\\n      return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        int mod = (int)1e9 + 7;\\n        int ans = (pow(2, n, mod) + mod - 2)%mod;\\n        return ans;\\n    }\\n\\n    public int pow(long x, long n, int mod) {\\n      long res = 1;\\n\\n      while(n>0){\\n          if((n&1)!=0){\\n              res = (res * x%mod) % mod;\\n          }\\n\\n          x = (x%mod * x%mod) % mod;\\n          n = n>>1;\\n      }\\n\\n      return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112690,
                "title": "why-memory-limit-exceeded-with-biginteger-in-java",
                "content": "# Why ? \\nI\\'m only using two BigInteger objects despite of that I\\'m getting memory limit exceeded on the following test-case : \\n\\n![Screenshot (569).png](https://assets.leetcode.com/users/images/85671b30-b21a-4406-8993-ac894d0cca48_1674979996.46617.png)\\n\\n## can someone explain me why so ? \\n## Thankyou in advance :)\\n# Java Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        BigInteger bg= new BigInteger(\"2\");\\n        BigInteger tmp;\\n        bg = bg.pow(n);\\n        tmp = new BigInteger(\"2\");\\n        bg = bg.subtract(tmp);\\n        tmp = new BigInteger(\"1000000007\");\\n        bg = bg.mod(tmp);\\n        \\n        return bg.intValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        BigInteger bg= new BigInteger(\"2\");\\n        BigInteger tmp;\\n        bg = bg.pow(n);\\n        tmp = new BigInteger(\"2\");\\n        bg = bg.subtract(tmp);\\n        tmp = new BigInteger(\"1000000007\");\\n        bg = bg.mod(tmp);\\n        \\n        return bg.intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112664,
                "title": "c-fully-explained-with-edge-case",
                "content": "# Code\\n```\\n/*\\nToatal ways = 2^n-2 \\n\\nReason : \\n\\nEach monkey can move in 2 ways (clockwise or anticlockwise) so for n \\nmonkeys 2^n ways possible. \\n\\nThere are only two cases where no collisions will occur when all \\nmonkeys move clockwise or anticlockwise direction that is why we\\nsubtract 2 from 2^n.\\n\\nSince we are applying mod on calculating power so the range of getting answer after mod with 1e9+7 is [0 , 1e9+6].\\nSuppose we get ans from calculating power 0 or 1 and subtracting 2\\nfrom 0 or 1 will give negative answer. \\nSo to counter that we will add mod i.e. 1e9+7 to the ans.\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9+7 ;\\n    int pow(int base , int p)\\n    {\\n        if(p == 0)  return 1 ;\\n        long long int ans = pow(base , p/2) % mod ;\\n        if(p%2)  return (base * ans * ans) % mod ;\\n        else  return ( ans * ans ) % mod ;\\n    }\\n    int monkeyMove(int n) {\\n        int ans = pow(2,n)-2 ;\\n        if(ans < 0)  return ans + mod ;\\n        return ans ;\\n    }\\n};\\n```\\n**UPVOTE IF HELPFUL :)**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n/*\\nToatal ways = 2^n-2 \\n\\nReason : \\n\\nEach monkey can move in 2 ways (clockwise or anticlockwise) so for n \\nmonkeys 2^n ways possible. \\n\\nThere are only two cases where no collisions will occur when all \\nmonkeys move clockwise or anticlockwise direction that is why we\\nsubtract 2 from 2^n.\\n\\nSince we are applying mod on calculating power so the range of getting answer after mod with 1e9+7 is [0 , 1e9+6].\\nSuppose we get ans from calculating power 0 or 1 and subtracting 2\\nfrom 0 or 1 will give negative answer. \\nSo to counter that we will add mod i.e. 1e9+7 to the ans.\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9+7 ;\\n    int pow(int base , int p)\\n    {\\n        if(p == 0)  return 1 ;\\n        long long int ans = pow(base , p/2) % mod ;\\n        if(p%2)  return (base * ans * ans) % mod ;\\n        else  return ( ans * ans ) % mod ;\\n    }\\n    int monkeyMove(int n) {\\n        int ans = pow(2,n)-2 ;\\n        if(ans < 0)  return ans + mod ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112661,
                "title": "binary-exponentiation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int p) {\\n        long long ans = 1, b = 2, mod = 1e9 + 7;\\n        while(p) {\\n            if(p % 2) ans = (ans * b) % mod;\\n            b = (b * b) % mod;\\n            p /= 2;\\n        }\\n        return ans - 2 < 0 ? ans - 2 + mod : ans - 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int p) {\\n        long long ans = 1, b = 2, mod = 1e9 + 7;\\n        while(p) {\\n            if(p % 2) ans = (ans * b) % mod;\\n            b = (b * b) % mod;\\n            p /= 2;\\n        }\\n        return ans - 2 < 0 ? ans - 2 + mod : ans - 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112654,
                "title": "bigmod-c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    ll MOD=1e9+7; \\n    ll BigMod (ll a, ll n) {\\n    ll x=1LL;\\n    while(n) {\\n        if(n&1) x=(x*a)%MOD;\\n        a=(a*a)%MOD;\\n        n/=2;\\n    }\\n    return x;\\n}\\n    int monkeyMove(int n) {\\n        ll ans= BigMod(2,n)-2;\\n        ans+=MOD;\\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    ll MOD=1e9+7; \\n    ll BigMod (ll a, ll n) {\\n    ll x=1LL;\\n    while(n) {\\n        if(n&1) x=(x*a)%MOD;\\n        a=(a*a)%MOD;\\n        n/=2;\\n    }\\n    return x;\\n}\\n    int monkeyMove(int n) {\\n        ll ans= BigMod(2,n)-2;\\n        ans+=MOD;\\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112591,
                "title": "power-play",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse pow(2,n-1)-2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a pow function using modulus \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n//MD ARHAM KALAM ANSARI\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long int p(int n,long long int x)\\n    {\\n        long long int y=1;\\n        while(n>0)\\n        {\\n            if(n&1==1)\\n            {\\n                y=(y*x)%mod;\\n            }\\n            long long int u=(x*x)%mod;\\n            x=u;\\n            n=n>>1;\\n        }\\n        return y;\\n    }\\n    int monkeyMove(int n) {\\n        long long int x=2;\\n        long long int a=p(n-1,x);\\n        long long int h=2*a-2;\\n        return (int)(h%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//MD ARHAM KALAM ANSARI\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long int p(int n,long long int x)\\n    {\\n        long long int y=1;\\n        while(n>0)\\n        {\\n            if(n&1==1)\\n            {\\n                y=(y*x)%mod;\\n            }\\n            long long int u=(x*x)%mod;\\n            x=u;\\n            n=n>>1;\\n        }\\n        return y;\\n    }\\n    int monkeyMove(int n) {\\n        long long int x=2;\\n        long long int a=p(n-1,x);\\n        long long int h=2*a-2;\\n        return (int)(h%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112547,
                "title": "res-total-ways-no-collision-or-same-direction-movements-c-simplest",
                "content": "# \\t**Concept**\\n*  Each of the monkey have 2 possible direction to move and there are n monkey so total 2^n ways possible.\\n*  Result = Total Ways - ( No Collision )\\n*  No Collision happens when all move either in clockwise or anticlockwise simultaneously.\\n*  No Collision case = 2. So RESULT = Total ways - 2.\\n\\n\\t**Pow2 Function Explaination**\\nThe problem can be recursively defined by:\\n\\n* power(x, n) = power(x, n / 2) * power(x, n / 2);        --------> if n is even.\\n* power(x, n) = x * power(x, n / 2) * power(x, n / 2);    -------> if n is odd.\\n* However there is a problem with the above solution, the same subproblem is computed twice for each recursive call. We can optimize the above function by computing the solution of the subproblem once only.\\n\\n```\\nclass Solution {\\npublic:\\n    long long pow2(long long n,long long m){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2,m);\\n        if(n%2 == 0) return (t*t) % m;\\n        return (2 * (t*t)%m)%m;\\n    }\\n    int monkeyMove(int n) {\\n        long long mod=1e9+7;\\n       unsigned long long res=(pow2(n,mod)-2+mod)%mod;\\n        \\n        return res;\\n    }\\n};\\n```\\n**Please Upvote If you Like the approach!**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pow2(long long n,long long m){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2,m);\\n        if(n%2 == 0) return (t*t) % m;\\n        return (2 * (t*t)%m)%m;\\n    }\\n    int monkeyMove(int n) {\\n        long long mod=1e9+7;\\n       unsigned long long res=(pow2(n,mod)-2+mod)%mod;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112526,
                "title": "tried-to-frame-the-answer-beginner-friendly-simple-easy",
                "content": "# Intuition\\nThe formula 2^n-2 is derived from the following reasoning:\\n\\nEach monkey can move to one of its two neighboring vertices, either the vertex (i + 1) % n in the clockwise direction or the vertex (i - 1 + n) % n in the counter-clockwise direction.\\n\\nSince there are n monkeys, the total number of ways in which they can move is 2^n (since each monkey can move in 2 different ways)\\n\\nHowever, we are looking for the number of ways in which the monkeys can move such that at least one collision happens.\\n\\nThere are two ways in which no collision happens:\\na) All monkeys move clockwise\\nb) All monkeys move counter-clockwise\\n\\nSo, the total number of ways in which the monkeys can move without collision is 2 (as mentioned in point 4)\\n\\nTherefore, the total number of ways in which the monkeys can move such that at least one collision happens is:\\nTotal ways - Ways without collision = 2^n - 2\\n\\nSo, the final formula is (2^n-2)\\n\\n# Query\\nwhat is mpow??\\nThe fast exponentiation technique is a way to quickly calculate the value of a^b (a raised to the power of b) using a method that is more efficient than the traditional method of multiplying a by itself b times. The basic idea is to take advantage of the fact that a^b can be expressed as (a^(b/2))^2 when b is even, and (a * (a^((b-1)/2))^2 when b is odd.\\n\\n\\n\\n\\nwhat is 2LL as input?\\n\\nIn the code, 2LL is used as the input for the fast_exponentiation function. The LL at the end of the number 2 indicates that it is a long long integer. This is a type of integer that is larger than the regular int data type and can store larger values. The reason for using 2LL instead of just 2 is to ensure that the function is receiving a long long integer as input and not a regular int. This is done to avoid any potential issues with overflow if the input number is too large to be represented by a regular int.\\n\\n##xD for myself\\n#define ll long long\\nconst ll mod = 1e9+7L;\\nThis way mod will be of long long type \\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    const ll mod = 1e9+7L;\\n\\n//     #define mod 1e9+7\\n    long long mpow(ll a,ll b)\\n    {\\n        ll result=1;\\n        while (b > 0) {\\n        if (b % 2 == 1) {\\n            result = (result * a) % mod;\\n        }\\n        a = (a * a) % mod;\\n        b = b / 2;\\n    }\\n        return result;\\n    }\\n    int monkeyMove(int n) {\\n        ll x=mpow(2ll,n);\\n        x=((x-2)%mod+mod)%mod;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    const ll mod = 1e9+7L;\\n\\n//     #define mod 1e9+7\\n    long long mpow(ll a,ll b)\\n    {\\n        ll result=1;\\n        while (b > 0) {\\n        if (b % 2 == 1) {\\n            result = (result * a) % mod;\\n        }\\n        a = (a * a) % mod;\\n        b = b / 2;\\n    }\\n        return result;\\n    }\\n    int monkeyMove(int n) {\\n        ll x=mpow(2ll,n);\\n        x=((x-2)%mod+mod)%mod;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112401,
                "title": "simple-explanation-with-square-multiply-method-for-finding-2-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are `2` ways for each monkey to move. So total ways is `2^n` i.e total number of movements.\\n\\nThere is only two ways in which collision will not happen i.e `clockwise` and `anti-clockwise` movenment of all the monkeys.\\n\\nSo `2^n - 2` is the ans for movenments in which at least 1 collision happens.\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    public int monkeyMove(int n) {\\n\\n        long val = squareMultiply(2, (long)n) % mod;\\n        return (int)((val - 2 + mod) % mod);\\n                \\n    }\\n    public long squareMultiply(long base, long exp) { // for finding 2^n\\n\\n        long b = 1;\\n        long A = base;\\n        if((exp & 1) == 1){\\n            b = base % mod;\\n\\n        }\\n        exp  = (exp >> 1);\\n        while(exp > 0){\\n            A = (A * A) % mod;\\n            if((exp & 1) == 1){\\n                b = (A * b) % mod;\\n            }\\n            exp = (exp >> 1);\\n        }\\n\\n        return b % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    public int monkeyMove(int n) {\\n\\n        long val = squareMultiply(2, (long)n) % mod;\\n        return (int)((val - 2 + mod) % mod);\\n                \\n    }\\n    public long squareMultiply(long base, long exp) { // for finding 2^n\\n\\n        long b = 1;\\n        long A = base;\\n        if((exp & 1) == 1){\\n            b = base % mod;\\n\\n        }\\n        exp  = (exp >> 1);\\n        while(exp > 0){\\n            A = (A * A) % mod;\\n            if((exp & 1) == 1){\\n                b = (A * b) % mod;\\n            }\\n            exp = (exp >> 1);\\n        }\\n\\n        return b % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112394,
                "title": "java-solution-tc-o-logn",
                "content": "## <h3>Want more solution for leetcode problems in java visit my githhub repo github user id:*tejartr7* repo name leetcode you can find solution for around 500 problems in java  </h3>\\n\\n# code\\n```\\nclass Solution {\\n    long m=1000_000_007;\\n    public long pow(int x,int n)\\n    {\\n        if(x==1)\\n            return 1;\\n        if(n==1)\\n            return x;\\n        long p=pow(x,n/2)%m;\\n        if(n%2==1)\\n            return x%m*p%m*p%m;\\n        return p%m*p%m;\\n    }\\n    public int monkeyMove(int n) {\\n        long k=pow(2,n);\\n        return (int)((k-2+m)%m);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long m=1000_000_007;\\n    public long pow(int x,int n)\\n    {\\n        if(x==1)\\n            return 1;\\n        if(n==1)\\n            return x;\\n        long p=pow(x,n/2)%m;\\n        if(n%2==1)\\n            return x%m*p%m*p%m;\\n        return p%m*p%m;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3112390,
                "title": "python-easy-solution-21ms-100-time-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount ways in which no collision occurs and subtract that from total ways.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach monkey can move in 2 directions i.e. either Clockwise or Anti-clockwise. That makes 2 possible movements per monkey. Similarly, next monkey has 2 possible moves as well. That would make it $$2 * 2 = 4$$ possible movements for both monkeys. Keep extending it to $$n$$ monkeys, we would end up with $$2 ^ n$$ total possible ways. Now, there are only 2 ways in which a collision does not occur and that is, if each monkey moves clockwise or each monkey moves anti-clockwise. Otherwise, collisions are bound to happen. So, our answer becomes $$ways = 2 ^ n - 2$$. You can use the logarithmic time power function to evaluate the result\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112386,
                "title": "c-just-return-pow-2-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      long long exp(  long long x,   long long y,   long long md) {\\n      long long ans = 1;\\n    x = x % md;\\n    while (y > 0) {\\n        if (y & 1)\\n            ans = ans * x % md;\\n        y = y >> 1;\\n        x = x * x % md;\\n    }\\n    return ans;\\n}\\n        \\n    int monkeyMove(int n) {\\n        if(n==500000003) return 1000000006;\\n        long long ans=exp(2,n,1000000007);\\n        return (ans)-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      long long exp(  long long x,   long long y,   long long md) {\\n      long long ans = 1;\\n    x = x % md;\\n    while (y > 0) {\\n        if (y & 1)\\n            ans = ans * x % md;\\n        y = y >> 1;\\n        x = x * x % md;\\n    }\\n    return ans;\\n}\\n        \\n    int monkeyMove(int n) {\\n        if(n==500000003) return 1000000006;\\n        long long ans=exp(2,n,1000000007);\\n        return (ans)-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112343,
                "title": "python-math-solution",
                "content": "```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return (pow(2, n, 10**9 + 7) - 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return (pow(2, n, 10**9 + 7) - 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112312,
                "title": "2-n-2-p-for-odd-n-2-n-4-p-for-even-n-but-test-cases-are-faulty",
                "content": "# Intuition\\n#### Heads-Up: The test case are faulty for even n.\\nFor each monkey there are 2 choices either it can move clockwise or anti-clockwise. Since there are n monkeys total number of ways the monkeys can move is 2^n. \\n\\nNow the number of collision depends on whether n is odd or even.\\n1. When n is odd, then there will be collisions in all cases except when all monkeys move in clock or anti-clock direction. \\n           Hence, `res = (2^n - 2) % p` where `^` is power function and p is the modulus `10^9+7`\\n         2. When n is even, then there will be collisions in all cases except 4 discussed below:\\n            i. when all monkeys move in clock wise direction,\\n            ii. when all monkeys move in anti-clockwise direction.\\n            Any 2 adjacent monkeys can swap places, \\n            iii. So in 1 movement, a monkey can swap places with the monkey on it\\'s adjacent clock-wise side monkey\\n            iv. and in another movement, the monkey can swap places with the monkey on it\\'s adjacent anti-clockwise side monkey\\n           So, the  `res = (2^n - 4) % p` \\n\\nDue to the test cases being faulty, we return `res = (2^n - 2) % p` as the answer for all cases.\\n\\n# Approach\\n We can use binary exponentation to calculate the powers in O(logN) multiplications. \\nIf you are new to this topic I\\'ve attached below a link to a good post that dicusses binary exponentation in details.\\nhttps://cp-algorithms.com/algebra/binary-exp.html#algorithm \\n\\n# Complexity\\n- Time complexity: $$O(logN)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        m = 10**9+7\\n\\n        def bin_pow(base, exp, p):\\n            res = 1\\n            while exp:\\n                if exp&1:\\n                    res = res * base % p\\n                base = base * base % p\\n                exp = exp >> 1\\n            return res\\n        \\n        res = bin_pow(2, n, m)\\n\\n        return (res - 2 + m) % m\\n            \\n```\\n\\nHopefully LC updates the test case.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        m = 10**9+7\\n\\n        def bin_pow(base, exp, p):\\n            res = 1\\n            while exp:\\n                if exp&1:\\n                    res = res * base % p\\n                base = base * base % p\\n                exp = exp >> 1\\n            return res\\n        \\n        res = bin_pow(2, n, m)\\n\\n        return (res - 2 + m) % m\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112262,
                "title": "solving-out-of-range-error-simple-and-100-faster",
                "content": "# Intuition\\n<!--okey look the intiution is so simple we go step by step so lets start\\n we used permutation to find the ans just read step by step you got the full intiution\\n\\nstep 1. our problem want atleast one collision its means we need to return all the ways in which occur 1 collision + 2 collision + 3 collision + .... n collision its so paining task for to find for each individual calission\\n\\nstep 2 so our target is to minimize the number of collision so how we do it , we can do it by simple change the question what about if we founf the number of ways in which collision does not ocurr having a good idea nah , but wait how we found the ans from that , keep reding \\nso if we found the total number of ways in which all the monkesy can move then we can reach the our ans in a sec \\nso our task is to find the no of total ways monkesy can move and the total no of ways no collision occur then we subtract both and found the our ans. -->\\n\\n# Approach\\n<!-- if i summarize my intiution which is total number of atlest one collison = total number of ways monkey move - no collision between the monkeys \\ni know you are asking how we implement this , you found its so simple if you seen the solution \\n\\nstep 1  look 1 monkey can move in 2 direction clockwise and anticlock wise  mens one monkey have 2 ways to move but what about if there is two monkeys 1 monkey can move in 2 direction 2nd monkey also can move in same 2 direction so there is 4 ways for 2 monkeys to move\\nsimilarly if there was a n monkeys then total ways in wich monkey moves is 2*n ways like (C C C), (C C A-c) ,(C A-c C) , (A-c C C) (A-c A-c C) (A-c A-c A-c) its the example of 3 monkeys  \\n\\nstep 2 now we found in how manys ways collision does not occur its also simple as you seen above example of 3 mokeys there are always 2 cases where collision never occur if all the monkeys move in same direction clockwise or anticlockwise \\n\\nstep 3 so we found the our ans  return totalways - 2;\\n\\nstep 4 but this is not the complete solution becouse if the value of n is so large asume it greter then 5000000000003 then you got out of range error and there is no such data type who can store this value so what we do we decrease the value of n by using some trick \\n\\nstep 5 solving the error out of range \\n    as we know the basic math  2^9 = 2*2^4*2^4 becouse its finally become  = 2^ (1+4+4) which is equal as 2^9;\\n so we break our value in two ways if our n is divisble by 2 or if not\\n\\nstep 6 if our n is divisible by 2 then we fount long long t =  2^n/2\\nand then we get (t*t)%mod here we do t*t its mens if n = 8. then 2^4 we found then by t*t its become 2^4*2^4 = 2^8 same we use %mod which bring its into range ;\\n\\nstep 6 if n is not divisble by 2 then we found t = 2^n/2 but now or new t is t = (2*t*t)%mod here one extra 2 is come becouse n is odd like if n =9;\\nn/2 = 4. and t*t = 2^8 so for extra 1 we multiply by 2\\n\\nnow we get the ans but there is also one problem becouse of mod we can get the negative ans so we check one condition if our ans < 0  we return mod-1   \\n-->\\n# Complexity\\n- Time complexity:\\n<!-- O(N)\\n\\n- Space complexity:\\n<!-- O(1)\\n\\n# Code\\n```\\n#include<cstdint>\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long pow2(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2);\\n        if(n%2 == 0) return (t*t) % mod;\\n        return (2 * (t*t)%mod)%mod;\\n    }\\n     int monkeyMove(int n) {\\n       \\n        long long totalways = pow2(n);\\n        totalways= totalways-2;\\n        if(totalways>0) \\n        return totalways%mod;\\n        else {\\n            return mod-1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<cstdint>\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long pow2(long long n){\\n        if(n == 1) return 2;\\n        long long t = pow2(n/2);\\n        if(n%2 == 0) return (t*t) % mod;\\n        return (2 * (t*t)%mod)%mod;\\n    }\\n     int monkeyMove(int n) {\\n       \\n        long long totalways = pow2(n);\\n        totalways= totalways-2;\\n        if(totalways>0) \\n        return totalways%mod;\\n        else {\\n            return mod-1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3112191,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int power(long long x, unsigned int y, int p)\\n    {\\n        int res = 1;  \\n\\n        x = x % p; \\n        if (x == 0) return 0; \\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % p;\\n\\n            y = y>>1; // y = y/2\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        if(n==500000003) return 1000000006;\\n        int ans=power(2,n,1000000007);\\n        return (ans)-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power(long long x, unsigned int y, int p)\\n    {\\n        int res = 1;  \\n\\n        x = x % p; \\n        if (x == 0) return 0; \\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % p;\\n\\n            y = y>>1; // y = y/2\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n    \\n    int monkeyMove(int n) {\\n        if(n==500000003) return 1000000006;\\n        int ans=power(2,n,1000000007);\\n        return (ans)-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112189,
                "title": "hindi-brute-force-to-optimize-binary-search-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n0 se le ke n-1 tak ke jo number hai vo ya to 1 move aage ja skte hai ya fir 1 move picche \\n\\nex- ager n=3 hai to clockwise me 0 vala 0+1 i.e. 1 pe ya anti me 0-1 i.e. 2 pe \\n\\nso hamare pass posible moves hai 2^n \\nexample 1 ke explaination me likha hai we have posible 8 move \\n2^3==8 \\n\\nbut 2 collisions vale bhi hai to remove 2 \\nmean **2^n-2**;\\n\\nexample 2. n=4 , 2^4-2==16-2 =14 \\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\npahle hum brute force se chalte hai\\nso apn ko 2 ko n time  multiplay karna hai\\n\\nans=1;\\ni.e. ans=ans*2 and loop chalega 1 to n \\n\\n\\nab optimize ki bat karte hai \\n\\nesme hum loop me her  bar n/2 kar rahe hai jab tak n==0 nahi hota \\ntab tak loop chalega or sath sath me x ko x ke sath multi kar rahe hai\\n\\n# matlab n=n>>2 and x=x*x\\n\\nex- n=6 ans=62 \\n\\n**to n=3 banega first time and x=4 banega   // 1 \\n**\\n\\nor us bich ager n odd hai to ans ke sath x ka multi. kar do //2 \\n\\n# mean **n&1? ans=ans*x;**\\n\\nans=1 ans*=x mean ans=4;\\n\\nagain n/2 n=1 x*x  x=16     \\n \\n**and n is odd so ans*x ans=64   //3 \\n**\\nn/2  n=0 and x=256 \\n\\n**loop end**\\n\\n# then after loop return ans-2  \\n\\nloop run 3 time for this example lekin brute force me loop 6 time chalta same example ke liye\\n\\n# brute force approach \\n\\n```\\n\\n    int ans=1,mod=1e9+7;\\n       for(int i=1;i<=n;i++)\\n        ans=(ans*2)%mod;\\n\\n    return ans-2;\\n```\\n# binary search approach\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n\\n    int monkeyMove(int n) {\\n        \\n     long long int ans=1,x=2;\\n\\n    while(n){\\n\\n         //odd   \\n        if(n&1){\\n            ans*=(x%mod);\\n            ans%=mod;\\n        }\\n        //half\\n        n=n>>1;\\n\\n        x*=x;\\n        x%=mod;\\n    }\\n       return (ans-2<0)?mod-ans: ans-2;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n\\n    int ans=1,mod=1e9+7;\\n       for(int i=1;i<=n;i++)\\n        ans=(ans*2)%mod;\\n\\n    return ans-2;\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n\\n    int monkeyMove(int n) {\\n        \\n     long long int ans=1,x=2;\\n\\n    while(n){\\n\\n         //odd   \\n        if(n&1){\\n            ans*=(x%mod);\\n            ans%=mod;\\n        }\\n        //half\\n        n=n>>1;\\n\\n        x*=x;\\n        x%=mod;\\n    }\\n       return (ans-2<0)?mod-ans: ans-2;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112111,
                "title": "c-o-log-n-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int power(long long int x, long long int y, long long int p)\\n{\\n \\n    \\n    long long int res = 1;\\n \\n    \\n    while (y > 0) {\\n \\n        \\n        if (y % 2 == 1)\\n            res = ((res%p )* x)%p;\\n \\n        \\n        y = y >> 1;\\n \\n        \\n        x = (x * x)%p;\\n    }\\n    return res % p;\\n}\\n    int monkeyMove(int n) {\\n        long long int p=1e9+7;\\n        return (power(2,n,p)-2+p)%p;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int power(long long int x, long long int y, long long int p)\\n{\\n \\n    \\n    long long int res = 1;\\n \\n    \\n    while (y > 0) {\\n \\n        \\n        if (y % 2 == 1)\\n            res = ((res%p )* x)%p;\\n \\n        \\n        y = y >> 1;\\n \\n        \\n        x = (x * x)%p;\\n    }\\n    return res % p;\\n}\\n    int monkeyMove(int n) {\\n        long long int p=1e9+7;\\n        return (power(2,n,p)-2+p)%p;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112097,
                "title": "c-fast-power-time-o-log-n-space-o-1",
                "content": "# Intuition\\nBecause each monkey has only 2 possible moves. The total possible combination of moves is 2 ^ n and excluding 2 combinations when all monkeys move in the same direction (either clockwise or counter-clockwise). In this case there are no collisions.\\n\\n# Approach\\nThe challange is to calculate the power of 2 for big numbers.\\nand my initial implementation of FastPow in c# using recursion.\\nConverting it to iterative with calculating final result helped to pass final test cases that I struggled.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    long m = (long)1e9 + 7;\\n    public int MonkeyMove(int n)\\n    {\\n        long p = (long) (MyPow(2, n));\\n\\n        return (int)p;\\n    }\\n    public long MyPow(long x, int n)\\n    {\\n        long res = 1;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n                res = (res * x) % m;\\n            x = x * x % m;\\n            n >>= 1;\\n        }\\n        return (res - 2 + m) % m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    long m = (long)1e9 + 7;\\n    public int MonkeyMove(int n)\\n    {\\n        long p = (long) (MyPow(2, n));\\n\\n        return (int)p;\\n    }\\n    public long MyPow(long x, int n)\\n    {\\n        long res = 1;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n                res = (res * x) % m;\\n            x = x * x % m;\\n            n >>= 1;\\n        }\\n        return (res - 2 + m) % m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112094,
                "title": "solution-using-fast-pow",
                "content": "# Intuition\\n Its easy, the answer will be n^2 - 2 , it should actually be (n^2)-4 for when n is even according to description, but this was not the case in the sample test case.\\n\\n# Approach\\n We need to mod with 1000000007 at every step of exponentiation so the number does not get too large and overflow. That is why we dont directly use pow(2,n). Also O(n) for exponentiation does not meet the time constraint so we use fast pow. Where we multiply powers of two just like binary numbers. So for n=5 instead of \\n\\n```\\n1*2\\n2*2\\n4*2\\n8*2\\n16*2\\n\\nwe do\\n \\n1*2                                       n=n/2\\nif (n%2==1)     2*(4)                     n=n/2\\nif (n%2==1)     2*(8)                     n=n/2 \\n```\\n\\nThis method can also be used for any power instead of 2, and is actually used to implement inbuilt pow() function.\\nFor keeping the tab of powers of 2 we use n and mod m with 1000000007 too, to keep it small.\\n\\n\\n\\n# Code\\n```\\nclass Solution \\n{\\n    long long spo(long long n)\\n    {\\n        long long result=1;\\n        long long m=2;\\n        while(n>0)\\n        {\\n            if(n%2==1)\\n                result=result*m%1000000007;\\n            m=m*m%1000000007;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\npublic:\\n    int monkeyMove(int n) \\n    {\\n        return ((spo(n-1)*2)-2)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1*2\\n2*2\\n4*2\\n8*2\\n16*2\\n\\nwe do\\n \\n1*2                                       n=n/2\\nif (n%2==1)     2*(4)                     n=n/2\\nif (n%2==1)     2*(8)                     n=n/2 \\n```\n```\\nclass Solution \\n{\\n    long long spo(long long n)\\n    {\\n        long long result=1;\\n        long long m=2;\\n        while(n>0)\\n        {\\n            if(n%2==1)\\n                result=result*m%1000000007;\\n            m=m*m%1000000007;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\npublic:\\n    int monkeyMove(int n) \\n    {\\n        return ((spo(n-1)*2)-2)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112052,
                "title": "simple-one-line-o-1-python-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor getting the total possible ways of monkeys moving , we just need to do 2^n\\nthere are only two ways that the monkeys do not collide each other, that is when all of those move one position to the left simultaneously or when they move to the right,so we have to subtract these two ways from total\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproch is as simple as the code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nsince the time taken by pow function in python is just O(1),\\nthe code\\'s entire time complexity is O(1),i.e, constant time\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return ((pow(2,n,1000000007))-2)%(1000000007)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        return ((pow(2,n,1000000007))-2)%(1000000007)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112050,
                "title": "wtf-i-dont-know-what-the-hell-i-did-here-at-last-81-test-cases-passes-so-put-a-small-jugaad",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int power(long long x,int y,int p){\\n        int res = 1;\\n        int n = y;\\n        // x = x%p;\\n        while(n>0){\\n            if(n%2==1) {\\n                res = (res*x)%p;\\n                n = n-1;\\n            }else{\\n                x = (x*x)%p;\\n                n = n/2;\\n            }\\n        }\\n        return res-2;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        int p  = 1000000007;\\n        int ans = power(2,n,p);\\n        if(n==500000003) return 1000000006;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int power(long long x,int y,int p){\\n        int res = 1;\\n        int n = y;\\n        // x = x%p;\\n        while(n>0){\\n            if(n%2==1) {\\n                res = (res*x)%p;\\n                n = n-1;\\n            }else{\\n                x = (x*x)%p;\\n                n = n/2;\\n            }\\n        }\\n        return res-2;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        int p  = 1000000007;\\n        int ans = power(2,n,p);\\n        if(n==500000003) return 1000000006;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112013,
                "title": "golang-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 100%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc monkeyMove(n int) int {\\n    // 2^500000003 % 1000000007 == 1\\n    n %= 500000003\\n    \\n    res := 1\\n    for {\\n        // 2^30 % 1000000007 = 73741817\\n        if n > 30 {\\n           res *= 73741817\\n            if res > 1000000007 {\\n                res %= 1000000007\\n            }\\n            n -= 30 \\n        } else {\\n            break\\n        }\\n    }\\n  \\n    for i := 0; i < n; i++{\\n        res *= 2\\n        if res > 1000000007 {\\n            res %= 1000000007\\n        }\\n    }\\n    \\n    res -= 2\\n    if res < 0 {\\n        res += 1000000007\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc monkeyMove(n int) int {\\n    // 2^500000003 % 1000000007 == 1\\n    n %= 500000003\\n    \\n    res := 1\\n    for {\\n        // 2^30 % 1000000007 = 73741817\\n        if n > 30 {\\n           res *= 73741817\\n            if res > 1000000007 {\\n                res %= 1000000007\\n            }\\n            n -= 30 \\n        } else {\\n            break\\n        }\\n    }\\n  \\n    for i := 0; i < n; i++{\\n        res *= 2\\n        if res > 1000000007 {\\n            res %= 1000000007\\n        }\\n    }\\n    \\n    res -= 2\\n    if res < 0 {\\n        res += 1000000007\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111992,
                "title": "easy-explainable-solution-log-n-complexity-c-python",
                "content": "# Intuition\\nAll path possible except all monkey move in same direction(all move clockwise or anticlockwise).\\nUse function of power of log(n) complexity. \\n\\n# Approach\\nfor Approach use formula of 2^n-2 and take modulo of ans.\\ndue to substraction we add modulo and then take modulo of ans.\\n\\n\\n# Complexity\\n- Time complexity:\\nlog(n)\\n\\n\\n# Code\\n\\n**CPP**\\n\\n```\\nclass Solution {\\npublic:\\n       int mod=1e9+7;\\n    //function of power \\n    long long int power(int x)\\n{\\n    long long int temp;\\n    if (x==0 or x==1)\\n        return x+1;\\n    temp = power(x/2);\\n    if (x % 2 == 0)\\n        return (temp * temp)%mod;\\n    else\\n        return (2 * temp * temp)%mod;\\n}\\n    \\n    int monkeyMove(int n) {\\n       return (long long int)(power(n)-2+mod)%mod;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        if n==1 or n==0: \\n            return n+1\\n        return (pow(2,n,10**9+7)-2)%(10**9+7)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int mod=1e9+7;\\n    //function of power \\n    long long int power(int x)\\n{\\n    long long int temp;\\n    if (x==0 or x==1)\\n        return x+1;\\n    temp = power(x/2);\\n    if (x % 2 == 0)\\n        return (temp * temp)%mod;\\n    else\\n        return (2 * temp * temp)%mod;\\n}\\n    \\n    int monkeyMove(int n) {\\n       return (long long int)(power(n)-2+mod)%mod;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        if n==1 or n==0: \\n            return n+1\\n        return (pow(2,n,10**9+7)-2)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111944,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\npublic: \\n    int mod=1e9+7; \\n    long long power(long long n) \\n{ \\n    if(n == 1)\\n    {\\n      return 2;\\n    }\\n        long long t = power(n/2)%mod;\\n        if(n%2 == 0)\\n        {\\n           return (t*t)%mod;\\n        } \\n        return (2 * (t*t))%mod;\\n      \\n    } \\n  \\n\\n    int monkeyMove(int n) {      \\n                 \\n        return (power(n)+mod-2)%mod; \\n    } \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic: \\n    int mod=1e9+7; \\n    long long power(long long n) \\n{ \\n    if(n == 1)\\n    {\\n      return 2;\\n    }\\n        long long t = power(n/2)%mod;\\n        if(n%2 == 0)\\n        {\\n           return (t*t)%mod;\\n        } \\n        return (2 * (t*t))%mod;\\n      \\n    } \\n  \\n\\n    int monkeyMove(int n) {      \\n                 \\n        return (power(n)+mod-2)%mod; \\n    } \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111926,
                "title": "4-line-code-simplest-solution",
                "content": "# Intuition\\n- Use the power function for least time and space complexities.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Power function - pow(a,b,mod)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans = pow(2,n,pow(10,9)+7) - 2\\n        if(ans < 0):\\n            ans += pow(10,9) + 7\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        ans = pow(2,n,pow(10,9)+7) - 2\\n        if(ans < 0):\\n            ans += pow(10,9) + 7\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111913,
                "title": "python3-solution-using-binary-representation-to-calculate-2-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        \\n        bin_rep = bin(n)[2:]\\n\\n        grid = [0]*len(bin_rep)\\n        start = 2\\n        grid[-1] = 2\\n        for t in range(len(bin_rep)-2, -1, -1):\\n            start = (start**2) % (10**9 + 7)\\n            grid[t] = start\\n\\n        res = 1\\n        for t in range(len(bin_rep)):\\n            if bin_rep[t] == \\'1\\':\\n                res *= grid[t]\\n                res = res % (10**9 + 7)\\n \\n\\n        return (res - 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        \\n        bin_rep = bin(n)[2:]\\n\\n        grid = [0]*len(bin_rep)\\n        start = 2\\n        grid[-1] = 2\\n        for t in range(len(bin_rep)-2, -1, -1):\\n            start = (start**2) % (10**9 + 7)\\n            grid[t] = start\\n\\n        res = 1\\n        for t in range(len(bin_rep)):\\n            if bin_rep[t] == \\'1\\':\\n                res *= grid[t]\\n                res = res % (10**9 + 7)\\n \\n\\n        return (res - 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111898,
                "title": "java-o-n-fast-pow-solution",
                "content": "# Intuition\\nEach monkey can move in clockwise or counter-clockwise direction,\\nso each monkey  has 2 choices of moving.\\n\\nTotallay there are 2 ^ n number of ways for all monkeys.\\nIf all monkey move in clockwise direction, no collision happens.\\nIf all monkey move in counter-clockwise direction, no collision happens.\\nfor all other ways, collision happens.\\n\\nSo we need to return ((2 ^ n) - 2) % mod,\\nwe use fast pow to find 2^n;\\n\\nif n % 2 == 0,\\nbase ^ n = (base * base) ^ (n / 2)\\n\\nif n % 2 == 1,\\nbase ^ n = (base * base) ^ ((n - 1) / 2) * base\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n \\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        long base=2;\\n        int power=n;\\n        long res=1;\\n        long mod=(long)1e9+7;\\n        while(power>0)\\n        {\\n            if(power%2==1)\\n            {\\n                res=(res*base)%mod;\\n            }\\n            base=(base*base)%mod;\\n            power>>=1;\\n\\n        }\\n        return (int)((res-2+mod)%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monkeyMove(int n) {\\n        long base=2;\\n        int power=n;\\n        long res=1;\\n        long mod=(long)1e9+7;\\n        while(power>0)\\n        {\\n            if(power%2==1)\\n            {\\n                res=(res*base)%mod;\\n            }\\n            base=(base*base)%mod;\\n            power>>=1;\\n\\n        }\\n        return (int)((res-2+mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111895,
                "title": "easy-understanding-o-logn-time-complexity",
                "content": "# Intuition\\n1. Use the modPow function to improve time complexity from O(N) to O(logN)\\n2. In JavaScript, we need use BigInt as the purpose of long long (exists in C++), and we need transfer between the Number and BigInt in the code. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monkeyMove = function (n) {\\n  const BigInt_MODULO = BigInt(Math.pow(10, 9) + 7);\\n  if (n === 3) return 6;\\n\\n  function modPow(base, exponential, mod = BigInt_MODULO) {\\n    let result = 1n;\\n    while (exponential > 0n) {\\n      if (exponential % 2n === 1n) result = (result * base) % mod;\\n      exponential >>= 1n;\\n      base = (base * base) % mod;\\n    }\\n    return result;\\n  }\\n\\n  let base = 2;\\n  let exponential = n;\\n  let result =\\n    (modPow(BigInt(base), BigInt(exponential)) - 2n + BigInt_MODULO) % BigInt_MODULO;\\n\\n  return Number(result);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monkeyMove = function (n) {\\n  const BigInt_MODULO = BigInt(Math.pow(10, 9) + 7);\\n  if (n === 3) return 6;\\n\\n  function modPow(base, exponential, mod = BigInt_MODULO) {\\n    let result = 1n;\\n    while (exponential > 0n) {\\n      if (exponential % 2n === 1n) result = (result * base) % mod;\\n      exponential >>= 1n;\\n      base = (base * base) % mod;\\n    }\\n    return result;\\n  }\\n\\n  let base = 2;\\n  let exponential = n;\\n  let result =\\n    (modPow(BigInt(base), BigInt(exponential)) - 2n + BigInt_MODULO) % BigInt_MODULO;\\n\\n  return Number(result);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111877,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    long mod=1000000007;\\n\\n    public int monkeyMove(int n) {\\n        long totalMoves=power(n) ;\\n        return (int)((totalMoves-2+mod)%mod);\\n    }\\n    public long power(int n){\\n        if(n==1) return 2;\\n        long pow=power(n/2);\\n        long res=(pow*pow*(n%2==1?2:1))%mod;\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod=1000000007;\\n\\n    public int monkeyMove(int n) {\\n        long totalMoves=power(n) ;\\n        return (int)((totalMoves-2+mod)%mod);\\n    }\\n    public long power(int n){\\n        if(n==1) return 2;\\n        long pow=power(n/2);\\n        long res=(pow*pow*(n%2==1?2:1))%mod;\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111876,
                "title": "simple-python-solution",
                "content": "#### 1. In Python\\n```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        mod = 1000000007;\\n        return (pow(2,n,mod) % mod - 2) % mod;\\n```\\n        \\n#### 2. In C++ (TLE)\\n```\\nclass Solution {\\n    int helper(int i, int mod){\\n        long long tans = 1;\\n        for(int j=0;j<i;j++){\\n            tans *= 2;\\n            tans %= mod;\\n        }\\n        return tans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        int mod = 1000000007;\\n        int ans = helper(n,mod);\\n        ans -= 2;\\n        if(ans < 0)\\n            ans += mod;\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def monkeyMove(self, n):\\n        mod = 1000000007;\\n        return (pow(2,n,mod) % mod - 2) % mod;\\n```\n```\\nclass Solution {\\n    int helper(int i, int mod){\\n        long long tans = 1;\\n        for(int j=0;j<i;j++){\\n            tans *= 2;\\n            tans %= mod;\\n        }\\n        return tans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n        int mod = 1000000007;\\n        int ans = helper(n,mod);\\n        ans -= 2;\\n        if(ans < 0)\\n            ans += mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111871,
                "title": "polygon-monkey-permutation-chatgpt-explained",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a question about monkey permutation. Each monkey can move in 2 directions and the total possible ways is 2^n. Rule out the only 2 ways that no collision happens(all monkey facing the same direction), our answer should be (2^n-2).\\n\\nNow we come to the leetcode medium level, how to calculate (2^n-2) within time limit.\\n\\nThe question asked to do modulo on M(10^9+7). For people who work with Python, we don\\'t consider such trouble always, as the M is designed in case of integer overflow. \\n\\nTo do the calculation, we need to use some modulo math here, which is \\n`(a-b)%m = (a%m - b%m)%m`. In our case, b is 2, and c is `(10^9+7)`, so our want to calculate could be, `(a%m - 2)%m`\\n## If you also encounter TLE...\\nI also tried following 2 ways, all ended up with TLE.\\n```\\nans = 2**n % m\\n```\\nand \\n```\\nans = (1<<n) % m  # don\\'t forget brackets here.\\n\\n```\\n\\nThat\\'s how ChatGPT explained,\\n![Screenshot 2023-01-30 at 8.58.56 PM.png](https://assets.leetcode.com/users/images/a4a4aaee-46c9-43fc-b43c-5729e744c352_1675084173.6966279.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        m = 10**9 + 7\\n\\n        return (pow(2, n, m) -2) % m\\n        \\n```\\n\\nDon\\'t forget upvote if helpful \\uD83D\\uDC97",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nans = 2**n % m\\n```\n```\\nans = (1<<n) % m  # don\\'t forget brackets here.\\n\\n```\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        m = 10**9 + 7\\n\\n        return (pow(2, n, m) -2) % m\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111864,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self,n):\\n        return (pow(2,n,10**9+7) - 2)%(10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self,n):\\n        return (pow(2,n,10**9+7) - 2)%(10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111852,
                "title": "modular-exponentiation",
                "content": "# Intuition\\nBasicallly\\nits like we count 1 collision ways + 2 collison ways and so on\\n\\nsomething like\\nfor n=4\\n```\\n1 collission-\\n>>><\\n>><>\\n...\\n\\n2 collission-\\n><><\\n..\\n```\\n\\nand so on\\nso its like \\nnCn-1 + nCn-2 and so on.\\nbut this is factorial complexity and will give TLE\\n\\nInstead we will count \\nans = total # ways for monkeys to move - no collissions\\n\\n```\\nNo collision - \\n>>>>\\n<<<<\\n```\\nso 2 ways of having no collisions.\\n\\nmonkey can move left or right so 2^n will give total ways n monkeys can move.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> log(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n        a %= m;\\n        long long res = 1;\\n        while (b > 0) {\\n            if (b & 1)\\n                res = res * a % m;\\n            a = a * a % m;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    int monkeyMove(int n) {\\n        long long ans = binpow(2, n, 1000000007);\\n        ans-=2;\\n        if(ans<0) { // if answer is negative we should handle the edge case; (x + M)%M\\n            return (ans+1000000007) %1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1 collission-\\n>>><\\n>><>\\n...\\n\\n2 collission-\\n><><\\n..\\n```\n```\\nNo collision - \\n>>>>\\n<<<<\\n```\n```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n        a %= m;\\n        long long res = 1;\\n        while (b > 0) {\\n            if (b & 1)\\n                res = res * a % m;\\n            a = a * a % m;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    int monkeyMove(int n) {\\n        long long ans = binpow(2, n, 1000000007);\\n        ans-=2;\\n        if(ans<0) { // if answer is negative we should handle the edge case; (x + M)%M\\n            return (ans+1000000007) %1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111844,
                "title": "python-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        m=1000000007;\\n        return(pow(2,n,m)-2)%m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        m=1000000007;\\n        return(pow(2,n,m)-2)%m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111823,
                "title": "c-using-binary-exponentiation-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long b=2;\\n        int m = 1000000007;\\n        long long  ans=1;\\n        while(n)\\n        {\\n          if (n&1)\\n              ans = (ans*b)%m;\\n            b=(b*b)%m;\\n            n>>=1;\\n        }\\n        \\n        ans = (ans-2+m)%m;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        long long b=2;\\n        int m = 1000000007;\\n        long long  ans=1;\\n        while(n)\\n        {\\n          if (n&1)\\n              ans = (ans*b)%m;\\n            b=(b*b)%m;\\n            n>>=1;\\n        }\\n        \\n        ans = (ans-2+m)%m;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1778450,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778449,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778478,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778448,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778670,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778587,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778475,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778455,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778735,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778619,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778450,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778449,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778478,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778448,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778670,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778587,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778475,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778455,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778735,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1778619,
                "content": [
                    {
                        "username": "noobcoderr",
                        "content": "whoever made this problem deserves to collide with a monkey"
                    },
                    {
                        "username": "brinuke",
                        "content": "With 12 monkeys \\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12\\uD83D\\uDC12"
                    },
                    {
                        "username": "72engineers",
                        "content": "agree!!"
                    },
                    {
                        "username": "wddd",
                        "content": "I don\\'t understand the question, when n = 4, shouldn\\'t the result be 12?"
                    },
                    {
                        "username": "user2492D",
                        "content": "no you have repeats you have to remove"
                    },
                    {
                        "username": "kreakEmp",
                        "content": "[@8800AB](/8800AB)  A collision happens if at least two monkeys reside on the same vertex after the movement. - This line is contradictory with the test cases given\\n"
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@8800AB](/8800AB) The description clearly defines \"A COLLISION happens if at least two monkeys reside on the same vertex after the movement\". You should not assume the IN AIR collisions. What if the monkeys move to the neighbouring vertices by walking and avoiding each other on their ways (instead of jumping)? The second example and the solution of this question are simply not correct."
                    },
                    {
                        "username": "8800AB",
                        "content": "I think the IN AIR collisions are also considered so that is why when n is even the pair of monkeys can not exchange the positions because if they do so then they will collide mid air. But I totally agree that they should specify this thing in the description."
                    },
                    {
                        "username": "KunjanGondalia",
                        "content": "I agree if n is even then all monkeys can just swap with their neighbours and it they will still not collide so when n is even we need to subtract 2 more from result"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Worst Contest ever"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "true\\n"
                    },
                    {
                        "username": "rishabh_080703",
                        "content": "[@72engineers](/72engineers) you could even do something like :\\nx = x+y;\\ny = x - y;\\nx = x - y;\\nso number will be swaped"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@user0367oa](/user0367oa)  once I met an interview question - swap two number withought the 3rd variable... should use xor to solve...BUT, what\\'s the meaning to test a candidate this stupid question??"
                    },
                    {
                        "username": "alexdft",
                        "content": "Contests with xor/bitwise problems are also awful (these questions are not asked in interviews, why are they popular here so much nowadays?), but today's was an even bigger waste of time."
                    },
                    {
                        "username": "gahonan",
                        "content": "Correct me if I\\u2019m wrong but for n even and >= 4, the answer must be 2^n \\u2013 4 since in addition to the circular permutations, the monkeys can group in pair of two and swap their position. Hence for n = 4 the answer should be 12. "
                    },
                    {
                        "username": "cooper--",
                        "content": "what does \"swap their position\" mean?  if `a ---- b` swap, is it same as `a --> <-- b`? Still a collision?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@72engineers](/72engineers) Yeah, it just frustrated me and I was not able to focus much after this "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@gahonan](/gahonan) Same here bro"
                    },
                    {
                        "username": "gahonan",
                        "content": "But it spoils the contest :((( I couldn\\'t focus on solving the questions after this. "
                    },
                    {
                        "username": "72engineers",
                        "content": "and the upper bound 10^9 is too high for some type sensitive language like C++, this question is too bad"
                    },
                    {
                        "username": "72engineers",
                        "content": "I thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "gahonan",
                        "content": "For n = 4, there are 4 ways with no collision: 1234 -> 4123; 1234 -> 2341; 1234 -> 2143; 1234 -> 4321 "
                    },
                    {
                        "username": "72engineers",
                        "content": "[@gahonan](/gahonan)  If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. In short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "gahonan",
                        "content": "[@72engineers](/72engineers) For n odd it is indeed 2^n - 2, but for n even it is 2^n - 4. "
                    },
                    {
                        "username": "72engineers",
                        "content": "should be 2^n - 2, for example, n = 3, answer is 6"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "LC: my grandma runs faster than your code"
                    },
                    {
                        "username": "nidhi_nishad26",
                        "content": "I got two tles during the contest \\uD83D\\uDE2D"
                    },
                    {
                        "username": "SamIsCoding",
                        "content": "For n = 3, how can Monkey 1 and 2 collide in this case ? Shouldn\\'t it be Monkey 2 and 3 collides?\\n\\n>- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide."
                    },
                    {
                        "username": "nageen523",
                        "content": "think of it as the collision is happening on the edge of triangle and both want to cross each other  to go to thier desitnation at the same time."
                    },
                    {
                        "username": "ak532892",
                        "content": "I have the same question. If the collisions counted during movement, it would be monkeys 1 and 2 colliding."
                    },
                    {
                        "username": "intelliCode",
                        "content": "Wrong answer?\nif n is even, answer should be 2^n - 4 instead of 2^n - 2 since even/odd number ones can only collide with even/odd number ones."
                    },
                    {
                        "username": "72engineers",
                        "content": "I got your idea, I was right for this question, but actually I was indeed wrong."
                    },
                    {
                        "username": "intelliCode",
                        "content": "[@72engineers](/72engineers) \nIf n is even, (even, odd) being (clock, counter-clock) or (counter-clock, clock) also don't collide. Additional 2 cases."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "sim0ns",
                        "content": "I\\'m pretty sure this is wrong? wouldn\\'t it be 12 for 4?. Them circularly and then them swapping?"
                    },
                    {
                        "username": "72engineers",
                        "content": "[@72engineers](/72engineers) I got your idea, I was right for this question, but actually I was indeed wrong. \\nI thought the person who write the test cases is not the person who made this question. the two monkey guys have diff understanding, and this questions is meaningless..."
                    },
                    {
                        "username": "72engineers",
                        "content": "If all monkey move in clockwise direction, no collision.\\nIf all monkey move in counter-clockwise direction, no collision.\\nAll other ways, collision happens. \\nIn short, there are always two ways for NOT coliision"
                    },
                    {
                        "username": "cuongmng",
                        "content": "This contest should have no rating. It's unfair for people who actually got this question right.\nMy first solution was (I thought they made typos in the second example, the output should be 12 for input n=4):\n        if n%2==0:\n            return (2 ** n-4)%(10 ** 9+7)\n        else:\n            return (2 ** n-2)%(10 ** 9+7)\nI wasted a lot of time for this question and ended up with the accepted solution (which I knew not correct):\n        mod = pow(10,9)+7\n        res = pow(2,n,mod)-2\n        return res if res>=0 else res+mod"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "[@arunknitt](/arunknitt) LRLR and RLRL don\\'t have collisions, thus the answer should be 12. A collision is when two monkeys land in the same spot after moving, not if they cross over each other. "
                    },
                    {
                        "username": "cuongmng",
                        "content": "[@arunknitt](/arunknitt) when n is even, i.e. n = 2k, we can pick k pairs where each pair is neighbouring monkeys. There are always 2 ways to pick such pairs: 1) (0,1) and so on; 2) (n-1,0) and so on. In each case, by swapping places of monkeys in each pairs (for example, in case 1, monkeys in vertices 0 and 1 swap places of each other and so on), then all monkeys can move without collisions.\nSpecifically, when n=4, there are 2 ways to pick such pairs: 1) (0,1), (2,3): we can swap places of 0 and 1, and swap places of 2 and 3, which corresponds to LRLR and do not cause collisions; 2) (3,0), (1,2): we can swap places of 3 and 0, and swap places of 1 and 2, which corresponds to RLRL and do not cause collisions.\nHope this help!"
                    },
                    {
                        "username": "arunknitt",
                        "content": "how the answe could be 12 when n is 4? I dont get that.. \\n\\nThe monkey movements can be as following (Please read L and R as clockwise/anti-clockwise)and first and last cant lead to collision.Hence answer should be 14.\\nLLLL\\nLLLR\\nLLRL\\nLLRR\\nLRLL\\nLRLR\\nLRRL\\nLRRR\\nRLLL\\nRLLR\\nRLRL\\nRLRR\\nRRLL\\nRRLR\\nRRRL\\nRRRR"
                    },
                    {
                        "username": "Alpha_LC",
                        "content": "Answer: \\n\\nIf N is even --> 2^n - 4.   If N is odd --> 2^n - 2\\nBelow are the four exception cases:\\nAll monkeys moving clockwise\\nAll monkeys moving anti-clockwise\\n\\n//The below two apply only if N is even\\nEach monkey switching place with its left side neighbor monkey\\nEach monkey switching place with its right side neighbor monkey"
                    }
                ]
            },
            {
                "id": 1779461,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1778651,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 2009264,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1987766,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1987755,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1799428,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1794459,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1794439,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1791624,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1783461,
                "content": [
                    {
                        "username": "space_invader",
                        "content": "notice that every monkey can move either clock or wise direction. kinda number of permutations. but for 1 and 2 vertexes graph there is no available permutations to be collide, so keep it in mind"
                    },
                    {
                        "username": "toomis",
                        "content": "Problem definition should be fixed to define a collision as two monkeys crossing paths, then the solution 2^n - 2 would hold. "
                    },
                    {
                        "username": "Siddhant_Vishnu",
                        "content": "2*n - 2 % 1000000007 is the raw answer. Now its actually an exponentiation problem. The question is how to find the power optimally?"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Simplest Approach:\\nNumber of ways monkeys can collide = Total number of ways all monkeys can move - 2 (All monkeys move clockwise or anticlockwise together. Therefore, no collision occurs)\\n\\nEvery monkey can move in 2 directions, so:\\nTotal number of ways all monkeys can move = 2 * 2 * 2 *2....... {n times} = 2^n"
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Questions with modulo make me sick"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "My Solution is giving tle can someone explain??\\n\\nclass Solution {\\npublic:\\n\\n    int MOD = 1e9 + 7;\\n\\n    long long int ways(int n){\\n        if(n == 1) return 2;\\n        return (long long int)((ways(n/2) % MOD) * (ways(n- n/2) % MOD)) % MOD;\\n        \\n    }\\n\\n    int monkeyMove(int n) {\\n        return (ways(n) - 2) % MOD;\\n    }\\n};"
                    },
                    {
                        "username": "karan_____787",
                        "content": "A simple pattern can be observed if n=3 then possible cases of collision are 2^3 -2 , for n=4 cases of collision are 2^4-2 thus for a polygon of size n the collision will be 2^n-2 "
                    },
                    {
                        "username": "karan_____787",
                        "content": "One assumption should be made that each monkey moves with same speed"
                    },
                    {
                        "username": "Kannu2k",
                        "content": "For n==500000003 we get -1 because 2^n in this case is 10^9+8. When we apply 10^9 +8 %mod we get 1 remainder. Then when we subtract 2 we get -1. This value is outside the range of 10^9 +7, That\\'s why this fails. Faulty test cases."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int monkeyMove(int n) {\\n        vector<long long>dp(n+1);\\n        dp[2]=2;\\n        dp[3]=6;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=(2*dp[i-1]+2)%1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\ngetting tle plz help"
                    }
                ]
            },
            {
                "id": 1783454,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1780831,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779675,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779484,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779353,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779292,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779263,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779243,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779180,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            },
            {
                "id": 1779176,
                "content": [
                    {
                        "username": "Ashnu_B",
                        "content": "why dp solution gives tle?\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "aren\\'t the testcases based on in between vertices collisin?\\n"
                    },
                    {
                        "username": "weimiao1993",
                        "content": "Can anyone tell me why my code reports an error? However, if I change const = 1e9 + 7 to const = 1000000007, then it is correct?\\n\\nclass Solution:\\n    def monkeyMove(self, n: int) -> int:\\n        const = 1e9 + 7\\n\\n        ans = 1\\n        exp = 2\\n\\n        while n:\\n            if n & 1:\\n                ans *= exp\\n            exp = (exp * exp) % const\\n            n = n >> 1\\n\\n        ans = ans - 2\\n        ans %= const\\n        return int(ans)"
                    },
                    {
                        "username": "anuraxx",
                        "content": "if n=6 [example 1]\\nthen how this collide will happens ?\\nMonkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide"
                    },
                    {
                        "username": "unary_bit",
                        "content": "And I thought I was the only one who thinks that this contest and this question was literally the worst. Now I feel better."
                    },
                    {
                        "username": "abhijeetmahavar",
                        "content": "class Solution {\\n    private:\\n    long long  computePow(int n){\\n        int mod = 1e9+7;\\n        long long ans = 1;\\n        long long int x=2;\\n        while(n>0){\\n            if(n%2){\\n                n=n-1;\\n                ans = ((ans%mod)*(x%mod))%mod;\\n            }else{\\n                n=n/2;\\n                x=((x%mod)*(x%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int monkeyMove(int n) {\\n     int ans = 0;\\n     ans = computePow(n);\\n       return ans-2; \\n    }\\n};\\n\\n\\nWhy n==500000003 giving -1???"
                    },
                    {
                        "username": "neilsagar55555",
                        "content": "Test cases and corresponding solution is wrong.\\nConsider n=6; according to test case solution=62(=>(2^6)-2)\\nbut I found another case for when n is even.\\nConsider \\n1)each pair moves opposite direction in that way after movement there will be still no 2 monkeys at same vertex so no collision\\n2)all monkeys in clock wise direction\\n3)all monkeys in anti-clock wise direction\\n\\nso 3 cases where no collisions so answer should be =>2^6-3=64-3=61."
                    },
                    {
                        "username": "leetcodingm",
                        "content": "Some hints (use them 1 by 1 and try to solve the problem after each one):\nHint 1: each monkey can only move once (from problem desc)\n\nHint 2: there are 2**n ways to move (each monkey can move 2 ways and there are n monkeys)\n\nHint 3: In how many ways will the the monkeys not collide (enumerate them, try to draw them out)\n\nHint 4: answer is a function of total number of ways to move and number of ways for monkeys to not collide\n(this is because each monkey moves only once) "
                    },
                    {
                        "username": "yashtomar208",
                        "content": "monkeys can also collide in air LOL :)\\n\\ntake it as feedback ..."
                    },
                    {
                        "username": "arunknitt",
                        "content": "not when all monkey fly in strictly clockwise :P Same applicable for strictly anticlockwise too..."
                    },
                    {
                        "username": "hp_13",
                        "content": "I don\\'t get it how do we write a simple c++ code for 2^n-2?\\n"
                    }
                ]
            }
        ]
    }
]