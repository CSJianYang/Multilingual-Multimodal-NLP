[
    {
        "title": "Minimize the Maximum of Two Arrays",
        "question_content": "We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:\n\n\tarr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1.\n\tarr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2.\n\tNo integer is present in both arr1 and arr2.\n\nGiven divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.\n&nbsp;\nExample 1:\n\nInput: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3\nOutput: 4\nExplanation: \nWe can distribute the first 4 natural numbers into arr1 and arr2.\narr1 = [1] and arr2 = [2,3,4].\nWe can see that both arrays satisfy all the conditions.\nSince the maximum value is 4, we return it.\n\nExample 2:\n\nInput: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1\nOutput: 3\nExplanation: \nHere arr1 = [1,2], and arr2 = [3] satisfy all conditions.\nSince the maximum value is 3, we return it.\nExample 3:\n\nInput: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2\nOutput: 15\nExplanation: \nHere, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].\nIt can be shown that it is not possible to obtain a lower maximum satisfying all conditions. \n\n&nbsp;\nConstraints:\n\n\t2 <= divisor1, divisor2 <= 105\n\t1 <= uniqueCnt1, uniqueCnt2 < 109\n\t2 <= uniqueCnt1 + uniqueCnt2 <= 109",
        "solutions": [
            {
                "id": 2946508,
                "title": "python-lcm-and-binary-search-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment.** The required number `L` is the one that satisfies several criteria:\\n1. After removing all multiples of `D1` from the range `[1,L]`, there should remain at least `C1` elements to fill the first array.\\n2. After removing all multiples of `D2` from the range `[1,L]`, there should remain at least `C2` elements to fill the second array.\\n3. Numbers from the range `[1,L]` that are multiples of both `D1` and `D2` (thus, multiples of `lcm(D1,D2)`) should be skipped, thus, increasing the candidate value by 1.\\n\\nSo basically we should check every `L` starting from `C1+C2`. The first one that satisfies all the criteria is our winner. Given the constraints, it is better to use binary search to perform the scan.\\n\\n**Python #1.** Imperative binary search.\\n```\\nclass Solution:\\n    def minimizeSet(self, D1: int, D2: int, C1: int, C2: int) -> int:\\n        \\n        L, R, G = 0, 10**10, lcm(D1, D2)\\n\\n        while L < R:\\n            \\n            M = (L+R)//2                # [0] try middle value\\n            \\n            x = M - M//D1 >= C1         # [1] criterion 1\\n            y = M - M//D2 >= C2         # [2] criterion 2\\n            z = M - M//G  >= C1 + C2    # [3] criterion 3\\n            \\n            if x and y and z : R = M    # [4] classical step of\\n            else             : L = M+1  #     the binary search\\n\\n        return L\\n```\\n\\n**Python #2.** One-liner: the above solution can be compressed using Python\\'s `bisect_left` with the key function composed of the 3 discussed conditions.\\n```\\nclass Solution:\\n    def minimizeSet(self, D1: int, D2: int, C1: int, C2: int) -> int:\\n        \\n        return bisect_left(range(10**10), True, key=lambda M: M-M//D1 >= C1 and \\n                                                              M-M//D2 >= C2 and \\n                                                              M-M//lcm(D1,D2) >= C1+C2) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, D1: int, D2: int, C1: int, C2: int) -> int:\\n        \\n        L, R, G = 0, 10**10, lcm(D1, D2)\\n\\n        while L < R:\\n            \\n            M = (L+R)//2                # [0] try middle value\\n            \\n            x = M - M//D1 >= C1         # [1] criterion 1\\n            y = M - M//D2 >= C2         # [2] criterion 2\\n            z = M - M//G  >= C1 + C2    # [3] criterion 3\\n            \\n            if x and y and z : R = M    # [4] classical step of\\n            else             : L = M+1  #     the binary search\\n\\n        return L\\n```\n```\\nclass Solution:\\n    def minimizeSet(self, D1: int, D2: int, C1: int, C2: int) -> int:\\n        \\n        return bisect_left(range(10**10), True, key=lambda M: M-M//D1 >= C1 and \\n                                                              M-M//D2 >= C2 and \\n                                                              M-M//lcm(D1,D2) >= C1+C2) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946511,
                "title": "binary-search-venn-diagram-set-diagrams-explanation-with-diagram",
                "content": "**Idea:**\\n* Binary Search on possible answer. For each possible candidate `(say x)` I will check that whether if I take values from `[1, x]` will I be able to satisfy or not ? If `yes` then all numbers `>= x` will always be valid answers. so I go towards lesser numbers. Similarly if `x` does not satisfy the requirement then no number `<= x` will be able to. So in that case we move higher.\\n* How to check whether a number `x` satisfies the requirements or not ? Check the diagram below. It\\'s just mathematics. Explained in code comments of `check()` function\\n\\n![image](https://assets.leetcode.com/users/images/6866acd3-02bd-4012-82d5-a481919e16a7_1671900710.9502451.jpeg)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long lo = 1, hi = 1e17;\\n        while (hi > lo + 1) {\\n            long long mid = (lo + hi) >> 1;\\n            if (check(d1, d2, u1, u2, mid)) hi = mid;\\n            else lo = mid;\\n        }\\n        return hi;\\n    }\\n\\n    bool check(long long d1, long long d2, long long u1, long long u2, long long x) {\\n        long long A = x / d1;  // A = # of numbers divisible by d1\\n        long long A_ = x - A;  // A\\' = # of numbers not divisible by d1\\n        long long B = x / d2;\\t// B = # of numbers divisible by d2\\n        long long B_ = x - B;\\t// B\\' = # of numbers not divisible by d2\\n        long long AIB = x / lcm(d1, d2); // A Intersection B = # of numbers divisible by BOTH d1 AND d2\\n        long long AuB = A + B - AIB;\\t// A Union B = # of numbers divisible by EITHER d1 OR d2\\n        long long A_I_B_ = x - (AuB);\\t// (A\\' Union B\\') = (A Intersection B)\\' = # of numbers not divisible by NEITHER OF THEM\\n\\n        // needA = # of numbers needed to have atleast u1 numbers of set1, these numbers\\n        // don\\'t include (A\\' Union B\\')\\n        long long needA = (A_ - A_I_B_ >= u1) ? 0 : u1 - (A_ - A_I_B_);\\n\\n        // needB = # of numbers needed to have atleast u2 numbers of set2, these numbers\\n        // don\\'t include (A\\' Union B\\')\\n        long long needB = (B_ - A_I_B_ >= u2) ? 0 : u2 - (B_ - A_I_B_);\\n\\n        /*\\n        Why not consider (A\\' Union B\\') ?\\n        -> I will assign those numbers to whichever set needs it.\\n        */\\n\\n        // Available (A\\' Union B\\') value should be more than the needed # of values to make sets\\n        return (A_I_B_ >= needA + needB);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long lo = 1, hi = 1e17;\\n        while (hi > lo + 1) {\\n            long long mid = (lo + hi) >> 1;\\n            if (check(d1, d2, u1, u2, mid)) hi = mid;\\n            else lo = mid;\\n        }\\n        return hi;\\n    }\\n\\n    bool check(long long d1, long long d2, long long u1, long long u2, long long x) {\\n        long long A = x / d1;  // A = # of numbers divisible by d1\\n        long long A_ = x - A;  // A\\' = # of numbers not divisible by d1\\n        long long B = x / d2;\\t// B = # of numbers divisible by d2\\n        long long B_ = x - B;\\t// B\\' = # of numbers not divisible by d2\\n        long long AIB = x / lcm(d1, d2); // A Intersection B = # of numbers divisible by BOTH d1 AND d2\\n        long long AuB = A + B - AIB;\\t// A Union B = # of numbers divisible by EITHER d1 OR d2\\n        long long A_I_B_ = x - (AuB);\\t// (A\\' Union B\\') = (A Intersection B)\\' = # of numbers not divisible by NEITHER OF THEM\\n\\n        // needA = # of numbers needed to have atleast u1 numbers of set1, these numbers\\n        // don\\'t include (A\\' Union B\\')\\n        long long needA = (A_ - A_I_B_ >= u1) ? 0 : u1 - (A_ - A_I_B_);\\n\\n        // needB = # of numbers needed to have atleast u2 numbers of set2, these numbers\\n        // don\\'t include (A\\' Union B\\')\\n        long long needB = (B_ - A_I_B_ >= u2) ? 0 : u2 - (B_ - A_I_B_);\\n\\n        /*\\n        Why not consider (A\\' Union B\\') ?\\n        -> I will assign those numbers to whichever set needs it.\\n        */\\n\\n        // Available (A\\' Union B\\') value should be more than the needed # of values to make sets\\n        return (A_I_B_ >= needA + needB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947016,
                "title": "binary-search-on-answer-intuition-approach-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you have to minimise/maximise, there\\'s a very high chance you can binary search on the answer. Here if we know a number X provides us enough numbers to fulfill both conditions, then we can simply look for a number smaller than X which might satisfy the condition, if not we will look for a larger number. Now the question is to just check if a number X satisfies the condition or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow to check if a number X satisfies the condition or not, we will first calculate how many numbers are there from 1...X that are divisible by divisor1 and divisor2. We can find out this by dividing X by divisor1, i.e. `divisibleByD1 = X / divisor1`. Then we can do the same for divisor2, i.e. `divisibleByD2 = X / divisor2`. Now the number of integers that we can add to the first array are `elements1 = X - divisibleByD1` and number of elements we can add to the second array are `elements2 = X - divisibleByD2`. If you notice here there might be an overlap. For e.g. `divisor1 = 4` and `divisor2 = 6` and `X = 13`. Here `divisibleByD1 = 3 { 4, 8, 12 }` and `divisibleByD2 = 2 { 6, 12 }`. These are the elements that we cannot use in either array1 or array2. But there\\'s an overlap of 12 which we can\\'t use in either of the arrays but we\\'ve calulated it twice. To solve this, we will also calulate the number of elements divible by both divisor1 and divisor2 (which is number of elements divisble by lcm(divisor1, divisor2)) (this finds out the overlapping elements). Now X will satisfy the condition if `uniqueCnt1 <= elements1` && `uniqueCnt2 <= elements2` && `uniqueCnt1 + uniqueCnt2 <= X - (X / LCM)`.\\n# Complexity\\n- Time complexity: $$log_2(INT\\\\_MAX)$$ + $$log_2(a + b)$$ (to find gcd of two numbers) essentially $$log_2(N)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    int gcd(int a, int b) {\\n        if (!b) return a;\\n        return gcd(b, a % b);\\n    }\\n    int lcm(ll a, ll b) {\\n        ll temp = (a / gcd(a, b)) * b;\\n        return temp > INT_MAX ? INT_MAX : temp;\\n    }\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uc1, int uc2) {\\n        int l = 1, r = INT_MAX, LCM = lcm(divisor1, divisor2);\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            int a = mid / divisor1, b = mid / divisor2;\\n            if (uc1 <= mid - a && uc2 <= mid - b && uc1 + uc2 <= (mid - (mid / LCM))) {\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    int gcd(int a, int b) {\\n        if (!b) return a;\\n        return gcd(b, a % b);\\n    }\\n    int lcm(ll a, ll b) {\\n        ll temp = (a / gcd(a, b)) * b;\\n        return temp > INT_MAX ? INT_MAX : temp;\\n    }\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uc1, int uc2) {\\n        int l = 1, r = INT_MAX, LCM = lcm(divisor1, divisor2);\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            int a = mid / divisor1, b = mid / divisor2;\\n            if (uc1 <= mid - a && uc2 <= mid - b && uc1 + uc2 <= (mid - (mid / LCM))) {\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947014,
                "title": "formula",
                "content": "What if there is just one array to fill?\\n\\nWe can compute the max element in that array by adding the number of \"holes\" (multiples of `d`) to the number of elements.\\n\\nThe formula is `cnt + x`, where `x = (cnt + x) / d`.\\n- `x * d = cnt + add`\\n- `x (d - 1) = cnt`\\n- `x = cnt / (d - 1)`.\\n\\n> Note that, when `cnt` is divisible by `d - 1`, we need one less element.\\n> E.g. for `cnt == 10` and `d == 3`, the maximum number is 14 (10 + 10 / 2 - 1), because we do not need to skip the fifth hole:\\n> 1, 2, [], 4, 5,[], 7, 8,[], 10, 11, [], 13, 14, []\\n> Note that for `cnt == 11` and `d == 3`, the maximum number is 16 (11 + 11 / 2), because we skip all five holes:\\n> 1, 2, [], 4, 5,[], 7, 8,[], 10, 11, [], 13, 14,[], 16\\n\\nIf we have two arrays, we need to insert total `cnt1 + cnt2` elements. Multiples of `d1` and `d2` can be inserted into the other array, except for multiples of `lcm(d1, d2)`.\\n\\n> So, it is like a single array with `cnt = cnt1 + cnt2`, and `d = lcm(d1, d2)`.\\n\\nThere is an edge case when one array overpower the other (the other array can be fully populated using `holes` from the first array).\\n\\nTherefore, we return the largets of three maximum values (first array only, second array only, and both arrays).\\n\\n**C++**\\n```cpp\\nint getMax(int cnt, long long d1, long long d2 = 1) {\\n    long long d = lcm(d1, d2);\\n    return cnt + cnt / (d - 1) - (cnt % (d - 1) ? 0 : 1);\\n}\\nint minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n    return max({getMax(cnt1, d1), getMax(cnt2, d2), getMax(cnt1 + cnt2, d1, d2) });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint getMax(int cnt, long long d1, long long d2 = 1) {\\n    long long d = lcm(d1, d2);\\n    return cnt + cnt / (d - 1) - (cnt % (d - 1) ? 0 : 1);\\n}\\nint minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n    return max({getMax(cnt1, d1), getMax(cnt2, d2), getMax(cnt1 + cnt2, d1, d2) });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946484,
                "title": "binary-search-approach-c-10-lines-code",
                "content": "**Intuition**\\nHere, we can use binary search to look for the tightest upper bound. Given a value x, the condition for x to be a valid upper bound is that\\n\\n* there is enough number between 1 to x that are not divisible by divisor1;\\n* there is enough number between 1 to x that are not divisible by divisor2;\\n* in the overlapping area, if some numbers are allocated to cover uniqueCnt1 they cannot be used to cover uniqueCnt2.\\n```\\nint minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long ans=INT_MAX;\\n        long long low=1,high=INT_MAX;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long c1=mid-mid/d1;\\n            long long c2=mid-mid/d2;\\n            long long temp=mid-mid/(((long long)d1*d2)/__gcd(d1,d2));\\n            if(c1>=(long long)cnt1 and c2>=(long long)cnt2 and temp>=cnt1+cnt2){\\n                ans=min(ans,mid);\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long ans=INT_MAX;\\n        long long low=1,high=INT_MAX;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long c1=mid-mid/d1;\\n            long long c2=mid-mid/d2;\\n            long long temp=mid-mid/(((long long)d1*d2)/__gcd(d1,d2));\\n            if(c1>=(long long)cnt1 and c2>=(long long)cnt2 and temp>=cnt1+cnt2){\\n                ans=min(ans,mid);\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946621,
                "title": "c-java-python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/3ffc910c12ff8c84890fb15351216a0fa85dc3ac) for solutions of biweekly 94. \\n\\n**Intuition**\\nHere, we can use binary search to look for the tightest upper bound. Given a value `x`, the condition for `x` to be a valid upper bound is that \\n1) there is enough number between 1 to `x` that are not divisible by `divisor1`; \\n2) there is enough number between 1 to `x` that are not divisible by `divisor2`; \\n3) in the overlapping area, if some numbers are allocated to cover `uniqueCnt1` they cannot be used to cover `uniqueCnt2`. \\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic: \\n\\tint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\t\\tlong lo = 0, hi = INT_MAX, mult = lcm((long) divisor1, divisor2); \\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tint mid = lo + (hi-lo)/2; \\n\\t\\t\\tif (uniqueCnt1 <= mid-mid/divisor1 && uniqueCnt2 <= mid-mid/divisor2 && uniqueCnt1+uniqueCnt2 <= mid-mid/mult) hi = mid; \\n\\t\\t\\telse lo = mid+1; \\n\\t\\t}\\n\\t\\treturn lo; \\n\\t}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\t\\tint g = divisor1; \\n\\t\\tfor (int x = divisor2; x > 0; ) {int tmp = g; g = x; x = tmp % x; }\\n\\t\\tlong lo = 0, hi = Integer.MAX_VALUE, mult = ((long) divisor1*divisor2/g); \\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tlong mid = lo + (hi-lo)/2;\\n\\t\\t\\tif (uniqueCnt1 <= mid-mid/divisor1 && uniqueCnt2 <= mid-mid/divisor2 && uniqueCnt1+uniqueCnt2 <= mid-mid/mult) hi = mid; \\n\\t\\t\\telse lo = mid+1; \\n\\t\\t}\\n\\t\\treturn (int) lo; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n\\tdef minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int: \\n\\t\\tlo, hi = 0, 1<<32-1\\n\\t\\tmult = lcm(divisor1, divisor2)\\n\\t\\twhile lo < hi: \\n\\t\\t\\tmid = lo + hi >> 1\\n\\t\\t\\tif uniqueCnt1 <= mid - mid//divisor1 and uniqueCnt2 <= mid - mid//divisor2 and uniqueCnt1+uniqueCnt2 <= mid - mid//mult: hi = mid\\n\\t\\t\\telse: lo = mid+1\\n\\t\\treturn lo \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n\\tint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\t\\tlong lo = 0, hi = INT_MAX, mult = lcm((long) divisor1, divisor2); \\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tint mid = lo + (hi-lo)/2; \\n\\t\\t\\tif (uniqueCnt1 <= mid-mid/divisor1 && uniqueCnt2 <= mid-mid/divisor2 && uniqueCnt1+uniqueCnt2 <= mid-mid/mult) hi = mid; \\n\\t\\t\\telse lo = mid+1; \\n\\t\\t}\\n\\t\\treturn lo; \\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tpublic int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\t\\tint g = divisor1; \\n\\t\\tfor (int x = divisor2; x > 0; ) {int tmp = g; g = x; x = tmp % x; }\\n\\t\\tlong lo = 0, hi = Integer.MAX_VALUE, mult = ((long) divisor1*divisor2/g); \\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tlong mid = lo + (hi-lo)/2;\\n\\t\\t\\tif (uniqueCnt1 <= mid-mid/divisor1 && uniqueCnt2 <= mid-mid/divisor2 && uniqueCnt1+uniqueCnt2 <= mid-mid/mult) hi = mid; \\n\\t\\t\\telse lo = mid+1; \\n\\t\\t}\\n\\t\\treturn (int) lo; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n\\tdef minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int: \\n\\t\\tlo, hi = 0, 1<<32-1\\n\\t\\tmult = lcm(divisor1, divisor2)\\n\\t\\twhile lo < hi: \\n\\t\\t\\tmid = lo + hi >> 1\\n\\t\\t\\tif uniqueCnt1 <= mid - mid//divisor1 and uniqueCnt2 <= mid - mid//divisor2 and uniqueCnt1+uniqueCnt2 <= mid - mid//mult: hi = mid\\n\\t\\t\\telse: lo = mid+1\\n\\t\\treturn lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947402,
                "title": "no-binary-search-solution-top-100-runtime-memory",
                "content": "# Apporach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s $$f(u, d)$$ is the minimum possible maximum integer in an array of size $$u$$ that are not divisible by divisor $$d$$. There will be numbers from 1 to u, except that are divisible by $$d$$, and some numbers that are bigger than $$u$$.\\n\\nSo, we are missing all $$k \\\\cdot d $$ numbers from 1 to $$f(u, d)$$. How can we count the number of them? For each $$d - 1$$ numbers that exist in the array, we miss one $$k \\\\cdot d$$ number, where $$k \\\\in \\\\N$$. So the number of them equals $$floor(u / (d - 1))$$.\\n\\nBut we should not count the last $$k \\\\cdot d $$ number if $$u$$ is divisible by $$d - 1$$.\\n\\nSo, the final formula for $$f(u, d)$$:\\n$$f(u, d) = u + floor((u - 1) / (d - 1))$$\\n\\nWe should calculate $$f(u, d)$$ for the first array, then for the second one, and if there are a lot of numbers from both arrays, we should calculate for both arrays: $$f(u1 + u2, LCM(d1, d2))$$.\\n\\nThe resulting answer will be the maximum of the three functions:\\n$$max(f(u1, d1), f(u2, d2), f(u1 + u2, LCM(d1, d2)))$$\\n\\n\\n# Complexity\\n- Time complexity: $$O(log(divisor1+divisor2))$$, because it is the time complexity of LCM.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\ndef f(u, d):\\n    return u + (u - 1) // (d - 1)\\n\\n\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        return max(f(u1, d1), f(u2, d2), f(u1 + u2, math.lcm(d1, d2)))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef f(u, d):\\n    return u + (u - 1) // (d - 1)\\n\\n\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        return max(f(u1, d1), f(u2, d2), f(u1 + u2, math.lcm(d1, d2)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535059,
                "title": "java-binary-search-on-answers-mathematics",
                "content": "```\\nclass Solution {\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int low=1;\\n        int high=Integer.MAX_VALUE;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long num,long d1,long d2,long c1,long c2){\\n        long bothdivisiblebyd1andd2=num/lcm(d1,d2);\\n        long canbestoredinarr1=(num/d1)-bothdivisiblebyd1andd2;\\n        long canbestoredinarr2=(num/d2)-bothdivisiblebyd1andd2;\\n        long rest=num-(bothdivisiblebyd1andd2+canbestoredinarr1+canbestoredinarr2);\\n        if(c1>=canbestoredinarr2){\\n            rest-=(c1-canbestoredinarr2);\\n        }\\n        if(c2>=canbestoredinarr1){\\n            rest-=(c2-canbestoredinarr1);\\n        }\\n        if(rest>=0)\\n            return true;\\n        return false;\\n    }\\n    public long lcm(long d1,long d2){\\n        return (d1*d2)/gcd(d1,d2);\\n    }\\n    public long gcd(long a,long b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```\\n**Explanation :- https://youtu.be/gLi1UGe-oC4**\\n![image](https://assets.leetcode.com/users/images/f9473a08-7c24-4062-a636-e1987609a062_1684335305.079561.png)\\n![image](https://assets.leetcode.com/users/images/e8ac4487-76fd-4c74-aeb6-d5e918110923_1684335809.3325946.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int low=1;\\n        int high=Integer.MAX_VALUE;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long num,long d1,long d2,long c1,long c2){\\n        long bothdivisiblebyd1andd2=num/lcm(d1,d2);\\n        long canbestoredinarr1=(num/d1)-bothdivisiblebyd1andd2;\\n        long canbestoredinarr2=(num/d2)-bothdivisiblebyd1andd2;\\n        long rest=num-(bothdivisiblebyd1andd2+canbestoredinarr1+canbestoredinarr2);\\n        if(c1>=canbestoredinarr2){\\n            rest-=(c1-canbestoredinarr2);\\n        }\\n        if(c2>=canbestoredinarr1){\\n            rest-=(c2-canbestoredinarr1);\\n        }\\n        if(rest>=0)\\n            return true;\\n        return false;\\n    }\\n    public long lcm(long d1,long d2){\\n        return (d1*d2)/gcd(d1,d2);\\n    }\\n    public long gcd(long a,long b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952152,
                "title": "c-explanation-binary-search",
                "content": "# **If you helped, please upvote..**\\n# Intuition\\n* We need to find out element which is satisfy all the conditions and that is in between `1` to `INT_MAX`\\n* so we doing try and error method here,\\n* first we assume `x` is our ans in between `s = 1` and `e = INT_MAX` and we check the x is valid or not\\n\\n# Approach \\n![Untitled.jpg](https://assets.leetcode.com/users/images/9c0e7625-4105-4c1c-96ae-57b6b382d3d3_1672030345.8141906.jpeg)\\n\\n***Let\\'s Understand with ven diagram***\\n* assume `x` is our ans,\\n\\n***Terminology***\\n1. Total number of elements in between 1 to x, `x` = x;\\n2. Total number of elements divisible by d1 and d2 both in between 1 to x, `a = x / lcm(d1, d2)`;\\n3. Total number of elements divisible by d1 in between 1 to x = `x / d1`;\\n4.  b = (total number of elements divisible by d1)  - (a) => valid for array_2,  `b = x / d1 - a`\\n5. Total number of elements divisible by d2 in between 1 to x = x / d2;\\n6. c = (total number of elements divisible by d2)  - (a) => valid for array_1,  `c = x / d2 - a`\\n7. d = total number of elements valid for array_1 and array2,  `d = x - a - b - c`;\\n\\n\\n***Now find out value of x*** \\n1. Here, we take all elements of divisible by d2 in array_1, becuase it\\'s divisible by d2 but not d1 so we consider it\\'s valid for array_1\\n2. Suppose we need 10 elemements for array_1 and we have only 7 elements divisible by d2 so remaining elements taking from `valid for both array(red color in ven dia)`\\n3. similary, for array_2\\n4. if `valid for both array` elements not make up `c1` and `c2` then we say  `x` is not valid so we increament x now we apply binary search -> `s = x + 1`\\n5. In case, `c1` and `c2` make up then we decreament x `e = x`\\n6. and last we return `s`\\n\\n\\n\\n# Complexity\\n- Time complexity : $$O(log(N)$$ Where, N = INT_MAX\\n\\n- Space complexity : $$O(1)$$\\n\\n\\n# Code\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:      \\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll s = 1, e = INT_MAX;\\n        ll LCM = (1LL* d1 * d2) / __gcd(d1, d2);  // Here, lcm formula using gcd, lcm of d1, d2\\n        \\n        while(s < e) {\\n            ll x = (s + e) / 2;  // let\\'s assume x is our ans \\n            \\n            // x we have x number of elements\\n            \\n            // a = total number of element divisible by d1 and d2\\n            ll a = x / LCM; \\n            \\n            // b = (total number of elements divisible by d1)  - (a) => valid for array_2\\n            ll b = x / d1 - a;\\n            \\n            // c = (total number of elements divisible by d2)  - (a) => valid for array_1\\n            ll c = x / d2 - a;\\n            \\n            // d = total number of elements valid for array_1 and array2\\n            ll d = x - a - b - c;\\n            \\n            if(c < c1) d -= (c1 - c); // make up count c1 for array_1\\n            if(b < c2) d -= (c2 - b); // make up count c2 for array_2\\n             \\n            if(d >= 0) e = x;\\n            else s = x + 1; \\n        }\\n        return s; \\n    }\\n};\\n```\\n**If you understand please upvote \\uD83D\\uDE4F**\\nThank You ...",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:      \\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll s = 1, e = INT_MAX;\\n        ll LCM = (1LL* d1 * d2) / __gcd(d1, d2);  // Here, lcm formula using gcd, lcm of d1, d2\\n        \\n        while(s < e) {\\n            ll x = (s + e) / 2;  // let\\'s assume x is our ans \\n            \\n            // x we have x number of elements\\n            \\n            // a = total number of element divisible by d1 and d2\\n            ll a = x / LCM; \\n            \\n            // b = (total number of elements divisible by d1)  - (a) => valid for array_2\\n            ll b = x / d1 - a;\\n            \\n            // c = (total number of elements divisible by d2)  - (a) => valid for array_1\\n            ll c = x / d2 - a;\\n            \\n            // d = total number of elements valid for array_1 and array2\\n            ll d = x - a - b - c;\\n            \\n            if(c < c1) d -= (c1 - c); // make up count c1 for array_1\\n            if(b < c2) d -= (c2 - b); // make up count c2 for array_2\\n             \\n            if(d >= 0) e = x;\\n            else s = x + 1; \\n        }\\n        return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947151,
                "title": "java-binary-search-clean",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    private int gcd(int a, int b) {\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n\\n    public int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long lo = 1, hi = (int) 10e10;\\n        long ans = hi;\\n        long lcm = ((long) d1 * (long) d2) / gcd(d1, d2);\\n        while (lo <= hi) {\\n            long mid = lo + (hi - lo) / 2;\\n            int x = (int) (mid - mid / d1);\\n            int y = (int) (mid - mid / d2);\\n            int z = (int) (mid - mid / lcm);\\n            if (x < u1 || y < u2 || z < u1 + u2) {\\n                lo = mid + 1;\\n            } else {\\n                ans = Math.min(ans, mid);\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return (int) ans;\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    private int gcd(int a, int b) {\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n\\n    public int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long lo = 1, hi = (int) 10e10;\\n        long ans = hi;\\n        long lcm = ((long) d1 * (long) d2) / gcd(d1, d2);\\n        while (lo <= hi) {\\n            long mid = lo + (hi - lo) / 2;\\n            int x = (int) (mid - mid / d1);\\n            int y = (int) (mid - mid / d2);\\n            int z = (int) (mid - mid / lcm);\\n            if (x < u1 || y < u2 || z < u1 + u2) {\\n                lo = mid + 1;\\n            } else {\\n                ans = Math.min(ans, mid);\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return (int) ans;\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947018,
                "title": "beginer-friendly",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        l,  r = 0, 1 << 32 - 1\\n\\n        lcm = math.lcm(divisor1, divisor2)\\n        def valid(num):\\n            div1 = num - num // divisor1\\n            if div1 < uniqueCnt1: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor1\\n                return False\\n            div2 = num - num // divisor2 \\n            if div2 < uniqueCnt2: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor2\\n                return False\\n            union = num - num // lcm\\n            #  num // lcm: none wowrks, num: total, union: total - none works\\n            if union < (uniqueCnt1 + uniqueCnt2):\\n                # Numbers from the range [1,L] that are multiples of both C1 and C2 (thus, multiples of lcm(D1,D2)) should be skipped, thus, increasing the candidate value by 1.\\n                return False\\n            return True\\n\\n        while l + 1 != r:\\n            m = (l + r) // 2\\n            if (valid(m)):\\n                r = m \\n            else:\\n                l = m\\n        return r\\n            \\n```\\n# Reference:\\nhttps://leetcode.com/problems/minimize-the-maximum-of-two-arrays/solutions/2946508/python-lcm-and-binary-search-explained-bonus-one-liner/?orderBy=most_votes\\nBisect Template:\\nhttps://www.youtube.com/watch?v=JuDAqNyTG4g&ab_channel=%E4%BA%94%E7%82%B9%E4%B8%83%E8%BE%B9",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        l,  r = 0, 1 << 32 - 1\\n\\n        lcm = math.lcm(divisor1, divisor2)\\n        def valid(num):\\n            div1 = num - num // divisor1\\n            if div1 < uniqueCnt1: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor1\\n                return False\\n            div2 = num - num // divisor2 \\n            if div2 < uniqueCnt2: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor2\\n                return False\\n            union = num - num // lcm\\n            #  num // lcm: none wowrks, num: total, union: total - none works\\n            if union < (uniqueCnt1 + uniqueCnt2):\\n                # Numbers from the range [1,L] that are multiples of both C1 and C2 (thus, multiples of lcm(D1,D2)) should be skipped, thus, increasing the candidate value by 1.\\n                return False\\n            return True\\n\\n        while l + 1 != r:\\n            m = (l + r) // 2\\n            if (valid(m)):\\n                r = m \\n            else:\\n                l = m\\n        return r\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050541,
                "title": "simple-c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain Idea to find the  minimum number is to  check numbers from 1 to INT_MAX if they can satisfy the 3 conditions of the question. Because our range can be from 1 to some number that is why 1 to INT_MAX. Since we know the answer will be between 1 to INT_MAX so we can apply binary search because its monotocially increasing or just imagine an array  from 1 to some big number that is always sorted, So binary search can be applied .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo actually for binary search here we have to check the following conditions:\\n1. If there are cnt1 numbers that are not divisible by divisor1 in the range form 1 to mid.\\n     - To check this conditon we know in a range for `1 to N `: `N/d` numbers are divisble by `d` .So` N- N/d` are the numbers which are divisble by `d`.\\n2. If there are cnt2 numbers that are not divisible by divisor2 in the range form 1 to mid.\\n3. SO we know there can be some numbers common in step1 and step2 but we have to take unique elemnts that not are divisible by d1 and d2 so we have to check If there are cnt1+cnt2 numbers that are not divisible by divisor1+divisor2 in the range form 1 to mid.\\n- For last one just check by lcm of d1 and d2 that will give us those numbers which are not divisble by both divisors.\\n- So check if these three conditons are satisfying then keep decrementing our high and that will be our answer\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimizeSet(int d1, int d2, int uqC1, int uqC2) {\\n        long int low=1,high=INT_MAX;\\n        int ans=INT_MAX;\\n        long long int lcm=((long long)d1*d2)/__gcd(d1,d2);\\n        while(low<=high){\\n             int  mid=low+(high-low)/2;\\n             int notd1= mid -mid/d1;// not divisble by d1\\n             int notd2= mid- mid/d2;// not divisible by d2\\n             int notboth= mid-mid/lcm;// not divisble by both\\n           if(notd1>=uqC1 and notd2>=uqC2 and notboth>=(uqC1+uqC2)){\\n               ans=mid;\\n               high=mid-1;\\n           }\\n           else low=mid+1;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimizeSet(int d1, int d2, int uqC1, int uqC2) {\\n        long int low=1,high=INT_MAX;\\n        int ans=INT_MAX;\\n        long long int lcm=((long long)d1*d2)/__gcd(d1,d2);\\n        while(low<=high){\\n             int  mid=low+(high-low)/2;\\n             int notd1= mid -mid/d1;// not divisble by d1\\n             int notd2= mid- mid/d2;// not divisible by d2\\n             int notboth= mid-mid/lcm;// not divisble by both\\n           if(notd1>=uqC1 and notd2>=uqC2 and notboth>=(uqC1+uqC2)){\\n               ans=mid;\\n               high=mid-1;\\n           }\\n           else low=mid+1;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443339,
                "title": "simple-c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(long long  x,long long  div1,int div2,long long  cnt1,long long  cnt2)\\n    {\\n        long long  a=x/div1;\\n        long long  b=x/div2;\\n        long long  a_=x-a;  // non div by div1 \\n        long long  b_=x-b;   // non div by div2\\n        long long  com=x/lcm(div1,div2);  // commons nos \\n        long long  extra=a+b-2*com;        // extra no present 1 time only \\n        long long  d=(a_+b_+extra)/2;\\n        if(a_<cnt1||b_<cnt2||cnt1+cnt2>d)\\n        return 0;\\n        return 1;\\n    }\\n    int minimizeSet(long long  div1, long long  div2, long long  cnt1, long long  cnt2) {\\n        long long  s=0,e=1e17,ans=0;\\n        while(s<=e)\\n        {\\n            long long  mid=(s+e)/2;\\n            if(solve(mid,div1,div2,cnt1,cnt2))\\n            ans=mid,e=mid-1;\\n            else\\n            s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(long long  x,long long  div1,int div2,long long  cnt1,long long  cnt2)\\n    {\\n        long long  a=x/div1;\\n        long long  b=x/div2;\\n        long long  a_=x-a;  // non div by div1 \\n        long long  b_=x-b;   // non div by div2\\n        long long  com=x/lcm(div1,div2);  // commons nos \\n        long long  extra=a+b-2*com;        // extra no present 1 time only \\n        long long  d=(a_+b_+extra)/2;\\n        if(a_<cnt1||b_<cnt2||cnt1+cnt2>d)\\n        return 0;\\n        return 1;\\n    }\\n    int minimizeSet(long long  div1, long long  div2, long long  cnt1, long long  cnt2) {\\n        long long  s=0,e=1e17,ans=0;\\n        while(s<=e)\\n        {\\n            long long  mid=(s+e)/2;\\n            if(solve(mid,div1,div2,cnt1,cnt2))\\n            ans=mid,e=mid-1;\\n            else\\n            s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972787,
                "title": "easy-intutive-binay-search-c",
                "content": "# Intuition\\nWe need to `minimize` `maximum` number such that all conditions of `uniqueCount\\'s` satisfies.\\n* We know inorder to find count of numbers which are divisible by some divisor d in the `range: 1-n` $=\\\\lfloor n/d \\\\rfloor$\\n* So count of numbers which are not divisible by d $= n - \\\\lfloor n/d \\\\rfloor$\\n* Using the above concept we can binary search on our answer\\uD83D\\uDE80.\\n\\n# Approach\\nFor each `mid` value we will see if there exist sufficient numbers $(count \\\\geq uniqueCount1)$ in range `1-mid` not divible by `divisor1` for `arr1` and sufficient numbers $(count \\\\geq uniqueCount2)$ then we will reduce our searchspace by doing $high=mid-1$\\notherwise, $low=mid+1$\\n\\n# Complexity\\n- Time complexity:\\n$O(logn)$ as in each operation we are reducring size of search space by half\\n\\n- Space complexity:\\n$O(1)$ as no extra space usedc except some innocent variables\\uD83D\\uDE05\\n\\n# Code\\n```\\nclass Solution {\\n    bool valid(long long mid, long long d1, long long d2, long long c1, long long c2)\\n    {\\n        long long valid1 = mid-mid/d1; // numbers which are not divisible by d1\\n        long long valid2 = mid-mid/d2; // numbers which are not divisible by d2\\n        long long lcm = (d1*1LL*d2)/__gcd(d1, d2);\\n\\n        long long validboth = mid-mid/lcm; // number which are not divisible by both d1 and d2\\n        return validboth>=c1+c2 and valid1>=c1 and valid2>=c2;\\n    }    \\n\\npublic:\\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        int low = 0;\\n        long long high = 1e12;\\n\\n        int ans = -1;\\n\\n        while(low <= high)\\n        {\\n            long long mid = low+(high-low)/2;\\n            if(valid(mid, d1, d2, c1, c2))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n### Last Hint: Use `long long` in order to avoid integer overflow while validating the `mid` value\\n## Please Upvote If Like my Solution, it means a lot\\uD83D\\uDCAF",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    bool valid(long long mid, long long d1, long long d2, long long c1, long long c2)\\n    {\\n        long long valid1 = mid-mid/d1; // numbers which are not divisible by d1\\n        long long valid2 = mid-mid/d2; // numbers which are not divisible by d2\\n        long long lcm = (d1*1LL*d2)/__gcd(d1, d2);\\n\\n        long long validboth = mid-mid/lcm; // number which are not divisible by both d1 and d2\\n        return validboth>=c1+c2 and valid1>=c1 and valid2>=c2;\\n    }    \\n\\npublic:\\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        int low = 0;\\n        long long high = 1e12;\\n\\n        int ans = -1;\\n\\n        while(low <= high)\\n        {\\n            long long mid = low+(high-low)/2;\\n            if(valid(mid, d1, d2, c1, c2))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947388,
                "title": "math-solution-max-result-of-3-conditions-no-binary-search-detailed-explanation",
                "content": "## 1. One array\\nThink of there is just one array to fill, and only one divisor `d`, array length `need`.\\n\\nCount from 1 to n, every `d` numbers we could take `d-1` to fill the array, just drop multiples of `d` and take all the rest. So if we need `need` numbers, the max number counted is `need / (d-1) * d`.\\n\\nBut how about if `need` is multiple of `d-1`? then `need / (d-1) * d` is exactly also a multiple of `d`, its useless, we should minus it by 1, it will be `need / (d-1) * d - 1`.\\n\\nLet\\'s call this solution as `solve(d, need)`, equals to `need * d / (d-1) - (need % (d-1) ? 0 : 1)`.\\n\\n\\n## 2. Two arrays\\nThen think of two arrays, one with divisor `d1` and length `need1`, another `d2` and `need2`.\\n\\nCount from 1 to n, we only drop common multiples of `d1` and `d2`, then divide the rest numbers into 3 types.\\n\\n* numbers could **only** fill array1, that means multiples of `d2`, mark total count of these numbers as `m1`.\\n* numbers could **only** fill array2, that means multiples of `d1`, mark total count of these numbers as `m2`.\\n* numbers could fill both array1 and array2, that means nether multiples of `d1` nor multiples of `d2`, mark total count of these type of numbers as `m0`.\\n\\nWe count `need1 + nees2` numbers, so now `m1 + m2 + m0 == need1 + nees2`.\\n\\nif `m1 <= need1 <= m1 + m0`, then we must get `m2 <= need2 <= m2 + m0`,\\nin this case, numbers we counted are enough to fill the two arrays,\\nso the result is `solve(lcm(d1, d2), need1+need2)`.\\n\\nif `need1 < m1`, then we must get `need2 > m2 + m0`, then we should count more numbers to fill array2, only drop multiples of `d2`, the result is `solve(d2, need2)`.\\n\\nif `need2 < m2`, same to above, the result is `solve(d1, need1)`.\\n\\n\\nThe final result is the max result of these 3 conditions.\\n\\n# Code\\n```\\nclass Solution {\\n    long gcd(long a, long b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    long lcm(long a, long b) {\\n        return a / gcd(a, b) * b;\\n    }\\n\\n    // Solution about just one divisor\\n    int solve(unsigned long d, unsigned long need) {\\n        return need * d / (d-1) - (need % (d-1) ? 0 : 1);\\n    }\\n\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long l = lcm(divisor1, divisor2);\\n        int s = uniqueCnt1 + uniqueCnt2;\\n        // Final result is the max result of these three conditions\\n        return max({solve(l, s), solve(divisor1, uniqueCnt1), solve(divisor2, uniqueCnt2)});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long gcd(long a, long b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    long lcm(long a, long b) {\\n        return a / gcd(a, b) * b;\\n    }\\n\\n    // Solution about just one divisor\\n    int solve(unsigned long d, unsigned long need) {\\n        return need * d / (d-1) - (need % (d-1) ? 0 : 1);\\n    }\\n\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long l = lcm(divisor1, divisor2);\\n        int s = uniqueCnt1 + uniqueCnt2;\\n        // Final result is the max result of these three conditions\\n        return max({solve(l, s), solve(divisor1, uniqueCnt1), solve(divisor2, uniqueCnt2)});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960229,
                "title": "python-3-7-lines-iteration-w-explanation-example-t-m-99-3-100",
                "content": "Here\\'s the plan:\\nSuppose, for example: \\n`divisor1 = 2, uniqueCnt1 = 11`, and `divisor2 = 3, uniqueCnt2 = 2`\\n\\nWe need at least 13 elements in total in the two groups. Four elements would be eligible for either\\ngroup (`[1,5,7,11]`), two for Group1 only (`[3,9]`), four for Group2 only (`[2,4,8,10]`), and two for neither group [6,12].\\nThe diagram below summarizes:\\n![a.jpg](https://assets.leetcode.com/users/images/639f5260-1a30-4602-bf8c-e96da587c936_1672179385.2714288.jpeg)\\n\\n\\n\\nClearly n needs to be increased by at least 4 (`n = 13+4 = 17`) in order for Group 1 to have 11 elements. We add 4 to n (so now n = 17), and determine the groups again:\\n```\\nGroup1 : `len([3,9,         15])    = 3`\\nGroup2 : `len([2,4,8,10,    14,16]) = 6`\\nBoth   : `len([1,5,7,11,13, 17])    = 6`\\nNeither: `len([6,12])               = 2\\n```\\nWe continue to iterate in this fashion, ending up with `n = 21`.\\n```\\nGroup1 : `len([3,9,         15,         21]) = 4` \\u2013\\nGroup2 : `len([2,4,8,10,    14,16    20   ]) = 7`     4 + 7  = 11\\nBoth   : `len([1,5,7,11,13, 17,      19   ]) = 7` \\u2013\\nNeither: `len([6,12,                 18   ]) = 3```\\n\\n```\\n```\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, ct1: int, ct2: int) -> int:\\n        \\n        f = lambda x: (x+abs(x))//2                             \\n\\n        n, prev, d = ct1 + ct2, 0, lcm(d1,d2)\\n\\n        while n > prev:                    # keep going until we do not \\n                                           # have to add more\\n            prev = n       \\n\\n            l1, l2  = n//d2 - n//d, n//d1 - n//d   # l1, l2 : length of group1, group2\\n\\n            n+= f(f(ct1 - l1) + f(ct2 - l2)- n + n//d + l2 + l1) # determine the incease in n\\n\\n        return n\\n```\\n[https://leetcode.com/problems/minimize-the-maximum-of-two-arrays/submissions/866527037/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nGroup1 : `len([3,9,         15])    = 3`\\nGroup2 : `len([2,4,8,10,    14,16]) = 6`\\nBoth   : `len([1,5,7,11,13, 17])    = 6`\\nNeither: `len([6,12])               = 2\\n```\n```\\nGroup1 : `len([3,9,         15,         21]) = 4` \\u2013\\nGroup2 : `len([2,4,8,10,    14,16    20   ]) = 7`     4 + 7  = 11\\nBoth   : `len([1,5,7,11,13, 17,      19   ]) = 7` \\u2013\\nNeither: `len([6,12,                 18   ]) = 3```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946735,
                "title": "simple-c-solution-binary-search-aggressive-cow-problem-type-approach",
                "content": "# Approach\\nUsing the binary search with low value as 1 and high value as INT_MAX and if we have a valid value then our answer should be less than or equal to that value. As any value greater than that value is obviously valid.\\n\\n# Complexity\\n- Time complexity:\\n    $$O(log(N))$$ for binary search\\n- Space complexity:\\n    $$O(1)$$\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\n    ll getGCD(int a,int b){\\n        if(b==0)return a;\\n\\n        return getGCD(b,a%b);\\n    }\\npublic:\\n    int minimizeSet(int div1, int div2, int cnt1, int cnt2) {\\n        ll ans=INT_MAX;\\n        ll low=1,high=INT_MAX;\\n        \\n        // Iterate with binary search to get Solution.\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            // Remaining Numbers Divisible by div1 from total mid numbers\\n            ll total1=mid-mid/div1;\\n            // Remaining Numbers Divisible by div2 from total mid numbers\\n            ll total2=mid-mid/div2;\\n\\n            // GCD of both div1 and div2\\n            ll gcd=getGCD(div1,div2);\\n            // Get the LCM of 2 numbers\\n            ll lcm=(ll)(((ll)div1)*((ll)div2))/gcd;\\n\\n            // Remaining numbers that are not divisible by div1 and div2 from total mid numbers.\\n            ll temp=mid-mid/lcm;\\n\\n            // If we have all satisfied then \\n            // set the high value to left of mid and store the mid val as ans.\\n            if(total1>=cnt1 and total2>=cnt2 and temp>=cnt1+cnt2){\\n                high=mid-1;\\n                ans=min(ans,mid);\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    ll getGCD(int a,int b){\\n        if(b==0)return a;\\n\\n        return getGCD(b,a%b);\\n    }\\npublic:\\n    int minimizeSet(int div1, int div2, int cnt1, int cnt2) {\\n        ll ans=INT_MAX;\\n        ll low=1,high=INT_MAX;\\n        \\n        // Iterate with binary search to get Solution.\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            // Remaining Numbers Divisible by div1 from total mid numbers\\n            ll total1=mid-mid/div1;\\n            // Remaining Numbers Divisible by div2 from total mid numbers\\n            ll total2=mid-mid/div2;\\n\\n            // GCD of both div1 and div2\\n            ll gcd=getGCD(div1,div2);\\n            // Get the LCM of 2 numbers\\n            ll lcm=(ll)(((ll)div1)*((ll)div2))/gcd;\\n\\n            // Remaining numbers that are not divisible by div1 and div2 from total mid numbers.\\n            ll temp=mid-mid/lcm;\\n\\n            // If we have all satisfied then \\n            // set the high value to left of mid and store the mid val as ans.\\n            if(total1>=cnt1 and total2>=cnt2 and temp>=cnt1+cnt2){\\n                high=mid-1;\\n                ans=min(ans,mid);\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946506,
                "title": "python3-binary-search",
                "content": "# Python | Binary Search\\nWe can think about `Given n, can we select some numbers from 1~n to have uniqueCnt1 numbers in arr1 and uniqueCnt2 in arr2?`\\nWe can check by this way:\\nFirst, we put in `arr1` the numbers that can fit in `arr1` but cannot fit in `arr2`, and put in `arr2` the numbers that can fit in `arr2` but cannot fit in `arr1`. \\nWe define the numbers as `only1` and `only2` in the `valid` function. \\nThen, if `uniqueCnt1` > `only1`, we should use the numbers that can both fit in `arr1` and `arr2`. So, we count the numbers that can both fit in `arr1` and `arr2` as the variable `both` in `valid` function.\\nIf `max(uniqueCnt1-only1, 0) + max(uniqueCnt2-only2, 0) > both`, it means that we cannot fill `arr1` and `arr2` with the `1~n` limit.\\nSo, we are start looking for the smallest `n` that can fulfill the case by binary search with `O(nlogn)` time complexity.\\n# Code\\n```python []\\n\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        uc1 = uniqueCnt1\\n        uc2 = uniqueCnt2\\n        d1 = divisor1\\n        d2 = divisor2\\n        def gcd(a, b):\\n            if a == 0:\\n                return b\\n            return gcd(b%a, a)\\n        def valid(n):\\n            only1 = n // d2 - n // lcm\\n            only2 = n // d1 - n // lcm\\n            both = n - n // d1 - n // d2 + n // lcm\\n            return max(0, uc1 - only1) + max(0, uc2 - only2) <= both\\n            \\n        gcd1 = gcd(d1, d2)\\n        lcm = d1*d2/gcd1\\n        return bisect_left(range(uniqueCnt1*d1+d2*uniqueCnt2+1), True, lo=1, key=valid)\\n            \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python []\\n\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        uc1 = uniqueCnt1\\n        uc2 = uniqueCnt2\\n        d1 = divisor1\\n        d2 = divisor2\\n        def gcd(a, b):\\n            if a == 0:\\n                return b\\n            return gcd(b%a, a)\\n        def valid(n):\\n            only1 = n // d2 - n // lcm\\n            only2 = n // d1 - n // lcm\\n            both = n - n // d1 - n // d2 + n // lcm\\n            return max(0, uc1 - only1) + max(0, uc2 - only2) <= both\\n            \\n        gcd1 = gcd(d1, d2)\\n        lcm = d1*d2/gcd1\\n        return bisect_left(range(uniqueCnt1*d1+d2*uniqueCnt2+1), True, lo=1, key=valid)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966857,
                "title": "c-binary-search-with-approach",
                "content": "# Observation\\nHere we have to minimize the maximum of two array and questions like that always use Binary Search to solve we pick one number if that number satisfy all the conditions so we have to go for more optimizedd solution in this case lesser number than the prev number which setisfy all the conditions\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere for each number we can find out how many numbers are divisibal by **div1** form 1 to mid numbers by ```mid/div1``` this many numbers we can easily add to the array2 and visa versa by there is some number which can not be taken in any array becoz thay divisibal by both div1 and div2 like e.g. div1=2 div2=3 and number=6 so number 6 can not be taken in any of it so for that we can find out such numbers by ````mid-lcm(div1,div2)````\\n\\n# Complexity\\n- Time complexity: O(NlongN) where N=INT_MAX\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n\\nint gcd(int a, int b) {\\n    if (!b) return a;\\n    return gcd(b, a % b);\\n}\\nint lcm(long long a, long long b) {\\n    long long temp = (a / gcd(a, b)) * b;\\n    return temp > INT_MAX ? INT_MAX : temp;\\n}\\n\\npublic:\\n    int minimizeSet(int div1, int div2, int cnt1, int cnt2) {\\n        int Lcm=lcm(div1,div2);\\n        int ans=-1;\\n        int low=1,high=INT_MAX;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int divBy1=mid/div1, divBy2=mid/div2;\\n            if(cnt1+cnt2<=mid-mid/Lcm && cnt1<=mid-divBy1 && cnt2<=mid-divBy2){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```mid/div1```\n````mid-lcm(div1,div2)```\n```\\nclass Solution {\\nprivate:\\n\\nint gcd(int a, int b) {\\n    if (!b) return a;\\n    return gcd(b, a % b);\\n}\\nint lcm(long long a, long long b) {\\n    long long temp = (a / gcd(a, b)) * b;\\n    return temp > INT_MAX ? INT_MAX : temp;\\n}\\n\\npublic:\\n    int minimizeSet(int div1, int div2, int cnt1, int cnt2) {\\n        int Lcm=lcm(div1,div2);\\n        int ans=-1;\\n        int low=1,high=INT_MAX;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int divBy1=mid/div1, divBy2=mid/div2;\\n            if(cnt1+cnt2<=mid-mid/Lcm && cnt1<=mid-divBy1 && cnt2<=mid-divBy2){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954965,
                "title": "java-solution-pure-math-o-1-beats-100-without-a-single-loop",
                "content": "# Intuition\\nlet `lcm` be the least common multiple of `divisor1` and `divisor2`\\n\\nWe can count possitive integers in batches (instead of one by one) to accelertae the algorithm. Say `divisor1=4` and `divisor2=6` and `lcm=12`.For every `lcm`-sized batch (e.g. `{1,2,3,4,5,6,7,8,9,10,11,12}`), there will be:\\n```\\nOne integer only able to fit into arr1 (divisible by 6 but not by 4): {6}\\nTwo integers only able to fit into arr2: {4,8}\\nOne integer can\\'t fit into either ones: {12} (of course that\\'s the lcm)\\nAll other left (eight) integers able to fit into both: {1,2,3,5,7,9,10,11}\\n```\\nLet\\'s define some variables: \\nthe number of integers, in a single `lcm`-sized batch, that can only fit into `arr1` (nondivisible by `divisor1` only `{6}`) is `nondiv1=1`\\n\\nand likewise `nondiv2=2 ({4,8})`, `common=8 ({1,2,3,5,7,9,10,11})` \\n\\n`nondiv1`, `nondiv2` and `common` are the candidates of our final answer (they can fit into at least one of `arr1` and `arr2`)\\n\\nFor each `lcm`-sized batch, there will be `lcm-1` candidates (only the `lcm` cannot contribute to our final answer)\\n\\n# Approach\\nTo find the final answer, we need to find at least `uniqueCnt1 + uniqueCnt2` different candidates. let\\'s take this example for the following explanation: \\n```\\ndivisor1 = 4 \\ndivisor2 = 6\\nuniqueCnt1 = 20000\\nuniqueCnt2 = 5000\\n``` \\nthe **criteria** for a valid answer is:\\n\\nthere exist a split of common: `common = common1 + common2`, such that:\\n`divisor1 + common1 >= uniqueCnt1` and \\n`divisor2 + common2 >= uniqueCnt2`\\n## I\\nSince for every 12 possitive integers (counting from 1) there will be 11 candidates, let\\'s first compute how many full batches do we need: `batches = (20000+5000) / 11 = 2272`\\n\\nAmong these 2272 batches, \\n\\n`nondiv1 = 1 * 2272 = 2272` (2272 integers only fit into `arr1`)\\n\\n`nondiv2 = 2 * 2272 = 4544` (4544 integers only fit into `arr2`)\\n\\n`common = 8 * 2272 = 18176` (18176 integers fit into both `arr1` and `arr2`)\\n\\n`nondiv1 + nondiv2 + common = 24992 < uniqueCnt1 + uniqueCnt2`, wee need more candidates\\n\\n## II\\n`(uniqueCnt1 + uniqueCnt2) % (lcm-1) = (20000+5000) % 11 = 8`, we still need to add 8 more candidates\\n\\nA full batch contributes `lcm - 1 = 11` candidates, of course the `remainder = 8` is smaller than `11` and we don\\'t need a full batch\\n\\nfor the next `8` integers:\\n\\nthere will be `8 / 4 = 2` ones only divisible by `4` (and of course only fit into `arr2`): `nondiv2 += 2`\\n\\n`8 / 6 = 1` integer only divisible by `6`: `nondiv1 += 1`\\n\\n`8 - 2 - 1 = 5` integers fit into both: `common += 5`\\n\\nnow we have:\\n\\n```\\nnondiv1 = 2273\\nnondiv2 = 4546\\ncommon = 18181\\nnondiv1 + nondiv2 + common = 25000 = uniqueCnt1 + uniqueCnt2\\n```\\n\\nWe\\'ve counted 2272 full batchs (that is `2272*12 = 27264` integers) together with `8` more remainders: `27264 + 8 = 27272`\\n\\nWe can verify with the **criteria** mentioned above that `27272` is the final answer\\n\\n## III\\n\\nSometimes we can just stop here, consider another example:\\n```\\ndivisor1 = 4 \\ndivisor2 = 6\\nuniqueCnt1 = 25000\\nuniqueCnt2 = 5000\\n``` \\nBy calculating the step (I) and step (II), we get:\\n```\\nnondiv1 = 2727\\nnondiv2 = 5454\\ncommon = 21819\\nanswer = 2727 * 12 + 3 = 32727\\n```\\n\\nWe have `nondiv1 + nondiv2 + common = 30000 = uniqueCnt1 + uniqueCnt2`, but `arr1` is not filled up yet even though we assign all `common` to `arr1`: `2727+21819=24546<25000`. And `arr2` is overflow: `5454 > 5000`\\n\\nIn other words, by step (I) and (II) we just find enough **number** of candidates despite some candidates are redundant and some are deficient. (remember we have 3 types of candidates)\\n\\nIn this scenario, we just need to find `25000-24546=454` more candidates for `arr1`:\\n\\nFor every 4 consecutive integers, there will be 3 able to fit into `arr1`:\\n\\n```\\nanswer += 454/(4-1)*4\\nanswer = 33331\\n```\\n\\n`454 % 3 = 1` more candidates needed,\\n\\n`answer + 1 = 33332` (divisible by 4) is an invalid candidates (these kind of cases is a little tricky to handle in the algorithm implementation), need to count onec more,\\n\\n`answer + 1 = 33333` is the final valid answer\\n\\n\\n# Complexity\\n- Time complexity: O(1) (despite calculating GCD)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static public long gcd(int a, int b) { return b==0 ? a : gcd(b, a%b); }\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long gcd=gcd(divisor1,divisor2), lcm=(long)divisor1*(long)divisor2/gcd;\\n        long divisible1=lcm/divisor1, divisible2=lcm/divisor2;\\n        long nondivisibleCommon = lcm - divisible1 - divisible2 + 1;\\n        long batches = (uniqueCnt1+uniqueCnt2)/(lcm-1), remainder = (uniqueCnt1+uniqueCnt2)%(lcm-1);\\n        long nondiv1=(divisible2-1)*batches, nondiv2=(divisible1-1)*batches, common=nondivisibleCommon*batches;\\n        nondiv1 += remainder/divisor2;\\n        nondiv2 += remainder/divisor1;\\n        common += (remainder-remainder/divisor1-remainder/divisor2);\\n        long answer = batches * lcm + remainder;\\n        if (nondiv1<=uniqueCnt1 && nondiv2<=uniqueCnt2) {\\n            return remainder==0 ? (int)answer - 1 : (int) answer;\\n        } else {\\n            long nondiv = nondiv1 >= uniqueCnt1 ? nondiv2 : nondiv1;\\n            long cnt = nondiv1 >= uniqueCnt1 ? uniqueCnt2 : uniqueCnt1;\\n            long divisor = nondiv1 >= uniqueCnt1 ? divisor2 : divisor1;\\n            long remain = cnt - nondiv - common;\\n            answer += remain/(divisor-1)*divisor;\\n            remain %= divisor-1;\\n            if (remain==0) {\\n                return  answer%divisor==0 ? (int)answer-1: (int)answer;\\n            } else if (answer%divisor + remain >= divisor) {\\n                return (int)answer + (int)remain + 1;\\n            } else {\\n                return (int)answer + (int)remain;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nOne integer only able to fit into arr1 (divisible by 6 but not by 4): {6}\\nTwo integers only able to fit into arr2: {4,8}\\nOne integer can\\'t fit into either ones: {12} (of course that\\'s the lcm)\\nAll other left (eight) integers able to fit into both: {1,2,3,5,7,9,10,11}\\n```\n```\\ndivisor1 = 4 \\ndivisor2 = 6\\nuniqueCnt1 = 20000\\nuniqueCnt2 = 5000\\n```\n```\\nnondiv1 = 2273\\nnondiv2 = 4546\\ncommon = 18181\\nnondiv1 + nondiv2 + common = 25000 = uniqueCnt1 + uniqueCnt2\\n```\n```\\ndivisor1 = 4 \\ndivisor2 = 6\\nuniqueCnt1 = 25000\\nuniqueCnt2 = 5000\\n```\n```\\nnondiv1 = 2727\\nnondiv2 = 5454\\ncommon = 21819\\nanswer = 2727 * 12 + 3 = 32727\\n```\n```\\nanswer += 454/(4-1)*4\\nanswer = 33331\\n```\n```\\nclass Solution {\\n    static public long gcd(int a, int b) { return b==0 ? a : gcd(b, a%b); }\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long gcd=gcd(divisor1,divisor2), lcm=(long)divisor1*(long)divisor2/gcd;\\n        long divisible1=lcm/divisor1, divisible2=lcm/divisor2;\\n        long nondivisibleCommon = lcm - divisible1 - divisible2 + 1;\\n        long batches = (uniqueCnt1+uniqueCnt2)/(lcm-1), remainder = (uniqueCnt1+uniqueCnt2)%(lcm-1);\\n        long nondiv1=(divisible2-1)*batches, nondiv2=(divisible1-1)*batches, common=nondivisibleCommon*batches;\\n        nondiv1 += remainder/divisor2;\\n        nondiv2 += remainder/divisor1;\\n        common += (remainder-remainder/divisor1-remainder/divisor2);\\n        long answer = batches * lcm + remainder;\\n        if (nondiv1<=uniqueCnt1 && nondiv2<=uniqueCnt2) {\\n            return remainder==0 ? (int)answer - 1 : (int) answer;\\n        } else {\\n            long nondiv = nondiv1 >= uniqueCnt1 ? nondiv2 : nondiv1;\\n            long cnt = nondiv1 >= uniqueCnt1 ? uniqueCnt2 : uniqueCnt1;\\n            long divisor = nondiv1 >= uniqueCnt1 ? divisor2 : divisor1;\\n            long remain = cnt - nondiv - common;\\n            answer += remain/(divisor-1)*divisor;\\n            remain %= divisor-1;\\n            if (remain==0) {\\n                return  answer%divisor==0 ? (int)answer-1: (int)answer;\\n            } else if (answer%divisor + remain >= divisor) {\\n                return (int)answer + (int)remain + 1;\\n            } else {\\n                return (int)answer + (int)remain;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946727,
                "title": "c-binary-search-lcm-using-set-theory",
                "content": "This is really a good problem. Why so many downvote.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse the binary to convert the problem to a decision problem:\\n- set the maximum in the total number set, check if it\\'s possible to distribute these numbers to the 2 ```uniqueCnt``` array.\\n\\n# Approach: Inside the Decision Problem\\n<!-- Describe your approach to solving the problem. -->\\nTo check if the distribution is possible, need to partition the number set into 3 parts:\\n- only NOT divisible by ```divisor1```\\n- only NOT divisible by ```divisor2```\\n- NOT divisible by both ```divisor1``` nor ```divisor2```\\n\\nYou can try to figure how to compute above numbers\\n\\neg.\\ngiven d1 = 2, d2 = 7, max_num = 16\\n```\\nset1  : 1,      3,      5,      7,      9,     11,     13,     15,\\nset2  : 1,  2,  3,  4,  5,  6,      8,  9, 10, 11, 12, 13,     15, 16\\ncommon: 1,      3,      5,              9,     11,     13,     15,\\n```\\nso the number of each set is\\n```\\na = set1 - common = 1\\nb = set2 - common = 7\\ncommon = 7\\n```\\n\\nThe possibility to distribute to the 2 array\\n```\\nbool possible = sum >= (n + m) && n <= (a + common) && m <= (b + common)\\n```\\n1. The total available number should be enough: ```sum >= (n + m)```\\n2. Enough numbers to distribute to each array: ```n <= (a + common) && m <= (b + common)```\\n\\nSo we can use binary search with the above decision problem to find out the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```O(log(1e10))```\\n1e10 is actually enough, because ```2 <= uniqueCnt1 + uniqueCnt2 <= 1e9```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // given div and max num, return the each set size\\n    inline array<long, 3> f(long d1, long d2, long ma) {\\n        long a = ma - ma / d1, b = ma - ma / d2;\\n        long common = ma - (ma / d1 + ma / d2 - ma / lcm(d1, d2));\\n        return {a - common, common, b - common};\\n    }\\n    \\n    int minimizeSet(int d1, int d2, int n, int m) {\\n        long l = 1, r = 1e10;\\n        \\n        while(l < r) {\\n            long mid = (l + r) / 2;  // len of array\\n            \\n            auto [a, common, b] = f(d1, d2, mid);\\n            long sum = a + common + b;\\n            bool possible = sum >= (n + m) && n <= (a + common) && m <= (b + common);\\n            \\n            if(!possible) l = mid + 1;\\n            else r = mid;\\n            \\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```uniqueCnt```\n```divisor1```\n```divisor2```\n```divisor1```\n```divisor2```\n```\\nset1  : 1,      3,      5,      7,      9,     11,     13,     15,\\nset2  : 1,  2,  3,  4,  5,  6,      8,  9, 10, 11, 12, 13,     15, 16\\ncommon: 1,      3,      5,              9,     11,     13,     15,\\n```\n```\\na = set1 - common = 1\\nb = set2 - common = 7\\ncommon = 7\\n```\n```\\nbool possible = sum >= (n + m) && n <= (a + common) && m <= (b + common)\\n```\n```sum >= (n + m)```\n```n <= (a + common) && m <= (b + common)```\n```O(log(1e10))```\n```2 <= uniqueCnt1 + uniqueCnt2 <= 1e9```\n```\\nclass Solution {\\npublic:\\n    // given div and max num, return the each set size\\n    inline array<long, 3> f(long d1, long d2, long ma) {\\n        long a = ma - ma / d1, b = ma - ma / d2;\\n        long common = ma - (ma / d1 + ma / d2 - ma / lcm(d1, d2));\\n        return {a - common, common, b - common};\\n    }\\n    \\n    int minimizeSet(int d1, int d2, int n, int m) {\\n        long l = 1, r = 1e10;\\n        \\n        while(l < r) {\\n            long mid = (l + r) / 2;  // len of array\\n            \\n            auto [a, common, b] = f(d1, d2, mid);\\n            long sum = a + common + b;\\n            bool possible = sum >= (n + m) && n <= (a + common) && m <= (b + common);\\n            \\n            if(!possible) l = mid + 1;\\n            else r = mid;\\n            \\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946509,
                "title": "c-binary-search-lcm",
                "content": "The minimum possible answer is UniqueCnt1 + UniqueCnt2.\\nThe values which are divisible by both divisor1 and divisor2 need to be added to the required total.\\n(This is stored in `both`)\\n\\nThe values which are multiple of divisor2 and not a multiple of divisor1 will be reserved for UniqueCnt1.\\n(This is stored in `OnlyA`)\\n\\nThe values which are multiple of divisor1 and not a multiple of divisor2 will be reserved for UniqueCnt2.\\n(This is stored in `OnlyB`)\\n\\nNow the total remaining value are ``ONLY THOSE`` which are neither multiple of divisor1 nor multiple of divisor2.\\n(This is store in `total`)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(long long div1, long long div2, int cnt1, int cnt2)\\n    {\\n        long long lcm = (div1 * div2) / __gcd(div1, div2);\\n        long long total = cnt1 + cnt2;\\n        long long l = total, r = 1e12;\\n        long long ans = 0;\\n        while (l <= r)\\n        {\\n            long long mid = (l + r) / 2;\\n            long long both = mid / lcm;\\n            long long onlyA = mid / div2 - both;\\n            long long onlyB = mid / div1 - both;\\n            total = max(0ll, cnt1 - onlyA) + max(0ll, cnt2 - onlyB);\\n            if (mid - onlyA - onlyB >= total + both)\\n            {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n/*Some Extra Test Cases:\\n78789 42659 58291 182389  => 240680\\n16 14 12 8                => 20\\n5 2 2 20                  => 39\\n\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(long long div1, long long div2, int cnt1, int cnt2)\\n    {\\n        long long lcm = (div1 * div2) / __gcd(div1, div2);\\n        long long total = cnt1 + cnt2;\\n        long long l = total, r = 1e12;\\n        long long ans = 0;\\n        while (l <= r)\\n        {\\n            long long mid = (l + r) / 2;\\n            long long both = mid / lcm;\\n            long long onlyA = mid / div2 - both;\\n            long long onlyB = mid / div1 - both;\\n            total = max(0ll, cnt1 - onlyA) + max(0ll, cnt2 - onlyB);\\n            if (mid - onlyA - onlyB >= total + both)\\n            {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n/*Some Extra Test Cases:\\n78789 42659 58291 182389  => 240680\\n16 14 12 8                => 20\\n5 2 2 20                  => 39\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565603,
                "title": "using-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(long long divisor1, long long divisor2, long long uniqueCnt1, long long uniqueCnt2) {\\n        long long ans = INT_MAX;\\n        long long lccmm = lcm(divisor1,divisor2);\\n        long long l = 0,r = 1e12;\\n        while(l <= r){\\n            long long mid = (l + r)/2;\\n            \\n            long long rem = mid;\\n            long long z = 0;\\n            \\n            long long rem1 = max(z,uniqueCnt1 - min(uniqueCnt1,mid/divisor2 - mid/lccmm));\\n            long long rem2 = max(z,uniqueCnt2 - min(uniqueCnt2,mid/divisor1 - mid/lccmm));\\n            \\n            rem = rem - mid/divisor2 - mid/divisor1 + mid/lccmm;\\n            \\n            if(rem1 + rem2 > rem){\\n                l = mid + 1;\\n            }\\n            else{\\n                if(mid%divisor1 == 0 && mid%divisor2 == 0){\\n                    ans = min(ans,mid + 1);\\n                }\\n                else ans = min(ans,mid);\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(long long divisor1, long long divisor2, long long uniqueCnt1, long long uniqueCnt2) {\\n        long long ans = INT_MAX;\\n        long long lccmm = lcm(divisor1,divisor2);\\n        long long l = 0,r = 1e12;\\n        while(l <= r){\\n            long long mid = (l + r)/2;\\n            \\n            long long rem = mid;\\n            long long z = 0;\\n            \\n            long long rem1 = max(z,uniqueCnt1 - min(uniqueCnt1,mid/divisor2 - mid/lccmm));\\n            long long rem2 = max(z,uniqueCnt2 - min(uniqueCnt2,mid/divisor1 - mid/lccmm));\\n            \\n            rem = rem - mid/divisor2 - mid/divisor1 + mid/lccmm;\\n            \\n            if(rem1 + rem2 > rem){\\n                l = mid + 1;\\n            }\\n            else{\\n                if(mid%divisor1 == 0 && mid%divisor2 == 0){\\n                    ans = min(ans,mid + 1);\\n                }\\n                else ans = min(ans,mid);\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096613,
                "title": "binary-search-faster-100",
                "content": "```c++\\n int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long ans = INT_MAX;\\n        long long low = 1, high = INT_MAX;\\n        auto common = (long long) d1 * d2 / __gcd(d1,d2); // alternate lcm((long long) d1, d2);\\n        \\n        while (low <= high) {\\n            auto mid = ( low + high ) / 2;\\n            auto notDivisibleByd1 = mid - mid / d1;\\n            auto notDivisibleByd2 = mid - mid / d2;\\n            auto notDivisibleByBoth = mid - mid / common;\\n            \\n            if (notDivisibleByd1 >= cnt1 \\n                and notDivisibleByd2 >= cnt2 \\n                and notDivisibleByBoth >= cnt1 + cnt2) \\n                    ans = mid, high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\n int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long ans = INT_MAX;\\n        long long low = 1, high = INT_MAX;\\n        auto common = (long long) d1 * d2 / __gcd(d1,d2); // alternate lcm((long long) d1, d2);\\n        \\n        while (low <= high) {\\n            auto mid = ( low + high ) / 2;\\n            auto notDivisibleByd1 = mid - mid / d1;\\n            auto notDivisibleByd2 = mid - mid / d2;\\n            auto notDivisibleByBoth = mid - mid / common;\\n            \\n            if (notDivisibleByd1 >= cnt1 \\n                and notDivisibleByd2 >= cnt2 \\n                and notDivisibleByBoth >= cnt1 + cnt2) \\n                    ans = mid, high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981519,
                "title": "c-binary-search-linewise-logic-explanation",
                "content": "# Code\\n```\\n\\n// Time Complexity = log(c1+c2), performing binary search with c1+c2 elements\\n\\nclass Solution {\\npublic:\\n\\n    bool satisfy( long long div1, long long div2, long long c1, long long c2, long long mid ){\\n        \\n        long long div_d1 = mid / div1;            // number of elements divisible by d1\\n        long long div_d2 = mid / div2;            // number of elements divisible by d2\\n\\n        long long not_div_d1 = mid - div_d1;    // number of elements not divisble by d1\\n        long long not_div_d2 = mid - div_d2;    // number of elements not divisble by d2\\n\\n        long long not_div_both = mid - mid / lcm(div1,div2);  // number of elements not divisble by both d1 and d2\\n\\n// so, finally,we check whether to construct the array1, do we have enough number of elements ? and similarly do we have enough elements NOT divisible by d2 to construct d2? and if the numbers NOT divisible by both d1 and d2 are more than c1 and c2, in this 3rd condition, simplty put, we are checking do we even have enough of the elegible numbers to be put in either of the arrays collectively, thus, c1+c2 <= not_div_both.\\n\\n        if( c1 <= not_div_d1 && c2 <= not_div_d2 && c1+c2 <=  not_div_both ) return true;\\n\\n        return false;\\n\\n    }\\n\\n    int minimizeSet(int div1, int div2, int c1, int c2) {\\n        \\n        long long ans = INT_MAX, hi = INT_MAX, l = 1; \\n\\n        while( l <= hi ){\\n        \\n            long long mid = l + (hi-l) / 2 ;\\n\\n            if( satisfy( div1, div2, c1, c2, mid ) ) {  // if we can, decrease the hi to mid-1, thus we have new minimum maximum integer.\\n                ans = min( mid, ans );\\n                hi = mid - 1;\\n            }\\n            else l = mid + 1; // if we cant satisfy(), we look for the integer in the right half of the array.\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\n\\n// Time Complexity = log(c1+c2), performing binary search with c1+c2 elements\\n\\nclass Solution {\\npublic:\\n\\n    bool satisfy( long long div1, long long div2, long long c1, long long c2, long long mid ){\\n        \\n        long long div_d1 = mid / div1;            // number of elements divisible by d1\\n        long long div_d2 = mid / div2;            // number of elements divisible by d2\\n\\n        long long not_div_d1 = mid - div_d1;    // number of elements not divisble by d1\\n        long long not_div_d2 = mid - div_d2;    // number of elements not divisble by d2\\n\\n        long long not_div_both = mid - mid / lcm(div1,div2);  // number of elements not divisble by both d1 and d2\\n\\n// so, finally,we check whether to construct the array1, do we have enough number of elements ? and similarly do we have enough elements NOT divisible by d2 to construct d2? and if the numbers NOT divisible by both d1 and d2 are more than c1 and c2, in this 3rd condition, simplty put, we are checking do we even have enough of the elegible numbers to be put in either of the arrays collectively, thus, c1+c2 <= not_div_both.\\n\\n        if( c1 <= not_div_d1 && c2 <= not_div_d2 && c1+c2 <=  not_div_both ) return true;\\n\\n        return false;\\n\\n    }\\n\\n    int minimizeSet(int div1, int div2, int c1, int c2) {\\n        \\n        long long ans = INT_MAX, hi = INT_MAX, l = 1; \\n\\n        while( l <= hi ){\\n        \\n            long long mid = l + (hi-l) / 2 ;\\n\\n            if( satisfy( div1, div2, c1, c2, mid ) ) {  // if we can, decrease the hi to mid-1, thus we have new minimum maximum integer.\\n                ans = min( mid, ans );\\n                hi = mid - 1;\\n            }\\n            else l = mid + 1; // if we cant satisfy(), we look for the integer in the right half of the array.\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975673,
                "title": "easy-c-binary-search-with-comments-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- take a number possible in the range 2 to (1e9), using binary search \\n- minimize the number taken, and for which solution is possible\\n# Complexity\\n- Time complexity: O(log(1e9))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(long long int mx,int div1,int div2,int u1,int u2){\\n        // find the count of elements can\\'t be taken in arr1\\n        long long int c1=mx/div1;\\n        long long int lcm=(long long) div1* (long long )div2/__gcd(div1,div2);\\n        // find the count of elements can\\'t be taken in both arrays\\n        int count=mx/lcm;\\n        // find the count of elements can\\'t be taken in arr2\\n        long long int c2=mx/div2;\\n        // if arr1 not feasible\\n        if(mx-c1<u1){\\n            return false;\\n        }\\n        // if arr2 not feasible\\n        if(mx-c2<u2){\\n            return false;\\n        }\\n        // if both array together not feasible\\n        if(mx-count<(u1+u2)){\\n            return false;\\n        }\\n        // now both the arrays together is feasible\\n        return true;\\n    }\\n    int minimizeSet(int div1, int div2, int u1, int u2) {\\n        long long int end=10000000000;\\n        long long int start=2;\\n        int ans=-1;\\n        while(start<=end){\\n            long long int mid=start+(end-start)/2;\\n            // check if it is possible for mid to be a possible solution\\n            if(isPossible(mid,div1,div2,u1,u2)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(long long int mx,int div1,int div2,int u1,int u2){\\n        // find the count of elements can\\'t be taken in arr1\\n        long long int c1=mx/div1;\\n        long long int lcm=(long long) div1* (long long )div2/__gcd(div1,div2);\\n        // find the count of elements can\\'t be taken in both arrays\\n        int count=mx/lcm;\\n        // find the count of elements can\\'t be taken in arr2\\n        long long int c2=mx/div2;\\n        // if arr1 not feasible\\n        if(mx-c1<u1){\\n            return false;\\n        }\\n        // if arr2 not feasible\\n        if(mx-c2<u2){\\n            return false;\\n        }\\n        // if both array together not feasible\\n        if(mx-count<(u1+u2)){\\n            return false;\\n        }\\n        // now both the arrays together is feasible\\n        return true;\\n    }\\n    int minimizeSet(int div1, int div2, int u1, int u2) {\\n        long long int end=10000000000;\\n        long long int start=2;\\n        int ans=-1;\\n        while(start<=end){\\n            long long int mid=start+(end-start)/2;\\n            // check if it is possible for mid to be a possible solution\\n            if(isPossible(mid,div1,div2,u1,u2)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964450,
                "title": "binary-search-approach-java-solution-clean-code",
                "content": "# Code\\n```java\\nclass Solution {\\n    int gcd(int a,int b){\\n        return b == 0 ? a : gcd(b,a % b);\\n    }\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long l = 1,r = (int)(2 * 1e9);\\n        long ans = r;\\n        long lcm = (1L * divisor1 * divisor2) / gcd(divisor1,divisor2);\\n        for(;l <= r;){\\n            long mid = (l + r) >> 1;\\n            long x = mid - mid / divisor1;\\n            long y = mid - mid / divisor2;\\n            long z = mid - mid / lcm;\\n            if(x < 1L * uniqueCnt1 || y < 1L * uniqueCnt2 || z < 1L * (uniqueCnt1 + uniqueCnt2)) l = mid + 1;\\n            else{\\n                ans = Math.min(ans,mid);\\n                r = mid - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    int gcd(int a,int b){\\n        return b == 0 ? a : gcd(b,a % b);\\n    }\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long l = 1,r = (int)(2 * 1e9);\\n        long ans = r;\\n        long lcm = (1L * divisor1 * divisor2) / gcd(divisor1,divisor2);\\n        for(;l <= r;){\\n            long mid = (l + r) >> 1;\\n            long x = mid - mid / divisor1;\\n            long y = mid - mid / divisor2;\\n            long z = mid - mid / lcm;\\n            if(x < 1L * uniqueCnt1 || y < 1L * uniqueCnt2 || z < 1L * (uniqueCnt1 + uniqueCnt2)) l = mid + 1;\\n            else{\\n                ans = Math.min(ans,mid);\\n                r = mid - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963101,
                "title": "python-3-solution-7-lines-o-n-o-n",
                "content": "\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        f=lambda x:(x+abs(x))//2\\n        n,prev,d=uniqueCnt1+uniqueCnt2,0,lcm(divisor1,divisor2)\\n        while n>prev:\\n            prev=n\\n            l1,l2=n//divisor2-n//d,n//divisor1-n//d\\n            n+=f(f(uniqueCnt1-l1)+f(uniqueCnt2-l2)-n+n//d+l2+l1)\\n\\n        return n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        f=lambda x:(x+abs(x))//2\\n        n,prev,d=uniqueCnt1+uniqueCnt2,0,lcm(divisor1,divisor2)\\n        while n>prev:\\n            prev=n\\n            l1,l2=n//divisor2-n//d,n//divisor1-n//d\\n            n+=f(f(uniqueCnt1-l1)+f(uniqueCnt2-l2)-n+n//d+l2+l1)\\n\\n        return n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962066,
                "title": "simple-binary-search-on-answer",
                "content": "# Intuition\\n\\nSuppose we don\\'t have the constraint of sizes of the array, then when an integer is only divisible by d1 we can put it into array2 and vice versa. We can only not put an integer in some array if it is divisible by both d1 and d2. And this is when our answer diverges from the current integer being checked.\\n\\nNow, with the constraint of the sizes divergence increases further as let\\'s suppose array2 is filled and a number divisible by only d1 comes up then it has no place to go.\\n\\n# Approach\\nThe easiest approch will be using binary search. For every index we will check if we have required number of integers(u1+u2) and also all the constraint are satiesfied.\\n\\n# Complexity\\n- Time complexity:\\nO(log(u1+u2))\\n\\n- Space complexity:\\nO(log(u1+u2))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gcd(long long a, long long b){\\n        return ((!b)?a:(gcd(b, a%b)));\\n    }\\n\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long l = 1, h = (long long)(2*(1e9)+1);\\n        long long ans = h;\\n        unsigned long long lcm = (d1/gcd(d1,d2))*d2; // Tricky might get overflowed for (d1*d2)/gcd(d1,d2)\\n        while(l<=h){\\n            long long m = l + (h-l)/2;\\n            long long d_1 = m/d1-m/lcm, d_2 = m/d2-m/lcm, d_1_2 = m/lcm;\\n            long long need = m-d_1_2-((d_1>u2)?(d_1-u2):0)-((d_2>u1)?(d_2-u1):0);\\n            if(need>=(u1+u2)){\\n                ans = m;\\n                h = m-1;\\n            }\\n            else l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcd(long long a, long long b){\\n        return ((!b)?a:(gcd(b, a%b)));\\n    }\\n\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long l = 1, h = (long long)(2*(1e9)+1);\\n        long long ans = h;\\n        unsigned long long lcm = (d1/gcd(d1,d2))*d2; // Tricky might get overflowed for (d1*d2)/gcd(d1,d2)\\n        while(l<=h){\\n            long long m = l + (h-l)/2;\\n            long long d_1 = m/d1-m/lcm, d_2 = m/d2-m/lcm, d_1_2 = m/lcm;\\n            long long need = m-d_1_2-((d_1>u2)?(d_1-u2):0)-((d_2>u1)?(d_2-u1):0);\\n            if(need>=(u1+u2)){\\n                ans = m;\\n                h = m-1;\\n            }\\n            else l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953982,
                "title": "very-very-easy-c-solution-which-beats-100-both-in-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a simple binary search problem, in this question we just need to understand that if an integer $$x$$ can give enough unique count for both divisors then we are sure that $$x+1$$ will also going to give the result.\\n\\nThe intution of this problem is simple. Lets say for a particular value of x, so\\n- all the multiples of d1 can be added to the unique count of d2: $$(x/d2)$$\\n- all the multiples of d2 can be added to the unique count of d1: $$(x/d1)$$\\n- but doing this way, there are some values that are going to be multiples of both d1 and d2 till x, so we need to make sure that these values should not be added to the unique count of both arrays i.e. $$x/lcm(d1, d2)$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo in order to approach to this problem, for a particular value of x and lcm l, n1 be the number of unique count of divisor d1 and n2 for d2 respectively\\n- let d = x/lcm(d1, d2)\\n- n1 = m/d2 - d\\n- n2 = m/d1 - d\\n- now after that we check whether uniqueCount1 < n1 and uniqueCount2 < n2.\\n- We now calculate what are the left values that we can use to add to any of the d1 and d2 unique count, `left = m - n1 - n2 - d;`\\n- Now if anyone of the count lefted, we store that lefted count\\n    - n1 = max(0l, uniqueCount1 - n1)\\n    - n2 = max(0l, uniqueCount2 - n2)\\n- we just need to validate now that whether `n1 + n2 <= left` to return our answer.\\n\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long lcm(long a, long b){\\n        return (a/__gcd(a, b)) * b;\\n    }\\n\\n    long minimizeSet(long d1, long d2, long u1, long u2) {\\n        auto ok = [&](long &m){\\n            long d = m/lcm(d1, d2); // value that is divisible by both d1, d2\\n            long n1 = m/d2 - d;\\n            long n2 = m/d1 - d;\\n\\n            long left = m - n1 - n2 - d;\\n\\n            // cout << m << \" \" << n1 << \" \" << n2 << \" \" << left << \" \" << d << endl;\\n            // left should be enough for u1 and u2\\n            n1 = max(0l, u1 - n1);\\n            n2 = max(0l, u2 - n2);\\n\\n            // cout << n1 << \" \" << n2 << endl;\\n                        \\n            return (n1 + n2) <= left;\\n        };\\n        \\n        long l = u1+u2, h = 2*(u1 + u2);\\n        long ans = h;\\n\\n        while(l <= h){\\n            long m = (h - l)/2 + l;\\n\\n            if(ok(m)){\\n                ans = m;\\n                h = m-1;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long lcm(long a, long b){\\n        return (a/__gcd(a, b)) * b;\\n    }\\n\\n    long minimizeSet(long d1, long d2, long u1, long u2) {\\n        auto ok = [&](long &m){\\n            long d = m/lcm(d1, d2); // value that is divisible by both d1, d2\\n            long n1 = m/d2 - d;\\n            long n2 = m/d1 - d;\\n\\n            long left = m - n1 - n2 - d;\\n\\n            // cout << m << \" \" << n1 << \" \" << n2 << \" \" << left << \" \" << d << endl;\\n            // left should be enough for u1 and u2\\n            n1 = max(0l, u1 - n1);\\n            n2 = max(0l, u2 - n2);\\n\\n            // cout << n1 << \" \" << n2 << endl;\\n                        \\n            return (n1 + n2) <= left;\\n        };\\n        \\n        long l = u1+u2, h = 2*(u1 + u2);\\n        long ans = h;\\n\\n        while(l <= h){\\n            long m = (h - l)/2 + l;\\n\\n            if(ok(m)){\\n                ans = m;\\n                h = m-1;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2948907,
                "title": "binary-search-sets-math-with-explanation-via-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool predicate(long long d1, long long d2, long long u1, long long u2, long long x) {\\n        long long A = x / d1; // total numbers divisible by d1\\n        long long A_ = x - A; // total numbers not divisible by d1\\n        long long B = x / d2; // total numbers divisible by d2\\n        long long B_ = x - B; // total numbers not divisible by d2\\n        long long AIB = x / lcm(d1, d2); // total numbers divisible by d1 & d2\\n        long long AUB = A + B - AIB; // total numbers divisible by d1 or d2 \\n        long long AUB_ = x - AUB; // total numbers neither divisible by d1 nor d2 \\n\\n        long long needA = max(u1 - (B-AIB), 0ll); // required numbers after using the numbers that are not divisible by d1 but d2\\n        long long needB = max(u2 - (A-AIB), 0ll); // required numbers after using the numbers that are not divisible by d1 but d2\\n\\n        // total required elements should by less than equal to numbers left those are not divisible both d1 & d2\\n        return AUB_ >= needA + needB;\\n    }\\n    \\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long low = 1, high = 1e17;\\n        while (high > low + 1) {\\n            long long mid = (low + high) >> 1;\\n            if (predicate(d1, d2, u1, u2, mid)) \\n                high = mid;\\n            else \\n                low = mid;\\n        }\\n        \\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Union Find",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predicate(long long d1, long long d2, long long u1, long long u2, long long x) {\\n        long long A = x / d1; // total numbers divisible by d1\\n        long long A_ = x - A; // total numbers not divisible by d1\\n        long long B = x / d2; // total numbers divisible by d2\\n        long long B_ = x - B; // total numbers not divisible by d2\\n        long long AIB = x / lcm(d1, d2); // total numbers divisible by d1 & d2\\n        long long AUB = A + B - AIB; // total numbers divisible by d1 or d2 \\n        long long AUB_ = x - AUB; // total numbers neither divisible by d1 nor d2 \\n\\n        long long needA = max(u1 - (B-AIB), 0ll); // required numbers after using the numbers that are not divisible by d1 but d2\\n        long long needB = max(u2 - (A-AIB), 0ll); // required numbers after using the numbers that are not divisible by d1 but d2\\n\\n        // total required elements should by less than equal to numbers left those are not divisible both d1 & d2\\n        return AUB_ >= needA + needB;\\n    }\\n    \\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long low = 1, high = 1e17;\\n        while (high > low + 1) {\\n            long long mid = (low + high) >> 1;\\n            if (predicate(d1, d2, u1, u2, mid)) \\n                high = mid;\\n            else \\n                low = mid;\\n        }\\n        \\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948467,
                "title": "basic-proper-naming-of-variable",
                "content": "bool ispossible(long long mid,long long d1,int uc1,long long d2,int uc2,long long lcm)\\n    {\\n        long long bothCantTake=mid/lcm;\\n        long long iCanTake=mid-mid/d1;\\n        long long uCanTake=mid-mid/d2;\\n\\n        if(uc1>iCanTake || uc2>uCanTake)\\n            return false;\\n        \\n        if(uc1+uc2>mid-bothCantTake)\\n            return false;\\n        \\n        return true;\\n    }\\n    int minimizeSet(int d1, int d2, int uc1, int uc2)\\n    {    \\n         long long div1=d1,div2=d2;\\n         long long lcm=div1*div2/(__gcd(div1,div2));\\n         \\n         long long l=1,h=INT_MAX,ans=1;\\n         while(l<=h)\\n         {\\n             long long mid=h+(l-h)/2;\\n             if(ispossible(mid,d1,uc1,d2,uc2,lcm))\\n             {\\n                 ans=mid;\\n                 h=mid-1;\\n             }\\n             else\\n                 l=mid+1;\\n             \\n         }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "bool ispossible(long long mid,long long d1,int uc1,long long d2,int uc2,long long lcm)\\n    {\\n        long long bothCantTake=mid/lcm;\\n        long long iCanTake=mid-mid/d1;\\n        long long uCanTake=mid-mid/d2;\\n\\n        if(uc1>iCanTake || uc2>uCanTake)\\n            return false;\\n        \\n        if(uc1+uc2>mid-bothCantTake)\\n            return false;\\n        \\n        return true;\\n    }\\n    int minimizeSet(int d1, int d2, int uc1, int uc2)\\n    {    \\n         long long div1=d1,div2=d2;\\n         long long lcm=div1*div2/(__gcd(div1,div2));\\n         \\n         long long l=1,h=INT_MAX,ans=1;\\n         while(l<=h)\\n         {\\n             long long mid=h+(l-h)/2;\\n             if(ispossible(mid,d1,uc1,d2,uc2,lcm))\\n             {\\n                 ans=mid;\\n                 h=mid-1;\\n             }\\n             else\\n                 l=mid+1;\\n             \\n         }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2947440,
                "title": "python-3-solved-using-binary-search-and-set-theory",
                "content": "# Intuition\\nSo, basically, assuming that we used largest element x out of both arrays and fulfilled arr1.length == uniqueCnt1 and arr2.length == uniqueCnt2, then it could also be the case that y < x could also uphold same conditions as x. Thus, this leads me to considering search space of possible candidate answer values and utilizing binary search to minimize the max. of two arrays s.t. conditions hold.\\n\\n# Approach\\nBasically, to know if given target value x satisfy conditions, I utilize set theory to derive number of elements I can use to fill either arrays, or particular array and make sure that it satisfy the length requirements.\\nIf it does, then I reduce search space to consider lower values of x. Otherwise, current x isn\\'t large enough and I have to increase upper bound of range of positive integers to have enough options to fill both arrays arr1 and arr2!\\n\\n# Complexity\\n- Time complexity:\\nO(log(10^12) * 1) => O(log(1))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        #basically, given that we used some maximum integer of both arrays, arr1 and arr2, and satisfied above conditions,\\n        #we can see if trying lower values than current max still upholds condition since our main goal is minimizing the max.\\n        #element of both arrays! This means that we can utilize search space of answer candidates and execute binary search\\n        #for minimizing optimization.\\n        \\n        #I can define helper to check if given max value can uphold the conditions! \\n        \\n        def isGood(x):\\n            nonlocal divisor1, divisor2\\n            #get number of elements we can\\'t use to fill up either arr1 and arr2 within range of positive integers [1, x]!\\n            dontUseFirst = x // divisor1\\n            dontUseSecond = x // divisor2\\n            #seeing how many times lcm of both divisors go into x tells number of elements that can\\'t be used in either arrays!\\n            #Ex. div1 = 9, div2 = 4, x = 35\\n            #dontUseFirst = 35//9=3(9, 18, 27) dontUseSecond = 35//4=8(4, 8, 12 ,16,...) dontUseBoth = 35//36 = 0!\\n            #no number from 1-35 is divisible by both 9 and 4!\\n            dontUseBoth = x // math.lcm(divisor1, divisor2)\\n            \\n            #make sure we have enough elements in range of positive integers bounded by x to satisfy length requirements!\\n            if(x - dontUseBoth < uniqueCnt1 + uniqueCnt2):\\n                return False\\n            elif(x - dontUseFirst < uniqueCnt1): \\n                return False\\n            elif(x - dontUseSecond < uniqueCnt2):\\n                return False\\n            else:\\n                return True \\n        \\n        #we have to define left and right bound of search space to bin. search upon!\\n        left, right = 1, 10 ** 12\\n        ans = None\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = isGood(mid)\\n            #if mid value candidate upholds condition, then it could be that vals < mid could still uphold conditions!\\n            if(res):\\n                ans = mid\\n                right = mid - 1\\n                continue\\n            else:\\n                left = mid + 1\\n                continue\\n                \\n        return ans\\n        \\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n    \\n                    \\n                \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        #basically, given that we used some maximum integer of both arrays, arr1 and arr2, and satisfied above conditions,\\n        #we can see if trying lower values than current max still upholds condition since our main goal is minimizing the max.\\n        #element of both arrays! This means that we can utilize search space of answer candidates and execute binary search\\n        #for minimizing optimization.\\n        \\n        #I can define helper to check if given max value can uphold the conditions! \\n        \\n        def isGood(x):\\n            nonlocal divisor1, divisor2\\n            #get number of elements we can\\'t use to fill up either arr1 and arr2 within range of positive integers [1, x]!\\n            dontUseFirst = x // divisor1\\n            dontUseSecond = x // divisor2\\n            #seeing how many times lcm of both divisors go into x tells number of elements that can\\'t be used in either arrays!\\n            #Ex. div1 = 9, div2 = 4, x = 35\\n            #dontUseFirst = 35//9=3(9, 18, 27) dontUseSecond = 35//4=8(4, 8, 12 ,16,...) dontUseBoth = 35//36 = 0!\\n            #no number from 1-35 is divisible by both 9 and 4!\\n            dontUseBoth = x // math.lcm(divisor1, divisor2)\\n            \\n            #make sure we have enough elements in range of positive integers bounded by x to satisfy length requirements!\\n            if(x - dontUseBoth < uniqueCnt1 + uniqueCnt2):\\n                return False\\n            elif(x - dontUseFirst < uniqueCnt1): \\n                return False\\n            elif(x - dontUseSecond < uniqueCnt2):\\n                return False\\n            else:\\n                return True \\n        \\n        #we have to define left and right bound of search space to bin. search upon!\\n        left, right = 1, 10 ** 12\\n        ans = None\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = isGood(mid)\\n            #if mid value candidate upholds condition, then it could be that vals < mid could still uphold conditions!\\n            if(res):\\n                ans = mid\\n                right = mid - 1\\n                continue\\n            else:\\n                left = mid + 1\\n                continue\\n                \\n        return ans\\n        \\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n    \\n                    \\n                \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947218,
                "title": "c-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we use **Binary Search** to search for the answer.\\nIf the numbers from 1 to the ```end``` is enough for the arrays ( i.e ```arr1``` and ```arr2```), then the answer is smaller or equal to the ```end```, else the answer is bigger than the ```end```.\\n\\n# Complexity\\n- Time complexity: $$O(log(INT\\\\_MAX))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        _d1 = divisor1, _d2 = divisor2, _c1 = uniqueCnt1, _c2 = uniqueCnt2;\\n        _LCM = lcm(_d1,_d2);\\n        unsigned long long left = 1, right = INT_MAX, middle;\\n        while(left < right)\\n        {   \\n            middle = (left + right) / 2;\\n            if(enough(middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    bool enough(int end)\\n    {\\n        if((end - end / _d1) < _c1 ||\\n           (end - end / _d2) < _c2 || \\n           (end - end / _LCM) < (_c1 + _c2))\\n            return false;\\n        else\\n            return true;\\n    }\\n\\nprivate:\\n    unsigned long long _d1, _d2, _c1, _c2;\\n    unsigned long long _LCM;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```end```\n```arr1```\n```arr2```\n```end```\n```end```\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        _d1 = divisor1, _d2 = divisor2, _c1 = uniqueCnt1, _c2 = uniqueCnt2;\\n        _LCM = lcm(_d1,_d2);\\n        unsigned long long left = 1, right = INT_MAX, middle;\\n        while(left < right)\\n        {   \\n            middle = (left + right) / 2;\\n            if(enough(middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    bool enough(int end)\\n    {\\n        if((end - end / _d1) < _c1 ||\\n           (end - end / _d2) < _c2 || \\n           (end - end / _LCM) < (_c1 + _c2))\\n            return false;\\n        else\\n            return true;\\n    }\\n\\nprivate:\\n    unsigned long long _d1, _d2, _c1, _c2;\\n    unsigned long long _LCM;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946882,
                "title": "c-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long st = 1, end = 9999999999, ans = 0;\\n        while(st<=end){\\n            long long mid = (st + end)/2;\\n            long long d1 = mid - mid/divisor1;\\n            long long lm = ((long long)divisor1*(long long)divisor2)/__gcd((long long)divisor1,(long long)divisor2);\\n            long long num = (mid/divisor2-(mid)/lm);\\n            int mn = min((int)uniqueCnt1,(int)num);\\n            long long d2 = mid - uniqueCnt1 - (mid/divisor2) + mn;\\n            if(d1>=uniqueCnt1&&d2>=uniqueCnt2){\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                st = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long st = 1, end = 9999999999, ans = 0;\\n        while(st<=end){\\n            long long mid = (st + end)/2;\\n            long long d1 = mid - mid/divisor1;\\n            long long lm = ((long long)divisor1*(long long)divisor2)/__gcd((long long)divisor1,(long long)divisor2);\\n            long long num = (mid/divisor2-(mid)/lm);\\n            int mn = min((int)uniqueCnt1,(int)num);\\n            long long d2 = mid - uniqueCnt1 - (mid/divisor2) + mn;\\n            if(d1>=uniqueCnt1&&d2>=uniqueCnt2){\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                st = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946789,
                "title": "cpp-binary-search-venn",
                "content": "```\\n /*  Venn : for numbers in [1, N]\\n+------------------------------------------------+------------------------------------------------------------+\\n| C: divisible by both divisor1 and divisor2     | A: divisible by divisor1 but not by divisor2               |    D1\\n+------------------------------------------------+------------------------------------------------------------+\\n| B: divisible by divisor2 but not by divisor1   | #: not divisible by either divisor1 or divisor2            |\\n+------------------------------------------------+------------------------------------------------------------+\\n                   D2\\n\\nDefine:\\nD1:=divisible by divisor1\\nD2:=divisible by divisor2\\n\\nAs depicted by Venn diagram,\\nC :=divisible by both divisor1 and divisor2       =D1 & D2\\nA :=divisible by divisor1 but not by divisor2     =D1 - C\\nB :=divisible by divisor2 but not by divisor1     =D2 - C\\n# :=not divisible by either divisor1 or divisor2  =[1,N]-D1-D2+C\\n\\nSo that,\\nElement of A can be used to meet uniqueCnt2, i.e. A contributes at most min(|A|, uniqueCnt2)\\nElement of B can be used to meet uniqueCnt1, i.e. B contributes at most min(|B|, uniqueCnt1)\\n\\nTotally, within [1,N]\\nmin(|A|,uniqueCnt2) + min(|B|, uniqueCnt1) + |#| can be used.\\n\\nMeanwhile, we know:\\n|D1|= N/divisor1 \\n|D2|= N/divisor2 \\n|C| = N/lcm(divisor1, divisor2)\\n|A| = |D1|-|C|\\n|B| = |D2|-|C|\\n|#| = N-|A|-|B|-|C|\\n*/\\n\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long d=lcm((long)divisor1, divisor2);\\n        int lo=1, hi=INT_MAX, n, cnt, a, b, c;\\n        while(lo<hi) {\\n            n=lo+(hi-lo)/2;\\n            c=n/d;\\n\\t\\t\\ta=n/divisor1-c;\\n            b=n/divisor2-c;\\n            cnt=min(a, uniqueCnt2)+min(b, uniqueCnt1)-a-b-c+n;\\n            if(cnt<uniqueCnt1+uniqueCnt2) {\\n                lo=n+1;\\n            } else {\\n                hi=n;\\n            }\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n /*  Venn : for numbers in [1, N]\\n+------------------------------------------------+------------------------------------------------------------+\\n| C: divisible by both divisor1 and divisor2     | A: divisible by divisor1 but not by divisor2               |    D1\\n+------------------------------------------------+------------------------------------------------------------+\\n| B: divisible by divisor2 but not by divisor1   | #: not divisible by either divisor1 or divisor2            |\\n+------------------------------------------------+------------------------------------------------------------+\\n                   D2\\n\\nDefine:\\nD1:=divisible by divisor1\\nD2:=divisible by divisor2\\n\\nAs depicted by Venn diagram,\\nC :=divisible by both divisor1 and divisor2       =D1 & D2\\nA :=divisible by divisor1 but not by divisor2     =D1 - C\\nB :=divisible by divisor2 but not by divisor1     =D2 - C\\n# :=not divisible by either divisor1 or divisor2  =[1,N]-D1-D2+C\\n\\nSo that,\\nElement of A can be used to meet uniqueCnt2, i.e. A contributes at most min(|A|, uniqueCnt2)\\nElement of B can be used to meet uniqueCnt1, i.e. B contributes at most min(|B|, uniqueCnt1)\\n\\nTotally, within [1,N]\\nmin(|A|,uniqueCnt2) + min(|B|, uniqueCnt1) + |#| can be used.\\n\\nMeanwhile, we know:\\n|D1|= N/divisor1 \\n|D2|= N/divisor2 \\n|C| = N/lcm(divisor1, divisor2)\\n|A| = |D1|-|C|\\n|B| = |D2|-|C|\\n|#| = N-|A|-|B|-|C|\\n*/\\n\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long d=lcm((long)divisor1, divisor2);\\n        int lo=1, hi=INT_MAX, n, cnt, a, b, c;\\n        while(lo<hi) {\\n            n=lo+(hi-lo)/2;\\n            c=n/d;\\n\\t\\t\\ta=n/divisor1-c;\\n            b=n/divisor2-c;\\n            cnt=min(a, uniqueCnt2)+min(b, uniqueCnt1)-a-b-c+n;\\n            if(cnt<uniqueCnt1+uniqueCnt2) {\\n                lo=n+1;\\n            } else {\\n                hi=n;\\n            }\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946755,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int c1, int c2) \\n    {\\n           long long l = 1LL*c1+1LL*c2 , r = 1e18;\\n           long long int gd = (1LL*d1*d2)/__gcd(d1,d2);\\n           while(l<=r)\\n           {\\n              long long int mid = (1LL*l+1LL*r)/2; \\n               \\n              long long cnt = mid/gd;\\n              \\n               if((mid-cnt)>=(1LL*c1+1LL*c2)&&(mid-(mid/d1))>=c1&&(mid-(mid/d2))>=c2)\\n               {\\n                   r=mid-1;\\n               }\\n               else\\n                   l=mid+1;\\n           }\\n            return l;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int c1, int c2) \\n    {\\n           long long l = 1LL*c1+1LL*c2 , r = 1e18;\\n           long long int gd = (1LL*d1*d2)/__gcd(d1,d2);\\n           while(l<=r)\\n           {\\n              long long int mid = (1LL*l+1LL*r)/2; \\n               \\n              long long cnt = mid/gd;\\n              \\n               if((mid-cnt)>=(1LL*c1+1LL*c2)&&(mid-(mid/d1))>=c1&&(mid-(mid/d2))>=c2)\\n               {\\n                   r=mid-1;\\n               }\\n               else\\n                   l=mid+1;\\n           }\\n            return l;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946565,
                "title": "dont-need-binary-search",
                "content": "\\n\\t\\t\\tneed=n=n1+n2\\n\\n            lcm=math.lcm(d1,d2)\\n\\n            while need:\\n                            \\n                only1 = n // d2 - n // lcm\\n                \\n                only2 = n // d1 - n // lcm\\n                \\n                free = n - n // d1 - n // d2 + n // lcm              \\n                \\n                need= max(max(0, n1 - only1) + max(0, n2 - only2)- free,0)\\n\\n                n+=need\\n\\n            return n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\t\\t\\tneed=n=n1+n2\\n\\n            lcm=math.lcm(d1,d2)\\n\\n            while need:\\n                            \\n                only1 = n // d2 - n // lcm\\n                \\n                only2 = n // d1 - n // lcm\\n                \\n                free = n - n // d1 - n // d2 + n // lcm              \\n                \\n                need= max(max(0, n1 - only1) + max(0, n2 - only2)- free,0)\\n\\n                n+=need\\n\\n            return n",
                "codeTag": "Unknown"
            },
            {
                "id": 2946549,
                "title": "python-o-logn-runtime-with-explanation",
                "content": "# Intuition\\n1st Insight: Seeing that uniqueCnt1 and uniqueCnt2 are order of $$10^9$$ and our answer is also potentially of that magnitude, we might think to consider a logarithmic solution such as binary search.\\n\\n2nd Insight: It isn\\'t obvious how to find the minimum maximum value across all arrays satisfying the condition or even construct the arrays. One question we might ask is can we determine if a maximum value $$V$$ is possible? Yes we can! \\n\\n*Also another reason to consider this approach is if some value $$V$$ is possible, then it is possible to construct such arrays for any value greater than $$V$$ e.g. using the same array constructed for $$V$$.\\n\\nLet $$k$$ be the number of elements that don\\'t divide $$divisor1$$. If $$k < uniqueCnt1$$ then $$V$$ isn\\'t possible as there aren\\'t enough numbers from $$1$$ to $$V$$ that don\\'t divide $$divisor1$$. We can make the same argument for $$divisor2$$ and $$uniqueCnt2$$.\\n\\nNow there is one more condition that is neccessary for $$V$$ to possible. Let $$k$$ be the number of elements that are not divisible by at least 1 of $$divisor1$$ and $$divisor2$$. We must have that $$k >= uniqueCnt1 + uniqueCnt2$$.\\n\\n$$V$$ is valid if and only if these three properties are satisfied.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThus we solve this problem using binary search. We can let our right pointer be $$10^{10}$$ which is sufficiently high and our left be 1. Inside the while loop we perform the checks as described above. To do the third check notice that the number of elements from $$1$$ to $$V$$ that dont divide at least one of $$divisor1$$ and $$divisor2$$ is equal to $$V$$ minus the number of elements that divide both $$divisor1$$ and $$divisor2$$. This is just \\n$$V - V/lcm(divisor1,divisor2)$$. We use this binary search to find the lowest possible value of V.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(uniqueCnt1+uniqueCnt2))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n```\\nimport math\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n        def gcd(a, b):\\n            if (a == 0):\\n                return b\\n\\n            if (b == 0):\\n                return a\\n\\n            if (a == b):\\n                return a\\n\\n            if (a > b):\\n                return gcd(a-b, b)\\n            return gcd(a, b-a)\\n        \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n            \\n        d1=divisor1\\n        d2=divisor2\\n        u1=uniqueCnt1\\n        u2=uniqueCnt2\\n        \\n        l=1\\n        r=10**(10)\\n        #r=7\\n        res=float(\\'inf\\')\\n        while l<=r:\\n            m=(l+r)//2\\n            x=m-m//d1\\n            y=m-m//d2\\n            z=m-m//(lcm(d1,d2))\\n            \\n            if x<u1 or y<u2 or z<u1+u2:\\n                l=m+1\\n                continue\\n            else:\\n                res=min(res,m)\\n                r=m-1\\n                \\n            \\n            \\n       \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n        def gcd(a, b):\\n            if (a == 0):\\n                return b\\n\\n            if (b == 0):\\n                return a\\n\\n            if (a == b):\\n                return a\\n\\n            if (a > b):\\n                return gcd(a-b, b)\\n            return gcd(a, b-a)\\n        \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n            \\n        d1=divisor1\\n        d2=divisor2\\n        u1=uniqueCnt1\\n        u2=uniqueCnt2\\n        \\n        l=1\\n        r=10**(10)\\n        #r=7\\n        res=float(\\'inf\\')\\n        while l<=r:\\n            m=(l+r)//2\\n            x=m-m//d1\\n            y=m-m//d2\\n            z=m-m//(lcm(d1,d2))\\n            \\n            if x<u1 or y<u2 or z<u1+u2:\\n                l=m+1\\n                continue\\n            else:\\n                res=min(res,m)\\n                r=m-1\\n                \\n            \\n            \\n       \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063190,
                "title": "c-binary-search-inclusion-exclusion-principle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBe careful that lcm function may overflow.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool satisfy(int divisor1, int divisor2, long long uniqueCnt1, long long uniqueCnt2, long maximum) {\\n        long long a = maximum / lcm((long long)divisor1, (long long)divisor2);\\n        long long x = maximum - maximum / divisor1 - maximum / divisor2 + a;\\n        long long y = maximum / divisor1 - a;\\n        long long z = maximum / divisor2 - a;\\n        // printf(\"maximum: %lld, a: %lld, x: %lld, y: %lld, z: %lld\\\\n\", maximum, a, x, y, z);\\n\\n        uniqueCnt1 -= min(uniqueCnt1, z);\\n        uniqueCnt2 -= min(uniqueCnt2, y);\\n        return x >= uniqueCnt1 + uniqueCnt2;\\n    }\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        // binary search\\n        long long l = 0, r = 1e10;\\n        while( l + 1 < r ) {\\n            long long mid = (l + r) / 2;\\n            if( satisfy(divisor1, divisor2, uniqueCnt1, uniqueCnt2, mid) )\\n                r = mid;\\n            else\\n                l = mid;\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool satisfy(int divisor1, int divisor2, long long uniqueCnt1, long long uniqueCnt2, long maximum) {\\n        long long a = maximum / lcm((long long)divisor1, (long long)divisor2);\\n        long long x = maximum - maximum / divisor1 - maximum / divisor2 + a;\\n        long long y = maximum / divisor1 - a;\\n        long long z = maximum / divisor2 - a;\\n        // printf(\"maximum: %lld, a: %lld, x: %lld, y: %lld, z: %lld\\\\n\", maximum, a, x, y, z);\\n\\n        uniqueCnt1 -= min(uniqueCnt1, z);\\n        uniqueCnt2 -= min(uniqueCnt2, y);\\n        return x >= uniqueCnt1 + uniqueCnt2;\\n    }\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        // binary search\\n        long long l = 0, r = 1e10;\\n        while( l + 1 < r ) {\\n            long long mid = (l + r) / 2;\\n            if( satisfy(divisor1, divisor2, uniqueCnt1, uniqueCnt2, mid) )\\n                r = mid;\\n            else\\n                l = mid;\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050490,
                "title": "go-binary-search",
                "content": "```\\nfunc minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n    d1, d2, cnt1, cnt2 := divisor1, divisor2, uniqueCnt1, uniqueCnt2\\n    return sort.Search(math.MaxInt64, func(i int) bool{\\n        a := i / d1\\n        b := i / d2\\n        c := i / lcm(d1, d2)\\n        lb := i - (a - c) - b\\n        l1 := i - a - lb\\n        l2 := i - b - lb\\n        return min(l1, cnt1) + min(l2, cnt2) + lb >= cnt1 + cnt2\\n    })    \\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc lcm(a int, b int) int {\\n    c := gcd(a, b)\\n    return a / c * b\\n}\\n\\nfunc gcd(a int, b int) int {\\n    if a > b {\\n        return gcd(b, a)\\n    }\\n    if a == b {\\n        return a\\n    }\\n    return gcd(a, b - a)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n    d1, d2, cnt1, cnt2 := divisor1, divisor2, uniqueCnt1, uniqueCnt2\\n    return sort.Search(math.MaxInt64, func(i int) bool{\\n        a := i / d1\\n        b := i / d2\\n        c := i / lcm(d1, d2)\\n        lb := i - (a - c) - b\\n        l1 := i - a - lb\\n        l2 := i - b - lb\\n        return min(l1, cnt1) + min(l2, cnt2) + lb >= cnt1 + cnt2\\n    })    \\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc lcm(a int, b int) int {\\n    c := gcd(a, b)\\n    return a / c * b\\n}\\n\\nfunc gcd(a int, b int) int {\\n    if a > b {\\n        return gcd(b, a)\\n    }\\n    if a == b {\\n        return a\\n    }\\n    return gcd(a, b - a)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962049,
                "title": "binary-search-solution-for-minimum-maximum-integer-distribution-in-arrays",
                "content": "# Intuition\\n\\nWhen tasked with selecting elements for two arrays that meet specific conditions, we aim to ensure that the maximum value of the chosen numbers is as small as possible. Such minimization of a maximum value problem typically lends itself to a binary search solution. We can attempt every possible maximum number until we find the smallest one that meets our criteria. Evaluating whether a given number meets the criteria involves calculations related to division and least common multiples. This intuition was provided by OpenAI\\'s GPT-4.\\n\\n# Approach\\n1. Define a helper function to calculate the greatest common divisor of two numbers, aiding in the computation of the least common multiple.\\n2. Employ a binary search approach over a defined range to find our answer. This range starts from `1` and goes up to `2 * (cnt1 + cnt2) * max(div1, div2)`.\\n3. At each step, we calculate the count of numbers not divisible by either `div1` or `div2` and that are less than or equal to `mid`. We also ensure that the sum of these two counts is no less than `cnt1 + cnt2`.\\n4. If the current `mid` fits our criteria, we move `high` to `mid-1`. Otherwise, we shift `low` to `mid+1`. Additionally, every time the criteria are met, we try to update our answer.\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log n)$$ \\n    - The time complexity for binary search is $$O(\\\\log n)$$, and given that our boundaries are based on `cnt1`, `cnt2`, `div1`, and `div2`, in the worst case, n could be `2 * (cnt1 + cnt2) * max(div1, div2)`.\\n\\n- Space complexity: $$O(1)$$ \\n    - Beyond the input and a few constant space variables, we don\\'t use additional storage, so our space complexity remains at a constant level.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int64_t gcd(int64_t a, int64_t b) {\\n        \\n        while (b != 0) {\\n            std::swap(a, b);\\n            b %= a;\\n        }\\n\\n        return a;\\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n    \\n        int64_t low = 0LL;\\n        int64_t high = 2LL * (uniqueCnt1 + uniqueCnt2) * std::max(divisor1, divisor2);\\n        int64_t ans = INT64_MAX;\\n        while (low <= high) {\\n\\n            int64_t mid = (low + high) / 2;\\n            int64_t cnt1 = mid - mid / divisor1;\\n            int64_t cnt2 = mid - mid / divisor2;\\n\\n            int64_t lcm = divisor1 * (divisor2 / gcd (divisor1, divisor2));\\n            int64_t cnt1cnt2 = mid - mid / lcm;\\n            \\n            // If cnt1, cnt2, cn1cnt2 are all meet requirement, we will search on the left half, other wise, right half.\\n            if (cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 && cnt1cnt2 >= uniqueCnt1 + uniqueCnt2) {\\n                high = mid - 1;\\n                ans = std::min(ans, mid);\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return static_cast<int>(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int64_t gcd(int64_t a, int64_t b) {\\n        \\n        while (b != 0) {\\n            std::swap(a, b);\\n            b %= a;\\n        }\\n\\n        return a;\\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n    \\n        int64_t low = 0LL;\\n        int64_t high = 2LL * (uniqueCnt1 + uniqueCnt2) * std::max(divisor1, divisor2);\\n        int64_t ans = INT64_MAX;\\n        while (low <= high) {\\n\\n            int64_t mid = (low + high) / 2;\\n            int64_t cnt1 = mid - mid / divisor1;\\n            int64_t cnt2 = mid - mid / divisor2;\\n\\n            int64_t lcm = divisor1 * (divisor2 / gcd (divisor1, divisor2));\\n            int64_t cnt1cnt2 = mid - mid / lcm;\\n            \\n            // If cnt1, cnt2, cn1cnt2 are all meet requirement, we will search on the left half, other wise, right half.\\n            if (cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 && cnt1cnt2 >= uniqueCnt1 + uniqueCnt2) {\\n                high = mid - 1;\\n                ans = std::min(ans, mid);\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return static_cast<int>(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957898,
                "title": "c-binary-search-beat-100-in-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    long lcm;\\n    int BinarySearch(int div1,int unique1,int div2,int unique2)\\n    {\\n        long low=unique1,high=unique1+unique2,mid,number,totdis,ans=INT_MAX;\\n        long index1,index2,number2;\\n        long f; // number appear in two array\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(mid%(div1-1)==0) number=mid+mid/(div1-1)-1;\\n            else number=mid+mid/(div1-1);\\n            if(number%div1==0) number2=number-1;\\n            else number2=number;\\n            \\n            index1=mid;\\n            if(number2-number2/div2>unique1+unique2) index2=unique1+unique2;\\n            else index2=number2-number2/div2;\\n            // index2=min(number2-number2/div2,unique1+unique2);\\n            \\n            totdis=number-(number/div1)/(lcm/div1);\\n            \\n            f=index1+index2-totdis;\\n   \\n            if(index2>=unique2&&index1-unique1>=unique2-index2+f)\\n            {\\n                ans=number;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n     \\n        return ans;\\n    }\\n    int minimizeSet(int div1, int div2, int unique1, int unique2) {\\n        lcm=(long(div1)*long(div2))/gcd(div1,div2);\\n        return min(BinarySearch(div1,unique1,div2,unique2),BinarySearch(div2,unique2,div1,unique1)); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long lcm;\\n    int BinarySearch(int div1,int unique1,int div2,int unique2)\\n    {\\n        long low=unique1,high=unique1+unique2,mid,number,totdis,ans=INT_MAX;\\n        long index1,index2,number2;\\n        long f; // number appear in two array\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(mid%(div1-1)==0) number=mid+mid/(div1-1)-1;\\n            else number=mid+mid/(div1-1);\\n            if(number%div1==0) number2=number-1;\\n            else number2=number;\\n            \\n            index1=mid;\\n            if(number2-number2/div2>unique1+unique2) index2=unique1+unique2;\\n            else index2=number2-number2/div2;\\n            // index2=min(number2-number2/div2,unique1+unique2);\\n            \\n            totdis=number-(number/div1)/(lcm/div1);\\n            \\n            f=index1+index2-totdis;\\n   \\n            if(index2>=unique2&&index1-unique1>=unique2-index2+f)\\n            {\\n                ans=number;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n     \\n        return ans;\\n    }\\n    int minimizeSet(int div1, int div2, int unique1, int unique2) {\\n        lcm=(long(div1)*long(div2))/gcd(div1,div2);\\n        return min(BinarySearch(div1,unique1,div2,unique2),BinarySearch(div2,unique2,div1,unique1)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950370,
                "title": "binary-search-on-answer-c-runtime-100-beat",
                "content": "# Intuition\\nwe cannot check which is divisble or not which is taken and swap from each other \\n\\n# Approach\\nTake on ans which is large no \\nGet howmany number is not divisible by that div1 (a)and (b)same for div2\\nalong with check which is not divisble by both(c)\\na+b-c>=cnt1+cnt2 and a>=cnt1 and b>=cnt2\\n# Time complexity\\nO(log(10^18))\\n\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\n   #define ll long long \\n    public:\\n    long long gcd(long long int a, long long int b)\\n    {\\n        if (b == 0)\\n            return a;\\n    \\n        return gcd(b, a % b);\\n    }\\n    \\n    // Function to return LCM of\\n    // two numbers\\n    long long lcm(int a, int b) \\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    int minimizeSet(int div1, int div2, int cnt1, int cnt2) \\n    {\\n        ll low=0,high=1e18;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n            //not divisble by div1\\n            ll a=mid-mid/(ll)div1;\\n            ll b=mid-mid/(ll)div2;\\n            ll c=mid-mid/div1-mid/div2+mid/(lcm(div1,div2));\\n            if(a>=cnt1 and b>=cnt2 and (a+b-c)>=(cnt1+cnt2))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\n   #define ll long long \\n    public:\\n    long long gcd(long long int a, long long int b)\\n    {\\n        if (b == 0)\\n            return a;\\n    \\n        return gcd(b, a % b);\\n    }\\n    \\n    // Function to return LCM of\\n    // two numbers\\n    long long lcm(int a, int b) \\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    int minimizeSet(int div1, int div2, int cnt1, int cnt2) \\n    {\\n        ll low=0,high=1e18;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n            //not divisble by div1\\n            ll a=mid-mid/(ll)div1;\\n            ll b=mid-mid/(ll)div2;\\n            ll c=mid-mid/div1-mid/div2+mid/(lcm(div1,div2));\\n            if(a>=cnt1 and b>=cnt2 and (a+b-c)>=(cnt1+cnt2))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928039,
                "title": "golang-binary-search-1ms-solution-and-brute-force-tle-solution",
                "content": "# Code\\n```go\\n// binary search 1ms\\nfunc minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n\\tl, r := 1, math.MaxInt64\\n\\tdivisorLCM := lcm(divisor1, divisor2)\\n\\tfor l <= r {\\n\\t\\tm := (l+r) >> 1\\n\\t\\tcountNotDivBoth := m - (m / divisor1 + m / divisor2 - m / divisorLCM)\\n\\t\\tcountNotDiv1Only := min(m - m / divisor1 - countNotDivBoth, uniqueCnt1)\\n\\t\\tcountNotDiv2Only := min(m - m / divisor2 - countNotDivBoth, uniqueCnt2)\\n\\t\\tif countNotDiv1Only+countNotDiv2Only+countNotDivBoth >= uniqueCnt1+uniqueCnt2 {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\treturn r+1\\n}\\n\\nfunc lcm(x, y int) int {\\n    return x*y/gcd(x, y)\\n}\\n\\nfunc gcd(x, y int) int {\\n\\tif x < y {\\n\\t\\tx, y = y, x\\n\\t}\\n\\tif x%y == 0 {\\n\\t\\treturn y\\n\\t}\\n\\treturn gcd(y, x%y)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n\\n// brute force TLE\\nfunc minimizeSetTLE(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n    count1, count2, countBoth := 0, 0, 0\\n    i := 1\\n    for ;count1+count2+countBoth < uniqueCnt1+uniqueCnt2; i++ {\\n        switch {\\n        case i % divisor1 != 0 && i % divisor2 != 0:\\n            countBoth++\\n        case i % divisor1 != 0 && count1 < uniqueCnt1:\\n            count1++\\n        case i % divisor2 != 0 && count2 < uniqueCnt2:\\n            count2++\\n        }\\n    }\\n    return i-1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\n// binary search 1ms\\nfunc minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n\\tl, r := 1, math.MaxInt64\\n\\tdivisorLCM := lcm(divisor1, divisor2)\\n\\tfor l <= r {\\n\\t\\tm := (l+r) >> 1\\n\\t\\tcountNotDivBoth := m - (m / divisor1 + m / divisor2 - m / divisorLCM)\\n\\t\\tcountNotDiv1Only := min(m - m / divisor1 - countNotDivBoth, uniqueCnt1)\\n\\t\\tcountNotDiv2Only := min(m - m / divisor2 - countNotDivBoth, uniqueCnt2)\\n\\t\\tif countNotDiv1Only+countNotDiv2Only+countNotDivBoth >= uniqueCnt1+uniqueCnt2 {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\treturn r+1\\n}\\n\\nfunc lcm(x, y int) int {\\n    return x*y/gcd(x, y)\\n}\\n\\nfunc gcd(x, y int) int {\\n\\tif x < y {\\n\\t\\tx, y = y, x\\n\\t}\\n\\tif x%y == 0 {\\n\\t\\treturn y\\n\\t}\\n\\treturn gcd(y, x%y)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n\\n// brute force TLE\\nfunc minimizeSetTLE(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n    count1, count2, countBoth := 0, 0, 0\\n    i := 1\\n    for ;count1+count2+countBoth < uniqueCnt1+uniqueCnt2; i++ {\\n        switch {\\n        case i % divisor1 != 0 && i % divisor2 != 0:\\n            countBoth++\\n        case i % divisor1 != 0 && count1 < uniqueCnt1:\\n            count1++\\n        case i % divisor2 != 0 && count2 < uniqueCnt2:\\n            count2++\\n        }\\n    }\\n    return i-1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562183,
                "title": "a-simple-solution-that-is-readable-and-has-comments",
                "content": "# Approach\\nStep 1: Identify logic to determine if a solution is possible for some number \"n\".\\nStep 2: Find \"n\". \\n\\n# Complexity\\n- Time complexity: O(logN)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, c1: int, c2: int) -> int:\\n        LCM = lcm(d1, d2)\\n        def canFit(n, l):\\n            v1 = n//d1 #numbers divisible by d1 \\n            v2 = n//d2 #numbers divisible by d2\\n            v3 = n//l #numbers divisible by both d1 and d2\\n            \\n            guaranteedFor1 = v2-v3  #guaranteed allotment for d1\\n            guaranteedFor2 = v1-v3  #guaranteed allotment for d2\\n\\n            x = max(c1-guaranteedFor1, 0) #number of elements required to complete c1\\n            y = max(c2-guaranteedFor2, 0) #number of elements required to complete c2\\n\\n            # if required number of elements is less than or equal to available unalloted numbers, then its a possible solution\\n            if (x+y)<=(n-v1-v2+v3): return True\\n            return False\\n\\n        l = 1\\n        r = 10**10\\n\\n        while l<r:\\n            if l==r-1:\\n                if canFit(l, LCM): return l\\n                else: return r\\n            m = (l+r)//2\\n            if canFit(m, LCM): r = m\\n            else: l = m\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, c1: int, c2: int) -> int:\\n        LCM = lcm(d1, d2)\\n        def canFit(n, l):\\n            v1 = n//d1 #numbers divisible by d1 \\n            v2 = n//d2 #numbers divisible by d2\\n            v3 = n//l #numbers divisible by both d1 and d2\\n            \\n            guaranteedFor1 = v2-v3  #guaranteed allotment for d1\\n            guaranteedFor2 = v1-v3  #guaranteed allotment for d2\\n\\n            x = max(c1-guaranteedFor1, 0) #number of elements required to complete c1\\n            y = max(c2-guaranteedFor2, 0) #number of elements required to complete c2\\n\\n            # if required number of elements is less than or equal to available unalloted numbers, then its a possible solution\\n            if (x+y)<=(n-v1-v2+v3): return True\\n            return False\\n\\n        l = 1\\n        r = 10**10\\n\\n        while l<r:\\n            if l==r-1:\\n                if canFit(l, LCM): return l\\n                else: return r\\n            m = (l+r)//2\\n            if canFit(m, LCM): r = m\\n            else: l = m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551373,
                "title": "binary-search-counting-with-the-inclusion-exclusion-principle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 counts of interest that can be used to check if a given bound num provides enough space to cover the range while within the constraints. \\n1. c1: how many are divisible by divisor1\\n2. c2: how many are divisible by divisor2\\n3. c3: how many are divisible by both\\n\\nMultiples of divisor2 can be used for cnt1 if not multiples of divisor1 and vice versa. This leads to reduced counts uc1 and uc2 that together have to be covered by numbers not multiples of either divisor1 or divisor2. The calculations use the inclusion/exclusion principle from set theory.\\n\\n\\n# Approach\\nBinary search for the smallest valid upper bound\\n\\n# Complexity\\n- Time/space complexity logarithmic with respect to the search range\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        # binary search for solution\\n        def enough(num):\\n            c1, c2 = num//divisor1, num//divisor2\\n            c3 = num//lcm(divisor1,divisor2)\\n            # div2 can be used for cnt1 if not multiple of div1\\n            uc1 = max(0,uniqueCnt1 - c2 + c3) # reduced uniqueCnt1\\n            # div1 can be used for cnt2 if not multiple of div2\\n            uc2 = max(0,uniqueCnt2 - c1 + c3) # reduced uniqueCnt1\\n            # numbers that are not multiples of div1, div2\\n            # can be used for both. \\n            return uc1 + uc2 <= num - c1 - c2 + c3\\n\\n        left, right = uniqueCnt1+uniqueCnt2, pow(10,10)\\n        if enough(left): return left\\n        while left < right-1: # loop invariant ]left,right]\\n            mid = (left+right)//2\\n            if enough(mid): right = mid\\n            else: left = mid\\n        return right\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        # binary search for solution\\n        def enough(num):\\n            c1, c2 = num//divisor1, num//divisor2\\n            c3 = num//lcm(divisor1,divisor2)\\n            # div2 can be used for cnt1 if not multiple of div1\\n            uc1 = max(0,uniqueCnt1 - c2 + c3) # reduced uniqueCnt1\\n            # div1 can be used for cnt2 if not multiple of div2\\n            uc2 = max(0,uniqueCnt2 - c1 + c3) # reduced uniqueCnt1\\n            # numbers that are not multiples of div1, div2\\n            # can be used for both. \\n            return uc1 + uc2 <= num - c1 - c2 + c3\\n\\n        left, right = uniqueCnt1+uniqueCnt2, pow(10,10)\\n        if enough(left): return left\\n        while left < right-1: # loop invariant ]left,right]\\n            mid = (left+right)//2\\n            if enough(mid): right = mid\\n            else: left = mid\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503084,
                "title": "ez-understand-two-lines-of-codes-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNote that for each bunch of divisor size integers, there are divisor size - 1 integers do not divide the divisor, \\nIf no integers will be candidate for both array, the Maximum for each array can be computed with following equation:\\n`uniqueCnt / (divisor - 1) * divisor`\\nIf some inetgers can be considered for both array, we can treat it as a case when we have only one divisor which is `lcm(divisor1, divisor2)`\\nso the Maximum for both array can be compueted with the following equation:\\n`(uniqueCnt1 + uniqueCnt2) * lcm / (lcm - 1)`\\nTogether, we pick the max value among the max for each single array and the max for both given the divisor as lcm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Compute the lcm of divisor1, divisor2.\\n2. Find the max value among the three possible Maximums.\\n# Complexity\\n- Time complexity: O(log(divisor1.divisor2)) since lcm can be computed as abs(a,b) // gcd(a, b) and gcd(a,b) is computed by binary Euclidean algorithm.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        lcm = math.lcm(divisor1, divisor2)\\n        return math.ceil(max(\\n            uniqueCnt1 / (divisor1 - 1) * divisor1,\\n            uniqueCnt2 / (divisor2 - 1) * divisor2,\\n            (uniqueCnt1 + uniqueCnt2) * lcm / (lcm - 1)\\n        ))-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        lcm = math.lcm(divisor1, divisor2)\\n        return math.ceil(max(\\n            uniqueCnt1 / (divisor1 - 1) * divisor1,\\n            uniqueCnt2 / (divisor2 - 1) * divisor2,\\n            (uniqueCnt1 + uniqueCnt2) * lcm / (lcm - 1)\\n        ))-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475979,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long l= 1, r = 2000000000;\\n        while (l < r) {\\n            long long mid = (l + r) / 2;\\n            if (isEnough(divisor1, divisor2, uniqueCnt1, uniqueCnt2, mid)) r = mid;\\n            else l = mid + 1;\\n        }\\n        return r;\\n    }\\n\\n    bool isEnough(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2, long long i) {\\n        int non = i / std::lcm<long long>(divisor1, divisor2);\\n        int fit_2 = i / divisor1 - non;\\n        int fit_1 = i / divisor2 - non;\\n        int common = i - non - fit_2 - fit_1;\\n        return (max(uniqueCnt1 - fit_1, 0) + max(uniqueCnt2 - fit_2, 0) <= common);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long l= 1, r = 2000000000;\\n        while (l < r) {\\n            long long mid = (l + r) / 2;\\n            if (isEnough(divisor1, divisor2, uniqueCnt1, uniqueCnt2, mid)) r = mid;\\n            else l = mid + 1;\\n        }\\n        return r;\\n    }\\n\\n    bool isEnough(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2, long long i) {\\n        int non = i / std::lcm<long long>(divisor1, divisor2);\\n        int fit_2 = i / divisor1 - non;\\n        int fit_1 = i / divisor2 - non;\\n        int common = i - non - fit_2 - fit_1;\\n        return (max(uniqueCnt1 - fit_1, 0) + max(uniqueCnt2 - fit_2, 0) <= common);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416545,
                "title": "simple-code-using-binary-search-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the random values using the Binary search, then check if that value satisfies the given conditon then check for the minimum value.\\n\\n**How to check whether value satisfies the given condition or not??**\\n\\nMake two variable count1 and count2 for keeping the record of number of values availabe for unq set 1 and unq set 2, first add the number of divisor of div2 in cnt1 and vice versa for cnt2, then subtract the common multiple of div1 and div2 from c1 and c2, after that find the extra number that can be put in both of the set.\\nAfter that check whether with the help of the extra number the given condition satisfire or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPoss(long long div1,long long div2,long long unq1,long long unq2,long long mid)\\n    {\\n        \\n        \\n            long long c1=mid/div2;\\n            long long c2=mid/div1;\\n            long long den=(long long)div1*div2;\\n            long long common=mid/((den/__gcd(div1,div2)));\\n            c1=c1-common;\\n            c2=c2-common;\\n            long long extra=mid-(c1+c2)-common;\\n            long long diff1=unq1-c1;\\n            long long diff2=unq2-c2;\\n            if(diff1>0)\\n            {\\n                if(diff1>extra)return false;\\n                else extra=extra-diff1;\\n            }\\n            if(diff2>0)\\n            {\\n                if(diff2>extra)return false;\\n            }\\n            return true;\\n        \\n\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        //hk\\n        long long s=1;\\n        long long e=1e14;\\n        while(s<e)\\n        {\\n            long long mid=(e-s)/2+s;\\n            // cout<<mid<<\\'\\\\n\\';\\n            if(isPoss(divisor1,divisor2,uniqueCnt1,uniqueCnt2,mid))\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPoss(long long div1,long long div2,long long unq1,long long unq2,long long mid)\\n    {\\n        \\n        \\n            long long c1=mid/div2;\\n            long long c2=mid/div1;\\n            long long den=(long long)div1*div2;\\n            long long common=mid/((den/__gcd(div1,div2)));\\n            c1=c1-common;\\n            c2=c2-common;\\n            long long extra=mid-(c1+c2)-common;\\n            long long diff1=unq1-c1;\\n            long long diff2=unq2-c2;\\n            if(diff1>0)\\n            {\\n                if(diff1>extra)return false;\\n                else extra=extra-diff1;\\n            }\\n            if(diff2>0)\\n            {\\n                if(diff2>extra)return false;\\n            }\\n            return true;\\n        \\n\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        //hk\\n        long long s=1;\\n        long long e=1e14;\\n        while(s<e)\\n        {\\n            long long mid=(e-s)/2+s;\\n            // cout<<mid<<\\'\\\\n\\';\\n            if(isPoss(divisor1,divisor2,uniqueCnt1,uniqueCnt2,mid))\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355927,
                "title": "python-super-easy-lower-bound-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n\\n        l = 1\\n        h = 10 ** 10\\n        lcm = math.lcm(divisor1, divisor2)\\n        while l <= h:\\n            mid = l + (h-l) //2 \\n\\n            if mid - mid // divisor1 < uniqueCnt1 or mid - mid // divisor2 < uniqueCnt2  or  mid - mid//lcm <  uniqueCnt1 +  uniqueCnt2:\\n                l = mid +1\\n            else:\\n                h = mid -1\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n\\n        l = 1\\n        h = 10 ** 10\\n        lcm = math.lcm(divisor1, divisor2)\\n        while l <= h:\\n            mid = l + (h-l) //2 \\n\\n            if mid - mid // divisor1 < uniqueCnt1 or mid - mid // divisor2 < uniqueCnt2  or  mid - mid//lcm <  uniqueCnt1 +  uniqueCnt2:\\n                l = mid +1\\n            else:\\n                h = mid -1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304346,
                "title": "c-0ms-10-line",
                "content": "# Intuition\\nbinary search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        auto able = [&](int n){\\n            int not1 = n/d1, not2 = n/d2, not12 = n/lcm<long long>(d1, d2);\\n            return n - not1 >= cnt1 && n-not2 >= cnt2 && n >= cnt1+cnt2+not12;\\n        };\\n        int l = cnt1+cnt2-1, r = 2e9;\\n        while (l +1<r){\\n            auto mid = l + (r-l)/2;\\n            able(mid) ? r = mid : l = mid;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        auto able = [&](int n){\\n            int not1 = n/d1, not2 = n/d2, not12 = n/lcm<long long>(d1, d2);\\n            return n - not1 >= cnt1 && n-not2 >= cnt2 && n >= cnt1+cnt2+not12;\\n        };\\n        int l = cnt1+cnt2-1, r = 2e9;\\n        while (l +1<r){\\n            auto mid = l + (r-l)/2;\\n            able(mid) ? r = mid : l = mid;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274293,
                "title": "golang-0-ms-1-9-mb",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc gcd(a, b int) int {\\n\\tfor b != 0 {\\n\\t\\ta, b = b, a%b\\n\\t}\\n\\treturn a\\n}\\n\\nfunc minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n\\tcommon := divisor1 * divisor2 / gcd(divisor1, divisor2)\\n\\tcnt := uniqueCnt1 + uniqueCnt2\\n\\treturn sort.Search(2000000000, func(i int) bool {\\n\\t\\treturn i-i/common >= cnt && i-i/divisor1 >= uniqueCnt1 && i-i/divisor2 >= uniqueCnt2\\n\\t})\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc gcd(a, b int) int {\\n\\tfor b != 0 {\\n\\t\\ta, b = b, a%b\\n\\t}\\n\\treturn a\\n}\\n\\nfunc minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {\\n\\tcommon := divisor1 * divisor2 / gcd(divisor1, divisor2)\\n\\tcnt := uniqueCnt1 + uniqueCnt2\\n\\treturn sort.Search(2000000000, func(i int) bool {\\n\\t\\treturn i-i/common >= cnt && i-i/divisor1 >= uniqueCnt1 && i-i/divisor2 >= uniqueCnt2\\n\\t})\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204587,
                "title": "c",
                "content": "```\\nint gcd(int a, int b){\\n    int tmp = b ;\\n    while(tmp){\\n        b = a % tmp ;\\n        a = tmp ;\\n        tmp = b ;\\n    }\\n    return a ;\\n}\\nlong long lcm(int a, int b){\\n    long long ret = 1 ;\\n    return (long long)a * b / gcd(a, b) ;\\n}\\n\\nbool checkStatus(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2, int n){\\n    long long a = n - n/divisor1 ;\\n    long long b = n - n/divisor2 ;\\n    long long c = n - (n/divisor1 + n/divisor2 - n/lcm(divisor1, divisor2)) ;\\n    if(a < uniqueCnt1 || b < uniqueCnt2 || (a+b-c) < (uniqueCnt1 + uniqueCnt2))\\n        return false ;\\n    else\\n        return true ;\\n    \\n}\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2){\\n    int left = 1, right = INT_MAX-1 ;\\n    while(left < right ){\\n        int mid = left + (right - left) / 2 ;\\n        if(checkStatus(divisor1, divisor2, uniqueCnt1, uniqueCnt2, mid) )\\n            right = mid ;            \\n        else\\n            left = mid + 1 ;\\n    }\\n    return left ;\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nint gcd(int a, int b){\\n    int tmp = b ;\\n    while(tmp){\\n        b = a % tmp ;\\n        a = tmp ;\\n        tmp = b ;\\n    }\\n    return a ;\\n}\\nlong long lcm(int a, int b){\\n    long long ret = 1 ;\\n    return (long long)a * b / gcd(a, b) ;\\n}\\n\\nbool checkStatus(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2, int n){\\n    long long a = n - n/divisor1 ;\\n    long long b = n - n/divisor2 ;\\n    long long c = n - (n/divisor1 + n/divisor2 - n/lcm(divisor1, divisor2)) ;\\n    if(a < uniqueCnt1 || b < uniqueCnt2 || (a+b-c) < (uniqueCnt1 + uniqueCnt2))\\n        return false ;\\n    else\\n        return true ;\\n    \\n}\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2){\\n    int left = 1, right = INT_MAX-1 ;\\n    while(left < right ){\\n        int mid = left + (right - left) / 2 ;\\n        if(checkStatus(divisor1, divisor2, uniqueCnt1, uniqueCnt2, mid) )\\n            right = mid ;            \\n        else\\n            left = mid + 1 ;\\n    }\\n    return left ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165565,
                "title": "c-binary-search-medium-made-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a * b)/(__gcd(a,b));\\n    }\\n    bool ispossible(int mid,int d1,int d2,int u1,int u2){\\n        int c1 = (int)mid/d1;\\n        int c2 = (int)mid/d2;\\n        int temp = (int)mid/lcm(d1,d2);\\n        u1 -= (c2 - temp);\\n        u2 -= (c1 - temp);\\n        int t1 = mid - (c1 + c2 - temp);\\n        if(u1 < 0)u1 = 0;\\n        if(u2 < 0)u2 = 0;\\n        if(t1 >= u1 + u2)return true;\\n        return false;\\n    }\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long l = 1,r = 1e12;\\n        int ans = 1;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            if(ispossible(mid,d1,d2,u1,u2)){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a * b)/(__gcd(a,b));\\n    }\\n    bool ispossible(int mid,int d1,int d2,int u1,int u2){\\n        int c1 = (int)mid/d1;\\n        int c2 = (int)mid/d2;\\n        int temp = (int)mid/lcm(d1,d2);\\n        u1 -= (c2 - temp);\\n        u2 -= (c1 - temp);\\n        int t1 = mid - (c1 + c2 - temp);\\n        if(u1 < 0)u1 = 0;\\n        if(u2 < 0)u2 = 0;\\n        if(t1 >= u1 + u2)return true;\\n        return false;\\n    }\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long l = 1,r = 1e12;\\n        int ans = 1;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            if(ispossible(mid,d1,d2,u1,u2)){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100072,
                "title": "binary-search-set-logic-with-explanation",
                "content": "# Keypoint\\nFor all numbers smaller than X, there are several conditions: \\nA. not valid for both arr1 and arr2\\nB. valid for arr1 only\\nC. valid for arr2 only\\nD. valid for both arr1 and arr2\\n\\nX is valid only if following conditions are met:\\nB + C + D > UC1 + UC2  # need enough number to fill UC1+UC2 combined\\nB + D > UC1  # need enough number to fill UC1\\nC + D > UC2  # need enough number to fill UC2\\n\\nX\\'s validity is monotune, so we use binary search to find it.\\n\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        start, end  = 0, 10 ** 10\\n        while start != end:\\n            mid = (start + end) // 2\\n            A = mid // lcm(divisor1, divisor2)\\n            Bs = mid - mid // divisor1 # Bs is the count of valid number for divisor1\\n            Cs = mid - mid // divisor2\\n            D = A + Bs + Cs - mid\\n            B = Bs - D\\n            C = Cs - D\\n            # print(A,B,C,D)\\n            if B + C + D >= uniqueCnt1 + uniqueCnt2 and B + D >= uniqueCnt1 and C + D >= uniqueCnt2: end = mid\\n            else: start = mid + 1\\n        return start         \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        start, end  = 0, 10 ** 10\\n        while start != end:\\n            mid = (start + end) // 2\\n            A = mid // lcm(divisor1, divisor2)\\n            Bs = mid - mid // divisor1 # Bs is the count of valid number for divisor1\\n            Cs = mid - mid // divisor2\\n            D = A + Bs + Cs - mid\\n            B = Bs - D\\n            C = Cs - D\\n            # print(A,B,C,D)\\n            if B + C + D >= uniqueCnt1 + uniqueCnt2 and B + D >= uniqueCnt1 and C + D >= uniqueCnt2: end = mid\\n            else: start = mid + 1\\n        return start         \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042954,
                "title": "java-binary-search-left-most-equal",
                "content": "```\\n// Idea: binary serach (left most equal)\\n//\\n// Let\\'s find last number when we combine arr1, arr2.\\n//   lcm(div1, div2) = div1 * div2 / gcd(div1, div2) \\n//     mi: last number\\n//   cnt1: count of arr1 = mi - mi / div1\\n//   cnt2: count of arr2 = mi - mi / div2\\n// cntAll: count of arr1, arr2 = mi - mi / lcm(div1, div2)\\n\\n// 0ms 100.00% 39MB 67.32%\\n// binary search (left most equal)\\n// O(lgN) O(1)\\nclass Solution {\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    public int minimizeSet(int divisor1, int divisor2,\\n                           int uniqueCnt1, int uniqueCnt2) {\\n        long lo = 1, hi = (int)10e10;\\n        long ans = hi;\\n        long lcm = ((long)divisor1 * (long)divisor2) / gcd(divisor1, divisor2);\\n        while (lo < hi) {\\n            long mi = lo + (hi - lo) / 2;\\n            int cnt1 = (int)(mi - mi / divisor1);\\n            int cnt2 = (int)(mi - mi / divisor2);\\n            int cntAll = (int)(mi - mi / lcm);\\n            if (cnt1 < uniqueCnt1 || cnt2 < uniqueCnt2 || cntAll < uniqueCnt1 + uniqueCnt2) {\\n                lo = mi + 1;\\n            } else {\\n                hi = mi;\\n            }\\n        }\\n        return (int)lo;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n// Idea: binary serach (left most equal)\\n//\\n// Let\\'s find last number when we combine arr1, arr2.\\n//   lcm(div1, div2) = div1 * div2 / gcd(div1, div2) \\n//     mi: last number\\n//   cnt1: count of arr1 = mi - mi / div1\\n//   cnt2: count of arr2 = mi - mi / div2\\n// cntAll: count of arr1, arr2 = mi - mi / lcm(div1, div2)\\n\\n// 0ms 100.00% 39MB 67.32%\\n// binary search (left most equal)\\n// O(lgN) O(1)\\nclass Solution {\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    public int minimizeSet(int divisor1, int divisor2,\\n                           int uniqueCnt1, int uniqueCnt2) {\\n        long lo = 1, hi = (int)10e10;\\n        long ans = hi;\\n        long lcm = ((long)divisor1 * (long)divisor2) / gcd(divisor1, divisor2);\\n        while (lo < hi) {\\n            long mi = lo + (hi - lo) / 2;\\n            int cnt1 = (int)(mi - mi / divisor1);\\n            int cnt2 = (int)(mi - mi / divisor2);\\n            int cntAll = (int)(mi - mi / lcm);\\n            if (cnt1 < uniqueCnt1 || cnt2 < uniqueCnt2 || cntAll < uniqueCnt1 + uniqueCnt2) {\\n                lo = mi + 1;\\n            } else {\\n                hi = mi;\\n            }\\n        }\\n        return (int)lo;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039866,
                "title": "c-binary-search-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,int div1,int div2,int cnt1,int cnt2)\\n    {\\n        int a=mid-mid/div1;\\n        int b=mid-mid/div2;\\n        int c=mid/((1LL * div1*div2)/(1LL*__gcd(div1,div2)));\\n        if(a<cnt1 || b<cnt2 || (mid-c)<(cnt1+cnt2))\\n        return false;\\n        return true;\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int low=0;\\n        int high=INT_MAX;\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=(1LL * low+ 1LL * high)/2;\\n            if(check(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,int div1,int div2,int cnt1,int cnt2)\\n    {\\n        int a=mid-mid/div1;\\n        int b=mid-mid/div2;\\n        int c=mid/((1LL * div1*div2)/(1LL*__gcd(div1,div2)));\\n        if(a<cnt1 || b<cnt2 || (mid-c)<(cnt1+cnt2))\\n        return false;\\n        return true;\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int low=0;\\n        int high=INT_MAX;\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=(1LL * low+ 1LL * high)/2;\\n            if(check(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028075,
                "title": "how-do-we-get-the-upper-bound-for-binary-search",
                "content": "I was upsolving this problem, and I got a working binary search solution shared below. In the solution, I was able to easily figure out the lower bound of the search space `l = uniqueCnt1 + uniqueCnt2`. However, I arbitrarily picked `r = 1 << 31`, and it worked. I have no idea why it worked, and cannot prove that it is correct. What is a tighter upperbound that depends on the input size, and not just a number that is large enough?\\n\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        def ok(m):\\n            both = m // LCM\\n            c1 = m // divisor1 - both\\n            c2 = m // divisor2 - both\\n            pool_1 = m - both - c1\\n            pool_2 = m - both - c2\\n            pool_total = m - both\\n            return pool_total >= uniqueCnt1 + uniqueCnt2 and pool_1 >= uniqueCnt1 and pool_2 >= uniqueCnt2\\n            \\n            \\n        LCM = lcm(divisor1, divisor2)\\n        l, r = uniqueCnt1 + uniqueCnt2, 1 << 31\\n        while l < r:\\n            m = (l + r) // 2\\n            if ok(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        def ok(m):\\n            both = m // LCM\\n            c1 = m // divisor1 - both\\n            c2 = m // divisor2 - both\\n            pool_1 = m - both - c1\\n            pool_2 = m - both - c2\\n            pool_total = m - both\\n            return pool_total >= uniqueCnt1 + uniqueCnt2 and pool_1 >= uniqueCnt1 and pool_2 >= uniqueCnt2\\n            \\n            \\n        LCM = lcm(divisor1, divisor2)\\n        l, r = uniqueCnt1 + uniqueCnt2, 1 << 31\\n        while l < r:\\n            m = (l + r) // 2\\n            if ok(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004339,
                "title": "java-lcm-binary-search",
                "content": "```\\n    //3.lcm + Binary search\\n    //Runtime: 0ms 100%; Memory: 39.1MB 47%\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long left = uniqueCnt1 + uniqueCnt2, right = Integer.MAX_VALUE;\\n        long g = lcm(divisor1 , divisor2);\\n\\n        long res = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            long mid =  (left + right) / 2;\\n\\n            boolean x = (mid - mid / divisor1) >= uniqueCnt1;\\n            boolean y = (mid - mid / divisor2) >= uniqueCnt2;\\n            boolean z = (mid - mid / g) >= uniqueCnt1 + uniqueCnt2;\\n\\n            if (x && y && z){\\n                res = mid;\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return (int)res;\\n    }\\n\\n    private long lcm(int a, int b) {\\n        return 1l * a * b / gcd(a, b);\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0) return a;\\n        return gcd(b,a % b);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n    //3.lcm + Binary search\\n    //Runtime: 0ms 100%; Memory: 39.1MB 47%\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long left = uniqueCnt1 + uniqueCnt2, right = Integer.MAX_VALUE;\\n        long g = lcm(divisor1 , divisor2);\\n\\n        long res = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            long mid =  (left + right) / 2;\\n\\n            boolean x = (mid - mid / divisor1) >= uniqueCnt1;\\n            boolean y = (mid - mid / divisor2) >= uniqueCnt2;\\n            boolean z = (mid - mid / g) >= uniqueCnt1 + uniqueCnt2;\\n\\n            if (x && y && z){\\n                res = mid;\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return (int)res;\\n    }\\n\\n    private long lcm(int a, int b) {\\n        return 1l * a * b / gcd(a, b);\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0) return a;\\n        return gcd(b,a % b);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978485,
                "title": "binary-search-simple-approach",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n     using ll=long long;\\n     int low=0;\\n     ll high=1e12;\\n     int ans=0;ll m;\\n     while(low<=high)\\n     {\\n         m=low+(high-low)/2;\\n         ll a=m-m/divisor1;\\n         ll b=m-m/divisor2;\\n         ll lcm=((ll)divisor1*(ll)divisor2*1LL)/((ll)__gcd((ll)divisor1,(ll)divisor2));\\n         if(a>=uniqueCnt1 &&b>=uniqueCnt2&&(m-(m/lcm))>=uniqueCnt1+uniqueCnt2)\\n         {\\n             high=m-1;\\n            ans=m;\\n         }\\n         else\\n         low=m+1;\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n     using ll=long long;\\n     int low=0;\\n     ll high=1e12;\\n     int ans=0;ll m;\\n     while(low<=high)\\n     {\\n         m=low+(high-low)/2;\\n         ll a=m-m/divisor1;\\n         ll b=m-m/divisor2;\\n         ll lcm=((ll)divisor1*(ll)divisor2*1LL)/((ll)__gcd((ll)divisor1,(ll)divisor2));\\n         if(a>=uniqueCnt1 &&b>=uniqueCnt2&&(m-(m/lcm))>=uniqueCnt1+uniqueCnt2)\\n         {\\n             high=m-1;\\n            ans=m;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2977052,
                "title": "c-binary-search-on-only-2-conditions-0ms-5-9mb",
                "content": "This problem was INHO trickier than the fourth in this context to figure out.\\n\\nTo solve it, we need to find a number `m` such that:\\n* all the numbers in the `1 - m` range (included) other than the ones divisible by `d1` are at least `u1`, ie: `m - m / d1 >= u1`;\\n* all the numbers in the `1 - m` range (included) other than the ones divisible by `d2` are at least `u2`, ie: `m - m / d2 >= u2`;\\n* all the numbers in the `1 - m` range (included) other than the ones divisible by the both `d1` and `d2`, with `d3` being their `lcm`, are at least `u1 + u2`, ie: `m - m / d3 >= u1 + u2`.\\n\\nThe tricky part is to understand the third condition: we might get enough values satisfying both the initial two conditions, but we might still be off if some of those values would appear in both `arr1` and `arr2`, going against the specs - that is why we also need the third check to be met.\\n\\nFor example with `d1 == 3`, `d2 == 5`, `u1 == 8` and `u2 = 7` we would have, respectively, `arr1 == {1, 2, 4, 5, 7, 8, 10, 11}` and `arr2 == {1, 2, 3, 4, 6, 7, 8}`, concluding that `11` is the right upper limit of our range, but that is clearly not the case since we share a lot of elements in common between `arr1` and `arr2`, like `1`, `2`, `4`, etc.\\n\\nWe might be tempted to use only this condition now, but that would not work; for example in the third provided test case with  `d1 == 2`, `d2 == 4`, `u1 == 8` and `u2 = 2` we would get an upper limit of `13` using only the third condition (with `m - m / 4 >= 10`, so `3 * m >= 40` and then `m >= 13`), but that would be wrong too, since we can\\'t get `8` odd positive elements up to `13`.\\n\\nNow, in order to find a suitable value for `m`, we might go from `1` all the way up to the first value matching the condition, but given the specs, we would hardly avoid a TLE and, in any case, it would definitely not be efficient!\\n\\nWe can do better and so we will, proceeding with good old binary search `while` `l < r` and for each iteration:\\n* we will compute `m` as the mathematical average of `l` and `r` (initialised as `1` and double the sum of `u1` and `u2`, respectively);\\n* then, if `m` matches all three our conditions: we will shrink our range from the left, setting `r` to be `m` in the next iteration (notice, never `m - 1`, since `m` might actually be our perfect value here);\\n* alternatively, we will shrink our range from the left, setting `l` to be `m + 1`.\\n\\nOnce done, we can `return` `l` :)\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSet(long d1, long d2, int u1, int u2) {\\n        // support variables\\n        long tot = u1 + u2, l = 0, r = tot << 1, m, d3 = long(d1) * d2 / gcd(d1, d2);\\n        // bs loop\\n        while (l < r) {\\n            m = (l + r) >> 1;\\n            // checking if m meets the conditions or not\\n            if (m - m / d1 >= u1 && m - m / d2 >= u2 && m - m / d3 >= tot) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nMicro-optimised version, going for only 2 conditions once we ensure that `u1` is always the bigger of the two limits we need to satisfy; and it runs faster, yay \\uD83D\\uDCAA:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSet(long d1, long d2, int u1, int u2) {\\n        // support variables\\n        long tot = u1 + u2, l = 0, r = tot << 1, m, d3 = long(d1) * d2 / gcd(d1, d2);\\n        // making sure u1 is bigger\\n        if (u2 > u1) swap(d1, d2), swap(u1, u2);\\n        // bs loop\\n        while (l < r) {\\n            m = (l + r) >> 1;\\n            // checking if m meets the conditions or not\\n            if (m - m / d1 >= u1 && m - m / d3 >= tot) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimizeSet(long d1, long d2, int u1, int u2) {\\n        // support variables\\n        long tot = u1 + u2, l = 0, r = tot << 1, m, d3 = long(d1) * d2 / gcd(d1, d2);\\n        // bs loop\\n        while (l < r) {\\n            m = (l + r) >> 1;\\n            // checking if m meets the conditions or not\\n            if (m - m / d1 >= u1 && m - m / d2 >= u2 && m - m / d3 >= tot) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSet(long d1, long d2, int u1, int u2) {\\n        // support variables\\n        long tot = u1 + u2, l = 0, r = tot << 1, m, d3 = long(d1) * d2 / gcd(d1, d2);\\n        // making sure u1 is bigger\\n        if (u2 > u1) swap(d1, d2), swap(u1, u2);\\n        // bs loop\\n        while (l < r) {\\n            m = (l + r) >> 1;\\n            // checking if m meets the conditions or not\\n            if (m - m / d1 >= u1 && m - m / d3 >= tot) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973928,
                "title": "binary-search-in-c-java-python",
                "content": "# Intuition\\nThis is a very beautiful binary search problem. The intuition comes from the monotonicity of the answer. If x satisfies the conditions then x + 1 will always do the same and if x doesn\\'t then x - 1 will always not. Moreover this problem also uses a little bit of maths as well (inclusion-exclusion and lcm-gcd).\\n\\n# Approach\\nLet\\'s consider \"mid\" to be the upper limit, then\\n \\ncnt1 = Numbers from 1 to mid that are not divisible by divisor1\\ncnt2 = Numbers from 1 to mid that are not divisible by divisor2\\ncombined = Numbers from 1 to mid that are not divisible by both divisor1 and divisor2\\n\\nThe condition cnt1 >= uniqueCnt1 and cnt2 >= uniqueCnt2 are easy to interpret but combined >= uniqueCnt1 + uniqueCnt2 is such that if we take combined in cnt1 then cnt2 >= uniqueCnt2 should be valid for a solution to exist.\\n\\nAfter that its just typical binary search.\\n\\n# Complexity\\n- Time complexity:\\nO(log2(INT_MAX)) because of binary search\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nPython3\\n\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int,\\n                    uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        l = 1\\n        r = 1e10\\n        ans = -1\\n        lcm = math.lcm(divisor1, divisor2)\\n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            cnt1 = mid - mid // divisor1\\n            cnt2 = mid - mid // divisor2\\n            combined = mid - mid // lcm\\n            if cnt1 >= uniqueCnt1 and cnt2 >= uniqueCnt2 and combined >= uniqueCnt1 + uniqueCnt2:\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n\\n        return int(ans)\\n```\\n\\n```\\nJava\\n\\nclass Solution {\\n    private long calculateGCD(long a, long b) {\\n        if (b == 0) return a;\\n\\n        return calculateGCD(b, a % b);\\n    }\\n\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int l = 1;\\n        int r = Integer.MAX_VALUE;\\n        int ans = -1;\\n        long gcd = calculateGCD(divisor1, divisor2);\\n        long lcm = (long) divisor1 * divisor2 / gcd;\\n\\n        while (l <= r) {\\n            int mid = (l + ((r - l) >> 1));\\n            int cnt1 = mid - mid / divisor1;\\n            int cnt2 = mid - mid / divisor2;\\n            long combined = mid - mid / lcm;\\n            if (cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 &&\\n                    combined >= uniqueCnt1 + uniqueCnt2) {\\n                {\\n                    ans = mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n```\\nC++\\n\\nclass Solution {\\n    typedef long long ll;\\n\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n         int l = 1;\\n         int r = INT_MAX;\\n         int ans = -1;\\n         ll lcm = (ll) divisor1 * divisor2 / __gcd(divisor1, divisor2);\\n\\n         while (l <= r) {\\n             int mid = (l + ((r - l) >> 1));\\n             int cnt1 = mid - mid / divisor1;\\n             int cnt2 = mid - mid / divisor2;\\n             ll combined = mid - mid / lcm;\\n             if (cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 &&\\n             combined >= uniqueCnt1 + uniqueCnt2) {\\n                 ans = mid;\\n                 r = mid - 1;\\n             }\\n             else l = mid + 1;\\n         }\\n\\n         return ans;\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int,\\n                    uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        l = 1\\n        r = 1e10\\n        ans = -1\\n        lcm = math.lcm(divisor1, divisor2)\\n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            cnt1 = mid - mid // divisor1\\n            cnt2 = mid - mid // divisor2\\n            combined = mid - mid // lcm\\n            if cnt1 >= uniqueCnt1 and cnt2 >= uniqueCnt2 and combined >= uniqueCnt1 + uniqueCnt2:\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n\\n        return int(ans)\\n```\n```\\nJava\\n\\nclass Solution {\\n    private long calculateGCD(long a, long b) {\\n        if (b == 0) return a;\\n\\n        return calculateGCD(b, a % b);\\n    }\\n\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int l = 1;\\n        int r = Integer.MAX_VALUE;\\n        int ans = -1;\\n        long gcd = calculateGCD(divisor1, divisor2);\\n        long lcm = (long) divisor1 * divisor2 / gcd;\\n\\n        while (l <= r) {\\n            int mid = (l + ((r - l) >> 1));\\n            int cnt1 = mid - mid / divisor1;\\n            int cnt2 = mid - mid / divisor2;\\n            long combined = mid - mid / lcm;\\n            if (cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 &&\\n                    combined >= uniqueCnt1 + uniqueCnt2) {\\n                {\\n                    ans = mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nC++\\n\\nclass Solution {\\n    typedef long long ll;\\n\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n         int l = 1;\\n         int r = INT_MAX;\\n         int ans = -1;\\n         ll lcm = (ll) divisor1 * divisor2 / __gcd(divisor1, divisor2);\\n\\n         while (l <= r) {\\n             int mid = (l + ((r - l) >> 1));\\n             int cnt1 = mid - mid / divisor1;\\n             int cnt2 = mid - mid / divisor2;\\n             ll combined = mid - mid / lcm;\\n             if (cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 &&\\n             combined >= uniqueCnt1 + uniqueCnt2) {\\n                 ans = mid;\\n                 r = mid - 1;\\n             }\\n             else l = mid + 1;\\n         }\\n\\n         return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973709,
                "title": "swift-binary-search-o-logn-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizeSet(_ divisor1: Int, _ divisor2: Int, _ uniqueCnt1: Int, _ uniqueCnt2: Int) -> Int {\\n        func check(_ val: Int) -> Bool {\\n            let c = val / lcm(divisor1, divisor2) // # of integers divisible by both divisor1 and divisor2\\n            let a = (val / divisor1) - c // # of integers divisible by divisor1\\n            let b = (val / divisor2) - c // # of integers divisible by divisor2\\n            let remaining = val - (a + b) - c  // # of intergers not divisible by divisor1 or divisor2\\n            \\n            \\n            // subtract # of integers divisible by divisor2 from array1. integers divisible by divisor2 can be assign to array1\\n            \\n            // subtract # of integers divisible by divisor1 from array2. integers divisible by divisor1 can be assign to array2\\n            // return true if remaining # of integers is greater or equals to # of integers needed to fill array1 and array2\\n            \\n            return remaining >= max(0, uniqueCnt1 - b) + max(0, uniqueCnt2 - a)\\n        }\\n\\n        var left = 0\\n        var right = Int.max >> 1\\n\\n        var res = Int.max\\n            \\n        while left <= right {\\n            let mid = (left + right) >> 1\\n\\n            if check(mid) {\\n                right = mid - 1\\n                res = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n\\nfunc gcd(_ a:Int, _ b:Int) -> Int {\\n    if a == b {\\n        return a\\n    }\\n    else {\\n        if a > b {\\n            return gcd(a-b, b)\\n        }\\n        else {\\n            return gcd(a, b-a)\\n        }\\n    }\\n}\\n   \\nfunc lcm(_ x: Int, _ y: Int) -> Int {\\n   return x / gcd(x, y) * y\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeSet(_ divisor1: Int, _ divisor2: Int, _ uniqueCnt1: Int, _ uniqueCnt2: Int) -> Int {\\n        func check(_ val: Int) -> Bool {\\n            let c = val / lcm(divisor1, divisor2) // # of integers divisible by both divisor1 and divisor2\\n            let a = (val / divisor1) - c // # of integers divisible by divisor1\\n            let b = (val / divisor2) - c // # of integers divisible by divisor2\\n            let remaining = val - (a + b) - c  // # of intergers not divisible by divisor1 or divisor2\\n            \\n            \\n            // subtract # of integers divisible by divisor2 from array1. integers divisible by divisor2 can be assign to array1\\n            \\n            // subtract # of integers divisible by divisor1 from array2. integers divisible by divisor1 can be assign to array2\\n            // return true if remaining # of integers is greater or equals to # of integers needed to fill array1 and array2\\n            \\n            return remaining >= max(0, uniqueCnt1 - b) + max(0, uniqueCnt2 - a)\\n        }\\n\\n        var left = 0\\n        var right = Int.max >> 1\\n\\n        var res = Int.max\\n            \\n        while left <= right {\\n            let mid = (left + right) >> 1\\n\\n            if check(mid) {\\n                right = mid - 1\\n                res = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n\\nfunc gcd(_ a:Int, _ b:Int) -> Int {\\n    if a == b {\\n        return a\\n    }\\n    else {\\n        if a > b {\\n            return gcd(a-b, b)\\n        }\\n        else {\\n            return gcd(a, b-a)\\n        }\\n    }\\n}\\n   \\nfunc lcm(_ x: Int, _ y: Int) -> Int {\\n   return x / gcd(x, y) * y\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962070,
                "title": "simple-binary-search-on-inclusion-exclusion-principle",
                "content": "Using Set Theory Logic:\\n\\nn(A\\') - no of elements which aren\\'t divisible by d1 must be greater than uniqueCnt1\\n\\nn(B\\') - no of elements which aren\\'t divisible by d2 must be greater than uniqueCnt2\\n\\nn(A\\' & B\\') - no of elements which aren\\'t divisible by both d1 and d2 must be greater than total unique counts\\n\\nSo we can binary-search the limit which satisfies all of the three above conditions\\n\\n```\\n#define ll long long int\\nclass Solution {\\n    ll lc;\\npublic:\\n    ll gcd(ll d1,ll d2){\\n        if(d2==0)\\n            return d1;\\n        return gcd(d2,d1%d2);\\n    }\\n    \\n    ll lcm(ll d1,ll d2){\\n        return (d1*d2)/gcd(d1,d2);\\n    }\\n    \\n    int check(int d1,int d2,int c1,int c2,ll m){\\n        ll cnt1=m-(m/d1); // n(A\\')\\n        ll cnt2=m-(m/d2); // n(B\\')\\n        ll cnt3=m-(m/lc); // n(A\\'&B\\')\\n        \\n        return (cnt1>=c1 and cnt2>=c2 and cnt3>=(c1+c2));\\n    }\\n    \\n    \\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll l=1,r=1e18,ans;\\n        lc=lcm(d1,d2);\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(check(d1,d2,c1,c2,m)){\\n                r=m-1;\\n                ans=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    ll lc;\\npublic:\\n    ll gcd(ll d1,ll d2){\\n        if(d2==0)\\n            return d1;\\n        return gcd(d2,d1%d2);\\n    }\\n    \\n    ll lcm(ll d1,ll d2){\\n        return (d1*d2)/gcd(d1,d2);\\n    }\\n    \\n    int check(int d1,int d2,int c1,int c2,ll m){\\n        ll cnt1=m-(m/d1); // n(A\\')\\n        ll cnt2=m-(m/d2); // n(B\\')\\n        ll cnt3=m-(m/lc); // n(A\\'&B\\')\\n        \\n        return (cnt1>=c1 and cnt2>=c2 and cnt3>=(c1+c2));\\n    }\\n    \\n    \\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll l=1,r=1e18,ans;\\n        lc=lcm(d1,d2);\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(check(d1,d2,c1,c2,m)){\\n                r=m-1;\\n                ans=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961732,
                "title": "intuitive-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncheck three conditions:\\n```\\n- cnt1 < uniqueCnt1 \\n- cnt2 < uniqueCnt2\\n- total < (uniqueCnt1 + uniqueCnt2)\\n```\\n\\nIf any condition is true, there are no enough numbers\\n\\n**They key is how to count total**\\n```\\nlong total = mid - mid / lcm;\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(log INT_MAX)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int left = uniqueCnt1 + uniqueCnt2, right = INT_MAX;\\n        long lcm = 1l * divisor1 * divisor2 / gcd(divisor1, divisor2);\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            int cnt1 = mid - mid / divisor1;\\n            int cnt2 = mid - mid / divisor2;\\n            long total = mid - mid / lcm;\\n            if (cnt1 < uniqueCnt1 || cnt2 < uniqueCnt2 || total < (uniqueCnt1 + uniqueCnt2)) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n- cnt1 < uniqueCnt1 \\n- cnt2 < uniqueCnt2\\n- total < (uniqueCnt1 + uniqueCnt2)\\n```\n```\\nlong total = mid - mid / lcm;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int left = uniqueCnt1 + uniqueCnt2, right = INT_MAX;\\n        long lcm = 1l * divisor1 * divisor2 / gcd(divisor1, divisor2);\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            int cnt1 = mid - mid / divisor1;\\n            int cnt2 = mid - mid / divisor2;\\n            long total = mid - mid / lcm;\\n            if (cnt1 < uniqueCnt1 || cnt2 < uniqueCnt2 || total < (uniqueCnt1 + uniqueCnt2)) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959924,
                "title": "java-binary-search-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    private static int d1, d2, c1, c2;\\n    private static long lcm; // avoid Integer overflow\\n\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        d1 = divisor1; d2 = divisor2; c1 = uniqueCnt1; c2 = uniqueCnt2;\\n        lcm = findLCM(d1, d2);\\n        int start = uniqueCnt1 + uniqueCnt2, end = (uniqueCnt1 + uniqueCnt2) * 2 - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isSatisfied(mid)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n\\n    private boolean isSatisfied(int target) {\\n        long spaceOnlyFor1 = target / d2 - target / lcm;\\n        long spaceOnlyFor2 = target / d1 - target / lcm;\\n        long commonSpace = target - target / d1 - target / d2 + target / lcm;\\n        \\n        long commonNeededFor1 = Math.max(0L, c1 - spaceOnlyFor1);\\n        long commonNeededFor2 = Math.max(0L, c2 - spaceOnlyFor2);\\n        \\n        return commonSpace >= commonNeededFor1 + commonNeededFor2;\\n    }\\n\\n    private long findLCM(int a, int b) {\\n        int a_ = a, b_ = b;\\n        while (b_ > 0) {\\n            int temp = b_;\\n            b_ = a_ % b_;\\n            a_ = temp;\\n        }\\n        int gcd = a_;\\n        return (long)a * b / gcd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static int d1, d2, c1, c2;\\n    private static long lcm; // avoid Integer overflow\\n\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        d1 = divisor1; d2 = divisor2; c1 = uniqueCnt1; c2 = uniqueCnt2;\\n        lcm = findLCM(d1, d2);\\n        int start = uniqueCnt1 + uniqueCnt2, end = (uniqueCnt1 + uniqueCnt2) * 2 - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isSatisfied(mid)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n\\n    private boolean isSatisfied(int target) {\\n        long spaceOnlyFor1 = target / d2 - target / lcm;\\n        long spaceOnlyFor2 = target / d1 - target / lcm;\\n        long commonSpace = target - target / d1 - target / d2 + target / lcm;\\n        \\n        long commonNeededFor1 = Math.max(0L, c1 - spaceOnlyFor1);\\n        long commonNeededFor2 = Math.max(0L, c2 - spaceOnlyFor2);\\n        \\n        return commonSpace >= commonNeededFor1 + commonNeededFor2;\\n    }\\n\\n    private long findLCM(int a, int b) {\\n        int a_ = a, b_ = b;\\n        while (b_ > 0) {\\n            int temp = b_;\\n            b_ = a_ % b_;\\n            a_ = temp;\\n        }\\n        int gcd = a_;\\n        return (long)a * b / gcd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958679,
                "title": "easy-java-solution-beats-100-binary-searchbinra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//----------------BINARY SEARCH\\nclass Solution {\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long low = uniqueCnt1 + uniqueCnt2;\\n        long high = (int) 1e10;\\n        long lcm = LCM(divisor1, divisor2);\\n        long ans = 0;\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            // check all conditions\\n            boolean a = mid - mid / divisor1 >= uniqueCnt1;\\n            boolean b = mid - mid / divisor2 >= uniqueCnt2;\\n            boolean c = mid - mid / lcm >= uniqueCnt1 + uniqueCnt2;\\n            if (a && b && c) {\\n                ans = mid;\\n                high = mid-1;\\n            } else\\n                low = mid + 1;\\n\\n        }\\n        return (int)ans;\\n    }\\n\\n    long gcd(int a, int b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    // method to return LCM of two numbers\\n    long LCM(int a, int b) {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n}\\n// Time complexity : O(log 10^9)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n//----------------BINARY SEARCH\\nclass Solution {\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long low = uniqueCnt1 + uniqueCnt2;\\n        long high = (int) 1e10;\\n        long lcm = LCM(divisor1, divisor2);\\n        long ans = 0;\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            // check all conditions\\n            boolean a = mid - mid / divisor1 >= uniqueCnt1;\\n            boolean b = mid - mid / divisor2 >= uniqueCnt2;\\n            boolean c = mid - mid / lcm >= uniqueCnt1 + uniqueCnt2;\\n            if (a && b && c) {\\n                ans = mid;\\n                high = mid-1;\\n            } else\\n                low = mid + 1;\\n\\n        }\\n        return (int)ans;\\n    }\\n\\n    long gcd(int a, int b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    // method to return LCM of two numbers\\n    long LCM(int a, int b) {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n}\\n// Time complexity : O(log 10^9)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958178,
                "title": "struggled-for-2-hours-a-detailed-binary-search-explanation",
                "content": "Let there be 4 types of numbers for the purpose of our problem. \\n1. \\'Useless\\' numbers - numbers that can never go in set a or b\\n2. \\'A Exclusive\\' numbers - numbers that can only go in set a\\n3. \\'B Exclusive\\' numbers - numbers that can only go in set b\\n4. \\'Extra\\' numbers - numbers that can go in EITHER set a or b.\\n\\nTo solve this problem, we need to find the minimum number such that itself and all lesser numbers fulfill the required amount of numbers in set a and the required amount of numbers in set b. Binary search is a good fit for this problem because it is obvious that if some number x fulfills the condition, then all numbers >= x also fulfill the condition. Also, if some number y does not fulfill the condition, all numbers <= y also do not fulfill the condition. \\n\\nWe use binary search to try a number and tighten our search based on what our check function returns. \\n\\nOur check function finds how many there are of each kind of number.\\nWe can find the amount of useless numbers by dividing the picked number by the lcm of divisors a and b. This is logical because these numbers will have both a and b as factors so they cannot be used.\\nWe find the \\'a exclusive\\' numbers by dividing the picked number by b, and the \\'b exclusive\\' numbers by dividing the picked number by a. We have to remember to subtract the useless numbers from this calculation. \\nFinally, the extra numbers are implicitly calculated because they are the only other type of number. So we subtract useless, a, and b from the picked number to get the amount of extra numbers.\\n\\nWe apply all exclusive numbers to the counts of their respective sets, then check if the extra numbers can fulfill the remaining requirement. If they can, then the check function will return 1 to indicate that the picked number is good. Then, we can half the range of the binary search to all numbers less than middle. Likewise, we return -1 if the extra numbers are unable to fulfill the remaining requirement, halving the range of the binary search to mid+1.\\n\\n```\\nclass Solution {\\npublic:\\n    long check(long a, long b, long c1, long c2, long mid){\\n        long useless = (mid/lcm(a,b));\\n        long a_exclusive = (mid/b) - useless;\\n        long b_exclusive = (mid/a) - useless;\\n        long extra = mid-useless-a_exclusive-b_exclusive;\\n        c1 = max(long(0), c1-a_exclusive);\\n        c2 = max(long(0), c2-b_exclusive);\\n        if(extra >= c1+c2) return 1;\\n        else return -1;\\n    }\\n    int minimizeSet(int a, int b, int c1, int c2) {\\n        long ans = INT_MAX;\\n        long l = 0, r = INT_MAX;\\n        while(l <= r){\\n            long mid = (l+r)/2;\\n            auto res = check(a, b, c1, c2, mid);\\n            if(res == 1){ // good\\n                r = mid-1;\\n                ans = min(ans, mid);\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long check(long a, long b, long c1, long c2, long mid){\\n        long useless = (mid/lcm(a,b));\\n        long a_exclusive = (mid/b) - useless;\\n        long b_exclusive = (mid/a) - useless;\\n        long extra = mid-useless-a_exclusive-b_exclusive;\\n        c1 = max(long(0), c1-a_exclusive);\\n        c2 = max(long(0), c2-b_exclusive);\\n        if(extra >= c1+c2) return 1;\\n        else return -1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2957813,
                "title": "java-code",
                "content": "# Explaination link : [Full Intuition](https://leetcode.com/problems/minimize-the-maximum-of-two-arrays/solutions/2946508/python-lcm-and-binary-search-explained-bonus-one-liner/?orderBy=most_votes)\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSet(int D1, int D2, int C1, int C2) {\\n        long lcm = lcm(D1, D2);\\n        \\n        int start = C1 + C2;\\n        int end = Integer.MAX_VALUE;\\n\\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            //smallest number in [start, end] satisfying below 3 criterias is the answer\\n            Boolean c1 = (mid - mid / D1) >= C1;\\n            Boolean c2 = (mid - mid / D2) >= C2;\\n            Boolean c3 = (mid - mid / lcm) >= C1 + C2;\\n            if(c1 && c2 && c3){\\n                end = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    //Black Box \\n    private long lcm(int a, int b) //lcm of two integers can overflow\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    private long gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSet(int D1, int D2, int C1, int C2) {\\n        long lcm = lcm(D1, D2);\\n        \\n        int start = C1 + C2;\\n        int end = Integer.MAX_VALUE;\\n\\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            //smallest number in [start, end] satisfying below 3 criterias is the answer\\n            Boolean c1 = (mid - mid / D1) >= C1;\\n            Boolean c2 = (mid - mid / D2) >= C2;\\n            Boolean c3 = (mid - mid / lcm) >= C1 + C2;\\n            if(c1 && c2 && c3){\\n                end = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    //Black Box \\n    private long lcm(int a, int b) //lcm of two integers can overflow\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    private long gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956785,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    ll gcd(ll a, ll b)\\n   {\\n    if (a == 0)\\n        return b;\\n    return gcd(b % a, a);\\n     }\\n \\n    bool solve(ll mid,ll d1,ll d2,int c1,int c2){\\n        ll noofdiv1 = mid/d1;\\n        ll noofdiv2 = mid/d2;\\n        // common which are divisible by both \\n        ll lcm = ((d1*d2)/(gcd(d1,d2)));\\n        ll common = mid/lcm ; \\n        ll tot = noofdiv1 + noofdiv2 - common ; \\n        ll notdivbyboth = mid-tot;\\n        \\n        ll divby1butnotby2 = noofdiv1-common;\\n        ll divby2butnotby1 = noofdiv2-common;\\n        c1-=divby2butnotby1;\\n        c2-=divby1butnotby2;\\n       // cout<<c1<<\" \";\\n        ll rem = 0 ; \\n        if(c1>0)\\n            rem+=c1;\\n        if(c2 > 0)\\n            rem+=c2;\\n        if(rem <= notdivbyboth)\\n            return true;\\n        return false;\\n        \\n    }\\n       \\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll mx = max(d1,d2);\\n        ll l = 1 ; ll h = 1e12;\\n        ll ans=-1;\\n       // cout<<solve(11,d1,d2,c1,c2);\\n        while(l<= h){\\n            ll mid = l + (h-l)/2 ; \\n            if(solve(mid,d1,d2,c1,c2)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long int \\n    ll gcd(ll a, ll b)\\n   {\\n    if (a == 0)\\n        return b;\\n    return gcd(b % a, a);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2956413,
                "title": "100-fastest-binary-search-for-max-number-c",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll Lcm(ll a,ll b){\\n        return (1ll*a*b)/gcd(a,b);\\n    }\\n    ll gcd(ll a,ll b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n\\n    bool check(ll total,int& d1,int& d2,int& c1,int& c2){\\n        ll common=total/lcm; //excluded from both\\n        ll b=(total/d1 - common)-c2;   //divisible by d1 but not by d2, that cannot be included in second due to size.\\n        b=max(0ll,b);\\n        ll c=(total/d2 - common)-c1;  //divisible by d2 but not by d1 that cannot be included in first due to size.\\n        c=max(0ll,c);\\n        return (total-common-b-c)>=c1+c2;\\n    }\\n\\n    ll lcm;\\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll start=c1+c2,end=INT_MAX;\\n        lcm=Lcm(d1,d2);\\n        while(start<end){\\n            ll mid=(start+end)>>1;\\n            bool flag=check(mid,d1,d2,c1,c2);\\n\\n            if(flag) end=mid;\\n            else start=mid+1;\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll Lcm(ll a,ll b){\\n        return (1ll*a*b)/gcd(a,b);\\n    }\\n    ll gcd(ll a,ll b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n\\n    bool check(ll total,int& d1,int& d2,int& c1,int& c2){\\n        ll common=total/lcm; //excluded from both\\n        ll b=(total/d1 - common)-c2;   //divisible by d1 but not by d2, that cannot be included in second due to size.\\n        b=max(0ll,b);\\n        ll c=(total/d2 - common)-c1;  //divisible by d2 but not by d1 that cannot be included in first due to size.\\n        c=max(0ll,c);\\n        return (total-common-b-c)>=c1+c2;\\n    }\\n\\n    ll lcm;\\n    int minimizeSet(int d1, int d2, int c1, int c2) {\\n        ll start=c1+c2,end=INT_MAX;\\n        lcm=Lcm(d1,d2);\\n        while(start<end){\\n            ll mid=(start+end)>>1;\\n            bool flag=check(mid,d1,d2,c1,c2);\\n\\n            if(flag) end=mid;\\n            else start=mid+1;\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955120,
                "title": "c-clean-code-binary-search-algo-o-logn-logn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBIN SEARCH Idea came when the answer range lies in SORTED FASHION.\\n1 ... N (sorted)\\nTry to minimize N with the help of bin search algo\\n\\n\\n# Complexity\\n- Time complexity:O(Log N * Log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n\\n    //Need ll as mul of 2 big ints lead to overflow\\n    ll lcm(ll a, ll b){\\n        return (a*b)/__gcd(a,b); //log(min(a,b))\\n    }\\n\\n    //does 1 .... N satisfy the condition of ques or not\\n    bool satisfy(int d1, int d2, int c1, int c2, int N){\\n        int divbyd1 = N/d1; // this is simple math N/d1 int part says how many mul in range 1...N\\n        int notdivbyd1 = N - divbyd1; // total - pos = neg\\n        int divbyd2 = N/d2;\\n        int notdivbyd2 = N - divbyd2;\\n\\n        int divbyboth = N/lcm(d1,d2); //log(N) \\n        int notdivbyboth = N - divbyboth;\\n\\n        if(notdivbyd1 >= c1 && notdivbyd2 >= c2 && notdivbyboth >= c1+c2){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int s = 1;\\n        int e = INT_MAX;\\n        int ans = -1;\\n\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n\\n            if(satisfy(divisor1, divisor2,uniqueCnt1, uniqueCnt2, mid)){\\n                ans = mid; // potential ans, but lets try to shrink it bit more\\n                e = mid-1; //so that we shrink and find more optimal ans\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n\\n    //Need ll as mul of 2 big ints lead to overflow\\n    ll lcm(ll a, ll b){\\n        return (a*b)/__gcd(a,b); //log(min(a,b))\\n    }\\n\\n    //does 1 .... N satisfy the condition of ques or not\\n    bool satisfy(int d1, int d2, int c1, int c2, int N){\\n        int divbyd1 = N/d1; // this is simple math N/d1 int part says how many mul in range 1...N\\n        int notdivbyd1 = N - divbyd1; // total - pos = neg\\n        int divbyd2 = N/d2;\\n        int notdivbyd2 = N - divbyd2;\\n\\n        int divbyboth = N/lcm(d1,d2); //log(N) \\n        int notdivbyboth = N - divbyboth;\\n\\n        if(notdivbyd1 >= c1 && notdivbyd2 >= c2 && notdivbyboth >= c1+c2){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int s = 1;\\n        int e = INT_MAX;\\n        int ans = -1;\\n\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n\\n            if(satisfy(divisor1, divisor2,uniqueCnt1, uniqueCnt2, mid)){\\n                ans = mid; // potential ans, but lets try to shrink it bit more\\n                e = mid-1; //so that we shrink and find more optimal ans\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954394,
                "title": "c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long lcm( long long a, long long b ){\\n\\t\\t\\treturn a*b / __gcd(a,b);\\n\\t\\t}\\n\\t\\tbool criteria(int num, int div1, int div2, int uc1, int uc2){\\n\\t\\t\\tint cnt1 = num - num/div1;               // no of numbers not divisible by div1 or suitable for array1\\n\\t\\t\\tint cnt2 = num - num/div2;               // no of numbers not divisible by div2 or suitable for array2\\n\\t\\t\\tint cnt3 = num - num/ lcm(div1, div2);   // no of numbers not divisible by both div1 and div2 or suitable for both arrays\\n\\t\\t\\treturn cnt1 >= uc1 and cnt2 >= uc2 and cnt3 >= (uc1 + uc2);\\n\\t\\t}\\n\\t\\tint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\t\\t\\tlong long left = 0;\\n\\t\\t\\tlong long right = INT_MAX;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tlong long mid = left + (right - left) / 2;\\n\\t\\t\\t\\tif (criteria(mid, divisor1, divisor2, uniqueCnt1, uniqueCnt2)) right = mid;\\n\\t\\t\\t\\telse left = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t};e",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long lcm( long long a, long long b ){\\n\\t\\t\\treturn a*b / __gcd(a,b);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2954115,
                "title": "python-set-operations-with-binary-search",
                "content": "# Intuition\\nTricky problem, a little bit of math, division, sets and binary search. But to get this idea clearly while being under time pressure, good luck with that.\\n\\n# Approach\\nDo binary search between 0 and big enough number, idea is to find minimum value that satisfies check, pretty starightforward.\\nOn check just take divisions and do simple set inclusion/exclusion on them. Number you get after division is amount of numbers that are divisble with that number within solution candidate range.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N log N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def possible(self, candidate,  d1, d2, cnt1, cnt2):\\n        cant_do_both = candidate // lcm(d1, d2)\\n        cant_do_first = candidate // d1\\n        cant_do_second = candidate // d2\\n\\n        can_do_both = candidate - (cant_do_first + cant_do_second - cant_do_both)\\n\\n        cnt1 = max(0, cnt1 - (cant_do_second - cant_do_both))\\n        cnt2 = max(0, cnt2 - (cant_do_first - cant_do_both))\\n\\n        return can_do_both >= cnt1 + cnt2\\n\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        lo, hi = 0, 10**11\\n        \\n        while lo + 1 < hi:\\n            mid = (lo + hi) // 2\\n            if self.possible(mid,  divisor1, divisor2, uniqueCnt1, uniqueCnt2):  hi = mid                                    \\n            else: lo = mid                \\n        return hi\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def possible(self, candidate,  d1, d2, cnt1, cnt2):\\n        cant_do_both = candidate // lcm(d1, d2)\\n        cant_do_first = candidate // d1\\n        cant_do_second = candidate // d2\\n\\n        can_do_both = candidate - (cant_do_first + cant_do_second - cant_do_both)\\n\\n        cnt1 = max(0, cnt1 - (cant_do_second - cant_do_both))\\n        cnt2 = max(0, cnt2 - (cant_do_first - cant_do_both))\\n\\n        return can_do_both >= cnt1 + cnt2\\n\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        lo, hi = 0, 10**11\\n        \\n        while lo + 1 < hi:\\n            mid = (lo + hi) // 2\\n            if self.possible(mid,  divisor1, divisor2, uniqueCnt1, uniqueCnt2):  hi = mid                                    \\n            else: lo = mid                \\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953675,
                "title": "python3-kind-of-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAhh...never thought about binary search, just try greedy and keep bumping on test cases...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCore idea is to determine which element \"must place in specific array\", and the others can just place anywhere.\\nkeep tracking the remaining empty spaces, and the rest is math...the constraints did not allow any brute force mechanism...\\n\\n# Complexity\\n- Time complexity: ?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n      total = uniqueCnt1 + uniqueCnt2\\n      if divisor1 == divisor2:\\n        cnt = total\\n        p, q = divmod(cnt, divisor1 - 1)\\n        largest = divisor1 * p\\n        if q == 0:\\n          return largest - 1\\n        else:\\n          return largest + q\\n      \\n      # divisor1 and divisor2 are different\\n      lcm = math.lcm(divisor1, divisor2)\\n      # calculate how many covers need to do in one lcm\\n      cover1 = lcm // divisor2 - 1\\n      cover2 = lcm // divisor1 - 1\\n      one_lcm_valid = lcm - cover1 - cover2 - 1\\n      used1, used2, others = 0, 0, 0\\n      cur = 0\\n      all_covered_lcm_times = math.inf\\n      if cover1 != 0:\\n        all_covered_lcm_times = min(all_covered_lcm_times, uniqueCnt1 // cover1)\\n      if cover2 != 0:\\n        all_covered_lcm_times = min(all_covered_lcm_times, uniqueCnt2 // cover2)\\n      p, q = divmod(total, lcm - 1)\\n      all_covered_lcm_times = min(all_covered_lcm_times, p)\\n      cur = all_covered_lcm_times * lcm\\n      total -= all_covered_lcm_times * (lcm - 1)\\n      uniqueCnt1 -= all_covered_lcm_times * cover1\\n      uniqueCnt2 -= all_covered_lcm_times * cover2\\n      # print(cur, total, uniqueCnt1, uniqueCnt2)\\n      delta1, delta2 = 0, 0\\n      min_div = min(divisor1, divisor2)\\n      while total > min_div and uniqueCnt1 > 0 and uniqueCnt2 > 0:\\n        cur += min_div\\n        total -= min_div\\n        delta1 += min_div\\n        if delta1 >= divisor2:\\n          delta1 -= divisor2\\n          uniqueCnt1 -= 1\\n        delta2 += min_div\\n        if delta2 >= divisor1:\\n          delta2 -= divisor1\\n          uniqueCnt2 -= 1\\n      # print(cur, total, uniqueCnt1, uniqueCnt2)\\n      if uniqueCnt1 > 0 and uniqueCnt2 > 0:\\n        return cur + total\\n      if uniqueCnt1 == 0:\\n        cur -= delta1\\n        total += delta1\\n      else:\\n        cur -= delta2\\n        total += delta2\\n      # one container is used up, go to next \\n      if uniqueCnt1 == 0:\\n        p, q = divmod(total, divisor2 - 1)\\n        cur += p * divisor2\\n        if q == 0:\\n          return cur - 1\\n        return cur + q\\n      else:\\n        p, q = divmod(total, divisor1 - 1)\\n        cur += p * divisor1\\n        if q == 0:\\n          return cur - 1\\n        return cur + q\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n      total = uniqueCnt1 + uniqueCnt2\\n      if divisor1 == divisor2:\\n        cnt = total\\n        p, q = divmod(cnt, divisor1 - 1)\\n        largest = divisor1 * p\\n        if q == 0:\\n          return largest - 1\\n        else:\\n          return largest + q\\n      \\n      # divisor1 and divisor2 are different\\n      lcm = math.lcm(divisor1, divisor2)\\n      # calculate how many covers need to do in one lcm\\n      cover1 = lcm // divisor2 - 1\\n      cover2 = lcm // divisor1 - 1\\n      one_lcm_valid = lcm - cover1 - cover2 - 1\\n      used1, used2, others = 0, 0, 0\\n      cur = 0\\n      all_covered_lcm_times = math.inf\\n      if cover1 != 0:\\n        all_covered_lcm_times = min(all_covered_lcm_times, uniqueCnt1 // cover1)\\n      if cover2 != 0:\\n        all_covered_lcm_times = min(all_covered_lcm_times, uniqueCnt2 // cover2)\\n      p, q = divmod(total, lcm - 1)\\n      all_covered_lcm_times = min(all_covered_lcm_times, p)\\n      cur = all_covered_lcm_times * lcm\\n      total -= all_covered_lcm_times * (lcm - 1)\\n      uniqueCnt1 -= all_covered_lcm_times * cover1\\n      uniqueCnt2 -= all_covered_lcm_times * cover2\\n      # print(cur, total, uniqueCnt1, uniqueCnt2)\\n      delta1, delta2 = 0, 0\\n      min_div = min(divisor1, divisor2)\\n      while total > min_div and uniqueCnt1 > 0 and uniqueCnt2 > 0:\\n        cur += min_div\\n        total -= min_div\\n        delta1 += min_div\\n        if delta1 >= divisor2:\\n          delta1 -= divisor2\\n          uniqueCnt1 -= 1\\n        delta2 += min_div\\n        if delta2 >= divisor1:\\n          delta2 -= divisor1\\n          uniqueCnt2 -= 1\\n      # print(cur, total, uniqueCnt1, uniqueCnt2)\\n      if uniqueCnt1 > 0 and uniqueCnt2 > 0:\\n        return cur + total\\n      if uniqueCnt1 == 0:\\n        cur -= delta1\\n        total += delta1\\n      else:\\n        cur -= delta2\\n        total += delta2\\n      # one container is used up, go to next \\n      if uniqueCnt1 == 0:\\n        p, q = divmod(total, divisor2 - 1)\\n        cur += p * divisor2\\n        if q == 0:\\n          return cur - 1\\n        return cur + q\\n      else:\\n        p, q = divmod(total, divisor1 - 1)\\n        cur += p * divisor1\\n        if q == 0:\\n          return cur - 1\\n        return cur + q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953631,
                "title": "c-binary-search-approach-easy-to-understand",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int uc1, int uc2) {\\n        \\n        ll s = 1, e = INT_MAX;\\n        ll LCM = (1LL * d1 * d2) / (__gcd(d1, d2));\\n        \\n        while(s < e)\\n        {\\n            // total number of elements (1 to x)\\n            ll x = (s+e)/2;\\n            \\n            // elements divisible by both d1 and d2\\n            ll a = x / LCM;\\n            \\n            /* elements divisible by only d1 i.e.\\n            \\n               (elements divisible by d1) - (elements divisible by both d1 and d2) */\\n            ll b = x / d1 - a;\\n            \\n            /* elements divisible by only d2 i.e.\\n            \\n               (elements divisible by d2) - (elements divisible by both d1 and d2)*/\\n            ll c = x / d2 - a;\\n            \\n            /* elements not divisible by d1 and d2 i.e.\\n            \\n               (total number of elements) - \\n               (elements divisible by both d1 and d2) - \\n               (elements divisible by only d1) - \\n               (elements divisible by only d2)\\n             */\\n            ll d = x - a - b - c;\\n            \\n            // if elements divisible by d2 is less than unique count of arr 1, then we need to take elements from d.\\n            if(c < uc1)\\n                d -= (uc1 - c);\\n            \\n            // if elements divisible by d1 is less than unique count of arr 2, then we need to take elements from d.\\n            if(b < uc2)\\n                d -= (uc2 - b);\\n            \\n            // if d has more elements left, then it is a possible answer lets go tot the left side.\\n            if(d >= 0)\\n                e = x;\\n            else // lets go to right side.\\n                s = x+1;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int uc1, int uc2) {\\n        \\n        ll s = 1, e = INT_MAX;\\n        ll LCM = (1LL * d1 * d2) / (__gcd(d1, d2));\\n        \\n        while(s < e)\\n        {\\n            // total number of elements (1 to x)\\n            ll x = (s+e)/2;\\n            \\n            // elements divisible by both d1 and d2\\n            ll a = x / LCM;\\n            \\n            /* elements divisible by only d1 i.e.\\n            \\n               (elements divisible by d1) - (elements divisible by both d1 and d2) */\\n            ll b = x / d1 - a;\\n            \\n            /* elements divisible by only d2 i.e.\\n            \\n               (elements divisible by d2) - (elements divisible by both d1 and d2)*/\\n            ll c = x / d2 - a;\\n            \\n            /* elements not divisible by d1 and d2 i.e.\\n            \\n               (total number of elements) - \\n               (elements divisible by both d1 and d2) - \\n               (elements divisible by only d1) - \\n               (elements divisible by only d2)\\n             */\\n            ll d = x - a - b - c;\\n            \\n            // if elements divisible by d2 is less than unique count of arr 1, then we need to take elements from d.\\n            if(c < uc1)\\n                d -= (uc1 - c);\\n            \\n            // if elements divisible by d1 is less than unique count of arr 2, then we need to take elements from d.\\n            if(b < uc2)\\n                d -= (uc2 - b);\\n            \\n            // if d has more elements left, then it is a possible answer lets go tot the left side.\\n            if(d >= 0)\\n                e = x;\\n            else // lets go to right side.\\n                s = x+1;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953470,
                "title": "binary-search-easy-approch",
                "content": "# Intuition\\nfind the no of element which will not divide by particular element\\nlike I have 8 element and I want to chech How many are divisible by 3\\nso\\n8/3 = 2  element are 3 ,6\\nTwo element are divisible by 3\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing binary seach to find the minimum possible element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long g=__gcd(d1,d2);\\n        long long l=((long long)d1*(long long)d2)/g;\\n        long long left=1,right=1e15,ans=1e5;\\n        while(left<=right)\\n        {\\n           long long mid=(left+(right-left)/2);\\n           if(d1==d2)\\n           {\\n              long long cnt=mid-(mid/d1);\\n              if(cnt>=cnt1+cnt2)\\n              {\\n                  ans=mid;\\n                  right=mid-1;\\n              }\\n              else\\n              {\\n                  left=mid+1;\\n              }\\n           }\\n           else\\n           {\\n               long long common=mid/l;\\n               long long c1=mid/d1-common , c2=mid/d2-common;\\n               long long z1=cnt1,z2=cnt2;\\n               long long avail=(mid-c1-c2-common);\\n               z1-=min(z1,c2);\\n               z2-=min(z2,c1);\\n               if(z1+z2<=avail)\\n               {\\n                   ans=mid;\\n                   right=mid-1;\\n               }\\n               else\\n               {\\n                   left=mid+1;\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long g=__gcd(d1,d2);\\n        long long l=((long long)d1*(long long)d2)/g;\\n        long long left=1,right=1e15,ans=1e5;\\n        while(left<=right)\\n        {\\n           long long mid=(left+(right-left)/2);\\n           if(d1==d2)\\n           {\\n              long long cnt=mid-(mid/d1);\\n              if(cnt>=cnt1+cnt2)\\n              {\\n                  ans=mid;\\n                  right=mid-1;\\n              }\\n              else\\n              {\\n                  left=mid+1;\\n              }\\n           }\\n           else\\n           {\\n               long long common=mid/l;\\n               long long c1=mid/d1-common , c2=mid/d2-common;\\n               long long z1=cnt1,z2=cnt2;\\n               long long avail=(mid-c1-c2-common);\\n               z1-=min(z1,c2);\\n               z2-=min(z2,c1);\\n               if(z1+z2<=avail)\\n               {\\n                   ans=mid;\\n                   right=mid-1;\\n               }\\n               else\\n               {\\n                   left=mid+1;\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953469,
                "title": "binary-search-easy-approch",
                "content": "# Intuition\\nfind the no of element which will not divide by particular element\\nlike I have 8 element and I want to chech How many are divisible by 3\\nso\\n8/3 = 2  element are 3 ,6\\nTwo element are divisible by 3\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing binary seach to find the minimum possible element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long g=__gcd(d1,d2);\\n        long long l=((long long)d1*(long long)d2)/g;\\n        long long left=1,right=1e15,ans=1e5;\\n        while(left<=right)\\n        {\\n           long long mid=(left+(right-left)/2);\\n           if(d1==d2)\\n           {\\n              long long cnt=mid-(mid/d1);\\n              if(cnt>=cnt1+cnt2)\\n              {\\n                  ans=mid;\\n                  right=mid-1;\\n              }\\n              else\\n              {\\n                  left=mid+1;\\n              }\\n           }\\n           else\\n           {\\n               long long common=mid/l;\\n               long long c1=mid/d1-common , c2=mid/d2-common;\\n               long long z1=cnt1,z2=cnt2;\\n               long long avail=(mid-c1-c2-common);\\n               z1-=min(z1,c2);\\n               z2-=min(z2,c1);\\n               if(z1+z2<=avail)\\n               {\\n                   ans=mid;\\n                   right=mid-1;\\n               }\\n               else\\n               {\\n                   left=mid+1;\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        long long g=__gcd(d1,d2);\\n        long long l=((long long)d1*(long long)d2)/g;\\n        long long left=1,right=1e15,ans=1e5;\\n        while(left<=right)\\n        {\\n           long long mid=(left+(right-left)/2);\\n           if(d1==d2)\\n           {\\n              long long cnt=mid-(mid/d1);\\n              if(cnt>=cnt1+cnt2)\\n              {\\n                  ans=mid;\\n                  right=mid-1;\\n              }\\n              else\\n              {\\n                  left=mid+1;\\n              }\\n           }\\n           else\\n           {\\n               long long common=mid/l;\\n               long long c1=mid/d1-common , c2=mid/d2-common;\\n               long long z1=cnt1,z2=cnt2;\\n               long long avail=(mid-c1-c2-common);\\n               z1-=min(z1,c2);\\n               z2-=min(z2,c1);\\n               if(z1+z2<=avail)\\n               {\\n                   ans=mid;\\n                   right=mid-1;\\n               }\\n               else\\n               {\\n                   left=mid+1;\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953199,
                "title": "c-binary-search-time-log-int-max-space-o-1",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\n    bool pos(int val,int d1,int d2,int cnt1,int cnt2)\\n    {\\n        int x=val/d1;\\n        int y=val/d2;\\n        long long int lcm=(1ll*d1*d2)/(__gcd(1ll*d1,1ll*d2));\\n       // cout<<lcm<<endl;\\n        int commondiv=val/lcm;\\n        y-=commondiv;\\n        x-=commondiv;\\n        val-=commondiv;\\n        int ford1=y;\\n        int ford2=x;\\n        int rem=val-x-y;\\n        ford1=max(0,cnt1-ford1);\\n        ford2=max(0,cnt2-ford2);\\n       // cout<<rem<<\" \"<<ford1<<\" \"<<ford2<<endl;\\n        if(rem>=ford1+ford2)\\n            return true;\\n        return false;\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int l=1,r=INT_MAX;\\n        int ans=INT_MAX;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            // cout<<divisor1<<\" dfsdfd \"<<divisor2<<\" \"<<mid<<endl;\\n            if(pos(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n            {\\n               \\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    bool pos(int val,int d1,int d2,int cnt1,int cnt2)\\n    {\\n        int x=val/d1;\\n        int y=val/d2;\\n        long long int lcm=(1ll*d1*d2)/(__gcd(1ll*d1,1ll*d2));\\n       // cout<<lcm<<endl;\\n        int commondiv=val/lcm;\\n        y-=commondiv;\\n        x-=commondiv;\\n        val-=commondiv;\\n        int ford1=y;\\n        int ford2=x;\\n        int rem=val-x-y;\\n        ford1=max(0,cnt1-ford1);\\n        ford2=max(0,cnt2-ford2);\\n       // cout<<rem<<\" \"<<ford1<<\" \"<<ford2<<endl;\\n        if(rem>=ford1+ford2)\\n            return true;\\n        return false;\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int l=1,r=INT_MAX;\\n        int ans=INT_MAX;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            // cout<<divisor1<<\" dfsdfd \"<<divisor2<<\" \"<<mid<<endl;\\n            if(pos(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n            {\\n               \\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2953077,
                "title": "binary-search-venn-theory",
                "content": "```\\nclass Solution {\\nlong long int lcmm(long long int a,long long int b){\\n    return (a*b)/__gcd(a,b);\\n}\\npublic:\\n    int ans(int d1,int d2,int u1,int u2,long long int mid){\\n        long long int A = mid/d1; //divisible by A\\n        long long int B = mid/d2; //divisible by B\\n        long long int A_ = mid-A; //not divisible by A\\n        long long int B_ = mid-B; //not divisible by B\\n        long long int AIB = mid/(long long int)lcmm(d1,d2); //divisible by both A and B\\n        long long int AuB = A+B-AIB; // divisible by either A and B or both; \\n        long long int req = mid-AuB; // divisible by neither A nor B;\\n        long long int req1 = ((A_-req)>=u1)?(0):(u1-(A_-req)); //req still to get from common portion from req;\\n        long long int req2 = ((B_- req)>=u2)?(0):(u2-(B_-req)); //req still to get from common portion from req;\\n        // cout<<A_<<\" \"<<B_<<\" \"<<u1;\\n        return (req1+req2)<=req; //returning true if we got the both of the requirement gets fullfill\\n    }\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n\\t//doing simple binary search on anwers\\n        long long int low = 0;\\n        long long int high = 1e12;\\n        long long int sol = u1+u2;\\n        // cout<<ans(d1,d2,u1,u2,13);\\n        while(low<=high){\\n            long long int mid = (low+high)/2;\\n            if(ans(d1,d2,u1,u2,mid)){\\n                sol = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nlong long int lcmm(long long int a,long long int b){\\n    return (a*b)/__gcd(a,b);\\n}\\npublic:\\n    int ans(int d1,int d2,int u1,int u2,long long int mid){\\n        long long int A = mid/d1; //divisible by A\\n        long long int B = mid/d2; //divisible by B\\n        long long int A_ = mid-A; //not divisible by A\\n        long long int B_ = mid-B; //not divisible by B\\n        long long int AIB = mid/(long long int)lcmm(d1,d2); //divisible by both A and B\\n        long long int AuB = A+B-AIB; // divisible by either A and B or both; \\n        long long int req = mid-AuB; // divisible by neither A nor B;\\n        long long int req1 = ((A_-req)>=u1)?(0):(u1-(A_-req)); //req still to get from common portion from req;\\n        long long int req2 = ((B_- req)>=u2)?(0):(u2-(B_-req)); //req still to get from common portion from req;\\n        // cout<<A_<<\" \"<<B_<<\" \"<<u1;\\n        return (req1+req2)<=req; //returning true if we got the both of the requirement gets fullfill\\n    }\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n\\t//doing simple binary search on anwers\\n        long long int low = 0;\\n        long long int high = 1e12;\\n        long long int sol = u1+u2;\\n        // cout<<ans(d1,d2,u1,u2,13);\\n        while(low<=high){\\n            long long int mid = (low+high)/2;\\n            if(ans(d1,d2,u1,u2,mid)){\\n                sol = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2952428,
                "title": "swift-solution-binary-search-approach",
                "content": "# Approach\\n1. Calculate the least common multiple of the two denominators.\\n2. Use binary search to find the smallest possible number of people in the set.\\n3. If the number of people is less than the number of people in the union of the two sets, then the answer is the midpoint of the range we\\'re searching.\\n4. Otherwise, we know that the answer is between the midpoint and the upper bound of the range we\\'re searching.\\n5. Repeat until the range of numbers we\\'re searching is only one number long.\\n6. Return the number we found.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private func gcd(_ a: Int, _ b: Int) -> Int {\\n        return b == 0 ? a : gcd(b, a % b)\\n    }\\n\\n    func minimizeSet(_ d1: Int, _ d2: Int, _ u1: Int, _ u2: Int) -> Int {\\n        var lo = 1, hi = Int(10e10)\\n        var ans = hi\\n        let lcm = (d1 * d2) / gcd(d1, d2)\\n\\n        while lo <= hi {\\n            let mid = lo + (hi - lo) / 2\\n            let x = mid - mid / d1\\n            let y = mid - mid / d2\\n            let z = mid - mid / lcm\\n\\n            if x < u1 || y < u2 || z < u1 + u2 {\\n                lo = mid + 1\\n            }\\n            else {\\n                ans = min(ans, mid)\\n                hi = mid - 1\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    private func gcd(_ a: Int, _ b: Int) -> Int {\\n        return b == 0 ? a : gcd(b, a % b)\\n    }\\n\\n    func minimizeSet(_ d1: Int, _ d2: Int, _ u1: Int, _ u2: Int) -> Int {\\n        var lo = 1, hi = Int(10e10)\\n        var ans = hi\\n        let lcm = (d1 * d2) / gcd(d1, d2)\\n\\n        while lo <= hi {\\n            let mid = lo + (hi - lo) / 2\\n            let x = mid - mid / d1\\n            let y = mid - mid / d2\\n            let z = mid - mid / lcm\\n\\n            if x < u1 || y < u2 || z < u1 + u2 {\\n                lo = mid + 1\\n            }\\n            else {\\n                ans = min(ans, mid)\\n                hi = mid - 1\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951459,
                "title": "binary-search-based-solution-uses-lcm",
                "content": "# Intuition\\nAt first, the thought that comes to mind is to go brute force and check for each number if it can be used by div1 or div2. But it\\'s not the most time efficient solution keeping the parameters in mind. \\nI thought of counting the factors mathematically first as well, but then there would be a lot of conditions that are coming here into play. For example: we can reuse some multiple of div1 for div2, if div2 doesn\\'t divide it and so on. Still thinking of a pure mathematical solution. Will update here when I code it out.\\n\\n# Approach\\nThe idea is to choose an integer (k) as the upper limit i.e the maximum integer in the set that contains numbers from 1 to k. We only choose all the applicable non-multiples for div1 and div2 from this set. If we are able to get (uniqueCnt1 + uniqueCnt2) non-multiples from this set, we can try decreasing this upper limit and check if we are still able to get the total non-multiples. Else, we need to increase the upper limit (more non-multiples are needed). For this we use binary search on answer technique. \\n\\nFor checking if can pick non-multiples for div1 and div2 from this set, we do some maths. Find the multiples of both div1 and div2 individually and also multiples of their lcm (as they might have a common factor). With these we have the following options:\\n    1. We have 1 to limit numbers available.\\n    2. We absolutely cannot use the multiples of their lcm as they can be divided by div1 and div2 both.\\n    3. We can reuse the some multiples of div1 in div2, if div2 doesn\\'t divide them and hence, we don\\'t need to throw them away. Same for multiples of div2.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canUseElementsUnderLimit(int &limit,int &div1, int &div2, int &uniqueCnt1, int &uniqueCnt2)\\n    {\\n        //check all factors of div1 and div2 separately that are the range 1 to limit \\n        int totalAvailableIntegers = limit; \\n        int multiples1 = limit/div1;\\n        int multiples2 = limit/div2;\\n        int commonMultiples = 0;\\n\\n        if(lcm((long)div1,(long)div2)<=INT_MAX) commonMultiples = limit/lcm(div1,div2);\\n\\n        //common factors won\\'t be available to be used from the pool of all non-factors,as well as individual factors\\n        totalAvailableIntegers -= commonMultiples;\\n        multiples1 -= commonMultiples;\\n        multiples2 -= commonMultiples;\\n\\n        //If div1 has a multiple that is not a multiple of div2, then that number can be used by div2 first\\n        //We should use these numbers before other available numbers \\n        int totalNeeded1 = uniqueCnt1-multiples2 <0 ? 0 : uniqueCnt1-multiples2;\\n        int totalNeeded2 = uniqueCnt2-multiples1 <0 ? 0 : uniqueCnt2-multiples1;\\n\\n        totalAvailableIntegers -= multiples1;\\n        totalAvailableIntegers -= multiples2;\\n\\n        return (totalNeeded1+totalNeeded2)<=totalAvailableIntegers;\\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\n        int minPossibleInteger = 1;\\n        int maxPossibleInteger = INT_MAX;\\n        int minInteger = INT_MAX;\\n\\n        while(minPossibleInteger<=maxPossibleInteger)\\n        {\\n            int currMaximumInteger = minPossibleInteger + (maxPossibleInteger-minPossibleInteger)/2;\\n\\n            if(canUseElementsUnderLimit(currMaximumInteger,divisor1, divisor2, uniqueCnt1, uniqueCnt2))\\n            {\\n                minInteger = currMaximumInteger;\\n                maxPossibleInteger = currMaximumInteger-1;\\n            }else{\\n                minPossibleInteger = currMaximumInteger+1;\\n            }\\n        }\\n\\n        return minInteger;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canUseElementsUnderLimit(int &limit,int &div1, int &div2, int &uniqueCnt1, int &uniqueCnt2)\\n    {\\n        //check all factors of div1 and div2 separately that are the range 1 to limit \\n        int totalAvailableIntegers = limit; \\n        int multiples1 = limit/div1;\\n        int multiples2 = limit/div2;\\n        int commonMultiples = 0;\\n\\n        if(lcm((long)div1,(long)div2)<=INT_MAX) commonMultiples = limit/lcm(div1,div2);\\n\\n        //common factors won\\'t be available to be used from the pool of all non-factors,as well as individual factors\\n        totalAvailableIntegers -= commonMultiples;\\n        multiples1 -= commonMultiples;\\n        multiples2 -= commonMultiples;\\n\\n        //If div1 has a multiple that is not a multiple of div2, then that number can be used by div2 first\\n        //We should use these numbers before other available numbers \\n        int totalNeeded1 = uniqueCnt1-multiples2 <0 ? 0 : uniqueCnt1-multiples2;\\n        int totalNeeded2 = uniqueCnt2-multiples1 <0 ? 0 : uniqueCnt2-multiples1;\\n\\n        totalAvailableIntegers -= multiples1;\\n        totalAvailableIntegers -= multiples2;\\n\\n        return (totalNeeded1+totalNeeded2)<=totalAvailableIntegers;\\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\n        int minPossibleInteger = 1;\\n        int maxPossibleInteger = INT_MAX;\\n        int minInteger = INT_MAX;\\n\\n        while(minPossibleInteger<=maxPossibleInteger)\\n        {\\n            int currMaximumInteger = minPossibleInteger + (maxPossibleInteger-minPossibleInteger)/2;\\n\\n            if(canUseElementsUnderLimit(currMaximumInteger,divisor1, divisor2, uniqueCnt1, uniqueCnt2))\\n            {\\n                minInteger = currMaximumInteger;\\n                maxPossibleInteger = currMaximumInteger-1;\\n            }else{\\n                minPossibleInteger = currMaximumInteger+1;\\n            }\\n        }\\n\\n        return minInteger;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950768,
                "title": "python3-simple-binary-search-solution",
                "content": "# Intuition\\nSeeing size 10**9 simply means the solution should have runtime of O(logN)\\n\\n# Approach\\nUse binary search to find the minimal upper bound that satisfied the constraints\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n\\n        start, end = uniqueCnt1 + uniqueCnt2, (uniqueCnt1 + uniqueCnt2)*2\\n\\n        def gcd(x, y):\\n            x, y = max(x,y), min(x, y)\\n            while y:\\n                x, y = y, x % y\\n            return x\\n            \\n        while start < end:\\n            \\n            middle = (start + end) // 2\\n\\n            #these are the numbers that have no chance of being in arr1 and arr2, basicly middle // (lcm(divisor1, divisor2))\\n            no_chance = middle // ((divisor1 * divisor2) //gcd(divisor1, divisor2))\\n\\n            remain1 = middle - middle // divisor1\\n\\n            remain2 = middle - middle // divisor2\\n\\n            #make sure all arrays have enough numbers\\n            if (remain1 >= uniqueCnt1 and middle - no_chance - uniqueCnt1 >= uniqueCnt2) and (remain2 >= uniqueCnt2 and middle - no_chance - uniqueCnt2 >= uniqueCnt1) :\\n                end = middle\\n            else:\\n                start = middle + 1\\n\\n        return start\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n\\n        start, end = uniqueCnt1 + uniqueCnt2, (uniqueCnt1 + uniqueCnt2)*2\\n\\n        def gcd(x, y):\\n            x, y = max(x,y), min(x, y)\\n            while y:\\n                x, y = y, x % y\\n            return x\\n            \\n        while start < end:\\n            \\n            middle = (start + end) // 2\\n\\n            #these are the numbers that have no chance of being in arr1 and arr2, basicly middle // (lcm(divisor1, divisor2))\\n            no_chance = middle // ((divisor1 * divisor2) //gcd(divisor1, divisor2))\\n\\n            remain1 = middle - middle // divisor1\\n\\n            remain2 = middle - middle // divisor2\\n\\n            #make sure all arrays have enough numbers\\n            if (remain1 >= uniqueCnt1 and middle - no_chance - uniqueCnt1 >= uniqueCnt2) and (remain2 >= uniqueCnt2 and middle - no_chance - uniqueCnt2 >= uniqueCnt1) :\\n                end = middle\\n            else:\\n                start = middle + 1\\n\\n        return start\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950745,
                "title": "fully-commented-with-intution-tc-sc",
                "content": "# Intuition\\n    A1: Linear Search [won`t work]\\n    eg: Consider d1:12 , d2:3, u1:2 , u2: 10\\n    ->Filling Elements as Per Condition\\n    My O/P: a1: [1,3]\\n            a2: [2,4,5,7,8,10,11,13,14,16]\\n            ans:16\\n    Exp O/P: a1:[3,6]Bi\\n                a2:[1,2,4,5,7,8,10,11,13,14]\\n                ans:14\\n\\n---\\n\\n\\n    A2: Binary Search\\n    lets assume we know ans = 14\\n    a1(from [1,14] who can only be part of a1) => [3,6,9]\\n    a2(from [1,14] who can only be part of a2) => []\\n    a1Ia2(from [1,14] who can be part of a1 as well as a2) => [1,2,4,5,7,8,10,11,13,14]\\n\\n    Now, since we want only 2 elements in a1 ,=> a1:[3,6]\\n    Put elemets from a1Ia2 to a2 , => a2:[1,2,4,5,7,8,10,11,13,14]\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ , n = 2*(uniqueCount1 + uniqueCount2) \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    bool isPossible(ll x ,ll divisor1, ll divisor2, ll uniqueCnt1, ll uniqueCnt2) {\\n        //Denoting elements from  [1,x]\\n\\n        //Divisible by d1\\n        ll d1 = x/divisor1; \\n    \\n        //Divisible by d2\\n        ll d2 = x/divisor2; \\n\\n        //Divisible by Both d1 and d2\\n        ll d1Id2 = x/lcm(divisor1,divisor2);\\n\\n        //Union of divsible by d1 and divisible by d2\\n        ll d1Ud2 = d1 + d2 - d1Id2;\\n\\n        //NOT Divisible by d1 excluding Outer of Union  [can ONLY ba part of a1]\\n        ll _d1 = d1Ud2 - d1;\\n\\n        //NOT Divisible by d2 excluding Outer of Union [can ONLY ba part of a2]\\n        ll _d2 = d1Ud2 - d2;\\n\\n        // [can be a part of a1 as well as a2]\\n        ll outerU = x - d1Ud2; \\n        \\n        //How many more I need from OuterU\\n        ll needMore_d1 = _d1 >= uniqueCnt1 ? 0 : uniqueCnt1 - _d1;\\n        ll needMore_d2 = _d2 >= uniqueCnt2 ? 0 : uniqueCnt2 - _d2;\\n\\n        if(needMore_d1 + needMore_d2 <= outerU){\\n            //Have more or equal elements in OuterU to compensate \\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n        \\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n       ll low = 1,high = 2*(uniqueCnt1+uniqueCnt2); //if u1=2 , u2=7 then wilgo till 2*(2+7) = 18\\n \\n       while(low < high){\\n           ll mid = (low + high)/2;\\n           if(isPossible(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2)){\\n               //got my one possible Ans, now try to get less than this so go left\\n               high = mid;\\n           }\\n           else{\\n               //not possible at this mid , so try to get more elements my going Right\\n               low = mid+1;\\n\\n           }\\n       }\\n       return low;\\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    bool isPossible(ll x ,ll divisor1, ll divisor2, ll uniqueCnt1, ll uniqueCnt2) {\\n        //Denoting elements from  [1,x]\\n\\n        //Divisible by d1\\n        ll d1 = x/divisor1; \\n    \\n        //Divisible by d2\\n        ll d2 = x/divisor2; \\n\\n        //Divisible by Both d1 and d2\\n        ll d1Id2 = x/lcm(divisor1,divisor2);\\n\\n        //Union of divsible by d1 and divisible by d2\\n        ll d1Ud2 = d1 + d2 - d1Id2;\\n\\n        //NOT Divisible by d1 excluding Outer of Union  [can ONLY ba part of a1]\\n        ll _d1 = d1Ud2 - d1;\\n\\n        //NOT Divisible by d2 excluding Outer of Union [can ONLY ba part of a2]\\n        ll _d2 = d1Ud2 - d2;\\n\\n        // [can be a part of a1 as well as a2]\\n        ll outerU = x - d1Ud2; \\n        \\n        //How many more I need from OuterU\\n        ll needMore_d1 = _d1 >= uniqueCnt1 ? 0 : uniqueCnt1 - _d1;\\n        ll needMore_d2 = _d2 >= uniqueCnt2 ? 0 : uniqueCnt2 - _d2;\\n\\n        if(needMore_d1 + needMore_d2 <= outerU){\\n            //Have more or equal elements in OuterU to compensate \\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n        \\n    }\\n\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n       ll low = 1,high = 2*(uniqueCnt1+uniqueCnt2); //if u1=2 , u2=7 then wilgo till 2*(2+7) = 18\\n \\n       while(low < high){\\n           ll mid = (low + high)/2;\\n           if(isPossible(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2)){\\n               //got my one possible Ans, now try to get less than this so go left\\n               high = mid;\\n           }\\n           else{\\n               //not possible at this mid , so try to get more elements my going Right\\n               low = mid+1;\\n\\n           }\\n       }\\n       return low;\\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949401,
                "title": "binary-search-explained-solution",
                "content": "# Intuition\\n<!-- binary search with number theory -->\\n\\n# Approach\\n<!-- approach in comments -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(log(1e12)) nearly 40 iterations-->\\n\\n- Space complexity:\\n<!-- O(1) -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,int& div1,int& div2,int cnt1,int cnt2){\\n        int comm=0,first=0,second=0;\\n        //find numbers divisible by both div1 and div2 from 1-mid\\n        first=mid/div1;\\n        second=mid/div2;\\n        //to find numbers divisible by both div1 and div2 from 1-mid\\n        int gcd=__gcd(div1,div2);\\n        long long int lcm=((long long)div1*div2)/gcd;\\n        int common_multiples=mid/lcm;\\n        comm=(max(first,second)-common_multiples);\\n        //find numbers not divisible by div1 and div2\\n        first=mid-first;\\n        second=mid-second;\\n        //numbers which are not divisible by both div1 and div2\\n        comm=max(first,second)-comm;\\n        //eliminating comm from both the numbers\\n        first-=comm;\\n        second-=comm;\\n        //see how many can div1 and div2 satisfy without involving common\\n        cnt1=max(cnt1-first,0);\\n        cnt2=max(cnt2-second,0);\\n        //see if rest can be satisfied with common numbers between them\\n        if(cnt1+cnt2 <= comm)\\n            return true;\\n        return false;\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long int start=1,end=1e12,ans;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(check(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2)){\\n                ans=mid;\\n                end=mid-1;\\n            }else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,int& div1,int& div2,int cnt1,int cnt2){\\n        int comm=0,first=0,second=0;\\n        //find numbers divisible by both div1 and div2 from 1-mid\\n        first=mid/div1;\\n        second=mid/div2;\\n        //to find numbers divisible by both div1 and div2 from 1-mid\\n        int gcd=__gcd(div1,div2);\\n        long long int lcm=((long long)div1*div2)/gcd;\\n        int common_multiples=mid/lcm;\\n        comm=(max(first,second)-common_multiples);\\n        //find numbers not divisible by div1 and div2\\n        first=mid-first;\\n        second=mid-second;\\n        //numbers which are not divisible by both div1 and div2\\n        comm=max(first,second)-comm;\\n        //eliminating comm from both the numbers\\n        first-=comm;\\n        second-=comm;\\n        //see how many can div1 and div2 satisfy without involving common\\n        cnt1=max(cnt1-first,0);\\n        cnt2=max(cnt2-second,0);\\n        //see if rest can be satisfied with common numbers between them\\n        if(cnt1+cnt2 <= comm)\\n            return true;\\n        return false;\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long int start=1,end=1e12,ans;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(check(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2)){\\n                ans=mid;\\n                end=mid-1;\\n            }else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948684,
                "title": "lcm-and-math-only-rest-o-1-soln",
                "content": "# Intuition\\nIntuition is that lcm of d1,d2 and its multiple are truely the numbers that cannot appear in either of the list. Multiples of d1 can appear in 2nd and vice versa.\\n\\n# Approach\\nworst case is max of all the 3 different possibities. i.e max of lcm , div1 and div2 respectively\\n\\n\\'getlast\\' finds the last value skipping the divisor and its multiples for a given uniqCount!\\n\\nNow, finding lastvalue by skipping lcm and its multiple would have sufficed if only for the case where there is not enough unique cnt from d2 to fill the vacant slots left by d1 and vice versa. hence max of three diff. last values.\\n\\nGetting to above intuition was hard and have to see few exampes to get to this clarity! \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, d1,d2,uc1,uc2):\\n        def getlast(v,d):\\n            c, r = divmod(v, d-1)\\n            if r == 0: return c*d-1\\n            else: return c*d+r\\n        tot, lcm = uc1+uc2, math.lcm(d1,d2)\\n        lv = getlast(tot, lcm)\\n        val1 = getlast(uc2, d2)\\n        val2 = getlast(uc1, d1)\\n        return max(val1,val2,lv)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, d1,d2,uc1,uc2):\\n        def getlast(v,d):\\n            c, r = divmod(v, d-1)\\n            if r == 0: return c*d-1\\n            else: return c*d+r\\n        tot, lcm = uc1+uc2, math.lcm(d1,d2)\\n        lv = getlast(tot, lcm)\\n        val1 = getlast(uc2, d2)\\n        val2 = getlast(uc1, d1)\\n        return max(val1,val2,lv)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947696,
                "title": "binary-search-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using integer = long long;\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        const integer factor_lhs = divisor1, factor_rhs = divisor2;\\n        const integer factor_combined = factor_lhs * factor_rhs / std::gcd(factor_lhs, factor_rhs);\\n        const integer required_size_lhs = uniqueCnt1, required_size_rhs = uniqueCnt2;\\n        const integer total_size = required_size_lhs + required_size_rhs;\\n\\n        integer lower = 0, upper = 32 * total_size;\\n        while (lower < upper) {\\n            const integer target = lower + (upper - lower) / 2;\\n            const integer cnts_definite_lhs = \\n                std::min(required_size_lhs, (target / factor_rhs) - (target / factor_combined));\\n            const integer cnts_definite_rhs = \\n                std::min(required_size_rhs, (target / factor_lhs) - (target / factor_combined));\\n            const auto cnts_divisible_neither = \\n                target - (target / factor_lhs) - (target / factor_rhs) + (target / factor_combined);\\n            const auto cnts_required = \\n                total_size - cnts_definite_lhs - cnts_definite_rhs;\\n            const bool criteria = cnts_divisible_neither >= cnts_required;\\n            if (criteria) {\\n                upper = target;\\n            } else {\\n                lower = target + 1;\\n            }\\n        }\\n        return upper;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using integer = long long;\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        const integer factor_lhs = divisor1, factor_rhs = divisor2;\\n        const integer factor_combined = factor_lhs * factor_rhs / std::gcd(factor_lhs, factor_rhs);\\n        const integer required_size_lhs = uniqueCnt1, required_size_rhs = uniqueCnt2;\\n        const integer total_size = required_size_lhs + required_size_rhs;\\n\\n        integer lower = 0, upper = 32 * total_size;\\n        while (lower < upper) {\\n            const integer target = lower + (upper - lower) / 2;\\n            const integer cnts_definite_lhs = \\n                std::min(required_size_lhs, (target / factor_rhs) - (target / factor_combined));\\n            const integer cnts_definite_rhs = \\n                std::min(required_size_rhs, (target / factor_lhs) - (target / factor_combined));\\n            const auto cnts_divisible_neither = \\n                target - (target / factor_lhs) - (target / factor_rhs) + (target / factor_combined);\\n            const auto cnts_required = \\n                total_size - cnts_definite_lhs - cnts_definite_rhs;\\n            const bool criteria = cnts_divisible_neither >= cnts_required;\\n            if (criteria) {\\n                upper = target;\\n            } else {\\n                lower = target + 1;\\n            }\\n        }\\n        return upper;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947687,
                "title": "binary-search-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 <= uniqueCnt1 + uniqueCnt2 <= 10^9. So n is up to 10^9, which imply us need an O(logn) algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA binary search algotithm.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        def count(val, divisor):\\n            return val - val//divisor\\n        left = 1\\n        right = 10**10\\n        divisor3 = lcm(divisor1, divisor2)\\n        while left <= right:\\n            mid = (left+right)//2\\n            count1 = count(mid, divisor1)\\n            count2 = count(mid, divisor2)\\n            count12 = count(mid, divisor3)\\n            if count1 < uniqueCnt1 or count2 < uniqueCnt2 or (count12 < uniqueCnt1 + uniqueCnt2):\\n                left = mid + 1\\n            elif count1 >= uniqueCnt1 and count2 >= uniqueCnt2 and (count12 == uniqueCnt1 + uniqueCnt2):\\n                if mid % divisor3 == 0:\\n                    mid -= 1\\n                return mid\\n            else:\\n                right = mid - 1\\n        \\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        def count(val, divisor):\\n            return val - val//divisor\\n        left = 1\\n        right = 10**10\\n        divisor3 = lcm(divisor1, divisor2)\\n        while left <= right:\\n            mid = (left+right)//2\\n            count1 = count(mid, divisor1)\\n            count2 = count(mid, divisor2)\\n            count12 = count(mid, divisor3)\\n            if count1 < uniqueCnt1 or count2 < uniqueCnt2 or (count12 < uniqueCnt1 + uniqueCnt2):\\n                left = mid + 1\\n            elif count1 >= uniqueCnt1 and count2 >= uniqueCnt2 and (count12 == uniqueCnt1 + uniqueCnt2):\\n                if mid % divisor3 == 0:\\n                    mid -= 1\\n                return mid\\n            else:\\n                right = mid - 1\\n        \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947605,
                "title": "python-clean-binary-search",
                "content": "# Code\\n```\\nfrom math import gcd\\nclass Solution:\\n    def minimizeSet(self, a: int, b: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        lcm = a*b//gcd(a,b)\\n        def check(m):\\n            return m - m//a >= uniqueCnt1 and m - m//b >= uniqueCnt2 and m - m//lcm >= uniqueCnt1 + uniqueCnt2\\n        left, right = 1, 2*10**9\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def minimizeSet(self, a: int, b: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        lcm = a*b//gcd(a,b)\\n        def check(m):\\n            return m - m//a >= uniqueCnt1 and m - m//b >= uniqueCnt2 and m - m//lcm >= uniqueCnt1 + uniqueCnt2\\n        left, right = 1, 2*10**9\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947424,
                "title": "python-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):\\n        def dfs(num):\\n            a = num - num//math.lcm(divisor1,divisor2) >= uniqueCnt1 + uniqueCnt2\\n            b = num - num//divisor1 >= uniqueCnt1\\n            c = num - num//divisor2 >= uniqueCnt2\\n            return a and b and c\\n\\n        low, high = 1, 10**10\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n\\n            if dfs(mid): high = mid - 1\\n            else: low = mid + 1\\n\\n        return low\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):\\n        def dfs(num):\\n            a = num - num//math.lcm(divisor1,divisor2) >= uniqueCnt1 + uniqueCnt2\\n            b = num - num//divisor1 >= uniqueCnt1\\n            c = num - num//divisor2 >= uniqueCnt2\\n            return a and b and c\\n\\n        low, high = 1, 10**10\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n\\n            if dfs(mid): high = mid - 1\\n            else: low = mid + 1\\n\\n        return low\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947411,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n        lcm = math.lcm(divisor1, divisor2)\\n        def isok(num):\\n            div1 = num - num // divisor1 # (num // divisor) is elements that will be divisble by divisor1 in range 0 to num\\n            # num - matchingElems = number of elemts that will be missing in 0-num range\\n            \\n            if div1 < uniqueCnt1: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor1\\n                return False\\n            div2 = num - num // divisor2 \\n            if div2 < uniqueCnt2: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor2\\n                return False\\n            union = num - num // lcm\\n            #  num // lcm: none wowrks, num: total, union: total - none works\\n            if union < (uniqueCnt1 + uniqueCnt2):\\n                # Numbers from the range [1,L] that are multiples of both C1 and C2 (thus, multiples of lcm(D1,D2)) should be skipped, thus, increasing the candidate value by 1.\\n                return False\\n            return True\\n        \\n        l = 0\\n        r = 10**15\\n        while l < r:\\n            \\n            mid = (l+r)//2\\n            \\n            if isok(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n        lcm = math.lcm(divisor1, divisor2)\\n        def isok(num):\\n            div1 = num - num // divisor1 # (num // divisor) is elements that will be divisble by divisor1 in range 0 to num\\n            # num - matchingElems = number of elemts that will be missing in 0-num range\\n            \\n            if div1 < uniqueCnt1: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor1\\n                return False\\n            div2 = num - num // divisor2 \\n            if div2 < uniqueCnt2: \\n                # there isn\\'t enough number between 1 to num that are not divisible by divisor2\\n                return False\\n            union = num - num // lcm\\n            #  num // lcm: none wowrks, num: total, union: total - none works\\n            if union < (uniqueCnt1 + uniqueCnt2):\\n                # Numbers from the range [1,L] that are multiples of both C1 and C2 (thus, multiples of lcm(D1,D2)) should be skipped, thus, increasing the candidate value by 1.\\n                return False\\n            return True\\n        \\n        l = 0\\n        r = 10**15\\n        while l < r:\\n            \\n            mid = (l+r)//2\\n            \\n            if isok(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947328,
                "title": "c-o-log-n",
                "content": "# Approach\\n1. Min set is what is required to cover set 1, set 2 or both. \\n2. LCM is formula is used to calculate the number of skipped elements for the combined set.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n)), where n = 2 * 10^9 - Min(uniqueCnt1, uniqueCnt2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        return Math.Max(\\n            GetMinCount(Lcm(divisor1, divisor2), uniqueCnt1 + uniqueCnt2),\\n            Math.Max(\\n                GetMinCount(divisor1, uniqueCnt1), \\n                GetMinCount(divisor2, uniqueCnt2)));\\n    }\\n\\n    private static int GetMinCount(long divisor, int count) {\\n        var lo = count;\\n        var hi = 2000000000; // to cover 10^9 + 10^9\\n\\n        while (lo <= hi) {\\n            var mid = lo + (hi - lo) / 2;\\n\\n            var skipped = mid / divisor;\\n            var remaining = mid - skipped;\\n\\n            if (remaining > count) {\\n                hi = mid - 1;\\n            }\\n            else if (remaining < count) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                var left = mid - 1;\\n                var leftSkipped = left / divisor;\\n                var leftRemaining = left - leftSkipped;\\n\\n                // ensure that only the minimum value is returned\\n                if (leftRemaining < count) {\\n                    return (int)mid;\\n                }\\n\\n                hi = left;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static int Gfc(int a, int b)\\n    {\\n        while (b != 0)\\n        {\\n            int temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n\\n    private static long Lcm(int a, int b)\\n    {\\n        return (a / Gfc(a, b)) * (long)b;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        return Math.Max(\\n            GetMinCount(Lcm(divisor1, divisor2), uniqueCnt1 + uniqueCnt2),\\n            Math.Max(\\n                GetMinCount(divisor1, uniqueCnt1), \\n                GetMinCount(divisor2, uniqueCnt2)));\\n    }\\n\\n    private static int GetMinCount(long divisor, int count) {\\n        var lo = count;\\n        var hi = 2000000000; // to cover 10^9 + 10^9\\n\\n        while (lo <= hi) {\\n            var mid = lo + (hi - lo) / 2;\\n\\n            var skipped = mid / divisor;\\n            var remaining = mid - skipped;\\n\\n            if (remaining > count) {\\n                hi = mid - 1;\\n            }\\n            else if (remaining < count) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                var left = mid - 1;\\n                var leftSkipped = left / divisor;\\n                var leftRemaining = left - leftSkipped;\\n\\n                // ensure that only the minimum value is returned\\n                if (leftRemaining < count) {\\n                    return (int)mid;\\n                }\\n\\n                hi = left;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static int Gfc(int a, int b)\\n    {\\n        while (b != 0)\\n        {\\n            int temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n\\n    private static long Lcm(int a, int b)\\n    {\\n        return (a / Gfc(a, b)) * (long)b;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947286,
                "title": "c-binary-search",
                "content": "# Intuition\\nAll the multiplers of divisor1 can not be put in the array 1.\\nAll the multiplers of divisor2 can not be put in the array 2.\\nAll the multiplers of lcm(divisor1, divisor2) can not be put in both array.\\n\\n# Approach\\nLet\\'s think this question in a reversed perspective: given a number n, can we build the two arrays that fullfill the requirements by only using the numbers that $$<=n$$?\\n\\nThen we can binary search for the result.\\n\\n# Complexity\\n- Time complexity: O(lgN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        function<int(int, int)> gcd = [&gcd](int a, int b) -> int {\\n            if (b == 0) return a;\\n            return gcd(b, a % b);\\n        };\\n\\n        int gcdn = gcd(divisor1, divisor2);\\n        long lcm = divisor1 * 1L * divisor2 / gcdn;\\n\\n        auto check = [&](long n) -> bool {\\n            int rmd1 = uniqueCnt1 - n / divisor2 + n / lcm;\\n            int rmd2 = uniqueCnt2 - n / divisor1 + n / lcm;\\n            if (rmd1 <= 0 && rmd2 <= 0) return true;\\n            rmd1 = max(rmd1, 0);\\n            rmd2 = max(rmd2, 0);\\n            return n - n/divisor2 - n/divisor1 + n/lcm >= rmd2 + rmd1;\\n        };\\n\\n        long l = 1, r = INT_MAX;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        function<int(int, int)> gcd = [&gcd](int a, int b) -> int {\\n            if (b == 0) return a;\\n            return gcd(b, a % b);\\n        };\\n\\n        int gcdn = gcd(divisor1, divisor2);\\n        long lcm = divisor1 * 1L * divisor2 / gcdn;\\n\\n        auto check = [&](long n) -> bool {\\n            int rmd1 = uniqueCnt1 - n / divisor2 + n / lcm;\\n            int rmd2 = uniqueCnt2 - n / divisor1 + n / lcm;\\n            if (rmd1 <= 0 && rmd2 <= 0) return true;\\n            rmd1 = max(rmd1, 0);\\n            rmd2 = max(rmd2, 0);\\n            return n - n/divisor2 - n/divisor1 + n/lcm >= rmd2 + rmd1;\\n        };\\n\\n        long l = 1, r = INT_MAX;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947254,
                "title": "c-simplest-explanation-beats-100-runtime-100-memory-binary-search-lcm-venn-diagram",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        //min possible result\\n        int l=uniqueCnt1+uniqueCnt2;\\n        //max possible result\\n        int r=2*l;\\n        //initial result\\n        int ans=r;\\n        //binary search\\n        while(l<=r){\\n            //mid value of l, r\\n            int mid=l+(r-l)/2;\\n            //calculating lcm of divisor1, divisor2\\n            int gcd=__gcd(divisor1,divisor2);\\n            long long lcm=divisor1/__gcd(divisor1,divisor2);\\n            lcm*=(long long)divisor2;\\n            //count of numbers in range [1,mid] divisible by lcm\\n            int div_lcm=mid/lcm;\\n            //count of numbers in range [1,mid] \\n            //divisible by divisor1 & not divisible by lcm\\n            int div1=(mid/divisor1)-div_lcm;\\n            //count of numbers in range [1,mid] \\n            //divisible by divisor2 & not divisible by lcm\\n            int div2=(mid/divisor2)-div_lcm;\\n            //rest of the numbers in range [1,mid]\\n            int other=mid-div1-div2-div_lcm;\\n            //count of empty space in arr1 after inserting div2 numbers\\n            int emp_arr1=max(0,uniqueCnt1-div2);\\n            //count of empty space in arr2 after inserting div1 numbers\\n            int emp_arr2=max(0,uniqueCnt2-div1);\\n            //check if it\\'s possible to fullfill all the empty spaces\\n            //in arr1 and arr2 with the other numbers or not\\n            if(emp_arr1+emp_arr2<=other){\\n                //we got a result, let\\'s find a smaller one\\n                ans=mid;\\n                r=mid-1;\\n            }else{\\n                //not a valid result, let\\'s increase the lower value\\n                //and check a bigger one\\n                l=mid+1;\\n            }\\n        }\\n        //return the smallest possible ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        //min possible result\\n        int l=uniqueCnt1+uniqueCnt2;\\n        //max possible result\\n        int r=2*l;\\n        //initial result\\n        int ans=r;\\n        //binary search\\n        while(l<=r){\\n            //mid value of l, r\\n            int mid=l+(r-l)/2;\\n            //calculating lcm of divisor1, divisor2\\n            int gcd=__gcd(divisor1,divisor2);\\n            long long lcm=divisor1/__gcd(divisor1,divisor2);\\n            lcm*=(long long)divisor2;\\n            //count of numbers in range [1,mid] divisible by lcm\\n            int div_lcm=mid/lcm;\\n            //count of numbers in range [1,mid] \\n            //divisible by divisor1 & not divisible by lcm\\n            int div1=(mid/divisor1)-div_lcm;\\n            //count of numbers in range [1,mid] \\n            //divisible by divisor2 & not divisible by lcm\\n            int div2=(mid/divisor2)-div_lcm;\\n            //rest of the numbers in range [1,mid]\\n            int other=mid-div1-div2-div_lcm;\\n            //count of empty space in arr1 after inserting div2 numbers\\n            int emp_arr1=max(0,uniqueCnt1-div2);\\n            //count of empty space in arr2 after inserting div1 numbers\\n            int emp_arr2=max(0,uniqueCnt2-div1);\\n            //check if it\\'s possible to fullfill all the empty spaces\\n            //in arr1 and arr2 with the other numbers or not\\n            if(emp_arr1+emp_arr2<=other){\\n                //we got a result, let\\'s find a smaller one\\n                ans=mid;\\n                r=mid-1;\\n            }else{\\n                //not a valid result, let\\'s increase the lower value\\n                //and check a bigger one\\n                l=mid+1;\\n            }\\n        }\\n        //return the smallest possible ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947205,
                "title": "binary-search-solution-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see that the solution to the problem i.e. the minimum element of the maximum of two arrays is monotonic, i.e., if we find that the solution exists for, answer = a, then answer will exist for all values >= a, therfore in this case we can use binary search on the required value. The checker condition can be formed through some simple inclusion-exclusion principles.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us consider that the current value, that we are checking is x.\\nLet first and second divisor be d1 and d2, respectively.\\nLet the no. of elements required in arr1 and arr2 be c1 and c2.\\nTherefore, the number of elements which will be divided by only d1 = no. of elements divided by d1 - no. of elements divided by both d1 and d2.\\nfirst term is x / d1, second term will be x / lcm(d1, d2).\\nHence, the numbers which will be divisible by d1 only can be greedily put in arr2, similarly, the numbers which are divisible by d2 only can be put in arr1, greedily.\\nThe remaining numbers that we can insert into the array, are the numbers which are divisible by neither d1 nor d2 (let\\'s call this value as DIV_NONE), which can be calculated by simple inclusion-exclusion, we just have to check whether, the remaining numbers that are to be inserted in each array are less than or equal to DIV_NONE. \\n# Complexity\\n- Time complexity: O(log2(max_value_of_element))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:   O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d11, int d22, int c11, int c22) {\\n        #define int long long\\n        int c1 = c11, c2 = c22, d1 = d11, d2 = d22;\\n        int l = 0, r = 3e9 + 1;\\n        int ans = -1;\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            int lcm = (d1 * d2) / __gcd(d1, d2);\\n            int cnt1 = mid / d1, cnt2 = mid / d2, cnt3 = mid / lcm;\\n            int div_only_by_d1 = cnt1 - cnt3, div_only_by_d2 = cnt2 - cnt3;\\n            int div_by_none = mid - (cnt1 + cnt2 - cnt3);\\n            int rem = c1 + c2 - min(div_only_by_d1, c2) - min(c1, div_only_by_d2);\\n            if(rem <= div_by_none) {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        #undef int\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d11, int d22, int c11, int c22) {\\n        #define int long long\\n        int c1 = c11, c2 = c22, d1 = d11, d2 = d22;\\n        int l = 0, r = 3e9 + 1;\\n        int ans = -1;\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            int lcm = (d1 * d2) / __gcd(d1, d2);\\n            int cnt1 = mid / d1, cnt2 = mid / d2, cnt3 = mid / lcm;\\n            int div_only_by_d1 = cnt1 - cnt3, div_only_by_d2 = cnt2 - cnt3;\\n            int div_by_none = mid - (cnt1 + cnt2 - cnt3);\\n            int rem = c1 + c2 - min(div_only_by_d1, c2) - min(c1, div_only_by_d2);\\n            if(rem <= div_by_none) {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        #undef int\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947184,
                "title": "simple-binary-search-solution-python3",
                "content": "# Intuition\\nThere are three conditions that need to be satisfied for both arrays to be filled with numbers from the range $1..n$:\\n- There must be at least `uniqueCnt1` numbers that are NOT divisible by `divisor1`\\n- There must be at least `uniqueCnt2` numbers that are NOT divisible by `divisor2`\\n- There must be at least `uniqueCnt1 + uniqueCnt2` numbers that are NOT divisible by BOTH `divisor1` and `divisor2`\\n  - If a number is divisible by both `divisor1` and `divisor2`, it cannot be placed in either array and must be skipped\\n  - In order to fill both arrays, there needs to be at least `uniqueCnt1` + `uniqueCnt2` valid numbers across both arrays\\n  - The LCM of `divisor1` and `divisor2` can be used to determine if a number is divisble by both\\n\\nThe quantity of numbers in the range $1..n$ that are divisible by $x$ is `n // x`. Thus,  `n - (n // x)` is the quantity of numbers in the range $1..n$ that are NOT divisible by $x$. \\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int, curNum: int = 1) -> int: \\n        low = 0\\n        high = 10**90\\n        answer = high\\n        lcm = math.lcm(divisor1, divisor2)\\n        \\n        # Binary Search for the answer (1..M, where M is the midpoint of the binary search)\\n        while low <= high:\\n            mid = (high + low) // 2\\n            \\n            # Three properties need to be satisfied:\\n            # - There are at least uniqueCnt1 numbers that are NOT divisible by divisor1\\n            # - There are at least uniqueCnt2 numbers that are NOT divisible by divisor2\\n            # - There are at least (uniqueCnt1 + uniqueCnt2) numbers that are NOT divisible by BOTH divisor1 and divisor2\\n            #   - (NOT divisible by LCM of divisor1 and divisor2)\\n            if (mid - (mid // divisor1)) < uniqueCnt1 or \\\\\\n               (mid - (mid // divisor2)) < uniqueCnt2 or \\\\\\n               (mid - (mid // lcm)) < (uniqueCnt1 + uniqueCnt2):\\n                low = mid + 1\\n            else:\\n                answer = min(answer, mid)\\n                high = mid - 1\\n\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int, curNum: int = 1) -> int: \\n        low = 0\\n        high = 10**90\\n        answer = high\\n        lcm = math.lcm(divisor1, divisor2)\\n        \\n        # Binary Search for the answer (1..M, where M is the midpoint of the binary search)\\n        while low <= high:\\n            mid = (high + low) // 2\\n            \\n            # Three properties need to be satisfied:\\n            # - There are at least uniqueCnt1 numbers that are NOT divisible by divisor1\\n            # - There are at least uniqueCnt2 numbers that are NOT divisible by divisor2\\n            # - There are at least (uniqueCnt1 + uniqueCnt2) numbers that are NOT divisible by BOTH divisor1 and divisor2\\n            #   - (NOT divisible by LCM of divisor1 and divisor2)\\n            if (mid - (mid // divisor1)) < uniqueCnt1 or \\\\\\n               (mid - (mid // divisor2)) < uniqueCnt2 or \\\\\\n               (mid - (mid // lcm)) < (uniqueCnt1 + uniqueCnt2):\\n                low = mid + 1\\n            else:\\n                answer = min(answer, mid)\\n                high = mid - 1\\n\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947128,
                "title": "python100-7-lines-if-code",
                "content": "```\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        def gain(num):return num - num // lcm(d1,d2) >= u1 + u2 and num - num // d1 >= u1 and num - num // d2 >= u2\\n        left, right = 1, pow(10, 10)\\n        while left <= right:\\n            mid = (left  + right) // 2\\n            if gain(mid): right = mid - 1\\n            else: left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        def gain(num):return num - num // lcm(d1,d2) >= u1 + u2 and num - num // d1 >= u1 and num - num // d2 >= u2\\n        left, right = 1, pow(10, 10)\\n        while left <= right:\\n            mid = (left  + right) // 2\\n            if gain(mid): right = mid - 1\\n            else: left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947119,
                "title": "rust-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse binary search to find the minimum such mid. After removing the numbers between 1 & mid inclusive that are not valid for constructing either arrays:\\n1) Do we have enough numbers to construct the first array?\\n2) Do we have enough number to construct the second array?\\n3) The remain total is no less than unique_cnt1 + unique_cnt2? \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimize_set(divisor1: i32, divisor2: i32, unique_cnt1: i32, unique_cnt2: i32) -> i32 {\\n        let (mut left, mut right) = (1, i32::MAX);\\n        \\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if Self::valid(divisor1 as i64, divisor2 as i64, unique_cnt1 as i64, unique_cnt2 as i64, mid as i64) { right = mid; }\\n            else { left = mid + 1; }\\n        }\\n        \\n        left\\n    }\\n\\n    fn gcd(a: i64, b: i64) -> i64 {\\n        if a < b { return Self::gcd(b, a) }\\n        if a % b == 0 { return b }\\n        Self::gcd(b, a % b)\\n    }\\n    \\n    fn valid(divisor1: i64, divisor2: i64, unique_cnt1: i64, unique_cnt2: i64, mid: i64) -> bool {\\n        let (mut cnt1, mut cnt2) = (mid / divisor1, mid / divisor2);\\n        let d = Self::gcd(divisor1, divisor2);\\n        let dbl = mid / (divisor1 * divisor2 / d);\\n        \\n        cnt1 + unique_cnt1 <= mid && cnt2 + unique_cnt2 <= mid && mid -  dbl >= unique_cnt1 + unique_cnt2 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_set(divisor1: i32, divisor2: i32, unique_cnt1: i32, unique_cnt2: i32) -> i32 {\\n        let (mut left, mut right) = (1, i32::MAX);\\n        \\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if Self::valid(divisor1 as i64, divisor2 as i64, unique_cnt1 as i64, unique_cnt2 as i64, mid as i64) { right = mid; }\\n            else { left = mid + 1; }\\n        }\\n        \\n        left\\n    }\\n\\n    fn gcd(a: i64, b: i64) -> i64 {\\n        if a < b { return Self::gcd(b, a) }\\n        if a % b == 0 { return b }\\n        Self::gcd(b, a % b)\\n    }\\n    \\n    fn valid(divisor1: i64, divisor2: i64, unique_cnt1: i64, unique_cnt2: i64, mid: i64) -> bool {\\n        let (mut cnt1, mut cnt2) = (mid / divisor1, mid / divisor2);\\n        let d = Self::gcd(divisor1, divisor2);\\n        let dbl = mid / (divisor1 * divisor2 / d);\\n        \\n        cnt1 + unique_cnt1 <= mid && cnt2 + unique_cnt2 <= mid && mid -  dbl >= unique_cnt1 + unique_cnt2 \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947051,
                "title": "c-simple-binary-search-with-explanation",
                "content": "# Intuition & Approach\\nBinary search for the answer. However, how could we know if any `num` can be enough for the current condition with `divisor1, divisor2, uniqueCnt1, uniqueCnt2` or not?\\nLet\\'s consider:\\n```c++\\ncnt1 = num - num / divisor1 // # of elements can put in array1\\ncnt2 = num - num / divisor2; // # of elements can put in array2\\ncnt3 = num - num / lcm(divisor1, divisor2); // # of elements can put in array1 or array2\\n```\\nSo these three `cnt` must be:\\n```\\ncnt1 >= uniqueCnt1\\ncnt2 >= uniqueCnt2\\ncnt3 >= (uniqueCnt1 + uniqueCnt2)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long a, long long b) {\\n        return a * b / __gcd(a, b);\\n    }\\n    bool criteria(int num, int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int cnt1 = num - num / divisor1;\\n        int cnt2 = num - num / divisor2;\\n        int cnt3 = num - num / lcm(divisor1, divisor2);\\n        return cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 && cnt3 >= (uniqueCnt1 + uniqueCnt2);\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long left = 0;\\n        long long right = INT_MAX;\\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (criteria(mid, divisor1, divisor2, uniqueCnt1, uniqueCnt2)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```c++\\ncnt1 = num - num / divisor1 // # of elements can put in array1\\ncnt2 = num - num / divisor2; // # of elements can put in array2\\ncnt3 = num - num / lcm(divisor1, divisor2); // # of elements can put in array1 or array2\\n```\n```\\ncnt1 >= uniqueCnt1\\ncnt2 >= uniqueCnt2\\ncnt3 >= (uniqueCnt1 + uniqueCnt2)\\n```\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long a, long long b) {\\n        return a * b / __gcd(a, b);\\n    }\\n    bool criteria(int num, int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int cnt1 = num - num / divisor1;\\n        int cnt2 = num - num / divisor2;\\n        int cnt3 = num - num / lcm(divisor1, divisor2);\\n        return cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 && cnt3 >= (uniqueCnt1 + uniqueCnt2);\\n    }\\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        long long left = 0;\\n        long long right = INT_MAX;\\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (criteria(mid, divisor1, divisor2, uniqueCnt1, uniqueCnt2)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946852,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int minimizeSet(const int divisor1,\\n                  const int divisor2,\\n                  const int uniqueCnt1,\\n                  const int uniqueCnt2) {\\n    const long long lcm = get_lcm(divisor1, divisor2);\\n    int low = uniqueCnt1 + uniqueCnt2;\\n    int high = numeric_limits<int>::max();\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      /**\\n       * `count1` stands for the number of distinct positive integers which can not be divisible by `divisor1`\\n       */\\n      const int count1 = mid - (mid / divisor1);\\n      /**\\n       * `count2` stands for the number of distinct positive integers which can not be divisible by `divisor2`\\n       */\\n      const int count2 = mid - (mid / divisor2);\\n      /**\\n       * `count12` stands for the number of distinct positive integers\\n       *                      which can neither be divisible by `divisor1` nor by `divisor2`\\n       *                      which can be in `arr1` or `arr2`\\n       */\\n      const int count12 = mid - (mid / divisor1) - (mid / divisor2) + (mid / lcm);\\n      /**\\n       * 1. `count1 - count12` stands for those positive integers which can be divisible by `divisor2`,\\n       *                       but cannot be disivible by `divisor1`, so they can only be in `arr1`.\\n       * 2. `count2 - count12` stands for those positive integers which can be divisible by `divisor1`,\\n       *                       but cannot be disivible by `divisor2`, so they can only be in `arr2`.\\n       */\\n      if (max(0, uniqueCnt1 - (count1 - count12)) + max(0, uniqueCnt2 - (count2 - count12)) <= count12) {\\n        /**\\n         * `mid` can be a possible maximum integer that can be in `arr1` or `arr2`\\n         */\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    return high;\\n  }\\n\\n private:\\n  int get_gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return get_gcd(b % a, a);\\n  }\\n  \\n  long long get_lcm(const int a, const int b) {\\n    const int gcd = get_gcd(a, b);\\n    return static_cast<long long>(a / gcd) * (b / gcd) * gcd;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int minimizeSet(const int divisor1,\\n                  const int divisor2,\\n                  const int uniqueCnt1,\\n                  const int uniqueCnt2) {\\n    const long long lcm = get_lcm(divisor1, divisor2);\\n    int low = uniqueCnt1 + uniqueCnt2;\\n    int high = numeric_limits<int>::max();\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      /**\\n       * `count1` stands for the number of distinct positive integers which can not be divisible by `divisor1`\\n       */\\n      const int count1 = mid - (mid / divisor1);\\n      /**\\n       * `count2` stands for the number of distinct positive integers which can not be divisible by `divisor2`\\n       */\\n      const int count2 = mid - (mid / divisor2);\\n      /**\\n       * `count12` stands for the number of distinct positive integers\\n       *                      which can neither be divisible by `divisor1` nor by `divisor2`\\n       *                      which can be in `arr1` or `arr2`\\n       */\\n      const int count12 = mid - (mid / divisor1) - (mid / divisor2) + (mid / lcm);\\n      /**\\n       * 1. `count1 - count12` stands for those positive integers which can be divisible by `divisor2`,\\n       *                       but cannot be disivible by `divisor1`, so they can only be in `arr1`.\\n       * 2. `count2 - count12` stands for those positive integers which can be divisible by `divisor1`,\\n       *                       but cannot be disivible by `divisor2`, so they can only be in `arr2`.\\n       */\\n      if (max(0, uniqueCnt1 - (count1 - count12)) + max(0, uniqueCnt2 - (count2 - count12)) <= count12) {\\n        /**\\n         * `mid` can be a possible maximum integer that can be in `arr1` or `arr2`\\n         */\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    return high;\\n  }\\n\\n private:\\n  int get_gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return get_gcd(b % a, a);\\n  }\\n  \\n  long long get_lcm(const int a, const int b) {\\n    const int gcd = get_gcd(a, b);\\n    return static_cast<long long>(a / gcd) * (b / gcd) * gcd;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946836,
                "title": "c-binary-search-solution-with-lcm",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int minimizeSet(ll divisor1, ll divisor2, ll uniqueCnt1, ll uniqueCnt2) {\\n        ll l = 1, r = 1\\'000\\'000\\'000\\'000\\'000;\\n        const auto check = [&](ll m) {\\n            const auto satisfiesFirst = m - m / divisor1;\\n            const auto satisfiesSecond = m - m / divisor2;\\n            const auto satisfirsBoth = satisfiesFirst + satisfiesSecond - m + m / lcm(divisor1, divisor2);\\n            if (satisfiesFirst < uniqueCnt1) {\\n                return false;\\n            }\\n            ll satisfiesSecondOnly = satisfiesSecond - satisfirsBoth;\\n            ll leftForSecond = satisfiesSecondOnly + min(satisfiesFirst - uniqueCnt1, satisfirsBoth);\\n            return leftForSecond >= uniqueCnt2;\\n        };\\n        while (l + 1 < r) {\\n            const auto m = (l + r) / 2;\\n            if (check(m)) {\\n                r = m;\\n            }\\n            else {\\n                l = m;\\n            }\\n        }\\n        return check(l) ? l : r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int minimizeSet(ll divisor1, ll divisor2, ll uniqueCnt1, ll uniqueCnt2) {\\n        ll l = 1, r = 1\\'000\\'000\\'000\\'000\\'000;\\n        const auto check = [&](ll m) {\\n            const auto satisfiesFirst = m - m / divisor1;\\n            const auto satisfiesSecond = m - m / divisor2;\\n            const auto satisfirsBoth = satisfiesFirst + satisfiesSecond - m + m / lcm(divisor1, divisor2);\\n            if (satisfiesFirst < uniqueCnt1) {\\n                return false;\\n            }\\n            ll satisfiesSecondOnly = satisfiesSecond - satisfirsBoth;\\n            ll leftForSecond = satisfiesSecondOnly + min(satisfiesFirst - uniqueCnt1, satisfirsBoth);\\n            return leftForSecond >= uniqueCnt2;\\n        };\\n        while (l + 1 < r) {\\n            const auto m = (l + r) / 2;\\n            if (check(m)) {\\n                r = m;\\n            }\\n            else {\\n                l = m;\\n            }\\n        }\\n        return check(l) ? l : r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946825,
                "title": "simple-c-optimal-solution-less-runtime-3ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniquenum1, int uniquenum2) {\\n        long start = 0;\\n        long end = 2e15;\\n        long l = lcm((long) divisor1, divisor2); \\n        while (start < end) {\\n            long center = start + (end - start)/2, extra = center/l; \\n            long num1 = center - center/divisor1, num2 = center - center/divisor2, num12 = center - center/divisor1 - center/divisor2 + center/l; \\n            if (center - center/l >= uniquenum1 + uniquenum2 && num1 >= uniquenum1 && num2 >= uniquenum2 && max(0l, uniquenum1-num1+num12)+max(0l, uniquenum2-num2+num12) <= num12) end = center; \\n            else start = center + 1;\\n        }\\n        return start; \\n    }\\n};\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int divisor1, int divisor2, int uniquenum1, int uniquenum2) {\\n        long start = 0;\\n        long end = 2e15;\\n        long l = lcm((long) divisor1, divisor2); \\n        while (start < end) {\\n            long center = start + (end - start)/2, extra = center/l; \\n            long num1 = center - center/divisor1, num2 = center - center/divisor2, num12 = center - center/divisor1 - center/divisor2 + center/l; \\n            if (center - center/l >= uniquenum1 + uniquenum2 && num1 >= uniquenum1 && num2 >= uniquenum2 && max(0l, uniquenum1-num1+num12)+max(0l, uniquenum2-num2+num12) <= num12) end = center; \\n            else start = center + 1;\\n        }\\n        return start; \\n    }\\n};\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946594,
                "title": "c-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a * b)/(__gcd(a,b));\\n    }\\n    bool ispossible(int mid,int d1,int d2,int u1,int u2){\\n        int c1 = (int)mid/d1;\\n        int c2 = (int)mid/d2;\\n        int temp = (int)mid/lcm(d1,d2);\\n        u1 -= (c2 - temp);\\n        u2 -= (c1 - temp);\\n        int t1 = mid - (c1 + c2 - temp);\\n        if(u1 < 0)u1 = 0;\\n        if(u2 < 0)u2 = 0;\\n        if(t1 >= u1 + u2)return true;\\n        return false;\\n    }\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long l = 1,r = 1e12;\\n        int ans = 1;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            if(ispossible(mid,d1,d2,u1,u2)){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a * b)/(__gcd(a,b));\\n    }\\n    bool ispossible(int mid,int d1,int d2,int u1,int u2){\\n        int c1 = (int)mid/d1;\\n        int c2 = (int)mid/d2;\\n        int temp = (int)mid/lcm(d1,d2);\\n        u1 -= (c2 - temp);\\n        u2 -= (c1 - temp);\\n        int t1 = mid - (c1 + c2 - temp);\\n        if(u1 < 0)u1 = 0;\\n        if(u2 < 0)u2 = 0;\\n        if(t1 >= u1 + u2)return true;\\n        return false;\\n    }\\n    int minimizeSet(int d1, int d2, int u1, int u2) {\\n        long long l = 1,r = 1e12;\\n        int ans = 1;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            if(ispossible(mid,d1,d2,u1,u2)){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946548,
                "title": "c-binary-search",
                "content": "# Intuition\\nif a certain  number n if valid that will mean n+1 will always be valid\\nand n-1 could be valid or not\\n\\n# Approach\\n\\nwe can use binary search to find the first valid max number\\nFFFFTTTTTTTTT\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        int s = cnt1+cnt2;\\n        int e = INT_MAX;\\n        while(s < e) {\\n            int mid = s + (e - s) / 2;\\n            if (valid(mid,d1,d2,cnt1,cnt2)) e = mid;\\n            else s = mid+1;\\n        }\\n        return s;\\n    }\\n    bool valid(int mx, int& d1, int& d2, int& cnt1, int& cnt2) {\\n        long long f1 = mx - mx/d1; // count numbers under <= mx that are not divisible by d1\\n        long long f2 = mx - mx/d2; // count numbers under <= mx that are not divisible by d2\\n        if (d1 == d2) { // if d1== d2 then f1 or f2 has to be >= cnt1+cnt2\\n            if (f1 >= cnt1+cnt2) return true;\\n            return false;\\n        }\\n        int gcd = __gcd(d1, d2);\\n        long long lcm = d1;\\n        lcm *= d2;\\n        lcm /= gcd;\\n        long long f3 = mx - mx/lcm; // countb numbers that are not divisible by both d1 and d2\\n        if (f3 >= cnt1+cnt2 && f1 >= cnt1 && f2 >= cnt2) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSet(int d1, int d2, int cnt1, int cnt2) {\\n        int s = cnt1+cnt2;\\n        int e = INT_MAX;\\n        while(s < e) {\\n            int mid = s + (e - s) / 2;\\n            if (valid(mid,d1,d2,cnt1,cnt2)) e = mid;\\n            else s = mid+1;\\n        }\\n        return s;\\n    }\\n    bool valid(int mx, int& d1, int& d2, int& cnt1, int& cnt2) {\\n        long long f1 = mx - mx/d1; // count numbers under <= mx that are not divisible by d1\\n        long long f2 = mx - mx/d2; // count numbers under <= mx that are not divisible by d2\\n        if (d1 == d2) { // if d1== d2 then f1 or f2 has to be >= cnt1+cnt2\\n            if (f1 >= cnt1+cnt2) return true;\\n            return false;\\n        }\\n        int gcd = __gcd(d1, d2);\\n        long long lcm = d1;\\n        lcm *= d2;\\n        lcm /= gcd;\\n        long long f3 = mx - mx/lcm; // countb numbers that are not divisible by both d1 and d2\\n        if (f3 >= cnt1+cnt2 && f1 >= cnt1 && f2 >= cnt2) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1726735,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1726701,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1726995,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1727019,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1869139,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1795668,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1727007,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1726815,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            },
            {
                "id": 1726776,
                "content": [
                    {
                        "username": "BatDad",
                        "content": "How come the answer to below is \"14\" instead of 17?\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\n\\nFirst Array = [1, 2, 3]\\nSecond Array = [4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\\n\\nMax is 17 in this case\\n"
                    },
                    {
                        "username": "yuedai",
                        "content": "Provided solutions give me a lot hint. If you don\\'t get the point of some solutions, try ask chatgpt to explain it to you. "
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "FirstArray = [3,6] (size of array should be 2 not 3 as uniqueCnt1 =2 ),(These are not divisible by 12)\\nSecond Array = [1,2, 4,5,7,8,10,11,13,14] (size of array =  uniqueCnt2 = 10),(These are not divisible by 3)\\nhence anwer is max which is 14 here."
                    },
                    {
                        "username": "AnubhavSrivastava",
                        "content": "Because the two arrays can also be like this :\\nFirst Array: [3,6]\\nSecond Array : [1,2,4,5,7,8,10,11,13,14]"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "` the minimum possible maximum integer that can be present in either array.`\\nSo undestandable, really. I just felt an insight the moment I read this.\\nCan someone explain it to me?"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) I've read another examples people asked above and understood what I got wrong. So lets finish this thread of explanation of horrible description. And ty btw"
                    },
                    {
                        "username": "yzhao156",
                        "content": "[@NevNadNik](/NevNadNik) Not sure if I understand you correctly, but when you have two list [1, 2] and [3]. The maximum value amoung the two lists is 3. Our goal is to make the number as small as possible"
                    },
                    {
                        "username": "NevNadNik",
                        "content": "[@yzhao156](/yzhao156) Still don\\'t get it. Ex Div1 = 3, Div2 = 5, U1 = 2, U2 = 1. We make two arrays [1,2] as not divisible by Div1 = 3, and [3] as not divisible by Div2 = 5. \\n*minimum possible maximum* we can have here, pulled in either arrays is 2 (not divisible by 3 and 5). But somehow testcase expects 3. Why??"
                    },
                    {
                        "username": "yzhao156",
                        "content": "I guess try to fill with small numbers and keep the largest number amoung the small numbers as small as possible. "
                    },
                    {
                        "username": "taksqth",
                        "content": "I got accepted with the following, but from reading the solutions I'm skeptical and starting to think that testing just wasn't strong enough. Can anyone please provide an example for which it fails, if there is one?\n\n```python\nimport math\n\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        lcm = math.lcm(divisor1, divisor2)\n        return math.ceil(max(\n            uniqueCnt1*divisor1/(divisor1-1),\n            uniqueCnt2*divisor2/(divisor2-1),\n            (uniqueCnt1+uniqueCnt2)*lcm/(lcm-1)\n        ))-1\n```"
                    },
                    {
                        "username": "vishaleet",
                        "content": "How can be maximum 14 it should be 17 ,i have written output of no. serialwise which are not divisible by divisior1 divisior2.\\nInput\\ndivisor1 =\\n12\\ndivisor2 =\\n3\\nuniqueCnt1 =\\n2\\nuniqueCnt2 =\\n10\\nOutput\\n17\\nExpected\\n14\\nStdout\\n divisior1=1 divisior1=2 for divisior2 4 for divisior2 5 for divisior2 7 for divisior2 8 for divisior2 10 for divisior2 11 for divisior2 13 for divisior2 14 for divisior2 16 for divisior2 17"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "same problem brother"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "for arr1=[3,6] and arr2= [1,2,4,5,7,8,10,11,13,14].\n\nHere you should consider 4 cases. \n1. num is divisble by div1 and div2.\n2. num is divisble by div1 but not by div2.\n3.  num is not divisble by div1 but divisible by div2.\n4.num is not divisible by div1 and div2"
                    },
                    {
                        "username": "shuklatushar89",
                        "content": "Can anyone explain this test case expected output ? and what is wrong in my code?\\nInput :-\\ndivisor1 = 12\\ndivisor2 = 3\\nuniqueCnt1 = 2\\nuniqueCnt2 = 10\\nOutput :- 17\\nExpected 14\\n\\nMy Code :-\\n```\\ndef minimizeSet(self, d1: int, d2: int, u1: int, u2: int) -> int:\\n        arr1, arr2 = [], []\\n        i, j = 1, 1 \\n        while len(arr1) < u1:\\n            if i % d1 != 0:\\n                arr1.append(i)\\n            i += 1\\n        while len(arr2) < u2:\\n            if j % d2 != 0 :\\n                if j not in arr1:\\n                    arr2.append(j)\\n            j += 1\\n        return max(arr1 + arr2)\\n```"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how is this not labelled hard?!"
                    },
                    {
                        "username": "rick_014",
                        "content": "Amazing question of binary search and set theory."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\nint minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        vector<int> arr1;\\n        int maxi = max(uniqueCnt1, uniqueCnt2);\\n        vector<int> arr2;\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            if (i % divisor1 != 0 )\\n            {\\n                arr1.push_back(i);\\n            }\\n            if(arr1.size()==uniqueCnt1){\\n                break;\\n            }\\n        }\\n\\n        for (int i = 1; i <= 9 * maxi; i++)\\n        {\\n            vector<int>::iterator it;\\n            it = find(arr1.begin(),arr1.end(),i);\\n            if (i % divisor2 != 0 && it == arr1.end())\\n            {\\n                arr2.push_back(i);\\n            }\\n            if(arr2.size()==uniqueCnt2){\\n                break;\\n            }\\n        }\\n\\n\\n        int mx1 = *max_element(arr1.begin(), arr1.end());\\n        int mx2 = *max_element(arr2.begin(), arr2.end());\\n        return max(mx1,mx2);\\n\\n    }\\n\\nwhy i am getting wrong ans for this"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "divisor1=16 \\ndivisor2==14\\nuniqueCnt1=12 \\nuniqueCnt2==8)\\n How answer is 20 , I think it should be 21"
                    },
                    {
                        "username": "arutsudar",
                        "content": "[@pavelpetrovitdev](/pavelpetrovitdev) \\nIn the problem statement it is mentioned that `No integer is present in both arr1 and arr2.`\\nSince, we used the number `12` in `arr2`, we cannot use the same in `arr1` as well.\\n\\nThe idea here was to pick the numbers from `1 to 20`, and\\nuse the number `14` in `arr1`, and\\nnumber `16` in `arr2`\\n(since the opposite is not possible).\\nAlong with that, we can pick the remaining needed unique numbers in any array."
                    },
                    {
                        "username": "pavelpetrovitdev",
                        "content": "[@arutsudar](/arutsudar) where number 12 in array 1 ? I suppose  12 % 16 != null \\n"
                    },
                    {
                        "username": "xiaomutoun",
                        "content": "The first array contains number 14 and some other 11 elements. The second array contains number 16 and some 7 elements. Thus the total is 20."
                    },
                    {
                        "username": "arutsudar",
                        "content": "arr1 = `1,2,3,4,5,6,7,8,9,10,11,14`\\narr2 = `12,13,15,16,17,18,19,20`\\nWe cannot use the number 14 in `arr2`, but we can use it in `arr1`.\\nUsing that, we can get the answer with the first 20 nos. instead of 21."
                    }
                ]
            }
        ]
    }
]